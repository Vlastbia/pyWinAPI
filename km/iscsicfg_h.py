import ctypes
from pyWinAPI import *
from pyWinAPI.shared.wtypes_h import *


class _MSiSCSI_TCPIPConfig(ctypes.Structure):
    pass


MSiSCSI_TCPIPConfig = _MSiSCSI_TCPIPConfig
PMSiSCSI_TCPIPConfig = POINTER(_MSiSCSI_TCPIPConfig)


class _MSiSCSI_NICConfig(ctypes.Structure):
    pass


MSiSCSI_NICConfig = _MSiSCSI_NICConfig
PMSiSCSI_NICConfig = POINTER(_MSiSCSI_NICConfig)


class _MSiSCSI_BootConfiguration(ctypes.Structure):
    pass


MSiSCSI_BootConfiguration = _MSiSCSI_BootConfiguration
PMSiSCSI_BootConfiguration = POINTER(_MSiSCSI_BootConfiguration)


class _MSiSCSI_SecurityCapabilities(ctypes.Structure):
    pass


MSiSCSI_SecurityCapabilities = _MSiSCSI_SecurityCapabilities
PMSiSCSI_SecurityCapabilities = POINTER(_MSiSCSI_SecurityCapabilities)


class _MSiSCSI_DiscoveryConfig(ctypes.Structure):
    pass


MSiSCSI_DiscoveryConfig = _MSiSCSI_DiscoveryConfig
PMSiSCSI_DiscoveryConfig = POINTER(_MSiSCSI_DiscoveryConfig)


class _MSiSCSI_RADIUSConfig(ctypes.Structure):
    pass


MSiSCSI_RADIUSConfig = _MSiSCSI_RADIUSConfig
PMSiSCSI_RADIUSConfig = POINTER(_MSiSCSI_RADIUSConfig

)

_iscsicfg_h_ = None
if not defined(_iscsicfg_h_):
    _iscsicfg_h_ = 1

    # MSiSCSI_TCPIPConfig - MSiSCSI_TCPIPConfig

    # *************************************************************************
    #
    #  iscsicfg.h
    #
    #  Module: iScsi Discovery api
    #
    #  Purpose: Header defining interface between user mode configuration
    #           apps and HBA driver miniport.
    #
    #  Copyright (c) 2001 Microsoft Corporation
    #
    # *************************************************************************

    from pyWinAPI.km.iscsidef_h import * # NOQA

    # This class is required.

    # TCP/IP configuration class, implement one instance for each IP address on
    # your adapter. For example, if you adapter supports 3 IP addresses then
    # your adapter would implement 3 instances of this class.

    # This class uses PDO instance names with 1 instance for each TCP/IP
    # interface.

    MSiSCSI_TCPIPConfigGuid = [
        0x7a2c6c2b,
        0xe5a5,
        0x49ad,
        [0xad, 0x68, 0x13, 0x30, 0x89, 0xac, 0xd7, 0x4d]
    ]

    if not defined(MIDL_PASS):
        MSiSCSI_TCPIPConfig_GUID = DEFINE_GUID(
            0x7a2c6c2b,
            0xe5a5,
            0x49ad,
            0xad,
            0x68,
            0x13,
            0x30,
            0x89,
            0xac,
            0xd7,
            0x4d
        )
    # END IF

    MSiSCSI_TCPIPConfig_UseLinkLocalAddress_SIZE = ctypes.sizeof(BOOLEAN)
    MSiSCSI_TCPIPConfig_UseLinkLocalAddress_ID = 1
    MSiSCSI_TCPIPConfig_EnableDHCP_SIZE = ctypes.sizeof(BOOLEAN)
    MSiSCSI_TCPIPConfig_EnableDHCP_ID = 2
    MSiSCSI_TCPIPConfig_UseDHCPForDNS_SIZE = ctypes.sizeof(BOOLEAN)
    MSiSCSI_TCPIPConfig_UseDHCPForDNS_ID = 3
    MSiSCSI_TCPIPConfig_IPVersions_SIZE = ctypes.sizeof(ULONG)
    MSiSCSI_TCPIPConfig_IPVersions_ID = 4
    MSiSCSI_TCPIPConfig_IpAddress_SIZE = ctypes.sizeof(ISCSI_IP_Address)
    MSiSCSI_TCPIPConfig_IpAddress_ID = 5
    MSiSCSI_TCPIPConfig_DefaultGateway_SIZE = ctypes.sizeof(ISCSI_IP_Address)
    MSiSCSI_TCPIPConfig_DefaultGateway_ID = 6
    MSiSCSI_TCPIPConfig_SubnetMask_SIZE = ctypes.sizeof(ISCSI_IP_Address)
    MSiSCSI_TCPIPConfig_SubnetMask_ID = 7
    MSiSCSI_TCPIPConfig_PreferredDNSServer_SIZE = (
        ctypes.sizeof(ISCSI_IP_Address)
    )
    MSiSCSI_TCPIPConfig_PreferredDNSServer_ID = 8
    MSiSCSI_TCPIPConfig_AlternateDNSServer_SIZE = (
        ctypes.sizeof(ISCSI_IP_Address)
    )
    MSiSCSI_TCPIPConfig_AlternateDNSServer_ID = 9

    _MSiSCSI_TCPIPConfig._fields_ = [
        # TRUE if the adapter should use an autogenerated and non routable
        # (link local) address as its IP address.
        ('UseLinkLocalAddress', BOOLEAN),
        # TRUE if the adapter should use DHCP to discovery its IP address
        # information.
        ('EnableDHCP', BOOLEAN),
        # TRUE if the adapter should use DHCP to discover DNS addresses.
        ('UseDHCPForDNS', BOOLEAN),
        # IP Versions supported **Add #defines**
        ('IPVersions', ULONG),
        # IP address of the adapter
        ('IpAddress', ISCSI_IP_Address),
        # Static Default Gateway IP address
        ('DefaultGateway', ISCSI_IP_Address),
        # Static Subnet Mask
        ('SubnetMask', ISCSI_IP_Address),
        # Preferred DNS Server
        ('PreferredDNSServer', ISCSI_IP_Address),
        # Alternate DNS Server
        ('AlternateDNSServer', ISCSI_IP_Address)
    ]

    MSiSCSI_TCPIPConfig_SIZE = (
        FIELD_OFFSET(MSiSCSI_TCPIPConfig, 'AlternateDNSServer') +
        MSiSCSI_TCPIPConfig_AlternateDNSServer_SIZE
    )

    # MSiSCSI_NICConfig - MSiSCSI_NICConfig

    # This class is optional.

    # NIC Port configuration class, implement one instance for each physical
    # network interface port on your adapter.

    # This class uses PDO instance names with 1 instance for each physical
    # network interface port on your adapter.

    class ISCSI_NIC_LINKSTATE(ENUM):
        ISCSI_NIC_LINKSTATE_DISCONNECTED = 0
        ISCSI_NIC_LINKSTATE_CONNECTED = 1


    PISCSI_NIC_LINKSTATE = POINTER(ISCSI_NIC_LINKSTATE)

    ISCSI_NIC_LINKSTATE_DISCONNECTED = (
        ISCSI_NIC_LINKSTATE.ISCSI_NIC_LINKSTATE_DISCONNECTED
    )
    ISCSI_NIC_LINKSTATE_CONNECTED = (
        ISCSI_NIC_LINKSTATE.ISCSI_NIC_LINKSTATE_CONNECTED
    )

    MSiSCSI_NICConfigGuid = [
        0xc75258e9,
        0xbe79,
        0x4a48,
        [0xa2, 0x3d, 0xee, 0xb6, 0xf8, 0xfb, 0x94, 0x0c]
        ]

    if not defined(MIDL_PASS):
        MSiSCSI_NICConfig_GUID = DEFINE_GUID(
            0xc75258e9,
            0xbe79,
            0x4a48,
            0xa2,
            0x3d,
            0xee,
            0xb6,
            0xf8,
            0xfb,
            0x94,
            0x0c
        )
    # END IF

    MSiSCSI_NICConfig_LinkSpeed_SIZE = ctypes.sizeof(ULONG)
    MSiSCSI_NICConfig_LinkSpeed_ID = 1
    MSiSCSI_NICConfig_MaxLinkSpeed_SIZE = ctypes.sizeof(ULONG)
    MSiSCSI_NICConfig_MaxLinkSpeed_ID = 2
    MSiSCSI_NICConfig_LinkState_SIZE = ctypes.sizeof(ULONG)
    MSiSCSI_NICConfig_LinkState_ID = 3
    MSiSCSI_NICConfig_MaxFrameSize_SIZE = ctypes.sizeof(ULONG)
    MSiSCSI_NICConfig_MaxFrameSize_ID = 4
    MSiSCSI_NICConfig_MacAddress_SIZE = ctypes.sizeof(UCHAR * 6)
    MSiSCSI_NICConfig_MacAddress_ID = 5

    _MSiSCSI_NICConfig._fields_ = [
        # Speed of network link in megabits per second.
        ('LinkSpeed', ULONG),
        # Maximum Speed of network link in megabits per second.
        ('MaxLinkSpeed', ULONG),
        # Link State **typedef**
        ('LinkState', ULONG),
        # Maximum frame size
        ('MaxFrameSize', ULONG),
        # Ethernet MAC Address
        ('MacAddress', UCHAR * 6)
    ]

    MSiSCSI_NICConfig_SIZE = (
        FIELD_OFFSET(MSiSCSI_NICConfig, 'MacAddress') +
        MSiSCSI_NICConfig_MacAddress_SIZE
    )

    # MSiSCSI_BootConfiguration - MSiSCSI_BootConfiguration

    # This class is optional.

    # This class exposes the boot configuration if the adapter is configured to
    # boot from an iSCSI disk.
    #
    # This class uses PDO instance names with a single instance.

    MSiSCSI_BootConfigurationGuid = [
        0x53ef8d5f,
        0x36f3,
        0x4124,
        [0x8b, 0x76, 0xc6, 0xad, 0x52, 0x1a, 0x10, 0x21]
    ]

    if not defined(MIDL_PASS):
        MSiSCSI_BootConfiguration_GUID = DEFINE_GUID(
            0x53ef8d5f,
            0x36f3,
            0x4124,
            0x8b,
            0x76,
            0xc6,
            0xad,
            0x52,
            0x1a,
            0x10,
            0x21
        )
    # END IF

    MSiSCSI_BootConfiguration_LUN_SIZE = ctypes.sizeof(ULONGLONG)
    MSiSCSI_BootConfiguration_LUN_ID = 1
    MSiSCSI_BootConfiguration_SecurityFlags_SIZE = ctypes.sizeof(ULONGLONG)
    MSiSCSI_BootConfiguration_SecurityFlags_ID = 2
    MSiSCSI_BootConfiguration_UsernameSize_SIZE = ctypes.sizeof(ULONG)
    MSiSCSI_BootConfiguration_UsernameSize_ID = 3
    MSiSCSI_BootConfiguration_PasswordSize_SIZE = ctypes.sizeof(ULONG)
    MSiSCSI_BootConfiguration_PasswordSize_ID = 4
    MSiSCSI_BootConfiguration_DiscoverBootDevice_SIZE = (
        ctypes.sizeof(BOOLEAN)
    )
    MSiSCSI_BootConfiguration_DiscoverBootDevice_ID = 5
    MSiSCSI_BootConfiguration_InitiatorNode_ID = 6
    MSiSCSI_BootConfiguration_TargetName_ID = 7
    MSiSCSI_BootConfiguration_TargetPortal_SIZE = (
        ctypes.sizeof(ISCSI_TargetPortal)
    )
    MSiSCSI_BootConfiguration_TargetPortal_ID = 8
    MSiSCSI_BootConfiguration_LoginOptions_SIZE = (
        ctypes.sizeof(ISCSI_LoginOptions)
    )
    MSiSCSI_BootConfiguration_LoginOptions_ID = 9
    MSiSCSI_BootConfiguration_Username_ID = 10
    MSiSCSI_BootConfiguration_Password_ID = 11

    _MSiSCSI_BootConfiguration._fields_ = [
        # LUN on target to use as boot device.
        ('LUN', ULONGLONG),
        # Security flags
        ('SecurityFlags', ULONGLONG),
        # Size in bytes of Target Username.
        ('UsernameSize', ULONG),
        # Size in bytes of Target Password.
        ('PasswordSize', ULONG),
        # If TRUE dynamically discover boot device.
        ('DiscoverBootDevice', BOOLEAN),
        # The InitiatorNode specifies the iSCSI name of the initiator node to
        # use for the connection. If empty, then the adapter can choose any
        # initiator node name.
        ('InitiatorNode', CHAR * (223 + 1)),
        # TargetName specifies the iSCSI target name on which the boot device
        # resides.
        ('TargetName', WCHAR * (223 + 1)),
        # Target portal to use for connection to the target.
        ('TargetPortal', ISCSI_TargetPortal),
        # Options that affect how login is performed. See ISCSI_LoginOptions
        ('LoginOptions', ISCSI_LoginOptions),
        # **extra fields** Authentication Username, for CHAP this is the
        # CHAP Name (CHAP_N) use when authenticating with the target. NOTE:
        # This field is a variable length array, the field that follows this
        # field starts immediately after the end of this field subject to
        # appropriate padding.
        ('Username', UCHAR * 1),
        # Authentication Password, for CHAP this is the shared secret to use
        # when generating the response to the target challange. This field
        # is a variable length array.
        # ('Password', UCHAR * 1)
    ]

    # MSiSCSI_SecurityCapabilities - MSiSCSI_SecurityCapabilities

    # This class is required if adapter supports IPSEC.
    #
    # This class exposes the security capabilities if the adapter
    # supports IPSEC.
    #
    # This class uses PDO instance names with a single instance.

    class ISCSI_ENCRYPTION_TYPES(ENUM):
        ISCSI_ENCRYPT_NONE = 0
        ISCSI_ENCRYPT_3DES_HMAC_SHA1 = 1
        ISCSI_ENCRYPT_AES_CTR = 2


    PISCSI_ENCRYPTION_TYPES = POINTER(ISCSI_ENCRYPTION_TYPES)

    ISCSI_ENCRYPT_NONE = ISCSI_ENCRYPTION_TYPES.ISCSI_ENCRYPT_NONE
    ISCSI_ENCRYPT_3DES_HMAC_SHA1 = (
        ISCSI_ENCRYPTION_TYPES.ISCSI_ENCRYPT_3DES_HMAC_SHA1
    )
    ISCSI_ENCRYPT_AES_CTR = ISCSI_ENCRYPTION_TYPES.ISCSI_ENCRYPT_AES_CTR

    MSiSCSI_SecurityCapabilitiesGuid = [
        0x225b9d64,
        0x47a9,
        0x41c8,
        [0x81 ,0xcd, 0x69, 0xbc, 0x02, 0x65, 0x2d, 0x87]
    ]

    if not defined(MIDL_PASS):
        MSiSCSI_SecurityCapabilities_GUID = DEFINE_GUID(
            0x225b9d64,
            0x47a9,
            0x41c8,
            0x81,
            0xcd,
            0x69,
            0xbc,
            0x02,
            0x65,
            0x2d,
            0x87
        )

    # END IF

    MSiSCSI_SecurityCapabilities_ProtectiScsiTraffic_SIZE = (
        ctypes.sizeof(BOOLEAN)
    )
    MSiSCSI_SecurityCapabilities_ProtectiScsiTraffic_ID = 1
    MSiSCSI_SecurityCapabilities_ProtectiSNSTraffic_SIZE = (
        ctypes.sizeof(BOOLEAN)
    )
    MSiSCSI_SecurityCapabilities_ProtectiSNSTraffic_ID = 2
    MSiSCSI_SecurityCapabilities_CertificatesSupported_SIZE = (
        ctypes.sizeof(BOOLEAN)
    )
    MSiSCSI_SecurityCapabilities_CertificatesSupported_ID = 3
    MSiSCSI_SecurityCapabilities_EncryptionAvailableCount_SIZE = (
        ctypes.sizeof(ULONG)
    )
    MSiSCSI_SecurityCapabilities_EncryptionAvailableCount_ID = 4
    MSiSCSI_SecurityCapabilities_EncryptionAvailable_ID = 5

    _MSiSCSI_SecurityCapabilities._fields = [
        # TRUE if the adapter can use IPSEC to protect iSCSI traffic.
        ('ProtectiScsiTraffic', BOOLEAN),
        # TRUE if the adapter can use IPSEC to protect iSNS traffic.
        ('ProtectiSNSTraffic', BOOLEAN),
        # TRUE if adapter supports certificates
        ('CertificatesSupported', BOOLEAN),
        # Number of encryption types available.
        ('EncryptionAvailableCount', ULONG),
        # **typedef** Array of encryption types. This field is a variable
        # length array.
        ('EncryptionAvailable', ULONG * 1)
    ]

    # MSiSCSI_DiscoveryConfig - MSiSCSI_DiscoveryConfig

    # This class is required.

    # This class exposes the configuration capabilities for the adapter to be
    # able to perform target discovery. An adapter needs to support target
    # discovery if it is ever placed on a separate network from the PC NIC.
    # Although the iSCSI Initiator service can use this class with any
    # discovery mechanism the best results are obtained by using iSNS.

    # This class uses PDO instance names with a single instance.

    MSiSCSI_DiscoveryConfigGuid = [
        0x45755098,
        0x4291,
        0x43df,
        [0x97, 0x20, 0xb5, 0x86, 0x42, 0xdd, 0x63,0xdf]
    ]

    if not defined(MIDL_PASS):
        MSiSCSI_DiscoveryConfig_GUID = DEFINE_GUID(
            0x45755098,
            0x4291,
            0x43df,
            0x97,
            0x20,
            0xb5,
            0x86,
            0x42,
            0xdd,
            0x63,
            0xdf
        )
    # END IF

    MSiSCSI_DiscoveryConfig_PerformiSNSDiscovery_SIZE = ctypes.sizeof(BOOLEAN)
    MSiSCSI_DiscoveryConfig_PerformiSNSDiscovery_ID = 1
    MSiSCSI_DiscoveryConfig_PerformSLPDiscovery_SIZE = ctypes.sizeof(BOOLEAN)
    MSiSCSI_DiscoveryConfig_PerformSLPDiscovery_ID = 2
    MSiSCSI_DiscoveryConfig_AutomaticiSNSDiscovery_SIZE = (
        ctypes.sizeof(BOOLEAN)
    )
    MSiSCSI_DiscoveryConfig_AutomaticiSNSDiscovery_ID = 3
    MSiSCSI_DiscoveryConfig_InitiatorName_ID = 4
    MSiSCSI_DiscoveryConfig_iSNSServer_SIZE = ctypes.sizeof(ISCSI_IP_Address)
    MSiSCSI_DiscoveryConfig_iSNSServer_ID = 5

    _MSiSCSI_DiscoveryConfig._fields_ = [
        # TRUE if adapter should perform target discovery via iSNS.
        ('PerformiSNSDiscovery', BOOLEAN),
        # TRUE if adapter should perform target discovery via SLP.
        ('PerformSLPDiscovery', BOOLEAN),
        # TRUE if adapter should perform automatic discovery of iSNS server.
        ('AutomaticiSNSDiscovery', BOOLEAN),
        # Default initiator name for registering with iSNS.
        ('InitiatorName', WCHAR * (256 + 1)),
        # If AutomaticiSNSDiscovery is FALSE then this contains the fixed
        # addresses of iSNS servers
        ('iSNSServer', ISCSI_IP_Address),
    ]

    MSiSCSI_DiscoveryConfig_SIZE = (
        FIELD_OFFSET(MSiSCSI_DiscoveryConfig, 'iSNSServer') +
        MSiSCSI_DiscoveryConfig_iSNSServer_SIZE
    )

    # MSiSCSI_RADIUSConfig - MSiSCSI_RADIUSConfig

    # This class is required if adapter supports using RADIUS for CHAP
    # authentication.

    # This class exposes the configuration capabilities if the adapter able to
    # use radius to perform CHAP authentication. Using RADIUS is encouraged
    # since it allows centralized management of CHAP credentials.

    # This class uses PDO instance names with a single instance.

    MSiSCSI_RADIUSConfigGuid = [
        0x8eaef9d8,
        0xc053,
        0x49d3,
        [0x92, 0x05, 0x65, 0xc7, 0x03, 0xc2, 0xec, 0xc1]
    ]

    if not defined(MIDL_PASS):
        MSiSCSI_RADIUSConfig_GUID = DEFINE_GUID(
            0x8eaef9d8,
            0xc053,
            0x49d3,
            0x92,
            0x05,
            0x65,
            0xc7,
            0x03,
            0xc2,
            0xec,
            0xc1
        )
    # END IF

    MSiSCSI_RADIUSConfig_UseRADIUSForCHAP_SIZE = ctypes.sizeof(BOOLEAN)
    MSiSCSI_RADIUSConfig_UseRADIUSForCHAP_ID = 1
    MSiSCSI_RADIUSConfig_SharedSecretSizeInBytes_SIZE = ctypes.sizeof(ULONG)
    MSiSCSI_RADIUSConfig_SharedSecretSizeInBytes_ID = 2
    MSiSCSI_RADIUSConfig_RADIUSServer_SIZE = ctypes.sizeof(ISCSI_IP_Address)
    MSiSCSI_RADIUSConfig_RADIUSServer_ID = 3
    MSiSCSI_RADIUSConfig_BackupRADIUSServer_SIZE = (
        ctypes.sizeof(ISCSI_IP_Address)
    )
    MSiSCSI_RADIUSConfig_BackupRADIUSServer_ID = 4
    MSiSCSI_RADIUSConfig_Reserved_SIZE = ctypes.sizeof(ULONG)
    MSiSCSI_RADIUSConfig_Reserved_ID = 5
    MSiSCSI_RADIUSConfig_SharedSecret_ID = 6

    _MSiSCSI_RADIUSConfig._fields_ = [
        # TRUE if adapter should use RADIUS for CHAP authentication
        ('UseRADIUSForCHAP', BOOLEAN),
        # Size in bytes of shared secret used to communicate with RADIUS
        # servers
        ('SharedSecretSizeInBytes', ULONG),
        # Fixed address of primary RADIUS server
        ('RADIUSServer', ISCSI_IP_Address),
        # Fixed address of backup RADIUS server
        ('BackupRADIUSServer', ISCSI_IP_Address),
        # Must be zero
        ('Reserved', ULONG),
        # Shared secret for communicating with primary and backup RADIUS
        # servers. This field is a variable length array.
        ('SharedSecret', UCHAR * 1)
    ]

# END IF
