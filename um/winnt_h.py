import ctypes
from pyWinAPI import *
from pyWinAPI.shared.wtypes_h import *
from pyWinAPI.shared.winapifamily_h import *
from pyWinAPI.shared.sdkddkver_h import *
from pyWinAPI.shared.guiddef_h import *
_ARM64_ = None
_CHPE_X86_ARM64_ = None
_ARM_ = None

class _PROCESSOR_NUMBER(ctypes.Structure):
    pass


PROCESSOR_NUMBER = _PROCESSOR_NUMBER
PPROCESSOR_NUMBER = POINTER(_PROCESSOR_NUMBER)


class _GROUP_AFFINITY(ctypes.Structure):
    pass


GROUP_AFFINITY = _GROUP_AFFINITY
PGROUP_AFFINITY = POINTER(_GROUP_AFFINITY)


class _FLOAT128(ctypes.Structure):
    pass


FLOAT128 = _FLOAT128


class _LARGE_INTEGER(ctypes.Structure):
    pass


LARGE_INTEGER = _LARGE_INTEGER


class _ULARGE_INTEGER(ctypes.Structure):
    pass


ULARGE_INTEGER = _ULARGE_INTEGER


class _LUID(ctypes.Structure):
    pass


LUID = _LUID
PLUID = POINTER(_LUID)


class _LIST_ENTRY(ctypes.Structure):
    pass


LIST_ENTRY = _LIST_ENTRY
PLIST_ENTRY = POINTER(_LIST_ENTRY)
PRLIST_ENTRY = POINTER(_LIST_ENTRY)


class _SINGLE_LIST_ENTRY(ctypes.Structure):
    pass


SINGLE_LIST_ENTRY = _SINGLE_LIST_ENTRY
PSINGLE_LIST_ENTRY = POINTER(_SINGLE_LIST_ENTRY)


class LIST_ENTRY32(ctypes.Structure):
    pass


class LIST_ENTRY64(ctypes.Structure):
    pass


class _OBJECTID(ctypes.Structure):
    pass


OBJECTID = _OBJECTID


class _ENUM_FLAG_SIZED_INTEGER(ctypes.Structure):
    pass


class _M128A(ctypes.Structure):
    pass


M128A = _M128A
PM128A = POINTER(_M128A)


class _XSAVE_FORMAT(ctypes.Structure):
    pass


XSAVE_FORMAT = _XSAVE_FORMAT
PXSAVE_FORMAT = POINTER(_XSAVE_FORMAT)


class _XSAVE_AREA_HEADER(ctypes.Structure):
    pass


XSAVE_AREA_HEADER = _XSAVE_AREA_HEADER
PXSAVE_AREA_HEADER = POINTER(_XSAVE_AREA_HEADER)


class _XSAVE_AREA(ctypes.Structure):
    pass


XSAVE_AREA = _XSAVE_AREA
PXSAVE_AREA = POINTER(_XSAVE_AREA)


class _XSTATE_CONTEXT(ctypes.Structure):
    pass


XSTATE_CONTEXT = _XSTATE_CONTEXT
PXSTATE_CONTEXT = POINTER(_XSTATE_CONTEXT)


class _SCOPE_TABLE_AMD64(ctypes.Structure):
    pass


SCOPE_TABLE_AMD64 = _SCOPE_TABLE_AMD64
PSCOPE_TABLE_AMD64 = POINTER(_SCOPE_TABLE_AMD64)


class _CONTEXT(ctypes.Structure):
    pass


CONTEXT = _CONTEXT
PCONTEXT = POINTER(_CONTEXT)


class _UNWIND_HISTORY_TABLE_ENTRY(ctypes.Structure):
    pass


UNWIND_HISTORY_TABLE_ENTRY = _UNWIND_HISTORY_TABLE_ENTRY
PUNWIND_HISTORY_TABLE_ENTRY = POINTER(_UNWIND_HISTORY_TABLE_ENTRY)


class _UNWIND_HISTORY_TABLE(ctypes.Structure):
    pass


UNWIND_HISTORY_TABLE = _UNWIND_HISTORY_TABLE
PUNWIND_HISTORY_TABLE = POINTER(_UNWIND_HISTORY_TABLE)


class _DISPATCHER_CONTEXT(ctypes.Structure):
    pass


DISPATCHER_CONTEXT = _DISPATCHER_CONTEXT
PDISPATCHER_CONTEXT = POINTER(_DISPATCHER_CONTEXT)


class _KNONVOLATILE_CONTEXT_POINTERS(ctypes.Structure):
    pass


KNONVOLATILE_CONTEXT_POINTERS = _KNONVOLATILE_CONTEXT_POINTERS
PKNONVOLATILE_CONTEXT_POINTERS = POINTER(_KNONVOLATILE_CONTEXT_POINTERS)


class _SCOPE_TABLE_ARM(ctypes.Structure):
    pass


SCOPE_TABLE_ARM = _SCOPE_TABLE_ARM
PSCOPE_TABLE_ARM = POINTER(_SCOPE_TABLE_ARM)


class _NEON128(ctypes.Structure):
    pass


NEON128 = _NEON128
PNEON128 = POINTER(_NEON128)


class _SCOPE_TABLE_ARM64(ctypes.Structure):
    pass


SCOPE_TABLE_ARM64 = _SCOPE_TABLE_ARM64
PSCOPE_TABLE_ARM64 = POINTER(_SCOPE_TABLE_ARM64)


class _ARM64_NT_NEON128(ctypes.Union):
    pass


ARM64_NT_NEON128 = _ARM64_NT_NEON128
PARM64_NT_NEON128 = POINTER(_ARM64_NT_NEON128)


class _ARM64_NT_CONTEXT(ctypes.Structure):
    pass


ARM64_NT_CONTEXT = _ARM64_NT_CONTEXT
PARM64_NT_CONTEXT = POINTER(_ARM64_NT_CONTEXT)


class _DISPATCHER_CONTEXT_ARM64(ctypes.Structure):
    pass


DISPATCHER_CONTEXT_ARM64 = _DISPATCHER_CONTEXT_ARM64
PDISPATCHER_CONTEXT_ARM64 = POINTER(_DISPATCHER_CONTEXT_ARM64)


class _KNONVOLATILE_CONTEXT_POINTERS_ARM64(ctypes.Structure):
    pass


KNONVOLATILE_CONTEXT_POINTERS_ARM64 = _KNONVOLATILE_CONTEXT_POINTERS_ARM64
PKNONVOLATILE_CONTEXT_POINTERS_ARM64 = POINTER(_KNONVOLATILE_CONTEXT_POINTERS_ARM64)


class _FLOATING_SAVE_AREA(ctypes.Structure):
    pass


FLOATING_SAVE_AREA = _FLOATING_SAVE_AREA


class _LDT_ENTRY(ctypes.Structure):
    pass


LDT_ENTRY = _LDT_ENTRY
PLDT_ENTRY = POINTER(_LDT_ENTRY)


class _WOW64_FLOATING_SAVE_AREA(ctypes.Structure):
    pass


WOW64_FLOATING_SAVE_AREA = _WOW64_FLOATING_SAVE_AREA


class _WOW64_CONTEXT(ctypes.Structure):
    pass


WOW64_CONTEXT = _WOW64_CONTEXT


class _WOW64_LDT_ENTRY(ctypes.Structure):
    pass


WOW64_LDT_ENTRY = _WOW64_LDT_ENTRY
PWOW64_LDT_ENTRY = POINTER(_WOW64_LDT_ENTRY)


class _WOW64_DESCRIPTOR_TABLE_ENTRY(ctypes.Structure):
    pass


WOW64_DESCRIPTOR_TABLE_ENTRY = _WOW64_DESCRIPTOR_TABLE_ENTRY
PWOW64_DESCRIPTOR_TABLE_ENTRY = POINTER(_WOW64_DESCRIPTOR_TABLE_ENTRY)


class _EXCEPTION_RECORD(ctypes.Structure):
    pass


EXCEPTION_RECORD = _EXCEPTION_RECORD


class _EXCEPTION_RECORD32(ctypes.Structure):
    pass


EXCEPTION_RECORD32 = _EXCEPTION_RECORD32
PEXCEPTION_RECORD32 = POINTER(_EXCEPTION_RECORD32)


class _EXCEPTION_RECORD64(ctypes.Structure):
    pass


EXCEPTION_RECORD64 = _EXCEPTION_RECORD64
PEXCEPTION_RECORD64 = POINTER(_EXCEPTION_RECORD64)


class _EXCEPTION_POINTERS(ctypes.Structure):
    pass


EXCEPTION_POINTERS = _EXCEPTION_POINTERS
PEXCEPTION_POINTERS = POINTER(_EXCEPTION_POINTERS)


class _GENERIC_MAPPING(ctypes.Structure):
    pass


GENERIC_MAPPING = _GENERIC_MAPPING


class _LUID_AND_ATTRIBUTES(ctypes.Structure):
    pass


LUID_AND_ATTRIBUTES = _LUID_AND_ATTRIBUTES
PLUID_AND_ATTRIBUTES = POINTER(_LUID_AND_ATTRIBUTES)


class _SID_IDENTIFIER_AUTHORITY(ctypes.Structure):
    pass


SID_IDENTIFIER_AUTHORITY = _SID_IDENTIFIER_AUTHORITY
PSID_IDENTIFIER_AUTHORITY = POINTER(_SID_IDENTIFIER_AUTHORITY)


class _SID(ctypes.Structure):
    pass


SID = _SID
PISID = POINTER(_SID)


class _SE_SID(ctypes.Union):
    pass


SE_SID = _SE_SID
PSE_SID = POINTER(_SE_SID)


class _SID_AND_ATTRIBUTES(ctypes.Structure):
    pass


SID_AND_ATTRIBUTES = _SID_AND_ATTRIBUTES
PSID_AND_ATTRIBUTES = POINTER(_SID_AND_ATTRIBUTES)


class _SID_AND_ATTRIBUTES_HASH(ctypes.Structure):
    pass


SID_AND_ATTRIBUTES_HASH = _SID_AND_ATTRIBUTES_HASH
PSID_AND_ATTRIBUTES_HASH = POINTER(_SID_AND_ATTRIBUTES_HASH)


class _ACL(ctypes.Structure):
    pass


ACL = _ACL


class _ACE_HEADER(ctypes.Structure):
    pass


ACE_HEADER = _ACE_HEADER


class _ACCESS_ALLOWED_ACE(ctypes.Structure):
    pass


ACCESS_ALLOWED_ACE = _ACCESS_ALLOWED_ACE


class _ACCESS_DENIED_ACE(ctypes.Structure):
    pass


ACCESS_DENIED_ACE = _ACCESS_DENIED_ACE


class _SYSTEM_AUDIT_ACE(ctypes.Structure):
    pass


SYSTEM_AUDIT_ACE = _SYSTEM_AUDIT_ACE


class _SYSTEM_ALARM_ACE(ctypes.Structure):
    pass


SYSTEM_ALARM_ACE = _SYSTEM_ALARM_ACE


class _SYSTEM_RESOURCE_ATTRIBUTE_ACE(ctypes.Structure):
    pass


SYSTEM_RESOURCE_ATTRIBUTE_ACE = _SYSTEM_RESOURCE_ATTRIBUTE_ACE
PSYSTEM_RESOURCE_ATTRIBUTE_ACE = POINTER(_SYSTEM_RESOURCE_ATTRIBUTE_ACE)


class _SYSTEM_SCOPED_POLICY_ID_ACE(ctypes.Structure):
    pass


SYSTEM_SCOPED_POLICY_ID_ACE = _SYSTEM_SCOPED_POLICY_ID_ACE
PSYSTEM_SCOPED_POLICY_ID_ACE = POINTER(_SYSTEM_SCOPED_POLICY_ID_ACE)


class _SYSTEM_MANDATORY_LABEL_ACE(ctypes.Structure):
    pass


SYSTEM_MANDATORY_LABEL_ACE = _SYSTEM_MANDATORY_LABEL_ACE
PSYSTEM_MANDATORY_LABEL_ACE = POINTER(_SYSTEM_MANDATORY_LABEL_ACE)


class _SYSTEM_PROCESS_TRUST_LABEL_ACE(ctypes.Structure):
    pass


SYSTEM_PROCESS_TRUST_LABEL_ACE = _SYSTEM_PROCESS_TRUST_LABEL_ACE
PSYSTEM_PROCESS_TRUST_LABEL_ACE = POINTER(_SYSTEM_PROCESS_TRUST_LABEL_ACE)


class _SYSTEM_ACCESS_FILTER_ACE(ctypes.Structure):
    pass


SYSTEM_ACCESS_FILTER_ACE = _SYSTEM_ACCESS_FILTER_ACE
PSYSTEM_ACCESS_FILTER_ACE = POINTER(_SYSTEM_ACCESS_FILTER_ACE)


class _ACCESS_ALLOWED_OBJECT_ACE(ctypes.Structure):
    pass


ACCESS_ALLOWED_OBJECT_ACE = _ACCESS_ALLOWED_OBJECT_ACE
PACCESS_ALLOWED_OBJECT_ACE = POINTER(_ACCESS_ALLOWED_OBJECT_ACE)


class _ACCESS_DENIED_OBJECT_ACE(ctypes.Structure):
    pass


ACCESS_DENIED_OBJECT_ACE = _ACCESS_DENIED_OBJECT_ACE
PACCESS_DENIED_OBJECT_ACE = POINTER(_ACCESS_DENIED_OBJECT_ACE)


class _SYSTEM_AUDIT_OBJECT_ACE(ctypes.Structure):
    pass


SYSTEM_AUDIT_OBJECT_ACE = _SYSTEM_AUDIT_OBJECT_ACE
PSYSTEM_AUDIT_OBJECT_ACE = POINTER(_SYSTEM_AUDIT_OBJECT_ACE)


class _SYSTEM_ALARM_OBJECT_ACE(ctypes.Structure):
    pass


SYSTEM_ALARM_OBJECT_ACE = _SYSTEM_ALARM_OBJECT_ACE
PSYSTEM_ALARM_OBJECT_ACE = POINTER(_SYSTEM_ALARM_OBJECT_ACE)


class _ACCESS_ALLOWED_CALLBACK_ACE(ctypes.Structure):
    pass


ACCESS_ALLOWED_CALLBACK_ACE = _ACCESS_ALLOWED_CALLBACK_ACE
PACCESS_ALLOWED_CALLBACK_ACE = POINTER(_ACCESS_ALLOWED_CALLBACK_ACE)


class _ACCESS_DENIED_CALLBACK_ACE(ctypes.Structure):
    pass


ACCESS_DENIED_CALLBACK_ACE = _ACCESS_DENIED_CALLBACK_ACE
PACCESS_DENIED_CALLBACK_ACE = POINTER(_ACCESS_DENIED_CALLBACK_ACE)


class _SYSTEM_AUDIT_CALLBACK_ACE(ctypes.Structure):
    pass


SYSTEM_AUDIT_CALLBACK_ACE = _SYSTEM_AUDIT_CALLBACK_ACE
PSYSTEM_AUDIT_CALLBACK_ACE = POINTER(_SYSTEM_AUDIT_CALLBACK_ACE)


class _SYSTEM_ALARM_CALLBACK_ACE(ctypes.Structure):
    pass


SYSTEM_ALARM_CALLBACK_ACE = _SYSTEM_ALARM_CALLBACK_ACE
PSYSTEM_ALARM_CALLBACK_ACE = POINTER(_SYSTEM_ALARM_CALLBACK_ACE)


class _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE(ctypes.Structure):
    pass


ACCESS_ALLOWED_CALLBACK_OBJECT_ACE = _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE
PACCESS_ALLOWED_CALLBACK_OBJECT_ACE = POINTER(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE)


class _ACCESS_DENIED_CALLBACK_OBJECT_ACE(ctypes.Structure):
    pass


ACCESS_DENIED_CALLBACK_OBJECT_ACE = _ACCESS_DENIED_CALLBACK_OBJECT_ACE
PACCESS_DENIED_CALLBACK_OBJECT_ACE = POINTER(_ACCESS_DENIED_CALLBACK_OBJECT_ACE)


class _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE(ctypes.Structure):
    pass


SYSTEM_AUDIT_CALLBACK_OBJECT_ACE = _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE
PSYSTEM_AUDIT_CALLBACK_OBJECT_ACE = POINTER(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE)


class _SYSTEM_ALARM_CALLBACK_OBJECT_ACE(ctypes.Structure):
    pass


SYSTEM_ALARM_CALLBACK_OBJECT_ACE = _SYSTEM_ALARM_CALLBACK_OBJECT_ACE
PSYSTEM_ALARM_CALLBACK_OBJECT_ACE = POINTER(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE)


class _ACL_REVISION_INFORMATION(ctypes.Structure):
    pass


ACL_REVISION_INFORMATION = _ACL_REVISION_INFORMATION


class _ACL_SIZE_INFORMATION(ctypes.Structure):
    pass


ACL_SIZE_INFORMATION = _ACL_SIZE_INFORMATION


class _SECURITY_DESCRIPTOR_RELATIVE(ctypes.Structure):
    pass


SECURITY_DESCRIPTOR_RELATIVE = _SECURITY_DESCRIPTOR_RELATIVE
PISECURITY_DESCRIPTOR_RELATIVE = POINTER(_SECURITY_DESCRIPTOR_RELATIVE)


class _SECURITY_DESCRIPTOR(ctypes.Structure):
    pass


SECURITY_DESCRIPTOR = _SECURITY_DESCRIPTOR
PISECURITY_DESCRIPTOR = POINTER(_SECURITY_DESCRIPTOR)


class _SECURITY_OBJECT_AI_PARAMS(ctypes.Structure):
    pass


SECURITY_OBJECT_AI_PARAMS = _SECURITY_OBJECT_AI_PARAMS
PSECURITY_OBJECT_AI_PARAMS = POINTER(_SECURITY_OBJECT_AI_PARAMS)


class _OBJECT_TYPE_LIST(ctypes.Structure):
    pass


OBJECT_TYPE_LIST = _OBJECT_TYPE_LIST
POBJECT_TYPE_LIST = POINTER(_OBJECT_TYPE_LIST)


class _PRIVILEGE_SET(ctypes.Structure):
    pass


PRIVILEGE_SET = _PRIVILEGE_SET
PPRIVILEGE_SET = POINTER(_PRIVILEGE_SET)


class _ACCESS_REASONS(ctypes.Structure):
    pass

ACCESS_REASONS = _ACCESS_REASONS
PACCESS_REASONS = POINTER(_ACCESS_REASONS)


class _SE_SECURITY_DESCRIPTOR(ctypes.Structure):
    pass


SE_SECURITY_DESCRIPTOR = _SE_SECURITY_DESCRIPTOR
PSE_SECURITY_DESCRIPTOR = POINTER(_SE_SECURITY_DESCRIPTOR)


class _SE_ACCESS_REQUEST(ctypes.Structure):
    pass


SE_ACCESS_REQUEST = _SE_ACCESS_REQUEST
PSE_ACCESS_REQUEST = POINTER(_SE_ACCESS_REQUEST)


class _SE_ACCESS_REPLY(ctypes.Structure):
    pass


SE_ACCESS_REPLY = _SE_ACCESS_REPLY
PSE_ACCESS_REPLY = POINTER(_SE_ACCESS_REPLY)


class _TOKEN_USER(ctypes.Structure):
    pass


TOKEN_USER = _TOKEN_USER
PTOKEN_USER = POINTER(_TOKEN_USER)


class _SE_TOKEN_USER(ctypes.Structure):
    pass


SE_TOKEN_USER = _SE_TOKEN_USER
PSE_TOKEN_USER = _SE_TOKEN_USER


class _TOKEN_GROUPS(ctypes.Structure):
    pass


TOKEN_GROUPS = _TOKEN_GROUPS
PTOKEN_GROUPS = POINTER(_TOKEN_GROUPS)


class _TOKEN_PRIVILEGES(ctypes.Structure):
    pass


TOKEN_PRIVILEGES = _TOKEN_PRIVILEGES
PTOKEN_PRIVILEGES = POINTER(_TOKEN_PRIVILEGES)


class _TOKEN_OWNER(ctypes.Structure):
    pass


TOKEN_OWNER = _TOKEN_OWNER
PTOKEN_OWNER = POINTER(_TOKEN_OWNER)


class _TOKEN_PRIMARY_GROUP(ctypes.Structure):
    pass


TOKEN_PRIMARY_GROUP = _TOKEN_PRIMARY_GROUP
PTOKEN_PRIMARY_GROUP = POINTER(_TOKEN_PRIMARY_GROUP)


class _TOKEN_DEFAULT_DACL(ctypes.Structure):
    pass


TOKEN_DEFAULT_DACL = _TOKEN_DEFAULT_DACL
PTOKEN_DEFAULT_DACL = POINTER(_TOKEN_DEFAULT_DACL)


class _TOKEN_USER_CLAIMS(ctypes.Structure):
    pass


TOKEN_USER_CLAIMS = _TOKEN_USER_CLAIMS
PTOKEN_USER_CLAIMS = POINTER(_TOKEN_USER_CLAIMS)


class _TOKEN_DEVICE_CLAIMS(ctypes.Structure):
    pass


TOKEN_DEVICE_CLAIMS = _TOKEN_DEVICE_CLAIMS
PTOKEN_DEVICE_CLAIMS = POINTER(_TOKEN_DEVICE_CLAIMS)


class _TOKEN_GROUPS_AND_PRIVILEGES(ctypes.Structure):
    pass


TOKEN_GROUPS_AND_PRIVILEGES = _TOKEN_GROUPS_AND_PRIVILEGES
PTOKEN_GROUPS_AND_PRIVILEGES = POINTER(_TOKEN_GROUPS_AND_PRIVILEGES)


class _TOKEN_LINKED_TOKEN(ctypes.Structure):
    pass


TOKEN_LINKED_TOKEN = _TOKEN_LINKED_TOKEN
PTOKEN_LINKED_TOKEN = POINTER(_TOKEN_LINKED_TOKEN)


class _TOKEN_ELEVATION(ctypes.Structure):
    pass


TOKEN_ELEVATION = _TOKEN_ELEVATION
PTOKEN_ELEVATION = POINTER(_TOKEN_ELEVATION)


class _TOKEN_MANDATORY_LABEL(ctypes.Structure):
    pass


TOKEN_MANDATORY_LABEL = _TOKEN_MANDATORY_LABEL
PTOKEN_MANDATORY_LABEL = POINTER(_TOKEN_MANDATORY_LABEL)


class _TOKEN_MANDATORY_POLICY(ctypes.Structure):
    pass


TOKEN_MANDATORY_POLICY = _TOKEN_MANDATORY_POLICY
PTOKEN_MANDATORY_POLICY = POINTER(_TOKEN_MANDATORY_POLICY)


class _TOKEN_ACCESS_INFORMATION(ctypes.Structure):
    pass


TOKEN_ACCESS_INFORMATION = _TOKEN_ACCESS_INFORMATION
PTOKEN_ACCESS_INFORMATION = POINTER(_TOKEN_ACCESS_INFORMATION)


class _TOKEN_AUDIT_POLICY(ctypes.Structure):
    pass


TOKEN_AUDIT_POLICY = _TOKEN_AUDIT_POLICY
PTOKEN_AUDIT_POLICY = POINTER(_TOKEN_AUDIT_POLICY)


class _TOKEN_SOURCE(ctypes.Structure):
    pass


TOKEN_SOURCE = _TOKEN_SOURCE
PTOKEN_SOURCE = POINTER(_TOKEN_SOURCE)


class _TOKEN_STATISTICS(ctypes.Structure):
    pass


TOKEN_STATISTICS = _TOKEN_STATISTICS
PTOKEN_STATISTICS = POINTER(_TOKEN_STATISTICS)


class _TOKEN_CONTROL(ctypes.Structure):
    pass


TOKEN_CONTROL = _TOKEN_CONTROL
PTOKEN_CONTROL = POINTER(_TOKEN_CONTROL)


class _TOKEN_ORIGIN(ctypes.Structure):
    pass


TOKEN_ORIGIN = _TOKEN_ORIGIN
PTOKEN_ORIGIN = POINTER(_TOKEN_ORIGIN)


class _TOKEN_APPCONTAINER_INFORMATION(ctypes.Structure):
    pass


TOKEN_APPCONTAINER_INFORMATION = _TOKEN_APPCONTAINER_INFORMATION
PTOKEN_APPCONTAINER_INFORMATION = POINTER(_TOKEN_APPCONTAINER_INFORMATION)


class _TOKEN_SID_INFORMATION(ctypes.Structure):
    pass


TOKEN_SID_INFORMATION = _TOKEN_SID_INFORMATION
PTOKEN_SID_INFORMATION = POINTER(_TOKEN_SID_INFORMATION)


class _TOKEN_BNO_ISOLATION_INFORMATION(ctypes.Structure):
    pass


TOKEN_BNO_ISOLATION_INFORMATION = _TOKEN_BNO_ISOLATION_INFORMATION
PTOKEN_BNO_ISOLATION_INFORMATION = POINTER(_TOKEN_BNO_ISOLATION_INFORMATION)


class _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE(ctypes.Structure):
    pass


CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE
PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = POINTER(_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE)


class _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE(ctypes.Structure):
    pass


CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE = _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE
PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE = POINTER(_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE)


class _CLAIM_SECURITY_ATTRIBUTE_V1(ctypes.Structure):
    pass


CLAIM_SECURITY_ATTRIBUTE_V1 = _CLAIM_SECURITY_ATTRIBUTE_V1
PCLAIM_SECURITY_ATTRIBUTE_V1 = POINTER(_CLAIM_SECURITY_ATTRIBUTE_V1)


class _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1(ctypes.Structure):
    pass


CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1
PCLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = POINTER(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1)


class _CLAIM_SECURITY_ATTRIBUTES_INFORMATION(ctypes.Structure):
    pass


CLAIM_SECURITY_ATTRIBUTES_INFORMATION = _CLAIM_SECURITY_ATTRIBUTES_INFORMATION
PCLAIM_SECURITY_ATTRIBUTES_INFORMATION = POINTER(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION)


class _SECURITY_QUALITY_OF_SERVICE(ctypes.Structure):
    pass


SECURITY_QUALITY_OF_SERVICE = _SECURITY_QUALITY_OF_SERVICE
PSECURITY_QUALITY_OF_SERVICE = POINTER(_SECURITY_QUALITY_OF_SERVICE)


class _SE_IMPERSONATION_STATE(ctypes.Structure):
    pass


SE_IMPERSONATION_STATE = _SE_IMPERSONATION_STATE
PSE_IMPERSONATION_STATE = POINTER(_SE_IMPERSONATION_STATE)


class _SECURITY_CAPABILITIES(ctypes.Structure):
    pass


SECURITY_CAPABILITIES = _SECURITY_CAPABILITIES
PSECURITY_CAPABILITIES = POINTER(_SECURITY_CAPABILITIES)
LPSECURITY_CAPABILITIES = POINTER(_SECURITY_CAPABILITIES)


class _JOB_SET_ARRAY(ctypes.Structure):
    pass


JOB_SET_ARRAY = _JOB_SET_ARRAY
PJOB_SET_ARRAY = POINTER(_JOB_SET_ARRAY)


class _EXCEPTION_REGISTRATION_RECORD(ctypes.Structure):
    pass


EXCEPTION_REGISTRATION_RECORD = _EXCEPTION_REGISTRATION_RECORD


class _NT_TIB(ctypes.Structure):
    pass


NT_TIB = _NT_TIB


class _NT_TIB32(ctypes.Structure):
    pass


NT_TIB32 = _NT_TIB32
PNT_TIB32 = POINTER(_NT_TIB32)


class _NT_TIB64(ctypes.Structure):
    pass


NT_TIB64 = _NT_TIB64
PNT_TIB64 = POINTER(_NT_TIB64)


class _UMS_CREATE_THREAD_ATTRIBUTES(ctypes.Structure):
    pass


UMS_CREATE_THREAD_ATTRIBUTES = _UMS_CREATE_THREAD_ATTRIBUTES
PUMS_CREATE_THREAD_ATTRIBUTES = POINTER(_UMS_CREATE_THREAD_ATTRIBUTES)


class _WOW64_ARCHITECTURE_INFORMATION(ctypes.Structure):
    pass


WOW64_ARCHITECTURE_INFORMATION = _WOW64_ARCHITECTURE_INFORMATION


class _QUOTA_LIMITS(ctypes.Structure):
    pass


QUOTA_LIMITS = _QUOTA_LIMITS
PQUOTA_LIMITS = POINTER(_QUOTA_LIMITS)


class _RATE_QUOTA_LIMIT(ctypes.Union):
    pass


RATE_QUOTA_LIMIT = _RATE_QUOTA_LIMIT
PRATE_QUOTA_LIMIT = POINTER(_RATE_QUOTA_LIMIT)


class _QUOTA_LIMITS_EX(ctypes.Structure):
    pass


QUOTA_LIMITS_EX = _QUOTA_LIMITS_EX
PQUOTA_LIMITS_EX = POINTER(_QUOTA_LIMITS_EX)


class _IO_COUNTERS(ctypes.Structure):
    pass


IO_COUNTERS = _IO_COUNTERS


class _PROCESS_MITIGATION_ASLR_POLICY(ctypes.Structure):
    pass


PROCESS_MITIGATION_ASLR_POLICY = _PROCESS_MITIGATION_ASLR_POLICY
PPROCESS_MITIGATION_ASLR_POLICY = POINTER(_PROCESS_MITIGATION_ASLR_POLICY)


class _PROCESS_MITIGATION_DEP_POLICY(ctypes.Structure):
    pass


PROCESS_MITIGATION_DEP_POLICY = _PROCESS_MITIGATION_DEP_POLICY
PPROCESS_MITIGATION_DEP_POLICY = POINTER(_PROCESS_MITIGATION_DEP_POLICY)


class _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY(ctypes.Structure):
    pass


PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY = _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY
PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY = POINTER(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY)


class _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY(ctypes.Structure):
    pass


PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY = _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY
PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY = POINTER(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY)


class _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY(ctypes.Structure):
    pass


PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY = _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY
PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY = POINTER(_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY)


class _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY(ctypes.Structure):
    pass


PROCESS_MITIGATION_DYNAMIC_CODE_POLICY = _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY
PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY = POINTER(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY)


class _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY(ctypes.Structure):
    pass


PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY = _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY
PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY = POINTER(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY)


class _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY(ctypes.Structure):
    pass


PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY
PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = POINTER(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY)


class _PROCESS_MITIGATION_FONT_DISABLE_POLICY(ctypes.Structure):
    pass


PROCESS_MITIGATION_FONT_DISABLE_POLICY = _PROCESS_MITIGATION_FONT_DISABLE_POLICY
PPROCESS_MITIGATION_FONT_DISABLE_POLICY = POINTER(_PROCESS_MITIGATION_FONT_DISABLE_POLICY)


class _PROCESS_MITIGATION_IMAGE_LOAD_POLICY(ctypes.Structure):
    pass


PROCESS_MITIGATION_IMAGE_LOAD_POLICY = _PROCESS_MITIGATION_IMAGE_LOAD_POLICY
PPROCESS_MITIGATION_IMAGE_LOAD_POLICY = POINTER(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY)


class _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY(ctypes.Structure):
    pass


PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY = _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY
PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY = POINTER(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY)


class _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY(ctypes.Structure):
    pass


PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY = _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY
PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY = POINTER(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY)


class _PROCESS_MITIGATION_CHILD_PROCESS_POLICY(ctypes.Structure):
    pass


PROCESS_MITIGATION_CHILD_PROCESS_POLICY = _PROCESS_MITIGATION_CHILD_PROCESS_POLICY
PPROCESS_MITIGATION_CHILD_PROCESS_POLICY = POINTER(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY)


class _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION(ctypes.Structure):
    pass


JOBOBJECT_BASIC_ACCOUNTING_INFORMATION = _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION
PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION = POINTER(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION)


class _JOBOBJECT_BASIC_LIMIT_INFORMATION(ctypes.Structure):
    pass


JOBOBJECT_BASIC_LIMIT_INFORMATION = _JOBOBJECT_BASIC_LIMIT_INFORMATION
PJOBOBJECT_BASIC_LIMIT_INFORMATION = POINTER(_JOBOBJECT_BASIC_LIMIT_INFORMATION)


class _JOBOBJECT_EXTENDED_LIMIT_INFORMATION(ctypes.Structure):
    pass


JOBOBJECT_EXTENDED_LIMIT_INFORMATION = _JOBOBJECT_EXTENDED_LIMIT_INFORMATION
PJOBOBJECT_EXTENDED_LIMIT_INFORMATION = POINTER(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION)


class _JOBOBJECT_BASIC_PROCESS_ID_LIST(ctypes.Structure):
    pass


JOBOBJECT_BASIC_PROCESS_ID_LIST = _JOBOBJECT_BASIC_PROCESS_ID_LIST
PJOBOBJECT_BASIC_PROCESS_ID_LIST = POINTER(_JOBOBJECT_BASIC_PROCESS_ID_LIST)


class _JOBOBJECT_BASIC_UI_RESTRICTIONS(ctypes.Structure):
    pass


JOBOBJECT_BASIC_UI_RESTRICTIONS = _JOBOBJECT_BASIC_UI_RESTRICTIONS
PJOBOBJECT_BASIC_UI_RESTRICTIONS = POINTER(_JOBOBJECT_BASIC_UI_RESTRICTIONS)


class _JOBOBJECT_SECURITY_LIMIT_INFORMATION(ctypes.Structure):
    pass


JOBOBJECT_SECURITY_LIMIT_INFORMATION = _JOBOBJECT_SECURITY_LIMIT_INFORMATION
PJOBOBJECT_SECURITY_LIMIT_INFORMATION = POINTER(_JOBOBJECT_SECURITY_LIMIT_INFORMATION)


class _JOBOBJECT_END_OF_JOB_TIME_INFORMATION(ctypes.Structure):
    pass


JOBOBJECT_END_OF_JOB_TIME_INFORMATION = _JOBOBJECT_END_OF_JOB_TIME_INFORMATION
PJOBOBJECT_END_OF_JOB_TIME_INFORMATION = POINTER(_JOBOBJECT_END_OF_JOB_TIME_INFORMATION)


class _JOBOBJECT_ASSOCIATE_COMPLETION_PORT(ctypes.Structure):
    pass


JOBOBJECT_ASSOCIATE_COMPLETION_PORT = _JOBOBJECT_ASSOCIATE_COMPLETION_PORT
PJOBOBJECT_ASSOCIATE_COMPLETION_PORT = POINTER(_JOBOBJECT_ASSOCIATE_COMPLETION_PORT)


class _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION(ctypes.Structure):
    pass


JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION
PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = POINTER(_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION)


class _JOBOBJECT_JOBSET_INFORMATION(ctypes.Structure):
    pass


JOBOBJECT_JOBSET_INFORMATION = _JOBOBJECT_JOBSET_INFORMATION
PJOBOBJECT_JOBSET_INFORMATION = POINTER(_JOBOBJECT_JOBSET_INFORMATION)


class _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION(ctypes.Structure):
    pass


JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION
PJOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = POINTER(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION)


class JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2(ctypes.Structure):
    pass


class _JOBOBJECT_LIMIT_VIOLATION_INFORMATION(ctypes.Structure):
    pass


JOBOBJECT_LIMIT_VIOLATION_INFORMATION = _JOBOBJECT_LIMIT_VIOLATION_INFORMATION
PJOBOBJECT_LIMIT_VIOLATION_INFORMATION = POINTER(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION)


class JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2(ctypes.Structure):
    pass


class _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION(ctypes.Structure):
    pass


JOBOBJECT_CPU_RATE_CONTROL_INFORMATION = _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION
PJOBOBJECT_CPU_RATE_CONTROL_INFORMATION = POINTER(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION)


class JOBOBJECT_NET_RATE_CONTROL_INFORMATION(ctypes.Structure):
    pass


class JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE(ctypes.Structure):
    pass


class JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2(ctypes.Structure):
    pass


class JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3(ctypes.Structure):
    pass


class _JOBOBJECT_IO_ATTRIBUTION_STATS(ctypes.Structure):
    pass


JOBOBJECT_IO_ATTRIBUTION_STATS = _JOBOBJECT_IO_ATTRIBUTION_STATS
PJOBOBJECT_IO_ATTRIBUTION_STATS = POINTER(_JOBOBJECT_IO_ATTRIBUTION_STATS)


class _JOBOBJECT_IO_ATTRIBUTION_INFORMATION(ctypes.Structure):
    pass


JOBOBJECT_IO_ATTRIBUTION_INFORMATION = _JOBOBJECT_IO_ATTRIBUTION_INFORMATION
PJOBOBJECT_IO_ATTRIBUTION_INFORMATION = POINTER(_JOBOBJECT_IO_ATTRIBUTION_INFORMATION)


class _SILOOBJECT_BASIC_INFORMATION(ctypes.Structure):
    pass


SILOOBJECT_BASIC_INFORMATION = _SILOOBJECT_BASIC_INFORMATION
PSILOOBJECT_BASIC_INFORMATION = POINTER(_SILOOBJECT_BASIC_INFORMATION)


class _SERVERSILO_BASIC_INFORMATION(ctypes.Structure):
    pass


SERVERSILO_BASIC_INFORMATION = _SERVERSILO_BASIC_INFORMATION
PSERVERSILO_BASIC_INFORMATION = POINTER(_SERVERSILO_BASIC_INFORMATION)


class _CACHE_DESCRIPTOR(ctypes.Structure):
    pass


CACHE_DESCRIPTOR = _CACHE_DESCRIPTOR
PCACHE_DESCRIPTOR = POINTER(_CACHE_DESCRIPTOR)


class _SYSTEM_LOGICAL_PROCESSOR_INFORMATION(ctypes.Structure):
    pass


SYSTEM_LOGICAL_PROCESSOR_INFORMATION = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION
PSYSTEM_LOGICAL_PROCESSOR_INFORMATION = POINTER(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION)


class _PROCESSOR_RELATIONSHIP(ctypes.Structure):
    pass


PROCESSOR_RELATIONSHIP = _PROCESSOR_RELATIONSHIP
PPROCESSOR_RELATIONSHIP = POINTER(_PROCESSOR_RELATIONSHIP)


class _NUMA_NODE_RELATIONSHIP(ctypes.Structure):
    pass


NUMA_NODE_RELATIONSHIP = _NUMA_NODE_RELATIONSHIP
PNUMA_NODE_RELATIONSHIP = POINTER(_NUMA_NODE_RELATIONSHIP)


class _CACHE_RELATIONSHIP(ctypes.Structure):
    pass


CACHE_RELATIONSHIP = _CACHE_RELATIONSHIP
PCACHE_RELATIONSHIP = POINTER(_CACHE_RELATIONSHIP)


class _PROCESSOR_GROUP_INFO(ctypes.Structure):
    pass


PROCESSOR_GROUP_INFO = _PROCESSOR_GROUP_INFO
PPROCESSOR_GROUP_INFO = POINTER(_PROCESSOR_GROUP_INFO)


class _GROUP_RELATIONSHIP(ctypes.Structure):
    pass


GROUP_RELATIONSHIP = _GROUP_RELATIONSHIP
PGROUP_RELATIONSHIP = POINTER(_GROUP_RELATIONSHIP)


class _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX(ctypes.Structure):
    pass


class _SYSTEM_CPU_SET_INFORMATION(ctypes.Structure):
    pass


class _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION(ctypes.Structure):
    pass


SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION
PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = POINTER(_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION)


class _XSTATE_FEATURE(ctypes.Structure):
    pass


XSTATE_FEATURE = _XSTATE_FEATURE
PXSTATE_FEATURE = POINTER(_XSTATE_FEATURE)


class _XSTATE_CONFIGURATION(ctypes.Structure):
    pass


XSTATE_CONFIGURATION = _XSTATE_CONFIGURATION
PXSTATE_CONFIGURATION = POINTER(_XSTATE_CONFIGURATION)


class _MEMORY_BASIC_INFORMATION(ctypes.Structure):
    pass


MEMORY_BASIC_INFORMATION = _MEMORY_BASIC_INFORMATION
PMEMORY_BASIC_INFORMATION = POINTER(_MEMORY_BASIC_INFORMATION)


class _MEMORY_BASIC_INFORMATION32(ctypes.Structure):
    pass


MEMORY_BASIC_INFORMATION32 = _MEMORY_BASIC_INFORMATION32
PMEMORY_BASIC_INFORMATION32 = POINTER(_MEMORY_BASIC_INFORMATION32)


class _MEMORY_BASIC_INFORMATION64(ctypes.Structure):
    pass


MEMORY_BASIC_INFORMATION64 = _MEMORY_BASIC_INFORMATION64
PMEMORY_BASIC_INFORMATION64 = POINTER(_MEMORY_BASIC_INFORMATION64)


class _CFG_CALL_TARGET_INFO(ctypes.Structure):
    pass


CFG_CALL_TARGET_INFO = _CFG_CALL_TARGET_INFO
PCFG_CALL_TARGET_INFO = POINTER(_CFG_CALL_TARGET_INFO)


class MEM_ADDRESS_REQUIREMENTS(ctypes.Structure):
    pass


PMEM_ADDRESS_REQUIREMENTS = POINTER(MEM_ADDRESS_REQUIREMENTS)


class MEM_EXTENDED_PARAMETER(ctypes.Structure):
    pass


PMEM_EXTENDED_PARAMETER = POINTER(MEM_EXTENDED_PARAMETER)


class _ENCLAVE_CREATE_INFO_SGX(ctypes.Structure):
    pass


ENCLAVE_CREATE_INFO_SGX = _ENCLAVE_CREATE_INFO_SGX
PENCLAVE_CREATE_INFO_SGX = POINTER(_ENCLAVE_CREATE_INFO_SGX)


class _ENCLAVE_INIT_INFO_SGX(ctypes.Structure):
    pass


ENCLAVE_INIT_INFO_SGX = _ENCLAVE_INIT_INFO_SGX
PENCLAVE_INIT_INFO_SGX = POINTER(_ENCLAVE_INIT_INFO_SGX)


class _ENCLAVE_CREATE_INFO_VBS(ctypes.Structure):
    pass


ENCLAVE_CREATE_INFO_VBS = _ENCLAVE_CREATE_INFO_VBS
PENCLAVE_CREATE_INFO_VBS = POINTER(_ENCLAVE_CREATE_INFO_VBS)


class _ENCLAVE_INIT_INFO_VBS(ctypes.Structure):
    pass


ENCLAVE_INIT_INFO_VBS = _ENCLAVE_INIT_INFO_VBS
PENCLAVE_INIT_INFO_VBS = POINTER(_ENCLAVE_INIT_INFO_VBS)


class _FILE_ID_128(ctypes.Structure):
    pass


FILE_ID_128 = _FILE_ID_128
PFILE_ID_128 = POINTER(_FILE_ID_128)


class _FILE_NOTIFY_INFORMATION(ctypes.Structure):
    pass


FILE_NOTIFY_INFORMATION = _FILE_NOTIFY_INFORMATION
PFILE_NOTIFY_INFORMATION = POINTER(_FILE_NOTIFY_INFORMATION)


class _FILE_NOTIFY_EXTENDED_INFORMATION(ctypes.Structure):
    pass


FILE_NOTIFY_EXTENDED_INFORMATION = _FILE_NOTIFY_EXTENDED_INFORMATION
PFILE_NOTIFY_EXTENDED_INFORMATION = POINTER(_FILE_NOTIFY_EXTENDED_INFORMATION)


class _FILE_SEGMENT_ELEMENT(ctypes.Union):
    pass


FILE_SEGMENT_ELEMENT = _FILE_SEGMENT_ELEMENT
PFILE_SEGMENT_ELEMENT = POINTER(_FILE_SEGMENT_ELEMENT)


class _REPARSE_GUID_DATA_BUFFER(ctypes.Structure):
    pass


REPARSE_GUID_DATA_BUFFER = _REPARSE_GUID_DATA_BUFFER
PREPARSE_GUID_DATA_BUFFER = POINTER(_REPARSE_GUID_DATA_BUFFER)


class _SCRUB_DATA_INPUT(ctypes.Structure):
    pass


SCRUB_DATA_INPUT = _SCRUB_DATA_INPUT
PSCRUB_DATA_INPUT = POINTER(_SCRUB_DATA_INPUT)


class _SCRUB_PARITY_EXTENT(ctypes.Structure):
    pass


SCRUB_PARITY_EXTENT = _SCRUB_PARITY_EXTENT
PSCRUB_PARITY_EXTENT = POINTER(_SCRUB_PARITY_EXTENT)


class _SCRUB_PARITY_EXTENT_DATA(ctypes.Structure):
    pass


SCRUB_PARITY_EXTENT_DATA = _SCRUB_PARITY_EXTENT_DATA
PSCRUB_PARITY_EXTENT_DATA = POINTER(_SCRUB_PARITY_EXTENT_DATA)


class _SCRUB_DATA_OUTPUT(ctypes.Structure):
    pass


SCRUB_DATA_OUTPUT = _SCRUB_DATA_OUTPUT
PSCRUB_DATA_OUTPUT = POINTER(_SCRUB_DATA_OUTPUT)


class _SHARED_VIRTUAL_DISK_SUPPORT(ctypes.Structure):
    pass


SHARED_VIRTUAL_DISK_SUPPORT = _SHARED_VIRTUAL_DISK_SUPPORT
PSHARED_VIRTUAL_DISK_SUPPORT = POINTER(_SHARED_VIRTUAL_DISK_SUPPORT)


class _NETWORK_APP_INSTANCE_EA(ctypes.Structure):
    pass


NETWORK_APP_INSTANCE_EA = _NETWORK_APP_INSTANCE_EA
PNETWORK_APP_INSTANCE_EA = POINTER(_NETWORK_APP_INSTANCE_EA)


class CM_Power_Data_s(ctypes.Structure):
    pass


CM_POWER_DATA = CM_Power_Data_s
PCM_POWER_DATA = POINTER(CM_Power_Data_s)


class _POWER_USER_PRESENCE(ctypes.Structure):
    pass


POWER_USER_PRESENCE = _POWER_USER_PRESENCE
PPOWER_USER_PRESENCE = POINTER(_POWER_USER_PRESENCE)


class _POWER_SESSION_CONNECT(ctypes.Structure):
    pass


POWER_SESSION_CONNECT = _POWER_SESSION_CONNECT
PPOWER_SESSION_CONNECT = POINTER(_POWER_SESSION_CONNECT)


class _POWER_SESSION_TIMEOUTS(ctypes.Structure):
    pass


POWER_SESSION_TIMEOUTS = _POWER_SESSION_TIMEOUTS
PPOWER_SESSION_TIMEOUTS = POINTER(_POWER_SESSION_TIMEOUTS)


class _POWER_SESSION_RIT_STATE(ctypes.Structure):
    pass


POWER_SESSION_RIT_STATE = _POWER_SESSION_RIT_STATE
PPOWER_SESSION_RIT_STATE = POINTER(_POWER_SESSION_RIT_STATE)


class _POWER_SESSION_WINLOGON(ctypes.Structure):
    pass


POWER_SESSION_WINLOGON = _POWER_SESSION_WINLOGON
PPOWER_SESSION_WINLOGON = POINTER(_POWER_SESSION_WINLOGON)


class _POWER_IDLE_RESILIENCY(ctypes.Structure):
    pass


POWER_IDLE_RESILIENCY = _POWER_IDLE_RESILIENCY
PPOWER_IDLE_RESILIENCY = POINTER(_POWER_IDLE_RESILIENCY)


class _POWER_MONITOR_INVOCATION(ctypes.Structure):
    pass


POWER_MONITOR_INVOCATION = _POWER_MONITOR_INVOCATION
PPOWER_MONITOR_INVOCATION = POINTER(_POWER_MONITOR_INVOCATION)


class _RESUME_PERFORMANCE(ctypes.Structure):
    pass


RESUME_PERFORMANCE = _RESUME_PERFORMANCE
PRESUME_PERFORMANCE = POINTER(_RESUME_PERFORMANCE)


class SET_POWER_SETTING_VALUE(ctypes.Structure):
    pass


PSET_POWER_SETTING_VALUE = POINTER(SET_POWER_SETTING_VALUE)


class NOTIFY_USER_POWER_SETTING(ctypes.Structure):
    pass


PNOTIFY_USER_POWER_SETTING = POINTER(NOTIFY_USER_POWER_SETTING)


class _APPLICATIONLAUNCH_SETTING_VALUE(ctypes.Structure):
    pass


APPLICATIONLAUNCH_SETTING_VALUE = _APPLICATIONLAUNCH_SETTING_VALUE
PAPPLICATIONLAUNCH_SETTING_VALUE = POINTER(_APPLICATIONLAUNCH_SETTING_VALUE)


class _POWER_PLATFORM_INFORMATION(ctypes.Structure):
    pass


POWER_PLATFORM_INFORMATION = _POWER_PLATFORM_INFORMATION
PPOWER_PLATFORM_INFORMATION = POINTER(_POWER_PLATFORM_INFORMATION)


class BATTERY_REPORTING_SCALE(ctypes.Structure):
    pass


PBATTERY_REPORTING_SCALE = POINTER(BATTERY_REPORTING_SCALE)


class PPM_WMI_LEGACY_PERFSTATE(ctypes.Structure):
    pass


PPPM_WMI_LEGACY_PERFSTATE = POINTER(PPM_WMI_LEGACY_PERFSTATE)


class PPM_WMI_IDLE_STATE(ctypes.Structure):
    pass


PPPM_WMI_IDLE_STATE = POINTER(PPM_WMI_IDLE_STATE)


class PPM_WMI_IDLE_STATES(ctypes.Structure):
    pass


PPPM_WMI_IDLE_STATES = POINTER(PPM_WMI_IDLE_STATES)


class PPM_WMI_IDLE_STATES_EX(ctypes.Structure):
    pass


PPPM_WMI_IDLE_STATES_EX = POINTER(PPM_WMI_IDLE_STATES_EX)


class PPM_WMI_PERF_STATE(ctypes.Structure):
    pass


PPPM_WMI_PERF_STATE = POINTER(PPM_WMI_PERF_STATE)


class PPM_WMI_PERF_STATES(ctypes.Structure):
    pass


PPPM_WMI_PERF_STATES = POINTER(PPM_WMI_PERF_STATES)


class PPM_WMI_PERF_STATES_EX(ctypes.Structure):
    pass


PPPM_WMI_PERF_STATES_EX = POINTER(PPM_WMI_PERF_STATES_EX)


class PPM_IDLE_STATE_ACCOUNTING(ctypes.Structure):
    pass


PPPM_IDLE_STATE_ACCOUNTING = POINTER(PPM_IDLE_STATE_ACCOUNTING)


class PPM_IDLE_ACCOUNTING(ctypes.Structure):
    pass


PPPM_IDLE_ACCOUNTING = POINTER(PPM_IDLE_ACCOUNTING)


class PPM_IDLE_STATE_BUCKET_EX(ctypes.Structure):
    pass


PPPM_IDLE_STATE_BUCKET_EX = POINTER(PPM_IDLE_STATE_BUCKET_EX)


class PPM_IDLE_STATE_ACCOUNTING_EX(ctypes.Structure):
    pass

PPPM_IDLE_STATE_ACCOUNTING_EX = POINTER(PPM_IDLE_STATE_ACCOUNTING_EX)


class PPM_IDLE_ACCOUNTING_EX(ctypes.Structure):
    pass


PPPM_IDLE_ACCOUNTING_EX = POINTER(PPM_IDLE_ACCOUNTING_EX)


class PPM_PERFSTATE_EVENT(ctypes.Structure):
    pass


PPPM_PERFSTATE_EVENT = POINTER(PPM_PERFSTATE_EVENT)


class PPM_PERFSTATE_DOMAIN_EVENT(ctypes.Structure):
    pass


PPPM_PERFSTATE_DOMAIN_EVENT = POINTER(PPM_PERFSTATE_DOMAIN_EVENT)


class PPM_IDLESTATE_EVENT(ctypes.Structure):
    pass


PPPM_IDLESTATE_EVENT = POINTER(PPM_IDLESTATE_EVENT)


class PPM_THERMALCHANGE_EVENT(ctypes.Structure):
    pass


PPPM_THERMALCHANGE_EVENT = POINTER(PPM_THERMALCHANGE_EVENT)


class PPM_THERMAL_POLICY_EVENT(ctypes.Structure):
    pass

PPPM_THERMAL_POLICY_EVENT = POINTER(PPM_THERMAL_POLICY_EVENT)


class POWER_ACTION_POLICY(ctypes.Structure):
    pass


PPOWER_ACTION_POLICY = POINTER(POWER_ACTION_POLICY)


class SYSTEM_POWER_LEVEL(ctypes.Structure):
    pass


PSYSTEM_POWER_LEVEL = POINTER(SYSTEM_POWER_LEVEL)


class _SYSTEM_POWER_POLICY(ctypes.Structure):
    pass


SYSTEM_POWER_POLICY = _SYSTEM_POWER_POLICY
PSYSTEM_POWER_POLICY = POINTER(_SYSTEM_POWER_POLICY)


class PROCESSOR_IDLESTATE_INFO(ctypes.Structure):
    pass


PPROCESSOR_IDLESTATE_INFO = POINTER(PROCESSOR_IDLESTATE_INFO)


class PROCESSOR_IDLESTATE_POLICY(ctypes.Structure):
    pass


PPROCESSOR_IDLESTATE_POLICY = POINTER(PROCESSOR_IDLESTATE_POLICY)


class _PROCESSOR_POWER_POLICY_INFO(ctypes.Structure):
    pass


PROCESSOR_POWER_POLICY_INFO = _PROCESSOR_POWER_POLICY_INFO
PPROCESSOR_POWER_POLICY_INFO = POINTER(_PROCESSOR_POWER_POLICY_INFO)


class _PROCESSOR_POWER_POLICY(ctypes.Structure):
    pass


PROCESSOR_POWER_POLICY = _PROCESSOR_POWER_POLICY
PPROCESSOR_POWER_POLICY = POINTER(_PROCESSOR_POWER_POLICY)


class PROCESSOR_PERFSTATE_POLICY(ctypes.Structure):
    pass


PPROCESSOR_PERFSTATE_POLICY = POINTER(PROCESSOR_PERFSTATE_POLICY)


class _ADMINISTRATOR_POWER_POLICY(ctypes.Structure):
    pass


ADMINISTRATOR_POWER_POLICY = _ADMINISTRATOR_POWER_POLICY
PADMINISTRATOR_POWER_POLICY = POINTER(_ADMINISTRATOR_POWER_POLICY)


class _HIBERFILE_BUCKET(ctypes.Structure):
    pass


HIBERFILE_BUCKET = _HIBERFILE_BUCKET
PHIBERFILE_BUCKET = POINTER(_HIBERFILE_BUCKET)


class SYSTEM_POWER_CAPABILITIES(ctypes.Structure):
    pass


PSYSTEM_POWER_CAPABILITIES = POINTER(SYSTEM_POWER_CAPABILITIES)


class SYSTEM_BATTERY_STATE(ctypes.Structure):
    pass


PSYSTEM_BATTERY_STATE = POINTER(SYSTEM_BATTERY_STATE)


class _IMAGE_DOS_HEADER(ctypes.Structure):
    pass


IMAGE_DOS_HEADER = _IMAGE_DOS_HEADER
PIMAGE_DOS_HEADER = POINTER(_IMAGE_DOS_HEADER)


class _IMAGE_OS2_HEADER(ctypes.Structure):
    pass


IMAGE_OS2_HEADER = _IMAGE_OS2_HEADER
PIMAGE_OS2_HEADER = POINTER(_IMAGE_OS2_HEADER)


class _IMAGE_VXD_HEADER(ctypes.Structure):
    pass


IMAGE_VXD_HEADER = _IMAGE_VXD_HEADER
PIMAGE_VXD_HEADER = POINTER(_IMAGE_VXD_HEADER)


class _IMAGE_FILE_HEADER(ctypes.Structure):
    pass


IMAGE_FILE_HEADER = _IMAGE_FILE_HEADER
PIMAGE_FILE_HEADER = POINTER(_IMAGE_FILE_HEADER)


class _IMAGE_DATA_DIRECTORY(ctypes.Structure):
    pass


IMAGE_DATA_DIRECTORY = _IMAGE_DATA_DIRECTORY
PIMAGE_DATA_DIRECTORY = POINTER(_IMAGE_DATA_DIRECTORY)


class _IMAGE_OPTIONAL_HEADER(ctypes.Structure):
    pass


IMAGE_OPTIONAL_HEADER32 = _IMAGE_OPTIONAL_HEADER
PIMAGE_OPTIONAL_HEADER32 = POINTER(_IMAGE_OPTIONAL_HEADER)


class _IMAGE_ROM_OPTIONAL_HEADER(ctypes.Structure):
    pass


IMAGE_ROM_OPTIONAL_HEADER = _IMAGE_ROM_OPTIONAL_HEADER
PIMAGE_ROM_OPTIONAL_HEADER = POINTER(_IMAGE_ROM_OPTIONAL_HEADER)


class _IMAGE_OPTIONAL_HEADER64(ctypes.Structure):
    pass


IMAGE_OPTIONAL_HEADER64 = _IMAGE_OPTIONAL_HEADER64
PIMAGE_OPTIONAL_HEADER64 = POINTER(_IMAGE_OPTIONAL_HEADER64)


class _IMAGE_NT_HEADERS64(ctypes.Structure):
    pass


IMAGE_NT_HEADERS64 = _IMAGE_NT_HEADERS64
PIMAGE_NT_HEADERS64 = POINTER(_IMAGE_NT_HEADERS64)


class _IMAGE_NT_HEADERS(ctypes.Structure):
    pass


IMAGE_NT_HEADERS32 = _IMAGE_NT_HEADERS
PIMAGE_NT_HEADERS32 = POINTER(_IMAGE_NT_HEADERS)


class _IMAGE_ROM_HEADERS(ctypes.Structure):
    pass


IMAGE_ROM_HEADERS = _IMAGE_ROM_HEADERS
PIMAGE_ROM_HEADERS = POINTER(_IMAGE_ROM_HEADERS)


class ANON_OBJECT_HEADER(ctypes.Structure):
    pass


class ANON_OBJECT_HEADER_V2(ctypes.Structure):
    pass


class ANON_OBJECT_HEADER_BIGOBJ(ctypes.Structure):
    pass


class _IMAGE_SECTION_HEADER(ctypes.Structure):
    pass


IMAGE_SECTION_HEADER = _IMAGE_SECTION_HEADER
PIMAGE_SECTION_HEADER = POINTER(_IMAGE_SECTION_HEADER)


class _IMAGE_SYMBOL(ctypes.Structure):
    pass


IMAGE_SYMBOL = _IMAGE_SYMBOL


class _IMAGE_SYMBOL_EX(ctypes.Structure):
    pass


IMAGE_SYMBOL_EX = _IMAGE_SYMBOL_EX


class IMAGE_AUX_SYMBOL_TOKEN_DEF(ctypes.Structure):
    pass


class _IMAGE_AUX_SYMBOL(ctypes.Union):
    pass


IMAGE_AUX_SYMBOL = _IMAGE_AUX_SYMBOL


class _IMAGE_AUX_SYMBOL_EX(ctypes.Union):
    pass


IMAGE_AUX_SYMBOL_EX = _IMAGE_AUX_SYMBOL_EX


class _IMAGE_RELOCATION(ctypes.Structure):
    pass


IMAGE_RELOCATION = _IMAGE_RELOCATION


class _IMAGE_LINENUMBER(ctypes.Structure):
    pass


IMAGE_LINENUMBER = _IMAGE_LINENUMBER


class _IMAGE_BASE_RELOCATION(ctypes.Structure):
    pass


IMAGE_BASE_RELOCATION = _IMAGE_BASE_RELOCATION


class _IMAGE_ARCHIVE_MEMBER_HEADER(ctypes.Structure):
    pass


IMAGE_ARCHIVE_MEMBER_HEADER = _IMAGE_ARCHIVE_MEMBER_HEADER
PIMAGE_ARCHIVE_MEMBER_HEADER = POINTER(_IMAGE_ARCHIVE_MEMBER_HEADER)


class _IMAGE_EXPORT_DIRECTORY(ctypes.Structure):
    pass


IMAGE_EXPORT_DIRECTORY = _IMAGE_EXPORT_DIRECTORY
PIMAGE_EXPORT_DIRECTORY = POINTER(_IMAGE_EXPORT_DIRECTORY)


class _IMAGE_IMPORT_BY_NAME(ctypes.Structure):
    pass


IMAGE_IMPORT_BY_NAME = _IMAGE_IMPORT_BY_NAME
PIMAGE_IMPORT_BY_NAME = POINTER(_IMAGE_IMPORT_BY_NAME)


class _IMAGE_THUNK_DATA64(ctypes.Structure):
    pass


IMAGE_THUNK_DATA64 = _IMAGE_THUNK_DATA64


class _IMAGE_THUNK_DATA32(ctypes.Structure):
    pass


IMAGE_THUNK_DATA32 = _IMAGE_THUNK_DATA32


class _IMAGE_TLS_DIRECTORY64(ctypes.Structure):
    pass


IMAGE_TLS_DIRECTORY64 = _IMAGE_TLS_DIRECTORY64


class _IMAGE_TLS_DIRECTORY32(ctypes.Structure):
    pass


IMAGE_TLS_DIRECTORY32 = _IMAGE_TLS_DIRECTORY32


class _IMAGE_IMPORT_DESCRIPTOR(ctypes.Structure):
    pass


IMAGE_IMPORT_DESCRIPTOR = _IMAGE_IMPORT_DESCRIPTOR


class _IMAGE_BOUND_IMPORT_DESCRIPTOR(ctypes.Structure):
    pass


IMAGE_BOUND_IMPORT_DESCRIPTOR = _IMAGE_BOUND_IMPORT_DESCRIPTOR
PIMAGE_BOUND_IMPORT_DESCRIPTOR = POINTER(_IMAGE_BOUND_IMPORT_DESCRIPTOR)


class _IMAGE_BOUND_FORWARDER_REF(ctypes.Structure):
    pass


IMAGE_BOUND_FORWARDER_REF = _IMAGE_BOUND_FORWARDER_REF
PIMAGE_BOUND_FORWARDER_REF = POINTER(_IMAGE_BOUND_FORWARDER_REF)


class _IMAGE_DELAYLOAD_DESCRIPTOR(ctypes.Structure):
    pass


IMAGE_DELAYLOAD_DESCRIPTOR = _IMAGE_DELAYLOAD_DESCRIPTOR
PIMAGE_DELAYLOAD_DESCRIPTOR = POINTER(_IMAGE_DELAYLOAD_DESCRIPTOR)


class _IMAGE_RESOURCE_DIRECTORY(ctypes.Structure):
    pass


IMAGE_RESOURCE_DIRECTORY = _IMAGE_RESOURCE_DIRECTORY
PIMAGE_RESOURCE_DIRECTORY = POINTER(_IMAGE_RESOURCE_DIRECTORY)


class _IMAGE_RESOURCE_DIRECTORY_ENTRY(ctypes.Structure):
    pass


IMAGE_RESOURCE_DIRECTORY_ENTRY = _IMAGE_RESOURCE_DIRECTORY_ENTRY
PIMAGE_RESOURCE_DIRECTORY_ENTRY = POINTER(_IMAGE_RESOURCE_DIRECTORY_ENTRY)


class _IMAGE_RESOURCE_DIRECTORY_STRING(ctypes.Structure):
    pass


IMAGE_RESOURCE_DIRECTORY_STRING = _IMAGE_RESOURCE_DIRECTORY_STRING
PIMAGE_RESOURCE_DIRECTORY_STRING = POINTER(_IMAGE_RESOURCE_DIRECTORY_STRING)


class _IMAGE_RESOURCE_DIR_STRING_U(ctypes.Structure):
    pass


IMAGE_RESOURCE_DIR_STRING_U = _IMAGE_RESOURCE_DIR_STRING_U
PIMAGE_RESOURCE_DIR_STRING_U = POINTER(_IMAGE_RESOURCE_DIR_STRING_U)


class _IMAGE_RESOURCE_DATA_ENTRY(ctypes.Structure):
    pass


IMAGE_RESOURCE_DATA_ENTRY = _IMAGE_RESOURCE_DATA_ENTRY
PIMAGE_RESOURCE_DATA_ENTRY = POINTER(_IMAGE_RESOURCE_DATA_ENTRY)


class _IMAGE_LOAD_CONFIG_CODE_INTEGRITY(ctypes.Structure):
    pass


IMAGE_LOAD_CONFIG_CODE_INTEGRITY = _IMAGE_LOAD_CONFIG_CODE_INTEGRITY
PIMAGE_LOAD_CONFIG_CODE_INTEGRITY = POINTER(_IMAGE_LOAD_CONFIG_CODE_INTEGRITY)


class _IMAGE_DYNAMIC_RELOCATION_TABLE(ctypes.Structure):
    pass


IMAGE_DYNAMIC_RELOCATION_TABLE = _IMAGE_DYNAMIC_RELOCATION_TABLE
PIMAGE_DYNAMIC_RELOCATION_TABLE = POINTER(_IMAGE_DYNAMIC_RELOCATION_TABLE)


class _IMAGE_DYNAMIC_RELOCATION32(ctypes.Structure):
    pass


IMAGE_DYNAMIC_RELOCATION32 = _IMAGE_DYNAMIC_RELOCATION32
PIMAGE_DYNAMIC_RELOCATION32 = POINTER(_IMAGE_DYNAMIC_RELOCATION32)


class _IMAGE_DYNAMIC_RELOCATION64(ctypes.Structure):
    pass


IMAGE_DYNAMIC_RELOCATION64 = _IMAGE_DYNAMIC_RELOCATION64
PIMAGE_DYNAMIC_RELOCATION64 = POINTER(_IMAGE_DYNAMIC_RELOCATION64)


class _IMAGE_DYNAMIC_RELOCATION32_V2(ctypes.Structure):
    pass


IMAGE_DYNAMIC_RELOCATION32_V2 = _IMAGE_DYNAMIC_RELOCATION32_V2
PIMAGE_DYNAMIC_RELOCATION32_V2 = POINTER(_IMAGE_DYNAMIC_RELOCATION32_V2)


class _IMAGE_DYNAMIC_RELOCATION64_V2(ctypes.Structure):
    pass


IMAGE_DYNAMIC_RELOCATION64_V2 = _IMAGE_DYNAMIC_RELOCATION64_V2
PIMAGE_DYNAMIC_RELOCATION64_V2 = POINTER(_IMAGE_DYNAMIC_RELOCATION64_V2)


class _IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER(ctypes.Structure):
    pass


IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER = _IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER


class _IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER(ctypes.Structure):
    pass


IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER = _IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER


class _IMAGE_LOAD_CONFIG_DIRECTORY32(ctypes.Structure):
    pass


IMAGE_LOAD_CONFIG_DIRECTORY32 = _IMAGE_LOAD_CONFIG_DIRECTORY32
PIMAGE_LOAD_CONFIG_DIRECTORY32 = POINTER(_IMAGE_LOAD_CONFIG_DIRECTORY32)


class _IMAGE_LOAD_CONFIG_DIRECTORY64(ctypes.Structure):
    pass


IMAGE_LOAD_CONFIG_DIRECTORY64 = _IMAGE_LOAD_CONFIG_DIRECTORY64
PIMAGE_LOAD_CONFIG_DIRECTORY64 = POINTER(_IMAGE_LOAD_CONFIG_DIRECTORY64)


class _IMAGE_HOT_PATCH_INFO(ctypes.Structure):
    pass


IMAGE_HOT_PATCH_INFO = _IMAGE_HOT_PATCH_INFO
PIMAGE_HOT_PATCH_INFO = POINTER(_IMAGE_HOT_PATCH_INFO)


class _IMAGE_HOT_PATCH_BASE(ctypes.Structure):
    pass


IMAGE_HOT_PATCH_BASE = _IMAGE_HOT_PATCH_BASE
PIMAGE_HOT_PATCH_BASE = POINTER(_IMAGE_HOT_PATCH_BASE)


class _IMAGE_HOT_PATCH_HASHES(ctypes.Structure):
    pass


IMAGE_HOT_PATCH_HASHES = _IMAGE_HOT_PATCH_HASHES
PIMAGE_HOT_PATCH_HASHES = POINTER(_IMAGE_HOT_PATCH_HASHES)


class _IMAGE_CE_RUNTIME_FUNCTION_ENTRY(ctypes.Structure):
    pass


IMAGE_CE_RUNTIME_FUNCTION_ENTRY = _IMAGE_CE_RUNTIME_FUNCTION_ENTRY
PIMAGE_CE_RUNTIME_FUNCTION_ENTRY = POINTER(_IMAGE_CE_RUNTIME_FUNCTION_ENTRY)


class _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY(ctypes.Structure):
    pass


IMAGE_ARM_RUNTIME_FUNCTION_ENTRY = _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY
PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY = POINTER(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY)


class _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY(ctypes.Structure):
    pass


IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY
PIMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = POINTER(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY)


class _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY(ctypes.Structure):
    pass


IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = POINTER(_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY)


class _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY(ctypes.Structure):
    pass


IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY
PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = POINTER(_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY)


class _IMAGE_RUNTIME_FUNCTION_ENTRY(ctypes.Structure):
    pass


_PIMAGE_RUNTIME_FUNCTION_ENTRY = POINTER(_IMAGE_RUNTIME_FUNCTION_ENTRY)


class _IMAGE_ENCLAVE_CONFIG32(ctypes.Structure):
    pass


IMAGE_ENCLAVE_CONFIG32 = _IMAGE_ENCLAVE_CONFIG32
PIMAGE_ENCLAVE_CONFIG32 = POINTER(_IMAGE_ENCLAVE_CONFIG32)


class _IMAGE_ENCLAVE_CONFIG64(ctypes.Structure):
    pass


IMAGE_ENCLAVE_CONFIG64 = _IMAGE_ENCLAVE_CONFIG64
PIMAGE_ENCLAVE_CONFIG64 = POINTER(_IMAGE_ENCLAVE_CONFIG64)


class _IMAGE_ENCLAVE_IMPORT(ctypes.Structure):
    pass


IMAGE_ENCLAVE_IMPORT = _IMAGE_ENCLAVE_IMPORT
PIMAGE_ENCLAVE_IMPORT = POINTER(_IMAGE_ENCLAVE_IMPORT)


class _IMAGE_DEBUG_DIRECTORY(ctypes.Structure):
    pass


IMAGE_DEBUG_DIRECTORY = _IMAGE_DEBUG_DIRECTORY
PIMAGE_DEBUG_DIRECTORY = POINTER(_IMAGE_DEBUG_DIRECTORY)


class _IMAGE_COFF_SYMBOLS_HEADER(ctypes.Structure):
    pass


IMAGE_COFF_SYMBOLS_HEADER = _IMAGE_COFF_SYMBOLS_HEADER
PIMAGE_COFF_SYMBOLS_HEADER = POINTER(_IMAGE_COFF_SYMBOLS_HEADER)


class _FPO_DATA(ctypes.Structure):
    pass


FPO_DATA = _FPO_DATA
PFPO_DATA = POINTER(_FPO_DATA)


class _IMAGE_DEBUG_MISC(ctypes.Structure):
    pass


IMAGE_DEBUG_MISC = _IMAGE_DEBUG_MISC
PIMAGE_DEBUG_MISC = POINTER(_IMAGE_DEBUG_MISC)


class _IMAGE_FUNCTION_ENTRY(ctypes.Structure):
    pass


IMAGE_FUNCTION_ENTRY = _IMAGE_FUNCTION_ENTRY
PIMAGE_FUNCTION_ENTRY = POINTER(_IMAGE_FUNCTION_ENTRY)


class _IMAGE_FUNCTION_ENTRY64(ctypes.Structure):
    pass


IMAGE_FUNCTION_ENTRY64 = _IMAGE_FUNCTION_ENTRY64
PIMAGE_FUNCTION_ENTRY64 = POINTER(_IMAGE_FUNCTION_ENTRY64)


class _IMAGE_SEPARATE_DEBUG_HEADER(ctypes.Structure):
    pass


IMAGE_SEPARATE_DEBUG_HEADER = _IMAGE_SEPARATE_DEBUG_HEADER
PIMAGE_SEPARATE_DEBUG_HEADER = POINTER(_IMAGE_SEPARATE_DEBUG_HEADER)


class _NON_PAGED_DEBUG_INFO(ctypes.Structure):
    pass


NON_PAGED_DEBUG_INFO = _NON_PAGED_DEBUG_INFO
PNON_PAGED_DEBUG_INFO = POINTER(_NON_PAGED_DEBUG_INFO)


class _ImageArchitectureHeader(ctypes.Structure):
    pass


IMAGE_ARCHITECTURE_HEADER = _ImageArchitectureHeader
PIMAGE_ARCHITECTURE_HEADER = POINTER(_ImageArchitectureHeader)


class _ImageArchitectureEntry(ctypes.Structure):
    pass


IMAGE_ARCHITECTURE_ENTRY = _ImageArchitectureEntry
PIMAGE_ARCHITECTURE_ENTRY = POINTER(_ImageArchitectureEntry)


class IMPORT_OBJECT_HEADER(ctypes.Structure):
    pass


class IMAGE_COR20_HEADER(ctypes.Structure):
    pass


PIMAGE_COR20_HEADER = POINTER(IMAGE_COR20_HEADER)


class _SLIST_ENTRY(ctypes.Structure):
    pass


SLIST_ENTRY = _SLIST_ENTRY
PSLIST_ENTRY = POINTER(_SLIST_ENTRY)


class _SLIST_HEADER(ctypes.Union):
    pass


SLIST_HEADER = _SLIST_HEADER
PSLIST_HEADER = POINTER(_SLIST_HEADER)


class _RTL_RUN_ONCE(ctypes.Union):
    pass


RTL_RUN_ONCE = _RTL_RUN_ONCE
PRTL_RUN_ONCE = POINTER(_RTL_RUN_ONCE)


class _RTL_BARRIER(ctypes.Structure):
    pass


RTL_BARRIER = _RTL_BARRIER
PRTL_BARRIER = POINTER(_RTL_BARRIER)


class _MESSAGE_RESOURCE_ENTRY(ctypes.Structure):
    pass


MESSAGE_RESOURCE_ENTRY = _MESSAGE_RESOURCE_ENTRY
PMESSAGE_RESOURCE_ENTRY = POINTER(_MESSAGE_RESOURCE_ENTRY)


class _MESSAGE_RESOURCE_BLOCK(ctypes.Structure):
    pass


MESSAGE_RESOURCE_BLOCK = _MESSAGE_RESOURCE_BLOCK
PMESSAGE_RESOURCE_BLOCK = POINTER(_MESSAGE_RESOURCE_BLOCK)


class _MESSAGE_RESOURCE_DATA(ctypes.Structure):
    pass


MESSAGE_RESOURCE_DATA = _MESSAGE_RESOURCE_DATA
PMESSAGE_RESOURCE_DATA = POINTER(_MESSAGE_RESOURCE_DATA)


class _OSVERSIONINFOA(ctypes.Structure):
    pass


OSVERSIONINFOA = _OSVERSIONINFOA
POSVERSIONINFOA = POINTER(_OSVERSIONINFOA)
LPOSVERSIONINFOA = POINTER(_OSVERSIONINFOA)


class _OSVERSIONINFOW(ctypes.Structure):
    pass


OSVERSIONINFOW = _OSVERSIONINFOW
POSVERSIONINFOW = POINTER(_OSVERSIONINFOW)
LPOSVERSIONINFOW = POINTER(_OSVERSIONINFOW)
RTL_OSVERSIONINFOW = _OSVERSIONINFOW
PRTL_OSVERSIONINFOW = POINTER(_OSVERSIONINFOW)


class _OSVERSIONINFOEXA(ctypes.Structure):
    pass

OSVERSIONINFOEXA = _OSVERSIONINFOEXA
POSVERSIONINFOEXA = POINTER(_OSVERSIONINFOEXA)
LPOSVERSIONINFOEXA = POINTER(_OSVERSIONINFOEXA)


class _OSVERSIONINFOEXW(ctypes.Structure):
    pass


OSVERSIONINFOEXW = _OSVERSIONINFOEXW
POSVERSIONINFOEXW = POINTER(_OSVERSIONINFOEXW)
LPOSVERSIONINFOEXW = POINTER(_OSVERSIONINFOEXW)
RTL_OSVERSIONINFOEXW = _OSVERSIONINFOEXW
PRTL_OSVERSIONINFOEXW = POINTER(_OSVERSIONINFOEXW)


class _NV_MEMORY_RANGE(ctypes.Structure):
    pass


NV_MEMORY_RANGE = _NV_MEMORY_RANGE
PNV_MEMORY_RANGE = POINTER(_NV_MEMORY_RANGE)


class CORRELATION_VECTOR(ctypes.Structure):
    pass


class _CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG(ctypes.Structure):
    pass


CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG = _CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG
PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG = POINTER(_CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG)


class _IMAGE_POLICY_ENTRY(ctypes.Structure):
    pass


IMAGE_POLICY_ENTRY = _IMAGE_POLICY_ENTRY


class _IMAGE_POLICY_METADATA(ctypes.Structure):
    pass


IMAGE_POLICY_METADATA = _IMAGE_POLICY_METADATA


class _RTL_CRITICAL_SECTION_DEBUG(ctypes.Structure):
    pass


RTL_CRITICAL_SECTION_DEBUG = _RTL_CRITICAL_SECTION_DEBUG
PRTL_CRITICAL_SECTION_DEBUG = POINTER(_RTL_CRITICAL_SECTION_DEBUG)
RTL_RESOURCE_DEBUG = _RTL_CRITICAL_SECTION_DEBUG
PRTL_RESOURCE_DEBUG = POINTER(_RTL_CRITICAL_SECTION_DEBUG)

class _RTL_CRITICAL_SECTION(ctypes.Structure):
    pass


RTL_CRITICAL_SECTION = _RTL_CRITICAL_SECTION
PRTL_CRITICAL_SECTION = POINTER(_RTL_CRITICAL_SECTION)


class _RTL_SRWLOCK(ctypes.Structure):
    pass


RTL_SRWLOCK = _RTL_SRWLOCK
PRTL_SRWLOCK = POINTER(_RTL_SRWLOCK)


class _RTL_CONDITION_VARIABLE(ctypes.Structure):
    pass


RTL_CONDITION_VARIABLE = _RTL_CONDITION_VARIABLE
PRTL_CONDITION_VARIABLE = POINTER(_RTL_CONDITION_VARIABLE)


class _HEAP_OPTIMIZE_RESOURCES_INFORMATION(ctypes.Structure):
    pass


HEAP_OPTIMIZE_RESOURCES_INFORMATION = _HEAP_OPTIMIZE_RESOURCES_INFORMATION
PHEAP_OPTIMIZE_RESOURCES_INFORMATION = POINTER(_HEAP_OPTIMIZE_RESOURCES_INFORMATION)


class _ACTIVATION_CONTEXT_QUERY_INDEX(ctypes.Structure):
    pass


ACTIVATION_CONTEXT_QUERY_INDEX = _ACTIVATION_CONTEXT_QUERY_INDEX
PACTIVATION_CONTEXT_QUERY_INDEX = POINTER(_ACTIVATION_CONTEXT_QUERY_INDEX)


class _ASSEMBLY_FILE_DETAILED_INFORMATION(ctypes.Structure):
    pass


ASSEMBLY_FILE_DETAILED_INFORMATION = _ASSEMBLY_FILE_DETAILED_INFORMATION
PASSEMBLY_FILE_DETAILED_INFORMATION = POINTER(_ASSEMBLY_FILE_DETAILED_INFORMATION)


class _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION(ctypes.Structure):
    pass


ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION = _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION
PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION = POINTER(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION)


class _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION(ctypes.Structure):
    pass


ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION
PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = POINTER(_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION)


class _COMPATIBILITY_CONTEXT_ELEMENT(ctypes.Structure):
    pass


COMPATIBILITY_CONTEXT_ELEMENT = _COMPATIBILITY_CONTEXT_ELEMENT
PCOMPATIBILITY_CONTEXT_ELEMENT = POINTER(_COMPATIBILITY_CONTEXT_ELEMENT)


class _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION(ctypes.Structure):
    pass


ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION = _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION
PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION = POINTER(_ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION)


class _SUPPORTED_OS_INFO(ctypes.Structure):
    pass


SUPPORTED_OS_INFO = _SUPPORTED_OS_INFO
PSUPPORTED_OS_INFO = POINTER(_SUPPORTED_OS_INFO)


class _ACTIVATION_CONTEXT_DETAILED_INFORMATION(ctypes.Structure):
    pass


ACTIVATION_CONTEXT_DETAILED_INFORMATION = _ACTIVATION_CONTEXT_DETAILED_INFORMATION
PACTIVATION_CONTEXT_DETAILED_INFORMATION = POINTER(_ACTIVATION_CONTEXT_DETAILED_INFORMATION)


class _HARDWARE_COUNTER_DATA(ctypes.Structure):
    pass


HARDWARE_COUNTER_DATA = _HARDWARE_COUNTER_DATA
PHARDWARE_COUNTER_DATA = POINTER(_HARDWARE_COUNTER_DATA)


class _PERFORMANCE_DATA(ctypes.Structure):
    pass


PERFORMANCE_DATA = _PERFORMANCE_DATA
PPERFORMANCE_DATA = POINTER(_PERFORMANCE_DATA)


class _EVENTLOGRECORD(ctypes.Structure):
    pass


EVENTLOGRECORD = _EVENTLOGRECORD
PEVENTLOGRECORD = POINTER(_EVENTLOGRECORD)


class _EVENTSFORLOGFILE(ctypes.Structure):
    pass


class _PACKEDEVENTINFO(ctypes.Structure):
    pass


class _TAPE_ERASE(ctypes.Structure):
    pass


TAPE_ERASE = _TAPE_ERASE
PTAPE_ERASE = POINTER(_TAPE_ERASE)


class _TAPE_PREPARE(ctypes.Structure):
    pass


TAPE_PREPARE = _TAPE_PREPARE
PTAPE_PREPARE = POINTER(_TAPE_PREPARE)


class _TAPE_WRITE_MARKS(ctypes.Structure):
    pass


TAPE_WRITE_MARKS = _TAPE_WRITE_MARKS
PTAPE_WRITE_MARKS = POINTER(_TAPE_WRITE_MARKS)


class _TAPE_GET_POSITION(ctypes.Structure):
    pass


TAPE_GET_POSITION = _TAPE_GET_POSITION
PTAPE_GET_POSITION = POINTER(_TAPE_GET_POSITION)


class _TAPE_SET_POSITION(ctypes.Structure):
    pass


TAPE_SET_POSITION = _TAPE_SET_POSITION
PTAPE_SET_POSITION = POINTER(_TAPE_SET_POSITION)


class _TAPE_GET_DRIVE_PARAMETERS(ctypes.Structure):
    pass


TAPE_GET_DRIVE_PARAMETERS = _TAPE_GET_DRIVE_PARAMETERS
PTAPE_GET_DRIVE_PARAMETERS = POINTER(_TAPE_GET_DRIVE_PARAMETERS)


class _TAPE_SET_DRIVE_PARAMETERS(ctypes.Structure):
    pass


TAPE_SET_DRIVE_PARAMETERS = _TAPE_SET_DRIVE_PARAMETERS
PTAPE_SET_DRIVE_PARAMETERS = POINTER(_TAPE_SET_DRIVE_PARAMETERS)


class _TAPE_GET_MEDIA_PARAMETERS(ctypes.Structure):
    pass


TAPE_GET_MEDIA_PARAMETERS = _TAPE_GET_MEDIA_PARAMETERS
PTAPE_GET_MEDIA_PARAMETERS = POINTER(_TAPE_GET_MEDIA_PARAMETERS)


class _TAPE_SET_MEDIA_PARAMETERS(ctypes.Structure):
    pass


TAPE_SET_MEDIA_PARAMETERS = _TAPE_SET_MEDIA_PARAMETERS
PTAPE_SET_MEDIA_PARAMETERS = POINTER(_TAPE_SET_MEDIA_PARAMETERS)


class _TAPE_CREATE_PARTITION(ctypes.Structure):
    pass


TAPE_CREATE_PARTITION = _TAPE_CREATE_PARTITION
PTAPE_CREATE_PARTITION = POINTER(_TAPE_CREATE_PARTITION)


class _TAPE_WMI_OPERATIONS(ctypes.Structure):
    pass


TAPE_WMI_OPERATIONS = _TAPE_WMI_OPERATIONS
PTAPE_WMI_OPERATIONS = POINTER(_TAPE_WMI_OPERATIONS)


class _TRANSACTION_BASIC_INFORMATION(ctypes.Structure):
    pass


TRANSACTION_BASIC_INFORMATION = _TRANSACTION_BASIC_INFORMATION
PTRANSACTION_BASIC_INFORMATION = POINTER(_TRANSACTION_BASIC_INFORMATION)


class _TRANSACTIONMANAGER_BASIC_INFORMATION(ctypes.Structure):
    pass


TRANSACTIONMANAGER_BASIC_INFORMATION = _TRANSACTIONMANAGER_BASIC_INFORMATION
PTRANSACTIONMANAGER_BASIC_INFORMATION = POINTER(_TRANSACTIONMANAGER_BASIC_INFORMATION)


class _TRANSACTIONMANAGER_LOG_INFORMATION(ctypes.Structure):
    pass


TRANSACTIONMANAGER_LOG_INFORMATION = _TRANSACTIONMANAGER_LOG_INFORMATION
PTRANSACTIONMANAGER_LOG_INFORMATION = POINTER(_TRANSACTIONMANAGER_LOG_INFORMATION)


class _TRANSACTIONMANAGER_LOGPATH_INFORMATION(ctypes.Structure):
    pass


TRANSACTIONMANAGER_LOGPATH_INFORMATION = _TRANSACTIONMANAGER_LOGPATH_INFORMATION
PTRANSACTIONMANAGER_LOGPATH_INFORMATION = POINTER(_TRANSACTIONMANAGER_LOGPATH_INFORMATION)


class _TRANSACTIONMANAGER_RECOVERY_INFORMATION(ctypes.Structure):
    pass


TRANSACTIONMANAGER_RECOVERY_INFORMATION = _TRANSACTIONMANAGER_RECOVERY_INFORMATION
PTRANSACTIONMANAGER_RECOVERY_INFORMATION = POINTER(_TRANSACTIONMANAGER_RECOVERY_INFORMATION)


class _TRANSACTIONMANAGER_OLDEST_INFORMATION(ctypes.Structure):
    pass


TRANSACTIONMANAGER_OLDEST_INFORMATION = _TRANSACTIONMANAGER_OLDEST_INFORMATION
PTRANSACTIONMANAGER_OLDEST_INFORMATION = POINTER(_TRANSACTIONMANAGER_OLDEST_INFORMATION)


class _TRANSACTION_PROPERTIES_INFORMATION(ctypes.Structure):
    pass


TRANSACTION_PROPERTIES_INFORMATION = _TRANSACTION_PROPERTIES_INFORMATION
PTRANSACTION_PROPERTIES_INFORMATION = POINTER(_TRANSACTION_PROPERTIES_INFORMATION)


class _TRANSACTION_BIND_INFORMATION(ctypes.Structure):
    pass


TRANSACTION_BIND_INFORMATION = _TRANSACTION_BIND_INFORMATION
PTRANSACTION_BIND_INFORMATION = POINTER(_TRANSACTION_BIND_INFORMATION)


class _TRANSACTION_ENLISTMENT_PAIR(ctypes.Structure):
    pass


TRANSACTION_ENLISTMENT_PAIR = _TRANSACTION_ENLISTMENT_PAIR
PTRANSACTION_ENLISTMENT_PAIR = POINTER(_TRANSACTION_ENLISTMENT_PAIR)


class _TRANSACTION_ENLISTMENTS_INFORMATION(ctypes.Structure):
    pass


TRANSACTION_ENLISTMENTS_INFORMATION = _TRANSACTION_ENLISTMENTS_INFORMATION
PTRANSACTION_ENLISTMENTS_INFORMATION = POINTER(_TRANSACTION_ENLISTMENTS_INFORMATION)


class _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION(ctypes.Structure):
    pass


TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION
PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = POINTER(_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION)


class _RESOURCEMANAGER_BASIC_INFORMATION(ctypes.Structure):
    pass


RESOURCEMANAGER_BASIC_INFORMATION = _RESOURCEMANAGER_BASIC_INFORMATION
PRESOURCEMANAGER_BASIC_INFORMATION = POINTER(_RESOURCEMANAGER_BASIC_INFORMATION)


class _RESOURCEMANAGER_COMPLETION_INFORMATION(ctypes.Structure):
    pass


RESOURCEMANAGER_COMPLETION_INFORMATION = _RESOURCEMANAGER_COMPLETION_INFORMATION
PRESOURCEMANAGER_COMPLETION_INFORMATION = POINTER(_RESOURCEMANAGER_COMPLETION_INFORMATION)


class _ENLISTMENT_BASIC_INFORMATION(ctypes.Structure):
    pass


ENLISTMENT_BASIC_INFORMATION = _ENLISTMENT_BASIC_INFORMATION
PENLISTMENT_BASIC_INFORMATION = POINTER(_ENLISTMENT_BASIC_INFORMATION)


class _ENLISTMENT_CRM_INFORMATION(ctypes.Structure):
    pass


ENLISTMENT_CRM_INFORMATION = _ENLISTMENT_CRM_INFORMATION
PENLISTMENT_CRM_INFORMATION = POINTER(_ENLISTMENT_CRM_INFORMATION)


class _TRANSACTION_LIST_ENTRY(ctypes.Structure):
    pass


TRANSACTION_LIST_ENTRY = _TRANSACTION_LIST_ENTRY
PTRANSACTION_LIST_ENTRY = POINTER(_TRANSACTION_LIST_ENTRY)


class _TRANSACTION_LIST_INFORMATION(ctypes.Structure):
    pass


TRANSACTION_LIST_INFORMATION = _TRANSACTION_LIST_INFORMATION
PTRANSACTION_LIST_INFORMATION = POINTER(_TRANSACTION_LIST_INFORMATION)


class _KTMOBJECT_CURSOR(ctypes.Structure):
    pass


KTMOBJECT_CURSOR = _KTMOBJECT_CURSOR
PKTMOBJECT_CURSOR = POINTER(_KTMOBJECT_CURSOR)


class _TP_POOL_STACK_INFORMATION(ctypes.Structure):
    pass


TP_POOL_STACK_INFORMATION = _TP_POOL_STACK_INFORMATION
PTP_POOL_STACK_INFORMATION = POINTER(_TP_POOL_STACK_INFORMATION)


class _TP_CALLBACK_ENVIRON_V3(ctypes.Structure):
    pass


TP_CALLBACK_ENVIRON_V3 = _TP_CALLBACK_ENVIRON_V3


class _TP_CALLBACK_ENVIRON_V1(ctypes.Structure):
    pass


TP_CALLBACK_ENVIRON_V1 = _TP_CALLBACK_ENVIRON_V1


# /* + + BUILD Version: 0073  Increment this if a change has global effects
# Copyright (c) Microsoft Corporation. All rights reserved. Module Name:
# winnt.h Abstract: This module defines the 32 - Bit Windows types and
# constants that are defined by NT, but exposed through the Win32 API.
# Revision History: - -
_WINNT_ = None
if not defined(_WINNT_):
    _WINNT_ = 1

    if _MSC_VER >= 1200:
        pass
    # END IF

    if defined(__cplusplus):
        pass
    # END IF

    from pyWinAPI.km.crt.ctype_h import * # NOQA
    from pyWinAPI.shared.winapifamily_h import * # NOQA

    ANYSIZE_ARRAY = 1

    _MSC_EXTENSIONS = None

    # For compilers that don't support nameless unions/structs
    DUMMYUNIONNAME = 1
    if not defined(DUMMYUNIONNAME):
        NONAMELESSUNION = None
        if defined(NONAMELESSUNION) or not defined(_MSC_EXTENSIONS):
            pass
        else:
            pass
    # END IF   DUMMYUNIONNAME

    DUMMYSTRUCTNAME = 1
    if not defined(DUMMYSTRUCTNAME):
        NONAMELESSUNION = None
        if defined(NONAMELESSUNION) or not defined(_MSC_EXTENSIONS):
            pass
        else:
            pass
    # END IF   DUMMYSTRUCTNAME

    # end_ntoshvp
    from pyWinAPI.shared.specstrings_h import * # NOQA
    from pyWinAPI.shared.kernelspecs_h import * # NOQA

    STRICT_GS_ENABLED = None
    if defined(STRICT_GS_ENABLED):
        pass
    # END IF

    # begin_ntoshvp

    if (
        defined(_M_MRX000) and
        not (defined(MIDL_PASS) or defined(RC_INVOKED)) and
        defined(ENABLE_RESTRICTED)
    ):
        RESTRICTED_POINTER = POINTER
    else:
        RESTRICTED_POINTER = POINTER
    # END IF

    if (
        defined(_M_MRX000) or
        defined(_M_ALPHA) or
        defined(_M_PPC) or
        defined(_M_IA64) or
        defined(_M_AMD64) or
        defined(_M_ARM) or
        defined(_M_ARM64)
    ):
        ALIGNMENT_MACHINE = 1

        UNALIGNED = VOID
        if defined(_WIN64):
            UNALIGNED64 = VOID
        else:
            UNALIGNED64 = VOID
        # END IF
    else:
        UNALIGNED = VOID
        UNALIGNED64 = VOID
    # END IF
    # end_ntoshvp

    if defined(_WIN64) or defined(_M_ALPHA):
        MAX_NATURAL_ALIGNMENT = ctypes.sizeof(ULONGLONG)
        MEMORY_ALLOCATION_ALIGNMENT = 16
    else:
        MAX_NATURAL_ALIGNMENT = ctypes.sizeof(DWORD)
        MEMORY_ALLOCATION_ALIGNMENT = 8
    # END IF

    # TYPE_ALIGNMENT will return the alignment requirements of a given type for
    # the current platform.
    if defined(__cplusplus):
        if _MSC_VER >= 1300:
            def TYPE_ALIGNMENT(t):
                return ctypes.alignment(t)
                # return __alignof(t)
        # END IF
    else:
        def TYPE_ALIGNMENT(t):
            class _TEMP_(ctypes.Structure):
                _fields_ = [
                    ('x', CHAR),
                    ('test', t)
                ]
            return FIELD_OFFSET(_TEMP_, 'test')

    # END IF
    # Note: RC_INVOKED is checked in PROBE_ALIGNMENT to maintain compatibility
    # with previous
    # versions of the SDK which did not block inclusion in an .RC file.

    if defined(_AMD64_) or defined(_X86_):
        def PROBE_ALIGNMENT(_s):
            return TYPE_ALIGNMENT(DWORD)

    elif defined(_IA64_) or defined(_ARM_) or defined(_ARM64_):
        # TODO: WOWXX - Unblock ARM. Make all alignment checks DWORD for now.
        def PROBE_ALIGNMENT(_s):
            return TYPE_ALIGNMENT(DWORD)

    elif not defined(RC_INVOKED):
        pass
    # END IF

    # Define PROBE_ALIGNMENT32 to be the same as PROBE_ALIGNMENT on x86, so
    # that
    # code hosting x86 under WoW can handle x86's maximum guaranteed alignment.
    def PROBE_ALIGNMENT32(_s):
        return TYPE_ALIGNMENT(DWORD)

    # begin_ntoshvp
    # C_ASSERT() can be used to perform many compile - time assertions:
    # type sizes, field offsets, etc.
    # An assertion failure results in error C2118: negative subscript.
    SORTPP_PASS = None
    if not defined(SORTPP_PASS):
        def C_ASSERT(e):
            if e:
                return 1
            else:
                return -1
    else:
        def C_ASSERT(e):
            return 1        # nothing
    # END IF
    from pyWinAPI.shared.basetsd_h import * # NOQA

    if not defined(DECLSPEC_IMPORT):
        if (
            (
                defined(_M_IX86) or
                defined(_M_IA64) or
                defined(_M_AMD64) or
                defined(_M_ARM) or
                defined(_M_ARM64)
            ) and
            not defined(MIDL_PASS)
        ):
            DECLSPEC_IMPORT = VOID
        else:
            DECLSPEC_IMPORT = VOID
        # END IF
    # END IF

    if not defined(DECLSPEC_NORETURN):
        if _MSC_VER >= 1200 and not defined(MIDL_PASS):
            DECLSPEC_NORETURN = VOID
        else:
            DECLSPEC_NORETURN = VOID
        # END IF
    # END IF

    if not defined(DECLSPEC_NOTHROW):
        if _MSC_VER >= 1200 and not defined(MIDL_PASS):
            DECLSPEC_NOTHROW = VOID
        else:
            DECLSPEC_NOTHROW = VOID
        # END IF
    # END IF

    if not defined(DECLSPEC_ALIGN):
        if _MSC_VER >= 1300 and not defined(MIDL_PASS):
            def DECLSPEC_ALIGN(x):
                return ctypes.alignment(x)
        else:
            def DECLSPEC_ALIGN(x):
                pass

        # END IF
    # END IF
    # end_ntoshvp

    if not defined(SYSTEM_CACHE_ALIGNMENT_SIZE):
        if defined(_AMD64_) or defined(_X86_):
            SYSTEM_CACHE_ALIGNMENT_SIZE = 64
        else:
            SYSTEM_CACHE_ALIGNMENT_SIZE = 128
        # END IF
    # END IF
    if not defined(DECLSPEC_CACHEALIGN):
        DECLSPEC_CACHEALIGN = DECLSPEC_ALIGN(SYSTEM_CACHE_ALIGNMENT_SIZE)
    # END IF
    if not defined(DECLSPEC_UUID):
        if _MSC_VER >= 1100 and defined(__cplusplus):
            def DECLSPEC_UUID(x):
                return uuid(x)
        else:
            def DECLSPEC_UUID(x):
                pass

        # END IF
    # END IF
    if not defined(DECLSPEC_NOVTABLE):
        if _MSC_VER >= 1100 and defined(__cplusplus):
            DECLSPEC_NOVTABLE = VOID
        else:
            DECLSPEC_NOVTABLE = VOID
        # END IF
    # END IF

    if not defined(DECLSPEC_SELECTANY):
        if _MSC_VER >= 1100:
            DECLSPEC_SELECTANY = VOID
        else:
            DECLSPEC_SELECTANY = VOID
        # END IF
    # END IF

    if not defined(NOP_FUNCTION):
        if _MSC_VER >= 1210:
            NOP_FUNCTION = VOID
        else:
            NOP_FUNCTION = 0
        # END IF
    # END IF

    if not defined(DECLSPEC_ADDRSAFE):
        if _MSC_VER >= 1200 and (defined(_M_ALPHA) or defined(_M_AXP64)):
            DECLSPEC_ADDRSAFE = VOID
        else:
            DECLSPEC_ADDRSAFE = VOID
        # END IF
    # END IF

    if not defined(DECLSPEC_SAFEBUFFERS):
        if _MSC_VER >= 1600:
            DECLSPEC_SAFEBUFFERS = VOID
        else:
            DECLSPEC_SAFEBUFFERS = VOID
        # END IF
    # END IF

    if not defined(DECLSPEC_NOINLINE):
        if _MSC_VER >= 1300:
            DECLSPEC_NOINLINE = VOID
        else:
            DECLSPEC_NOINLINE = VOID
        # END IF
    # END IF

    if not defined(DECLSPEC_SAFEBUFFERS):
        if _MSC_VER >= 1300:
            DECLSPEC_SAFEBUFFERS = VOID
        else:
            DECLSPEC_SAFEBUFFERS = VOID
        # END IF
    # END IF
    _D1VERSIONLKG171_ = None
    if not defined(DECLSPEC_GUARDNOCF):

        if _MSC_FULL_VER >= 170065501 or defined(_D1VERSIONLKG171_):
            DECLSPEC_GUARDNOCF = VOID
        else:
            DECLSPEC_GUARDNOCF = VOID
        # END IF
    # END IF

    if not defined(DECLSPEC_GUARD_SUPPRESS):
        if _MSC_FULL_VER >= 181040116 or defined(_D1VERSIONLKG171_):
            DECLSPEC_GUARD_SUPPRESS = VOID
        else:
            DECLSPEC_GUARD_SUPPRESS = VOID
        # END IF
    # END IF

    if not defined(DECLSPEC_CHPE_GUEST):
        if _M_HYBRID:
            DECLSPEC_CHPE_GUEST = VOID
        else:
            DECLSPEC_CHPE_GUEST = VOID
        # END IF
    # END IF

    if not defined(DECLSPEC_CHPE_PATCHABLE):
        if _M_HYBRID:
            DECLSPEC_CHPE_PATCHABLE = VOID
        else:
            DECLSPEC_CHPE_PATCHABLE = VOID
        # END IF
    # END IF

    # begin_ntoshvp
    if not defined(FORCEINLINE):
        if _MSC_VER >= 1200:
            FORCEINLINE = VOID
        else:
            FORCEINLINE = VOID
        # END IF
    # END IF
    # CFORCEINLINE: __forceinline required for correctness.
    CFORCEINLINE = FORCEINLINE

    # STKFORCEINLINE: __forceinline required for correctness due to counting
    # stack
    # frames for a stack trace being captured.
    STKFORCEINLINE = FORCEINLINE

    # PFORCEINLINE: __forceinline required for performance.
    if not defined(PFORCEINLINE):
        PFORCEINLINE = FORCEINLINE
    # END IF
    # end_ntoshvp
    if not defined(DECLSPEC_DEPRECATED):
        if _MSC_VER >= 1300 and not defined(MIDL_PASS):
            DECLSPEC_DEPRECATED = VOID
            DEPRECATE_SUPPORTED = 1
        else:
            DECLSPEC_DEPRECATED = VOID
        # END IF
    else:
        DEPRECATE_SUPPORTED = None
    # END IF

    DEPRECATE_DDK_FUNCTIONS = None

    if defined(DEPRECATE_DDK_FUNCTIONS):
        if defined(_NTDDK_):
            DECLSPEC_DEPRECATED_DDK = DECLSPEC_DEPRECATED
            DEPRECATE_SUPPORTED = None
            if defined(DEPRECATE_SUPPORTED):
                PRAGMA_DEPRECATED_DDK = 1
            # END IF
        else:
            DECLSPEC_DEPRECATED_DDK = VOID
            PRAGMA_DEPRECATED_DDK = 1
        # END IF
    else:
        DECLSPEC_DEPRECATED_DDK = VOID
        PRAGMA_DEPRECATED_DDK = 0
    # END IF
    # begin_ntoshvp
    # Void

    import comtypes

    if _MSC_VER >= 800 or defined(_STDCALL_SUPPORTED):
        NTAPI = comtypes.CFUNCTYPE
    else:
        NTAPI = comtypes.CFUNCTYPE
    # END IF

    if not defined(_M_CEE_PURE):
        NTAPI_INLINE = NTAPI
    else:
        NTAPI_INLINE = NTAPI
    # END IF

    # Define API decoration for direct importing system DLL references.
    if not defined(_NTSYSTEM_):
        NTSYSAPI = DECLSPEC_IMPORT
        NTSYSCALLAPI = DECLSPEC_IMPORT
    else:
        _NTDLLBUILD_ = None

        NTSYSAPI = DECLSPEC_IMPORT
        if defined(_NTDLLBUILD_):
            NTSYSCALLAPI = DECLSPEC_IMPORT
        else:
            NTSYSCALLAPI = DECLSPEC_ADDRSAFE
        # END IF
    # END IF

    # Basics
    if not defined(VOID):
        if not defined(MIDL_PASS):
            pass
        # END IF
    # END IF

    # UNICODE (Wide Character) types
    if not defined(_MAC):
        pass
    else:
        # some Macintosh compilers don't define WCHAR in a convenient
        # location, or define it as a char
        pass
    # END IF

    WINDOWS_ENABLE_CPLUSPLUS = None
    if (
        _WIN32_WINNT >= 0x0600 or
        (defined(__cplusplus) and defined(WINDOWS_ENABLE_CPLUSPLUS))
    ):
        # UCS (Universal Character Set) types
        # Even pre - Unicode agreement, UCS values are always in the
        # range U + 00000000 to U + 7FFFFFFF, so we'll pick an obvious
        # value.
        UCSCHAR_INVALID_CHARACTER = 0xFFFFFFFF
        MIN_UCSCHAR = 0

        # We'll assume here that the ISO - 10646 / Unicode agreement
        # not to assign code points after U + 0010FFFF holds so that
        # we do not have to have separate "UCSCHAR" and "UNICODECHAR"
        # types.
        MAX_UCSCHAR = 0x0010FFFF
    # END IF   _WIN32_WINNT >= 0x0600

    # ANSI (Multi - byte Character) types
    # Neutral ANSI/UNICODE types and macros
    if defined(UNICODE):
        _TCHAR_DEFINED = None

        if not defined(_TCHAR_DEFINED):
            _TCHAR_DEFINED = 1
        # END IF  not _TCHAR_DEFINED

        def __TEXT(quote):
            return quote
    else:
        #  r_winnt
        _TCHAR_DEFINED = None
        if not defined(_TCHAR_DEFINED):
            _TCHAR_DEFINED = 1
        # END IF  not _TCHAR_DEFINED

        def __TEXT(quote):
            return quote
    # END IF  UNICODE

    def TEXT(quote):
        return __TEXT(quote)

    ALL_PROCESSOR_GROUPS = 0xFFFF

    # Structure to represent a system wide processor number. It contains a
    # group number and relative processor number within the group.
    _PROCESSOR_NUMBER._fields_ = [
        ('Group', WORD),
        ('Number', BYTE),
        ('Reserved', BYTE),
    ]

    # Structure to represent a group - specific affinity, such as that of a
    # thread. Specifies the group number and the affinity within that group.
    _GROUP_AFFINITY._fields_ = [
        ('Mask', KAFFINITY),
        ('Group', WORD),
        ('Reserved', WORD * 3),
    ]
    if defined(_WIN64):
        MAXIMUM_PROC_PER_GROUP = 64
    else:
        MAXIMUM_PROC_PER_GROUP = 32
    # END IF
    MAXIMUM_PROCESSORS = MAXIMUM_PROC_PER_GROUP

    # begin_ntoshvp
    # Handle to an Object
    if defined(STRICT):
        if 0 and (_MSC_VER > 1000):
            def DECLARE_HANDLE(name):
                return HANDLE # #__; typedef struct name##__ *name
        else:
            def DECLARE_HANDLE(name):
                return HANDLE # #__{int unused;}; typedef struct name##__ *name
        # END IF
    else:
        def DECLARE_HANDLE(name):
            return HANDLE
    # END IF

    # end_ntoshvp
    # Flag (bit) fields
    # begin_ntoshvp
    # Component Object Model defines, and macros
    if not defined(_HRESULT_DEFINED):
        _HRESULT_DEFINED = 1
        if defined(__midl):
            HRESULT = LONG
        else:
            HRESULT = LONG
        # END IF   __midl
    # END IF   not _HRESULT_DEFINED

    # end_ntoshvp
    if defined(__cplusplus):
        EXTERN_C = VOID
        EXTERN_C_START = VOID
        EXTERN_C_END = VOID
    else:
        EXTERN_C = VOID
        EXTERN_C_START = VOID
        EXTERN_C_END = VOID
    # END IF
    _MPPC_ = None
    if defined(_WIN32) or defined(_MPPC_):
        # Win32 doesn't support
        _68K_ = None
        if defined(_68K_):
            def STDMETHODCALLTYPE(idl_flags, res_type, func_name):
                return comtypes.COMMETHOD(idl_flags, res_type, func_name)
        else:
            def STDMETHODCALLTYPE(idl_flags, res_type, func_name):
                return comtypes.COMMETHOD(idl_flags, res_type, func_name)
        # END IF

        def STDMETHODVCALLTYPE(idl_flags, res_type, func_name, *args):
            return comtypes.COMMETHOD(idl_flags, res_type, func_name, *args)


        def STDAPICALLTYPE(restype):
            return comtypes.CFUNCTYPE(restype)


        def STDAPIVCALLTYPE(restype, *argtypes):
            return comtypes.CFUNCTYPE(restype, *argtypes)

    else:
        def STDMETHODCALLTYPE(idl_flags, res_type, func_name):
            return comtypes.COMMETHOD(idl_flags, res_type, func_name)


        def STDMETHODVCALLTYPE(idl_flags, res_type, func_name, *args):
            return comtypes.COMMETHOD(idl_flags, res_type, func_name, *args)


        def STDAPICALLTYPE(restype):
            return comtypes.CFUNCTYPE(restype)


        def STDAPIVCALLTYPE(restype, *argtypes):
            return comtypes.CFUNCTYPE(restype, *argtypes)
    # END IF

    def STDAPI():
        return STDAPICALLTYPE(HRESULT)

    def STDAPI_(type):
        return STDAPICALLTYPE(type)

    def STDMETHODIMP(method_name):
        return STDMETHODCALLTYPE([], HRESULT, method_name)

    def STDMETHODIMP_(type):
        def wrapper(method_name):
            return STDMETHODCALLTYPE([], type, method_name)

        return wrapper

    # The 'V' versions allow Variable Argument lists.

    def STDAPIV(*args):
        return STDAPIVCALLTYPE(HRESULT, *args)

    def STDAPIV_(type, *args):
        return STDAPIVCALLTYPE(type, *args)

    def STDMETHODIMPV(method_name, *args):
        return STDMETHODCALLTYPE([], HRESULT, method_name, *args)


    def STDMETHODIMPV_(type):
        def wrapper(method_name, *args):
            return STDMETHODCALLTYPE([], type, method_name, *args)

        return wrapper

    STDOVERRIDEMETHODIMP = STDMETHODIMP
    IFACEMETHODIMP = STDMETHODIMP


    def IFACEMETHODIMP_(type):
        return STDMETHODIMP_(type)

    STDOVERRIDEMETHODIMPV = STDMETHODIMPV
    IFACEMETHODIMPV = STDMETHODIMPV

    def IFACEMETHODIMPV_(type):
        return STDMETHODIMPV_(type)


    __COMPARTMENT_ID_DEFINED__ = None
    if not defined(__COMPARTMENT_ID_DEFINED__):
        __COMPARTMENT_ID_DEFINED__ = 1

        # Compartment identifier
        class COMPARTMENT_ID(ENUM):
            UNSPECIFIED_COMPARTMENT_ID = 0
            DEFAULT_COMPARTMENT_ID = 1

        PCOMPARTMENT_ID = POINTER(COMPARTMENT_ID)
        UNSPECIFIED_COMPARTMENT_ID = COMPARTMENT_ID.UNSPECIFIED_COMPARTMENT_ID
        DEFAULT_COMPARTMENT_ID = COMPARTMENT_ID.DEFAULT_COMPARTMENT_ID
    # END IF   __COMPARTMENT_ID_DEFINED__

    APPLICATION_ERROR_MASK = 0x20000000
    ERROR_SEVERITY_SUCCESS = 0x00000000
    ERROR_SEVERITY_INFORMATIONAL = 0x40000000
    ERROR_SEVERITY_WARNING = 0x80000000
    ERROR_SEVERITY_ERROR = 0xC0000000

    # begin_ntoshvp
    # _M_IX86 included so that EM CONTEXT structure compiles with
    # x86 programs. *** TBD should this be for all architectures?
    # 16 byte aligned type for 128 bit floats
    # For we define a 128 bit structure and use __declspec(align(16)) pragma to
    # align to 128 bits.
    if defined(_M_IA64) and not defined(MIDL_PASS):
        pass
    # END IF

    _FLOAT128._fields_ = [
        ('LowPart', INT64),
        ('HighPart', INT64),
    ]

    # INT64 is only supported by 2.0 and later midl.
    # __midl is set by the 2.0 midl and not by 1.0 midl.
    _ULONGLONG_ = ULONGLONG
    _MAC_INT_64 = None
    _INTEGRAL_MAX_BITS = None

    if (
        not defined(_MAC) and
        (not defined(MIDL_PASS) or defined(__midl)) and
        (
            not defined(_M_IX86) or
            (defined(_INTEGRAL_MAX_BITS) and _INTEGRAL_MAX_BITS >= 64)
        )
    ):
        MAXLONGLONG = 0x7FFFFFFFFFFFFFFF
    else:
        if defined(_MAC) and defined(_MAC_INT_64):
            MAXLONGLONG = 0x7FFFFFFFFFFFFFFF
        else:
            pass
        # END IF  _MAC and int64
    # END IF

    # Update Sequence Number
    if defined(MIDL_PASS):
        _LARGE_INTEGER._fields_ = [
            ('QuadPart', LONGLONG),
        ]
    else:
        class _LARGE_INTEGER(ctypes.Union):
            pass


        LARGE_INTEGER = _LARGE_INTEGER


        class DUMMYSTRUCTNAME(ctypes.Structure):
            pass


        DUMMYSTRUCTNAME._fields_ = [
            ('LowPart', DWORD),
            ('HighPart', LONG),
        ]
        _LARGE_INTEGER.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


        class u(ctypes.Structure):
            pass


        u._fields_ = [
            ('LowPart', DWORD),
            ('HighPart', LONG),
        ]
        _LARGE_INTEGER.u = u

        _LARGE_INTEGER._fields_ = [
            ('DUMMYSTRUCTNAME', _LARGE_INTEGER.DUMMYSTRUCTNAME),
            ('u', _LARGE_INTEGER.u),
            ('QuadPart', LONGLONG),
        ]
    # END IF  MIDL_PASS

    PLARGE_INTEGER = POINTER(LARGE_INTEGER)

    if defined(MIDL_PASS):
        _ULARGE_INTEGER._fields_ = [
            ('QuadPart', ULONGLONG),
        ]
    else:
        class _ULARGE_INTEGER(ctypes.Union):
            pass


        ULARGE_INTEGER = _ULARGE_INTEGER


        class DUMMYSTRUCTNAME(ctypes.Structure):
            pass


        DUMMYSTRUCTNAME._fields_ = [
            ('LowPart', DWORD),
            ('HighPart', DWORD),
        ]
        _ULARGE_INTEGER.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


        class u(ctypes.Structure):
            pass


        u._fields_ = [
            ('LowPart', DWORD),
            ('HighPart', DWORD),
        ]
        _ULARGE_INTEGER.u = u

        _ULARGE_INTEGER._fields_ = [
            ('DUMMYSTRUCTNAME', _ULARGE_INTEGER.DUMMYSTRUCTNAME),
            ('u', _ULARGE_INTEGER.u),
            ('QuadPart', ULONGLONG),
        ]
    # END IF  MIDL_PASS

    PULARGE_INTEGER = POINTER(ULARGE_INTEGER)
    # Reference count.

    RTL_REFERENCE_COUNT = LONG_PTR
    PRTL_REFERENCE_COUNT = POINTER(LONG_PTR)
    RTL_REFERENCE_COUNT32 = LONG
    PRTL_REFERENCE_COUNT32 = POINTER(LONG)

    # end_ntminiport end_ntndis end_ntminitape
    # end_ntoshvp
    # Locally Unique Identifier
    _LUID._fields_ = [
        ('LowPart', DWORD),
        ('HighPart', LONG),
    ]

    DWORDLONG = ULONGLONG
    PDWORDLONG - POINTER(DWORDLONG)
    _DWORDLONG_ = DWORDLONG
    # Define operations to logically shift an int64 by 0..31 bits and to
    # multiply
    # 32 - bits by 32 - bits to form a 64 - bit product.

    _M_CEE_PURE = None
    _68K_ = None
    _MPPC_ = None
    if (
        defined(MIDL_PASS) or
        defined(RC_INVOKED) or
        defined(_M_CEE_PURE) or
        defined(_68K_) or
        defined(_MPPC_) or
        defined(_M_IA64) or
        defined(_M_AMD64) or
        defined(_M_ARM) or
        defined(_M_ARM64) or
        defined(_M_HYBRID_X86_ARM64)
    ):
        # Midl does not understand inline assembler. Therefore, the Rtl
        # functions
        # are used for shifts by 0..31 and multiplies of 32 - bits times 32 -
        # bits to
        # form a 64 - bit product.
        # IA64 and AMD64 have native 64 - bit operations that are just as fast
        # as their
        # 32 - bit counter parts. Therefore, the int64 data type is used
        # directly to form
        # shifts of 0..31 and multiplies of 32 - bits times 32 - bits to form
        # a 64 - bit
        # product.
        def Int32x32To64(a, b):
            return INT64(LONG(a).value).value * INT64(LONG(b).value).value


        def UInt32x32To64(a, b):
            return UINT64(UINT(a).value).value * UINT64(UINT(b).value).value


        def Int64ShllMod32(a, b):
            return UINT64(a).value << b


        def Int64ShraMod32(a, b):
            return INT64(a).value >> b


        def Int64ShrlMod32(a, b):
            return UINT64(a).value >> b

    elif defined(_M_IX86):
        # The x86 C compiler understands inline assembler. Therefore, inline
        # functions
        # that employ inline assembler are used for shifts of 0..31. The
        # multiplies
        # rely on the compiler recognizing the cast of the multiplicand to
        # int64 to
        # generate the optimal code inline.
        def Int32x32To64(a, b):
            return INT64(INT64(LONG(a).value).value * LONG(b).value).value


        def UInt32x32To64(a, b):
            return UINT64(UINT64(UINT(a).value).value * UINT(b).value).value

        def Int64ShrlMod32(a, b):
            return UINT64(a).value >> b


        if _MSC_VER >= 1200:
            pass
        # END IF

        def Int64ShllMod32(a, b):
            return UINT64(a).value << b


        def Int64ShraMod32(a, b):
            return INT64(a).value >> b

        if _MSC_VER >= 1200:
            pass
        else:
            pass
        # END IF
    else:
        raise RuntimeError('Must define a target architecture.')
    # END IF

    # Define rotate intrinsics.
    if defined(__cplusplus):
        pass
    # END IF

    if defined(_M_AMD64):
        ucrtbase = ctypes.windll.UCRTBASE
        _rotl8 = ucrtbase._rotl8
        _rotl8.restype = INT

        _rotl16 = ucrtbase._rotl16
        _rotl16.restype = INT16

        _rotr8 = ucrtbase._rotr8
        _rotr8.restype = INT

        _rotr16 = ucrtbase._rotr16
        _rotr16.restype = INT16

        RotateLeft8 = _rotl8
        RotateLeft16 = _rotl16
        RotateRight8 = _rotr8
        RotateRight16 = _rotr16
    # END IF  _M_AMD64

    if _MSC_VER >= 1300:
        ucrtbase = ctypes.windll.UCRTBASE

        # UINT int
        # __cdecl
        # _rotl(
        # _In_ UINT Value,
        # _In_ INT Shift
        # );
        _rotl = ucrtbase._rotl
        _rotl.restype = INT

        # UINT __int64
        # __cdecl
        # _rotl64(
        # _In_ UINT INT64 Value,
        # _In_ INT Shift
        # );
        _rotl64 = ucrtbase._rotl64
        _rotl64.restype = INT64

        # UINT int
        # __cdecl
        # _rotr(
        # _In_ UINT Value,
        # _In_ INT Shift
        # );
        _rotr = ucrtbase._rotr
        _rotr.restype = INT

        # UINT __int64
        # __cdecl
        # _rotr64(
        # _In_ UINT INT64 Value,
        # _In_ INT Shift
        # );
        _rotr64 = ucrtbase._rotr64
        _rotr64.restype = INT64

        RotateLeft32 = _rotl
        RotateLeft64 = _rotl64
        RotateRight32 = _rotr
        RotateRight64 = _rotr64
    # END IF  _MSC_VER >= 1300

    if defined(__cplusplus):
        pass
    # END IF

    ANSI_NULL = 0
    UNICODE_NULL = 0
    UNICODE_STRING_MAX_BYTES = 65534
    UNICODE_STRING_MAX_CHARS = 32767
    BOOLEAN = BYTE
    PBOOLEAN = POINTER(BOOLEAN)

    # Doubly linked list structure. Can be used as either a list head, or
    # as link words.
    _LIST_ENTRY._fields_ = [
        ('Flink', POINTER(_LIST_ENTRY)),
        ('Blink', POINTER(_LIST_ENTRY)),
    ]

    # Singly linked list structure. Can be used as either a list head, or
    # as link words.
    _SINGLE_LIST_ENTRY._fields_ = [
        ('Next', POINTER(_SINGLE_LIST_ENTRY)),
    ]

    # end_ntoshvp
    # begin_ntoshvp
    # These are needed for portable debugger support.
    LIST_ENTRY32._fields_ = [
        ('Flink', DWORD),
        ('Blink', DWORD),
    ]

    LIST_ENTRY64._fields_ = [
        ('Flink', ULONGLONG),
        ('Blink', ULONGLONG),
    ]
    from pyWinAPI.shared.guiddef_h import * # NOQA

    __OBJECTID_DEFINED = None
    if not defined(__OBJECTID_DEFINED):
        __OBJECTID_DEFINED = 1

        _OBJECTID._fields_ = [
            # size is 20 GUID Lineage;
            ('Uniquifier', DWORD),
        ]
    # END IF   not _OBJECTID_DEFINED

    MINCHAR = 0x80
    MAXCHAR = 0x7F
    MINSHORT = 0x8000
    MAXSHORT = 0x7FFF
    MINLONG = 0x80000000
    MAXLONG = 0x7FFFFFFF
    MAXBYTE = 0xFF
    MAXWORD = 0xFFFF
    MAXDWORD = 0xFFFFFFFF

    # begin_ntoshvp
    # Calculate the byte offset of a field in a structure of type type.
    def FIELD_OFFSET(type, field):
        return LONGLONG_PTR(getattr(POINTER(type)(0), field)).value


    def UFIELD_OFFSET(type, field):
        return DWORDLONG_PTR(getattr(POINTER(type)(0), field)).value


    # Calculate the size of a field in a structure of type type, without
    # knowing or stating the type of the field.
    def RTL_FIELD_SIZE(type, field):
        return ctypes.sizeof(getattr(POINTER(type)(0), field))


    # Calculate the size of a structure of type type up through and
    # including a field.
    def RTL_SIZEOF_THROUGH_FIELD(type, field):
        return FIELD_OFFSET(type, field) + RTL_FIELD_SIZE(type, field)

    # end_ntoshvp
    # RTL_CONTAINS_FIELD usage:
    # if (RTL_CONTAINS_FIELD(pBlock, pBlock - >cbSize, dwMumble))
    # // safe to use pBlock - >dwMumble
    def RTL_CONTAINS_FIELD(Struct, Size, Field):
        return (
            (
                PCHAR(ctypes.byref(getattr(Struct(), Field))).value +
                ctypes.sizeof(getattr(Struct(), Field))
            ) <= PCHAR(Struct).value + Size
        )

    # Return the number of elements in a statically sized array.
    # DWORD Buffer[100];
    # RTL_NUMBER_OF(Buffer) == 100
    # This is also popularly known as: NUMBER_OF, ARRSIZE, _countof, NELEM,
    # etc.
    def RTL_NUMBER_OF_V1(A):
        return ctypes.sizeof(A) / ctypes.sizeof(A[0])

    _PREFAST_ = None
    SORTPP_PASS = None
    if (
        defined(__cplusplus) and
        not defined(MIDL_PASS) and
        not defined(RC_INVOKED) and
        not defined(_PREFAST_) and
        _MSC_FULL_VER >= 13009466 and
        not defined(SORTPP_PASS)
    ):
        # RtlpNumberOf is a function that takes a reference to an array of N
        # Ts.
        # typedef T array_of_T[N];
        # typedef array_of_T & reference_to_array_of_T;
        # RtlpNumberOf returns a pointer to an array of N chars.
        # We could return a reference instead of a pointer but older compilers
        # do not accept that.
        # typedef CHAR array_of_char[N];
        # typedef array_of_char *pointer_to_array_of_char;
        # (ctypes.sizeof(array_of_char) == N
        # (ctypes.sizeof(*pointer_to_array_of_char) == N
        # pointer_to_array_of_char RtlpNumberOf(reference_to_array_of_T);
        # We never even call RtlpNumberOf, we just take the size of
        # dereferencing its return type.
        # We do not even implement RtlpNumberOf, we just declare it.
        # Attempts to pass pointers instead of arrays to this macro result in
        # compile time errors.
        # That is the point.
        # end_ntndis end_ntminiport
        if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM):
            # begin_ntndis begin_ntminiport
            #  templates cannot be declared to have 'C' linkage
            # end_ntndis end_ntminiport
            pass
        # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM)
        # begin_ntndis begin_ntminiport

        def RTL_NUMBER_OF_V2(A):
            return ctypes.sizeof(RtlpNumberOf(A))


        # This does not work with:
        # VOID Foo()
        # {
        # struct { INT x; } y[2];
        # RTL_NUMBER_OF_V2(y); // illegal use of anonymous local type in
        # template instantiation
        # }
        # You must instead do:
        # struct Foo1 { INT x; };
        # VOID Foo()
        # {
        # Foo1 y[2];
        # RTL_NUMBER_OF_V2(y); // ok
        # }
        # OR
        # VOID Foo()
        # {
        # struct { INT x; } y[2];
        # RTL_NUMBER_OF_V1(y); // ok
        # }
        # OR
        # VOID Foo()
        # {
        # struct { INT x; } y[2];
        # _ARRAYSIZE(y); // ok
        # }
    else:
        def RTL_NUMBER_OF_V2(A):
            return RTL_NUMBER_OF_V1(A)
    # END IF

    ENABLE_RTL_NUMBER_OF_V2 = None

    if defined(ENABLE_RTL_NUMBER_OF_V2):
        def RTL_NUMBER_OF(A):
            return RTL_NUMBER_OF_V2(A)
    else:
        def RTL_NUMBER_OF(A):
            return RTL_NUMBER_OF_V1(A)
    # END IF
    # ARRAYSIZE is more readable version of RTL_NUMBER_OF_V2, and uses
    # it regardless of ENABLE_RTL_NUMBER_OF_V2
    # _ARRAYSIZE is a version useful for anonymous types
    def ARRAYSIZE(A):
        return RTL_NUMBER_OF_V2(A)


    def _ARRAYSIZE(A):
        return RTL_NUMBER_OF_V1(A)

    # An expression that yields the type of a field in a struct.
    def RTL_FIELD_TYPE(type, field):
        return getattr(POINTER(type)(0), field)

    # RTL_ to avoid collisions in the global namespace.
    # Given typedef struct _FOO { BYTE Bar[123]; } FOO;
    # RTL_NUMBER_OF_FIELD(FOO, Bar) == 123
    def RTL_NUMBER_OF_FIELD(type, field):
        return RTL_NUMBER_OF(RTL_FIELD_TYPE(type, field))

    # eg:
    # typedef struct FOO {
    # DWORD Integer;
    # PVOID Pointer;
    # } FOO;
    # RTL_PADDING_BETWEEN_FIELDS(FOO, Integer, Pointer) == 0 for Win32, 4 for
    # Win64
    def RTL_PADDING_BETWEEN_FIELDS(T, F1, F2):
        if FIELD_OFFSET(T, F2) > FIELD_OFFSET(T, F1):
            return (
                FIELD_OFFSET(T, F2) -
                FIELD_OFFSET(T, F1) -
                RTL_FIELD_SIZE(T, F1)
            )
        else:
            return (
                FIELD_OFFSET(T, F1) -
                FIELD_OFFSET(T, F2) -
                RTL_FIELD_SIZE(T, F2)
            )


    # RTL_ to avoid collisions in the global namespace.
    if defined(__cplusplus):
        def RTL_CONST_CAST(type):
            return type
    else:
        def RTL_CONST_CAST(type):
            return type

    # END IF
    # like (ctypes.sizeof
    # usually this would be * CHAR_BIT, but we don't necessarily have include
    # <limits.h>

    def RTL_BITS_OF(sizeOfArg):
        return ctypes.sizeof(sizeOfArg) * 8


    def RTL_BITS_OF_FIELD(type, field):
        return RTL_BITS_OF(RTL_FIELD_TYPE(type, field))


    # begin_ntoshvp
    # Calculate the address of the base of the structure given its type, and an
    # address of a field within the structure.
    def CONTAINING_RECORD(address, type, field):
        return (
            POINTER(type)(PCHAR(address).value -
            ULONG_PTR(ctypes.byref(getattr(POINTER(type)(0), field))).value).value
        )
    # end_ntoshvp
    # end_ntminiport end_ntndis
    # Exception handler routine definition.
    from pyWinAPI.km.crt.excpt_h import * # NOQA
    # _IRQL_requires_same_
    # _Function_class_(EXCEPTION_ROUTINE)
    # EXCEPTION_DISPOSITION
    # NTAPI
    # EXCEPTION_ROUTINE (
    # _Inout_ struct _EXCEPTION_RECORD *ExceptionRecord,
    # _In_ PVOID EstablisherFrame,
    # _Inout_ struct _CONTEXT *ContextRecord,
    # _In_ PVOID DispatcherContext
    # );
    EXCEPTION_ROUTINE = CALLBACK(
        NTAPI,
        POINTER(_EXCEPTION_RECORD),
        PVOID,
        POINTER(_CONTEXT),
        PVOID
    )

    PEXCEPTION_ROUTINE = POINTER(EXCEPTION_ROUTINE)

    VER_SERVER_NT = 0x80000000
    VER_WORKSTATION_NT = 0x40000000
    VER_SUITE_SMALLBUSINESS = 0x00000001
    VER_SUITE_ENTERPRISE = 0x00000002
    VER_SUITE_BACKOFFICE = 0x00000004
    VER_SUITE_COMMUNICATIONS = 0x00000008
    VER_SUITE_TERMINAL = 0x00000010
    VER_SUITE_SMALLBUSINESS_RESTRICTED = 0x00000020
    VER_SUITE_EMBEDDEDNT = 0x00000040
    VER_SUITE_DATACENTER = 0x00000080
    VER_SUITE_SINGLEUSERTS = 0x00000100
    VER_SUITE_PERSONAL = 0x00000200
    VER_SUITE_BLADE = 0x00000400
    VER_SUITE_EMBEDDED_RESTRICTED = 0x00000800
    VER_SUITE_SECURITY_APPLIANCE = 0x00001000
    VER_SUITE_STORAGE_SERVER = 0x00002000
    VER_SUITE_COMPUTE_SERVER = 0x00004000
    VER_SUITE_WH_SERVER = 0x00008000
    VER_SUITE_MULTIUSERTS = 0x00020000
    # Product types
    # This list grows with each OS release.
    # There is no ordering of values to ensure callers
    # do an equality test i.e. greater - than and less - than
    # comparisons are not useful.
    # NOTE: Values in this list should never be deleted.
    # When a product - type 'X' gets dropped from a
    # OS release onwards, the value of 'X' continues
    # to be used in the mapping table of GetProductInfo.
    PRODUCT_UNDEFINED = 0x00000000
    PRODUCT_ULTIMATE = 0x00000001
    PRODUCT_HOME_BASIC = 0x00000002
    PRODUCT_HOME_PREMIUM = 0x00000003
    PRODUCT_ENTERPRISE = 0x00000004
    PRODUCT_HOME_BASIC_N = 0x00000005
    PRODUCT_BUSINESS = 0x00000006
    PRODUCT_STANDARD_SERVER = 0x00000007
    PRODUCT_DATACENTER_SERVER = 0x00000008
    PRODUCT_SMALLBUSINESS_SERVER = 0x00000009
    PRODUCT_ENTERPRISE_SERVER = 0x0000000A
    PRODUCT_STARTER = 0x0000000B
    PRODUCT_DATACENTER_SERVER_CORE = 0x0000000C
    PRODUCT_STANDARD_SERVER_CORE = 0x0000000D
    PRODUCT_ENTERPRISE_SERVER_CORE = 0x0000000E
    PRODUCT_ENTERPRISE_SERVER_IA64 = 0x0000000F
    PRODUCT_BUSINESS_N = 0x00000010
    PRODUCT_WEB_SERVER = 0x00000011
    PRODUCT_CLUSTER_SERVER = 0x00000012
    PRODUCT_HOME_SERVER = 0x00000013
    PRODUCT_STORAGE_EXPRESS_SERVER = 0x00000014
    PRODUCT_STORAGE_STANDARD_SERVER = 0x00000015
    PRODUCT_STORAGE_WORKGROUP_SERVER = 0x00000016
    PRODUCT_STORAGE_ENTERPRISE_SERVER = 0x00000017
    PRODUCT_SERVER_FOR_SMALLBUSINESS = 0x00000018
    PRODUCT_SMALLBUSINESS_SERVER_PREMIUM = 0x00000019
    PRODUCT_HOME_PREMIUM_N = 0x0000001A
    PRODUCT_ENTERPRISE_N = 0x0000001B
    PRODUCT_ULTIMATE_N = 0x0000001C
    PRODUCT_WEB_SERVER_CORE = 0x0000001D
    PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT = 0x0000001E
    PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY = 0x0000001F
    PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING = 0x00000020
    PRODUCT_SERVER_FOUNDATION = 0x00000021
    PRODUCT_HOME_PREMIUM_SERVER = 0x00000022
    PRODUCT_SERVER_FOR_SMALLBUSINESS_V = 0x00000023
    PRODUCT_STANDARD_SERVER_V = 0x00000024
    PRODUCT_DATACENTER_SERVER_V = 0x00000025
    PRODUCT_ENTERPRISE_SERVER_V = 0x00000026
    PRODUCT_DATACENTER_SERVER_CORE_V = 0x00000027
    PRODUCT_STANDARD_SERVER_CORE_V = 0x00000028
    PRODUCT_ENTERPRISE_SERVER_CORE_V = 0x00000029
    PRODUCT_HYPERV = 0x0000002A
    PRODUCT_STORAGE_EXPRESS_SERVER_CORE = 0x0000002B
    PRODUCT_STORAGE_STANDARD_SERVER_CORE = 0x0000002C
    PRODUCT_STORAGE_WORKGROUP_SERVER_CORE = 0x0000002D
    PRODUCT_STORAGE_ENTERPRISE_SERVER_CORE = 0x0000002E
    PRODUCT_STARTER_N = 0x0000002F
    PRODUCT_PROFESSIONAL = 0x00000030
    PRODUCT_PROFESSIONAL_N = 0x00000031
    PRODUCT_SB_SOLUTION_SERVER = 0x00000032
    PRODUCT_SERVER_FOR_SB_SOLUTIONS = 0x00000033
    PRODUCT_STANDARD_SERVER_SOLUTIONS = 0x00000034
    PRODUCT_STANDARD_SERVER_SOLUTIONS_CORE = 0x00000035
    PRODUCT_SB_SOLUTION_SERVER_EM = 0x00000036
    PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM = 0x00000037
    PRODUCT_SOLUTION_EMBEDDEDSERVER = 0x00000038
    PRODUCT_SOLUTION_EMBEDDEDSERVER_CORE = 0x00000039
    PRODUCT_PROFESSIONAL_EMBEDDED = 0x0000003A
    PRODUCT_ESSENTIALBUSINESS_SERVER_MGMT = 0x0000003B
    PRODUCT_ESSENTIALBUSINESS_SERVER_ADDL = 0x0000003C
    PRODUCT_ESSENTIALBUSINESS_SERVER_MGMTSVC = 0x0000003D
    PRODUCT_ESSENTIALBUSINESS_SERVER_ADDLSVC = 0x0000003E
    PRODUCT_SMALLBUSINESS_SERVER_PREMIUM_CORE = 0x0000003F
    PRODUCT_CLUSTER_SERVER_V = 0x00000040
    PRODUCT_EMBEDDED = 0x00000041
    PRODUCT_STARTER_E = 0x00000042
    PRODUCT_HOME_BASIC_E = 0x00000043
    PRODUCT_HOME_PREMIUM_E = 0x00000044
    PRODUCT_PROFESSIONAL_E = 0x00000045
    PRODUCT_ENTERPRISE_E = 0x00000046
    PRODUCT_ULTIMATE_E = 0x00000047
    PRODUCT_ENTERPRISE_EVALUATION = 0x00000048
    PRODUCT_MULTIPOINT_STANDARD_SERVER = 0x0000004C
    PRODUCT_MULTIPOINT_PREMIUM_SERVER = 0x0000004D
    PRODUCT_STANDARD_EVALUATION_SERVER = 0x0000004F
    PRODUCT_DATACENTER_EVALUATION_SERVER = 0x00000050
    PRODUCT_ENTERPRISE_N_EVALUATION = 0x00000054
    PRODUCT_EMBEDDED_AUTOMOTIVE = 0x00000055
    PRODUCT_EMBEDDED_INDUSTRY_A = 0x00000056
    PRODUCT_THINPC = 0x00000057
    PRODUCT_EMBEDDED_A = 0x00000058
    PRODUCT_EMBEDDED_INDUSTRY = 0x00000059
    PRODUCT_EMBEDDED_E = 0x0000005A
    PRODUCT_EMBEDDED_INDUSTRY_E = 0x0000005B
    PRODUCT_EMBEDDED_INDUSTRY_A_E = 0x0000005C
    PRODUCT_STORAGE_WORKGROUP_EVALUATION_SERVER = 0x0000005F
    PRODUCT_STORAGE_STANDARD_EVALUATION_SERVER = 0x00000060
    PRODUCT_CORE_ARM = 0x00000061
    PRODUCT_CORE_N = 0x00000062
    PRODUCT_CORE_COUNTRYSPECIFIC = 0x00000063
    PRODUCT_CORE_SINGLELANGUAGE = 0x00000064
    PRODUCT_CORE = 0x00000065
    PRODUCT_PROFESSIONAL_WMC = 0x00000067
    PRODUCT_EMBEDDED_INDUSTRY_EVAL = 0x00000069
    PRODUCT_EMBEDDED_INDUSTRY_E_EVAL = 0x0000006A
    PRODUCT_EMBEDDED_EVAL = 0x0000006B
    PRODUCT_EMBEDDED_E_EVAL = 0x0000006C
    PRODUCT_NANO_SERVER = 0x0000006D
    PRODUCT_CLOUD_STORAGE_SERVER = 0x0000006E
    PRODUCT_CORE_CONNECTED = 0x0000006F
    PRODUCT_PROFESSIONAL_STUDENT = 0x00000070
    PRODUCT_CORE_CONNECTED_N = 0x00000071
    PRODUCT_PROFESSIONAL_STUDENT_N = 0x00000072
    PRODUCT_CORE_CONNECTED_SINGLELANGUAGE = 0x00000073
    PRODUCT_CORE_CONNECTED_COUNTRYSPECIFIC = 0x00000074
    PRODUCT_CONNECTED_CAR = 0x00000075
    PRODUCT_INDUSTRY_HANDHELD = 0x00000076
    PRODUCT_PPI_PRO = 0x00000077
    PRODUCT_ARM64_SERVER = 0x00000078
    PRODUCT_EDUCATION = 0x00000079
    PRODUCT_EDUCATION_N = 0x0000007A
    PRODUCT_IOTUAP = 0x0000007B
    PRODUCT_CLOUD_HOST_INFRASTRUCTURE_SERVER = 0x0000007C
    PRODUCT_ENTERPRISE_S = 0x0000007D
    PRODUCT_ENTERPRISE_S_N = 0x0000007E
    PRODUCT_PROFESSIONAL_S = 0x0000007F
    PRODUCT_PROFESSIONAL_S_N = 0x00000080
    PRODUCT_ENTERPRISE_S_EVALUATION = 0x00000081
    PRODUCT_ENTERPRISE_S_N_EVALUATION = 0x00000082
    PRODUCT_HOLOGRAPHIC = 0x00000087
    PRODUCT_PRO_SINGLE_LANGUAGE = 0x0000008A
    PRODUCT_PRO_CHINA = 0x0000008B
    PRODUCT_ENTERPRISE_SUBSCRIPTION = 0x0000008C
    PRODUCT_ENTERPRISE_SUBSCRIPTION_N = 0x0000008D
    PRODUCT_DATACENTER_NANO_SERVER = 0x0000008F
    PRODUCT_STANDARD_NANO_SERVER = 0x00000090
    PRODUCT_DATACENTER_A_SERVER_CORE = 0x00000091
    PRODUCT_STANDARD_A_SERVER_CORE = 0x00000092
    PRODUCT_DATACENTER_WS_SERVER_CORE = 0x00000093
    PRODUCT_STANDARD_WS_SERVER_CORE = 0x00000094
    PRODUCT_UTILITY_VM = 0x00000095
    PRODUCT_DATACENTER_EVALUATION_SERVER_CORE = 0x0000009F
    PRODUCT_STANDARD_EVALUATION_SERVER_CORE = 0x000000A0
    PRODUCT_PRO_WORKSTATION = 0x000000A1
    PRODUCT_PRO_WORKSTATION_N = 0x000000A2
    PRODUCT_PRO_FOR_EDUCATION = 0x000000A4
    PRODUCT_PRO_FOR_EDUCATION_N = 0x000000A5
    PRODUCT_AZURE_SERVER_CORE = 0x000000A8
    PRODUCT_AZURE_NANO_SERVER = 0x000000A9
    PRODUCT_ENTERPRISEG = 0x000000AB
    PRODUCT_ENTERPRISEGN = 0x000000AC
    PRODUCT_SERVERRDSH = 0x000000AF
    PRODUCT_CLOUD = 0x000000B2
    PRODUCT_CLOUDN = 0x000000B3
    PRODUCT_HUBOS = 0x000000B4
    PRODUCT_ONECOREUPDATEOS = 0x000000B6
    PRODUCT_ANDROMEDA = 0x000000B8
    PRODUCT_UNLICENSED = 0xABCDABCD
    from pyWinAPI.shared.sdkddkver_h import * # NOQA
    # ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
    # DEPRECATED: The Language ID concept is deprecated, please use
    # Locale Names instead, eg: "en" instead of a LANGID like 0x09.
    # See the documentation for GetLocaleInfoEx.
    # Note that the named locale APIs (eg GetLocaleInfoEx) are preferred.
    # WARNING: Not all locales/languages have unique Language IDs
    # The following two combinations of primary language ID and
    # sublanguage ID have special semantics:
    # Primary Language ID Sublanguage ID Result
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - -
    # LANG_NEUTRAL  SUBLANG_NEUTRAL  Language neutral
    # LANG_NEUTRAL  SUBLANG_DEFAULT  User default language
    # LANG_NEUTRAL  SUBLANG_SYS_DEFAULT System default language
    # LANG_INVARIANT  SUBLANG_NEUTRAL  Invariant locale
    # This concept is deprecated. It is strongly recommended that
    # applications test for locale names instead of Language IDs / LCIDs.
    # Primary language IDs.
    # WARNING: This pattern is broken and not followed for all languages.
    # Serbian, Bosnian & Croatian are a few examples.
    # WARNING: There are > 6000 human languages. The PRIMARYLANGID construct
    # cannot support all languages your application may encounter.
    # Please use Language Names, such as "en".
    # WARNING: Some languages may have more than one PRIMARYLANGID. Please
    # use Locale Names, such as "en - FJ".
    # WARNING: Some languages do not have assigned LANGIDs. Please use
    # Locale Names, such as "tlh - Piqd".
    # It is recommended that applications test for locale names or actual
    # LCIDs.
    # Note that the LANG, SUBLANG construction is not always consistent.
    # The named locale APIs (eg GetLocaleInfoEx) are recommended.
    # ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
    LANG_NEUTRAL = 0x00
    LANG_INVARIANT = 0x7F
    LANG_AFRIKAANS = 0x36
    LANG_ALBANIAN = 0x1C
    LANG_ALSATIAN = 0x84
    LANG_AMHARIC = 0x5E
    LANG_ARABIC = 0x01
    LANG_ARMENIAN = 0x2B
    LANG_ASSAMESE = 0x4D
    LANG_AZERI = 0x2C    # for Azerbaijani, LANG_AZERBAIJANI is preferred
    LANG_AZERBAIJANI = 0x2C
    LANG_BANGLA = 0x45
    LANG_BASHKIR = 0x6D
    LANG_BASQUE = 0x2D
    LANG_BELARUSIAN = 0x23
    LANG_BENGALI = 0x45    # Some prefer to use LANG_BANGLA
    LANG_BRETON = 0x7E
    LANG_BOSNIAN = 0x1A    # Use with SUBLANG_BOSNIAN_* Sublanguage IDs
    LANG_BOSNIAN_NEUTRAL = 0x781A    # Use with the ConvertDefaultLocale function
    LANG_BULGARIAN = 0x02
    LANG_CATALAN = 0x03
    LANG_CENTRAL_KURDISH = 0x92
    LANG_CHEROKEE = 0x5C
    LANG_CHINESE = 0x04    # Use with SUBLANG_CHINESE_* Sublanguage IDs
    LANG_CHINESE_SIMPLIFIED = 0x04    # Use with the ConvertDefaultLocale function
    LANG_CHINESE_TRADITIONAL = 0x7C04    # Use with the ConvertDefaultLocale function
    LANG_CORSICAN = 0x83
    LANG_CROATIAN = 0x1A
    LANG_CZECH = 0x05
    LANG_DANISH = 0x06
    LANG_DARI = 0x8C
    LANG_DIVEHI = 0x65
    LANG_DUTCH = 0x13
    LANG_ENGLISH = 0x09
    LANG_ESTONIAN = 0x25
    LANG_FAEROESE = 0x38
    LANG_FARSI = 0x29    # Deprecated: use LANG_PERSIAN instead
    LANG_FILIPINO = 0x64
    LANG_FINNISH = 0x0B
    LANG_FRENCH = 0x0C
    LANG_FRISIAN = 0x62
    LANG_FULAH = 0x67
    LANG_GALICIAN = 0x56
    LANG_GEORGIAN = 0x37
    LANG_GERMAN = 0x07
    LANG_GREEK = 0x08
    LANG_GREENLANDIC = 0x6F
    LANG_GUJARATI = 0x47
    LANG_HAUSA = 0x68
    LANG_HAWAIIAN = 0x75
    LANG_HEBREW = 0x0D
    LANG_HINDI = 0x39
    LANG_HUNGARIAN = 0x0E
    LANG_ICELANDIC = 0x0F
    LANG_IGBO = 0x70
    LANG_INDONESIAN = 0x21
    LANG_INUKTITUT = 0x5D
    LANG_IRISH = 0x3C    # Use with the SUBLANG_IRISH_IRELAND Sublanguage ID
    LANG_ITALIAN = 0x10
    LANG_JAPANESE = 0x11
    LANG_KANNADA = 0x4B
    LANG_KASHMIRI = 0x60
    LANG_KAZAK = 0x3F
    LANG_KHMER = 0x53
    LANG_KICHE = 0x86
    LANG_KINYARWANDA = 0x87
    LANG_KONKANI = 0x57
    LANG_KOREAN = 0x12
    LANG_KYRGYZ = 0x40
    LANG_LAO = 0x54
    LANG_LATVIAN = 0x26
    LANG_LITHUANIAN = 0x27
    LANG_LOWER_SORBIAN = 0x2E
    LANG_LUXEMBOURGISH = 0x6E
    LANG_MACEDONIAN = 0x2F    # the Former Yugoslav Republic of Macedonia
    LANG_MALAY = 0x3E
    LANG_MALAYALAM = 0x4C
    LANG_MALTESE = 0x3A
    LANG_MANIPURI = 0x58
    LANG_MAORI = 0x81
    LANG_MAPUDUNGUN = 0x7A
    LANG_MARATHI = 0x4E
    LANG_MOHAWK = 0x7C
    LANG_MONGOLIAN = 0x50
    LANG_NEPALI = 0x61
    LANG_NORWEGIAN = 0x14
    LANG_OCCITAN = 0x82
    LANG_ODIA = 0x48
    LANG_ORIYA = 0x48    # Deprecated: use LANG_ODIA, instead.
    LANG_PASHTO = 0x63
    LANG_PERSIAN = 0x29
    LANG_POLISH = 0x15
    LANG_PORTUGUESE = 0x16
    LANG_PULAR = 0x67    # Deprecated: use LANG_FULAH instead
    LANG_PUNJABI = 0x46
    LANG_QUECHUA = 0x6B
    LANG_ROMANIAN = 0x18
    LANG_ROMANSH = 0x17
    LANG_RUSSIAN = 0x19
    LANG_SAKHA = 0x85
    LANG_SAMI = 0x3B
    LANG_SANSKRIT = 0x4F
    LANG_SCOTTISH_GAELIC = 0x91
    LANG_SERBIAN = 0x1A    # Use with the SUBLANG_SERBIAN_* Sublanguage IDs
    LANG_SERBIAN_NEUTRAL = 0x7C1A    # Use with the ConvertDefaultLocale function
    LANG_SINDHI = 0x59
    LANG_SINHALESE = 0x5B
    LANG_SLOVAK = 0x1B
    LANG_SLOVENIAN = 0x24
    LANG_SOTHO = 0x6C
    LANG_SPANISH = 0x0A
    LANG_SWAHILI = 0x41
    LANG_SWEDISH = 0x1D
    LANG_SYRIAC = 0x5A
    LANG_TAJIK = 0x28
    LANG_TAMAZIGHT = 0x5F
    LANG_TAMIL = 0x49
    LANG_TATAR = 0x44
    LANG_TELUGU = 0x4A
    LANG_THAI = 0x1E
    LANG_TIBETAN = 0x51
    LANG_TIGRIGNA = 0x73
    LANG_TIGRINYA = 0x73    # Preferred spelling in locale
    LANG_TSWANA = 0x32
    LANG_TURKISH = 0x1F
    LANG_TURKMEN = 0x42
    LANG_UIGHUR = 0x80
    LANG_UKRAINIAN = 0x22
    LANG_UPPER_SORBIAN = 0x2E
    LANG_URDU = 0x20
    LANG_UZBEK = 0x43
    LANG_VALENCIAN = 0x03
    LANG_VIETNAMESE = 0x2A
    LANG_WELSH = 0x52
    LANG_WOLOF = 0x88
    LANG_XHOSA = 0x34
    LANG_YAKUT = 0x85    # Deprecated: use LANG_SAKHA,instead
    LANG_YI = 0x78
    LANG_YORUBA = 0x6A
    LANG_ZULU = 0x35
    # ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
    # DEPRECATED: The Sublanguage ID concept is deprecated, please use
    # Locale Names instead, eg: "en - US" instead of an LCID like 0x0409.
    # See the documentation for GetLocaleInfoEx.
    # The name immediately following SUBLANG_ dictates which primary
    # language ID that sublanguage ID can be combined with to form a
    # valid language ID.
    # Note that the LANG, SUBLANG construction is not always consistent.
    # The named locale APIs (eg GetLocaleInfoEx) are recommended.
    # WARNING: The pattern is broken and not followed for all languages.
    # Serbian, Bosnian & Croatian are a few examples.
    # WARNING: The "SUBLANG" depends on the primary language and is
    # inconsistent.
    # SUBLANG_ENGLISH_US is 0x1 and SUBLANG_SPANISH_US is 0x15, so
    # it is impossible to determine region merely by inspecting the
    # SUBLANG. Please use Locale Names such as "en - US" instead.
    # WARNING: Numerous SUBLANGS are assigned the same value, so 0x01 could be
    # US, French, or many other variations. Please use Locale Names
    # such as "en - US" instead. If that is not possible, consider
    # testing the entire LCID, eg: 0x0409.
    # WARNING: There are > 6000 human languages. The PRIMARYLANGID construct
    # cannot support all languages your application may encounter.
    # Please use Language Names, such as "en".
    # WARNING: There are > 200 country - regions. The SUBLANGID construct
    # cannot
    # represent all valid dialects of languages such as English.
    # Please use Locale Names, such as "en - US".
    # WARNING: Some languages may have more than one PRIMARYLANGID. Please
    # use Locale Names, such as "en - FJ".
    # WARNING: Some languages do not have assigned LANGIDs. Please use
    # Locale Names, such as "tlh - Piqd".
    # ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
    SUBLANG_NEUTRAL = 0x00    # language neutral
    SUBLANG_DEFAULT = 0x01    # user default
    SUBLANG_SYS_DEFAULT = 0x02    # system default
    SUBLANG_CUSTOM_DEFAULT = 0x03    # default custom language/locale
    SUBLANG_CUSTOM_UNSPECIFIED = 0x04    # custom language/locale
    SUBLANG_UI_CUSTOM_DEFAULT = 0x05    # Default custom MUI language/locale
    SUBLANG_AFRIKAANS_SOUTH_AFRICA = 0x01    # Afrikaans (South Africa) 0x0436 af - ZA
    SUBLANG_ALBANIAN_ALBANIA = 0x01    # Albanian (Albania) 0x041c sq - AL
    SUBLANG_ALSATIAN_FRANCE = 0x01    # Alsatian (France) 0x0484
    SUBLANG_AMHARIC_ETHIOPIA = 0x01    # Amharic (Ethiopia) 0x045e
    SUBLANG_ARABIC_SAUDI_ARABIA = 0x01    # Arabic (Saudi Arabia)
    SUBLANG_ARABIC_IRAQ = 0x02    # Arabic (Iraq)
    SUBLANG_ARABIC_EGYPT = 0x03    # Arabic (Egypt)
    SUBLANG_ARABIC_LIBYA = 0x04    # Arabic (Libya)
    SUBLANG_ARABIC_ALGERIA = 0x05    # Arabic (Algeria)
    SUBLANG_ARABIC_MOROCCO = 0x06    # Arabic (Morocco)
    SUBLANG_ARABIC_TUNISIA = 0x07    # Arabic (Tunisia)
    SUBLANG_ARABIC_OMAN = 0x08    # Arabic (Oman)
    SUBLANG_ARABIC_YEMEN = 0x09    # Arabic (Yemen)
    SUBLANG_ARABIC_SYRIA = 0x0A    # Arabic (Syria)
    SUBLANG_ARABIC_JORDAN = 0x0B    # Arabic (Jordan)
    SUBLANG_ARABIC_LEBANON = 0x0C    # Arabic (Lebanon)
    SUBLANG_ARABIC_KUWAIT = 0x0D    # Arabic (Kuwait)
    SUBLANG_ARABIC_UAE = 0x0E    # Arabic (U.A.E)
    SUBLANG_ARABIC_BAHRAIN = 0x0F    # Arabic (Bahrain)
    SUBLANG_ARABIC_QATAR = 0x10    # Arabic (Qatar)
    SUBLANG_ARMENIAN_ARMENIA = 0x01    # Armenian (Armenia) 0x042b hy - AM
    SUBLANG_ASSAMESE_INDIA = 0x01    # Assamese (India) 0x044d
    # Azeri (Latin) - for Azerbaijani, SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN
    # preferred
    SUBLANG_AZERI_LATIN = 0x01
    # Azeri (Cyrillic) - for Azerbaijani,
    # SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC preferred
    SUBLANG_AZERI_CYRILLIC = 0x02
    SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN = 0x01    # Azerbaijani (Azerbaijan, Latin)
    SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC = 0x02    # Azerbaijani (Azerbaijan, Cyrillic)
    SUBLANG_BANGLA_INDIA = 0x01    # Bangla (India)
    SUBLANG_BANGLA_BANGLADESH = 0x02    # Bangla (Bangladesh)
    SUBLANG_BASHKIR_RUSSIA = 0x01    # Bashkir (Russia) 0x046d ba - RU
    SUBLANG_BASQUE_BASQUE = 0x01    # Basque (Basque) 0x042d eu - ES
    SUBLANG_BELARUSIAN_BELARUS = 0x01    # Belarusian (Belarus) 0x0423 be - BY
    SUBLANG_BENGALI_INDIA = 0x01    # Bengali (India) - Note some prefer SUBLANG_BANGLA_INDIA
    SUBLANG_BENGALI_BANGLADESH = 0x02    # Bengali (Bangladesh) - Note some prefer SUBLANG_BANGLA_BANGLADESH
    SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN = 0x05    # Bosnian (Bosnia and Herzegovina - Latin) 0x141a bs - BA - Latn
    SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC = 0x08    # Bosnian (Bosnia and Herzegovina - Cyrillic) 0x201a bs - BA - Cyrl
    SUBLANG_BRETON_FRANCE = 0x01    # Breton (France) 0x047e
    SUBLANG_BULGARIAN_BULGARIA = 0x01    # Bulgarian (Bulgaria) 0x0402
    SUBLANG_CATALAN_CATALAN = 0x01    # Catalan (Catalan) 0x0403
    SUBLANG_CENTRAL_KURDISH_IRAQ = 0x01    # Central Kurdish (Iraq) 0x0492 ku - Arab - IQ
    SUBLANG_CHEROKEE_CHEROKEE = 0x01    # Cherokee (Cherokee) 0x045c chr - Cher - US
    SUBLANG_CHINESE_TRADITIONAL = 0x01    # Chinese (Taiwan) 0x0404 zh - TW
    SUBLANG_CHINESE_SIMPLIFIED = 0x02    # Chinese (PR China) 0x0804 zh - CN
    SUBLANG_CHINESE_HONGKONG = 0x03    # Chinese (Hong Kong S.A.R., P.R.C.) 0x0c04 zh - HK
    SUBLANG_CHINESE_SINGAPORE = 0x04    # Chinese (Singapore) 0x1004 zh - SG
    SUBLANG_CHINESE_MACAU = 0x05    # Chinese (Macau S.A.R.) 0x1404 zh - MO
    SUBLANG_CORSICAN_FRANCE = 0x01    # Corsican (France) 0x0483
    SUBLANG_CZECH_CZECH_REPUBLIC = 0x01    # Czech (Czech Republic) 0x0405
    SUBLANG_CROATIAN_CROATIA = 0x01    # Croatian (Croatia)
    SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN = 0x04    # Croatian (Bosnia and Herzegovina - Latin) 0x101a hr - BA
    SUBLANG_DANISH_DENMARK = 0x01    # Danish (Denmark) 0x0406
    SUBLANG_DARI_AFGHANISTAN = 0x01    # Dari (Afghanistan)
    SUBLANG_DIVEHI_MALDIVES = 0x01    # Divehi (Maldives) 0x0465 div - MV
    SUBLANG_DUTCH = 0x01    # Dutch
    SUBLANG_DUTCH_BELGIAN = 0x02    # Dutch (Belgian)
    SUBLANG_ENGLISH_US = 0x01    # English (USA)
    SUBLANG_ENGLISH_UK = 0x02    # English (UK)
    SUBLANG_ENGLISH_AUS = 0x03    # English (Australian)
    SUBLANG_ENGLISH_CAN = 0x04    # English (Canadian)
    SUBLANG_ENGLISH_NZ = 0x05    # English (New Zealand)
    SUBLANG_ENGLISH_EIRE = 0x06    # English (Irish)
    SUBLANG_ENGLISH_SOUTH_AFRICA = 0x07    # English (South Africa)
    SUBLANG_ENGLISH_JAMAICA = 0x08    # English (Jamaica)
    SUBLANG_ENGLISH_CARIBBEAN = 0x09    # English (Caribbean)
    SUBLANG_ENGLISH_BELIZE = 0x0A    # English (Belize)
    SUBLANG_ENGLISH_TRINIDAD = 0x0B    # English (Trinidad)
    SUBLANG_ENGLISH_ZIMBABWE = 0x0C    # English (Zimbabwe)
    SUBLANG_ENGLISH_PHILIPPINES = 0x0D    # English (Philippines)
    SUBLANG_ENGLISH_INDIA = 0x10    # English (India)
    SUBLANG_ENGLISH_MALAYSIA = 0x11    # English (Malaysia)
    SUBLANG_ENGLISH_SINGAPORE = 0x12    # English (Singapore)
    SUBLANG_ESTONIAN_ESTONIA = 0x01    # Estonian (Estonia) 0x0425 et - EE
    SUBLANG_FAEROESE_FAROE_ISLANDS = 0x01    # Faroese (Faroe Islands) 0x0438 fo - FO
    SUBLANG_FILIPINO_PHILIPPINES = 0x01    # Filipino (Philippines) 0x0464 fil - PH
    SUBLANG_FINNISH_FINLAND = 0x01    # Finnish (Finland) 0x040b
    SUBLANG_FRENCH = 0x01    # French
    SUBLANG_FRENCH_BELGIAN = 0x02    # French (Belgian)
    SUBLANG_FRENCH_CANADIAN = 0x03    # French (Canadian)
    SUBLANG_FRENCH_SWISS = 0x04    # French (Swiss)
    SUBLANG_FRENCH_LUXEMBOURG = 0x05    # French (Luxembourg)
    SUBLANG_FRENCH_MONACO = 0x06    # French (Monaco)
    SUBLANG_FRISIAN_NETHERLANDS = 0x01    # Frisian (Netherlands) 0x0462 fy - NL
    SUBLANG_FULAH_SENEGAL = 0x02    # Fulah (Senegal) 0x0867 ff - SN
    SUBLANG_GALICIAN_GALICIAN = 0x01    # Galician (Galician) 0x0456 gl - ES
    SUBLANG_GEORGIAN_GEORGIA = 0x01    # Georgian (Georgia) 0x0437 ka - GE
    SUBLANG_GERMAN = 0x01    # German
    SUBLANG_GERMAN_SWISS = 0x02    # German (Swiss)
    SUBLANG_GERMAN_AUSTRIAN = 0x03    # German (Austrian)
    SUBLANG_GERMAN_LUXEMBOURG = 0x04    # German (Luxembourg)
    SUBLANG_GERMAN_LIECHTENSTEIN = 0x05    # German (Liechtenstein)
    SUBLANG_GREEK_GREECE = 0x01    # Greek (Greece)
    SUBLANG_GREENLANDIC_GREENLAND = 0x01    # Greenlandic (Greenland) 0x046f kl - GL
    SUBLANG_GUJARATI_INDIA = 0x01    # Gujarati (India (Gujarati Script)) 0x0447 gu - IN
    SUBLANG_HAUSA_NIGERIA_LATIN = 0x01    # Hausa (Latin, Nigeria) 0x0468 ha - NG - Latn
    SUBLANG_HAWAIIAN_US = 0x01    # Hawiian (US) 0x0475 haw - US
    SUBLANG_HEBREW_ISRAEL = 0x01    # Hebrew (Israel) 0x040d
    SUBLANG_HINDI_INDIA = 0x01    # Hindi (India) 0x0439 hi - IN
    SUBLANG_HUNGARIAN_HUNGARY = 0x01    # Hungarian (Hungary) 0x040e
    SUBLANG_ICELANDIC_ICELAND = 0x01    # Icelandic (Iceland) 0x040f
    SUBLANG_IGBO_NIGERIA = 0x01    # Igbo (Nigeria) 0x0470 ig - NG
    SUBLANG_INDONESIAN_INDONESIA = 0x01    # Indonesian (Indonesia) 0x0421 id - ID
    SUBLANG_INUKTITUT_CANADA = 0x01    # Inuktitut (Syllabics) (Canada) 0x045d iu - CA - Cans
    SUBLANG_INUKTITUT_CANADA_LATIN = 0x02    # Inuktitut (Canada - Latin)
    SUBLANG_IRISH_IRELAND = 0x02    # Irish (Ireland)
    SUBLANG_ITALIAN = 0x01    # Italian
    SUBLANG_ITALIAN_SWISS = 0x02    # Italian (Swiss)
    SUBLANG_JAPANESE_JAPAN = 0x01    # Japanese (Japan) 0x0411
    SUBLANG_KANNADA_INDIA = 0x01    # Kannada (India (Kannada Script)) 0x044b kn - IN
    SUBLANG_KASHMIRI_SASIA = 0x02    # Kashmiri (South Asia)
    SUBLANG_KASHMIRI_INDIA = 0x02    # For app compatibility only
    SUBLANG_KAZAK_KAZAKHSTAN = 0x01    # Kazakh (Kazakhstan) 0x043f kk - KZ
    SUBLANG_KHMER_CAMBODIA = 0x01    # Khmer (Cambodia) 0x0453 kh - KH
    SUBLANG_KICHE_GUATEMALA = 0x01    # K'iche (Guatemala)
    SUBLANG_KINYARWANDA_RWANDA = 0x01    # Kinyarwanda (Rwanda) 0x0487 rw - RW
    SUBLANG_KONKANI_INDIA = 0x01    # Konkani (India) 0x0457 kok - IN
    SUBLANG_KOREAN = 0x01    # Korean (Extended Wansung)
    SUBLANG_KYRGYZ_KYRGYZSTAN = 0x01    # Kyrgyz (Kyrgyzstan) 0x0440 ky - KG
    SUBLANG_LAO_LAO = 0x01    # Lao (Lao PDR) 0x0454 lo - LA
    SUBLANG_LATVIAN_LATVIA = 0x01    # Latvian (Latvia) 0x0426 lv - LV
    SUBLANG_LITHUANIAN = 0x01    # Lithuanian
    SUBLANG_LOWER_SORBIAN_GERMANY = 0x02    # Lower Sorbian (Germany) 0x082e wee - DE
    SUBLANG_LUXEMBOURGISH_LUXEMBOURG = 0x01    # Luxembourgish (Luxembourg) 0x046e lb - LU
    SUBLANG_MACEDONIAN_MACEDONIA = 0x01    # Macedonian (Macedonia (FYROM)) 0x042f mk - MK
    SUBLANG_MALAY_MALAYSIA = 0x01    # Malay (Malaysia)
    SUBLANG_MALAY_BRUNEI_DARUSSALAM = 0x02    # Malay (Brunei Darussalam)
    SUBLANG_MALAYALAM_INDIA = 0x01    # Malayalam (India (Malayalam Script) ) 0x044c ml - IN
    SUBLANG_MALTESE_MALTA = 0x01    # Maltese (Malta) 0x043a mt - MT
    SUBLANG_MAORI_NEW_ZEALAND = 0x01    # Maori (New Zealand) 0x0481 mi - NZ
    SUBLANG_MAPUDUNGUN_CHILE = 0x01    # Mapudungun (Chile) 0x047a arn - CL
    SUBLANG_MARATHI_INDIA = 0x01    # Marathi (India) 0x044e mr - IN
    SUBLANG_MOHAWK_MOHAWK = 0x01    # Mohawk (Mohawk) 0x047c moh - CA
    SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA = 0x01    # Mongolian (Cyrillic, Mongolia)
    SUBLANG_MONGOLIAN_PRC = 0x02    # Mongolian (PRC)
    SUBLANG_NEPALI_INDIA = 0x02    # Nepali (India)
    SUBLANG_NEPALI_NEPAL = 0x01    # Nepali (Nepal) 0x0461 ne - NP
    SUBLANG_NORWEGIAN_BOKMAL = 0x01    # Norwegian (Bokmal)
    SUBLANG_NORWEGIAN_NYNORSK = 0x02    # Norwegian (Nynorsk)
    SUBLANG_OCCITAN_FRANCE = 0x01    # Occitan (France) 0x0482 oc - FR
    SUBLANG_ODIA_INDIA = 0x01    # Odia (India (Odia Script)) 0x0448 or - IN
    SUBLANG_ORIYA_INDIA = 0x01    # Deprecated: use SUBLANG_ODIA_INDIA instead
    SUBLANG_PASHTO_AFGHANISTAN = 0x01    # Pashto (Afghanistan)
    SUBLANG_PERSIAN_IRAN = 0x01    # Persian (Iran) 0x0429 fa - IR
    SUBLANG_POLISH_POLAND = 0x01    # Polish (Poland) 0x0415
    SUBLANG_PORTUGUESE = 0x02    # Portuguese
    SUBLANG_PORTUGUESE_BRAZILIAN = 0x01    # Portuguese (Brazil)
    SUBLANG_PULAR_SENEGAL = 0x02    # Deprecated: Use SUBLANG_FULAH_SENEGAL instead
    SUBLANG_PUNJABI_INDIA = 0x01    # Punjabi (India (Gurmukhi Script)) 0x0446 pa - IN
    SUBLANG_PUNJABI_PAKISTAN = 0x02    # Punjabi (Pakistan (Arabic Script)) 0x0846 pa - Arab - PK
    SUBLANG_QUECHUA_BOLIVIA = 0x01    # Quechua (Bolivia)
    SUBLANG_QUECHUA_ECUADOR = 0x02    # Quechua (Ecuador)
    SUBLANG_QUECHUA_PERU = 0x03    # Quechua (Peru)
    SUBLANG_ROMANIAN_ROMANIA = 0x01    # Romanian (Romania) 0x0418
    SUBLANG_ROMANSH_SWITZERLAND = 0x01    # Romansh (Switzerland) 0x0417 rm - CH
    SUBLANG_RUSSIAN_RUSSIA = 0x01    # Russian (Russia) 0x0419
    SUBLANG_SAKHA_RUSSIA = 0x01    # Sakha (Russia) 0x0485 sah - RU
    SUBLANG_SAMI_NORTHERN_NORWAY = 0x01    # Northern Sami (Norway)
    SUBLANG_SAMI_NORTHERN_SWEDEN = 0x02    # Northern Sami (Sweden)
    SUBLANG_SAMI_NORTHERN_FINLAND = 0x03    # Northern Sami (Finland)
    SUBLANG_SAMI_LULE_NORWAY = 0x04    # Lule Sami (Norway)
    SUBLANG_SAMI_LULE_SWEDEN = 0x05    # Lule Sami (Sweden)
    SUBLANG_SAMI_SOUTHERN_NORWAY = 0x06    # Southern Sami (Norway)
    SUBLANG_SAMI_SOUTHERN_SWEDEN = 0x07    # Southern Sami (Sweden)
    SUBLANG_SAMI_SKOLT_FINLAND = 0x08    # Skolt Sami (Finland)
    SUBLANG_SAMI_INARI_FINLAND = 0x09    # Inari Sami (Finland)
    SUBLANG_SANSKRIT_INDIA = 0x01    # Sanskrit (India) 0x044f sa - IN
    SUBLANG_SCOTTISH_GAELIC = 0x01    # Scottish Gaelic (United Kingdom) 0x0491 gd - GB
    SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN = 0x06    # Serbian (Bosnia and Herzegovina - Latin)
    SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC = 0x07    # Serbian (Bosnia and Herzegovina - Cyrillic)
    SUBLANG_SERBIAN_MONTENEGRO_LATIN = 0x0B    # Serbian (Montenegro - Latn)
    SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC = 0x0C    # Serbian (Montenegro - Cyrillic)
    SUBLANG_SERBIAN_SERBIA_LATIN = 0x09    # Serbian (Serbia - Latin)
    SUBLANG_SERBIAN_SERBIA_CYRILLIC = 0x0A    # Serbian (Serbia - Cyrillic)
    SUBLANG_SERBIAN_CROATIA = 0x01    # Croatian (Croatia) 0x041a hr - HR
    SUBLANG_SERBIAN_LATIN = 0x02    # Serbian (Latin)
    SUBLANG_SERBIAN_CYRILLIC = 0x03    # Serbian (Cyrillic)
    SUBLANG_SINDHI_INDIA = 0x01    # Sindhi (India) reserved 0x0459
    SUBLANG_SINDHI_PAKISTAN = 0x02    # Sindhi (Pakistan) 0x0859 sd - Arab - PK
    SUBLANG_SINDHI_AFGHANISTAN = 0x02    # For app compatibility only
    SUBLANG_SINHALESE_SRI_LANKA = 0x01    # Sinhalese (Sri Lanka)
    SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA = 0x01    # Northern Sotho (South Africa)
    SUBLANG_SLOVAK_SLOVAKIA = 0x01    # Slovak (Slovakia) 0x041b sk - SK
    SUBLANG_SLOVENIAN_SLOVENIA = 0x01    # Slovenian (Slovenia) 0x0424 sl - SI
    SUBLANG_SPANISH = 0x01    # Spanish (Castilian)
    SUBLANG_SPANISH_MEXICAN = 0x02    # Spanish (Mexico)
    SUBLANG_SPANISH_MODERN = 0x03    # Spanish (Modern)
    SUBLANG_SPANISH_GUATEMALA = 0x04    # Spanish (Guatemala)
    SUBLANG_SPANISH_COSTA_RICA = 0x05    # Spanish (Costa Rica)
    SUBLANG_SPANISH_PANAMA = 0x06    # Spanish (Panama)
    SUBLANG_SPANISH_DOMINICAN_REPUBLIC = 0x07    # Spanish (Dominican Republic)
    SUBLANG_SPANISH_VENEZUELA = 0x08    # Spanish (Venezuela)
    SUBLANG_SPANISH_COLOMBIA = 0x09    # Spanish (Colombia)
    SUBLANG_SPANISH_PERU = 0x0A    # Spanish (Peru)
    SUBLANG_SPANISH_ARGENTINA = 0x0B    # Spanish (Argentina)
    SUBLANG_SPANISH_ECUADOR = 0x0C    # Spanish (Ecuador)
    SUBLANG_SPANISH_CHILE = 0x0D    # Spanish (Chile)
    SUBLANG_SPANISH_URUGUAY = 0x0E    # Spanish (Uruguay)
    SUBLANG_SPANISH_PARAGUAY = 0x0F    # Spanish (Paraguay)
    SUBLANG_SPANISH_BOLIVIA = 0x10    # Spanish (Bolivia)
    SUBLANG_SPANISH_EL_SALVADOR = 0x11    # Spanish (El Salvador)
    SUBLANG_SPANISH_HONDURAS = 0x12    # Spanish (Honduras)
    SUBLANG_SPANISH_NICARAGUA = 0x13    # Spanish (Nicaragua)
    SUBLANG_SPANISH_PUERTO_RICO = 0x14    # Spanish (Puerto Rico)
    SUBLANG_SPANISH_US = 0x15    # Spanish (United States)
    SUBLANG_SWAHILI_KENYA = 0x01    # Swahili (Kenya) 0x0441 sw - KE
    SUBLANG_SWEDISH = 0x01    # Swedish
    SUBLANG_SWEDISH_FINLAND = 0x02    # Swedish (Finland)
    SUBLANG_SYRIAC_SYRIA = 0x01    # Syriac (Syria) 0x045a syr - SY
    SUBLANG_TAJIK_TAJIKISTAN = 0x01    # Tajik (Tajikistan) 0x0428 tg - TJ - Cyrl
    SUBLANG_TAMAZIGHT_ALGERIA_LATIN = 0x02    # Tamazight (Latin, Algeria) 0x085f tzm - Latn - DZ
    SUBLANG_TAMAZIGHT_MOROCCO_TIFINAGH = 0x04    # Tamazight (Tifinagh) 0x105f tzm - Tfng - MA
    SUBLANG_TAMIL_INDIA = 0x01    # Tamil (India)
    SUBLANG_TAMIL_SRI_LANKA = 0x02    # Tamil (Sri Lanka) 0x0849 ta - LK
    SUBLANG_TATAR_RUSSIA = 0x01    # Tatar (Russia) 0x0444 tt - RU
    SUBLANG_TELUGU_INDIA = 0x01    # Telugu (India (Telugu Script)) 0x044a te - IN
    SUBLANG_THAI_THAILAND = 0x01    # Thai (Thailand) 0x041e th - TH
    SUBLANG_TIBETAN_PRC = 0x01    # Tibetan (PRC)
    SUBLANG_TIGRIGNA_ERITREA = 0x02    # Tigrigna (Eritrea)
    SUBLANG_TIGRINYA_ERITREA = 0x02    # Tigrinya (Eritrea) 0x0873 ti - ER (preferred spelling)
    SUBLANG_TIGRINYA_ETHIOPIA = 0x01    # Tigrinya (Ethiopia) 0x0473 ti - ET
    SUBLANG_TSWANA_BOTSWANA = 0x02    # Setswana / Tswana (Botswana) 0x0832 tn - BW
    SUBLANG_TSWANA_SOUTH_AFRICA = 0x01    # Setswana / Tswana (South Africa) 0x0432 tn - ZA
    SUBLANG_TURKISH_TURKEY = 0x01    # Turkish (Turkey) 0x041f tr - TR
    SUBLANG_TURKMEN_TURKMENISTAN = 0x01    # Turkmen (Turkmenistan) 0x0442 tk - TM
    SUBLANG_UIGHUR_PRC = 0x01    # Uighur (PRC) 0x0480 ug - CN
    SUBLANG_UKRAINIAN_UKRAINE = 0x01    # Ukrainian (Ukraine) 0x0422 uk - UA
    SUBLANG_UPPER_SORBIAN_GERMANY = 0x01    # Upper Sorbian (Germany) 0x042e wen - DE
    SUBLANG_URDU_PAKISTAN = 0x01    # Urdu (Pakistan)
    SUBLANG_URDU_INDIA = 0x02    # Urdu (India)
    SUBLANG_UZBEK_LATIN = 0x01    # Uzbek (Latin)
    SUBLANG_UZBEK_CYRILLIC = 0x02    # Uzbek (Cyrillic)
    SUBLANG_VALENCIAN_VALENCIA = 0x02    # Valencian (Valencia) 0x0803 ca - ES - Valencia
    SUBLANG_VIETNAMESE_VIETNAM = 0x01    # Vietnamese (Vietnam) 0x042a vi - VN
    SUBLANG_WELSH_UNITED_KINGDOM = 0x01    # Welsh (United Kingdom) 0x0452 cy - GB
    SUBLANG_WOLOF_SENEGAL = 0x01    # Wolof (Senegal)
    SUBLANG_XHOSA_SOUTH_AFRICA = 0x01    # isiXhosa / Xhosa (South Africa) 0x0434 xh - ZA
    SUBLANG_YAKUT_RUSSIA = 0x01    # Deprecated: use SUBLANG_SAKHA_RUSSIA instead
    SUBLANG_YI_PRC = 0x01    # Yi (PRC)) 0x0478
    SUBLANG_YORUBA_NIGERIA = 0x01    # Yoruba (Nigeria) 046a yo - NG
    SUBLANG_ZULU_SOUTH_AFRICA = 0x01    # isiZulu / Zulu (South Africa) 0x0435 zu - ZA

    # Sorting IDs.
    # Note that the named locale APIs (eg CompareStringExEx) are recommended.
    SORT_DEFAULT = 0x0    # sorting default
    SORT_INVARIANT_MATH = 0x1    # Invariant (Mathematical Symbols)
    SORT_JAPANESE_XJIS = 0x0    # Japanese XJIS order
    SORT_JAPANESE_UNICODE = 0x1    # Japanese Unicode order (no longer supported)
    SORT_JAPANESE_RADICALSTROKE = 0x4    # Japanese radical/stroke order
    SORT_CHINESE_BIG5 = 0x0    # Chinese BIG5 order
    SORT_CHINESE_PRCP = 0x0    # PRC Chinese Phonetic order
    SORT_CHINESE_UNICODE = 0x1    # Chinese Unicode order (no longer supported)
    SORT_CHINESE_PRC = 0x2    # PRC Chinese Stroke Count order
    SORT_CHINESE_BOPOMOFO = 0x3    # Traditional Chinese Bopomofo order
    SORT_CHINESE_RADICALSTROKE = 0x4    # Traditional Chinese radical/stroke order.
    SORT_KOREAN_KSC = 0x0    # Korean KSC order
    SORT_KOREAN_UNICODE = 0x1    # Korean Unicode order (no longer supported)
    SORT_GERMAN_PHONE_BOOK = 0x1    # German Phone Book order
    SORT_HUNGARIAN_DEFAULT = 0x0    # Hungarian Default order
    SORT_HUNGARIAN_TECHNICAL = 0x1    # Hungarian Technical order
    SORT_GEORGIAN_TRADITIONAL = 0x0    # Georgian Traditional order
    SORT_GEORGIAN_MODERN = 0x1    # Georgian Modern order

    # end_r_winnt
    # ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
    # DEPRECATED: The LCID/LANGID/SORTID concept is deprecated, please use
    # Locale Names instead, eg: "en - US" instead of an LCID like 0x0409.
    # See the documentation for GetLocaleInfoEx.
    # A language ID is a 16 bit value which is the combination of a
    # primary language ID and a secondary language ID. The bits are
    # allocated as follows:
    # + - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - -
    # - - - - - - - - - - - - - - +
    # |  Sublanguage ID | Primary Language ID |
    # + - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - -
    # - - - - - - - - - - - - - - +
    # 15    10 9     0 bit
    # WARNING: This pattern is broken and not followed for all languages.
    # Serbian, Bosnian & Croatian are a few examples.
    # WARNING: There are > 6000 human languages. The PRIMARYLANGID construct
    # cannot support all languages your application may encounter.
    # Please use Language Names, such as "en".
    # WARNING: There are > 200 country - regions. The SUBLANGID construct
    # cannot
    # represent all valid dialects of languages such as English.
    # Please use Locale Names, such as "en - US".
    # WARNING: Some languages may have more than one PRIMARYLANGID. Please
    # use Locale Names, such as "en - FJ".
    # WARNING: Some languages do not have assigned LANGIDs. Please use
    # Locale Names, such as "tlh - Piqd".
    # It is recommended that applications test for locale names rather than
    # attempting to construct/deconstruct LANGID/PRIMARYLANGID/SUBLANGID
    # Language ID creation/extraction macros:
    # MAKELANGID - construct language id from a primary language id and
    # a sublanguage id.
    # PRIMARYLANGID - extract primary language id from a language id.
    # SUBLANGID  - extract sublanguage id from a language id.
    # Note that the LANG, SUBLANG construction is not always consistent.
    # The named locale APIs (eg GetLocaleInfoEx) are recommended.
    # DEPRECATED: Language IDs do not exist for all locales
    # ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
    def MAKELANGID(p, s):
        return (WORD(s).value << 10) | WORD(p).value


    def PRIMARYLANGID(lgid):
        return WORD(lgid).value & 0x3FF


    def SUBLANGID(lgid):
        return WORD(lgid).value >> 10


    # ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
    # DEPRECATED: The LCID/LANGID/SORTID concept is deprecated, please use
    # Locale Names instead, eg: en - US instead of an LCID like 0x0409.
    # See the documentation for GetLocaleInfoEx.
    # A locale ID is a 32 bit value which is the combination of a
    # language ID, a sort ID, and a reserved area. The bits are
    # allocated as follows:
    # + - - - - - - - - - - - - - + - - - - - - - - - + - - - - - - - - - - -
    # - - - - - - - - - - - - - - +
    # | Reserved | Sort ID | Language ID  |
    # + - - - - - - - - - - - - - + - - - - - - - - - + - - - - - - - - - - -
    # - - - - - - - - - - - - - - +
    # 31  20 19  16 15    0 bit
    # WARNING: This pattern isn't always followed
    # (es - ES_tradnl vs es - ES for example)
    # WARNING: Some locales do not have assigned LCIDs. Please use
    # Locale Names, such as "tlh - Piqd".
    # It is recommended that applications test for locale names rather than
    # attempting to rely on LCID or LANGID behavior.
    # DEPRECATED: Locale ID creation/extraction macros:
    # MAKELCID  - construct the locale id from a language id and a sort id.
    # MAKESORTLCID  - construct the locale id from a language id, sort id, and
    # sort version.
    # LANGIDFROMLCID - extract the language id from a locale id.
    # SORTIDFROMLCID - extract the sort id from a locale id.
    # SORTVERSIONFROMLCID - extract the sort version from a locale id.
    # Note that the LANG, SUBLANG construction is not always consistent.
    # The named locale APIs (eg GetLocaleInfoEx) are recommended.
    # DEPRECATED: LCIDs do not exist for all locales.
    # ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
    NLS_VALID_LOCALE_MASK = 0x000FFFFF


    def MAKELCID(lgid, srtid):
        return (
            DWORD(
                DWORD(WORD(srtid).value).value << 16 |
                DWORD(WORD(lgid).value).value
            ).value
        )


    def MAKESORTLCID(lgid, srtid, ver):
        return (
            DWORD(MAKELCID(lgid, srtid)).value |
            (DWORD(WORD(ver).value).value << 20)
        )


    def LANGIDFROMLCID(lcid):
        return WORD(lcid).value


    def SORTIDFROMLCID(lcid):
        return WORD((DWORD(lcid).value >> 16) & 0xF).value


    def SORTVERSIONFROMLCID(lcid):
        return WORD((DWORD(lcid).value >> 20) & 0xF).value

    # Maximum Locale Name Length in Windows
    # Locale names are preferred to the deprecated LCID/LANGID concepts.
    # Locale names should follow the BCP47 recommendations and typically
    # include language, script, regional variant, and perhaps additional
    # specifiers.
    # BCP47 allows some variation, eg: en - US is preferred to en - Latn - US.
    LOCALE_NAME_MAX_LENGTH = 85


    # ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED ** DEPRECATED **
    # Deprecated default System and User IDs for language and locale.
    # Locale names such as LOCALE_NAME_SYSTEM_DEFAULT,
    # LOCALE_NAME_USER_DEFAULT,
    # and LOCALE_NAME_INVARIANT are preferred. See documentation for
    # GetLocaleInfoEx.
    LANG_SYSTEM_DEFAULT = MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT)
    LANG_USER_DEFAULT = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT)
    LOCALE_SYSTEM_DEFAULT = MAKELCID(LANG_SYSTEM_DEFAULT, SORT_DEFAULT)
    LOCALE_USER_DEFAULT = MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT)


    # Other special IDs for language and locale.
    # DEPRECATED: These identifiers are all underspecified and lose
    # information.
    # Please use Locale Names such as "en - FJ".
    # See documentation for GetLocaleInfoEx.
    LOCALE_CUSTOM_DEFAULT = (
        MAKELCID(
            MAKELANGID(LANG_NEUTRAL, SUBLANG_CUSTOM_DEFAULT),
            SORT_DEFAULT
        )
    )
    LOCALE_CUSTOM_UNSPECIFIED = (
        MAKELCID(
            MAKELANGID(LANG_NEUTRAL, SUBLANG_CUSTOM_UNSPECIFIED),
            SORT_DEFAULT
        )
    )
    LOCALE_CUSTOM_UI_DEFAULT = (
        MAKELCID(
            MAKELANGID(LANG_NEUTRAL, SUBLANG_UI_CUSTOM_DEFAULT),
            SORT_DEFAULT
        )
    )
    LOCALE_NEUTRAL = (
        MAKELCID(
            MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
            SORT_DEFAULT
        )
    )
    LOCALE_INVARIANT = (
        MAKELCID(
            MAKELANGID(LANG_INVARIANT, SUBLANG_NEUTRAL),
            SORT_DEFAULT
        )
    )

    # Transient keyboard Locale IDs (LCIDs)
    # Should only be used for keyboard layout identification
    # DEPRECATED: These identifiers are all transient and will change, even at
    # different times on the same system.
    # Please use Locale Names such as "en - FJ".
    # See documentation for GetLocaleInfoEx.
    LOCALE_TRANSIENT_KEYBOARD1 = 0x2000
    LOCALE_TRANSIENT_KEYBOARD2 = 0x2400
    LOCALE_TRANSIENT_KEYBOARD3 = 0x2800
    LOCALE_TRANSIENT_KEYBOARD4 = 0x2C00


    # Locale with an unassigned LCID
    # These locales cannot be queried by LCID
    # Currently same as LOCALE_CUSTOM_UNSPECIFIED
    # DEPRECATED: Please use Locale Names; see documentation for
    # GetLocaleInfoEx.
    LOCALE_UNASSIGNED_LCID = LOCALE_CUSTOM_UNSPECIFIED

    # begin_ntminiport begin_ntndis begin_ntminitape
    # Macros used to eliminate compiler warning generated when formal
    # parameters or local variables are not declared.
    # Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
    # referenced but will be once the module is completely developed.
    # Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
    # referenced but will be once the module is completely developed.
    # Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
    # DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
    # eventually be made into a null macro to help determine whether there
    # is unfinished work.
    # begin_ntoshvp
    lint = None
    if not defined(lint):
        if defined(_PREFAST_):
            def UNREFERENCED_PARAMETER(P):
                return P
                # return _Prefast_unreferenced_parameter_impl_(
                #     "PREfast",
                #     (VOID(P), 0)
                # )


            def DBG_UNREFERENCED_PARAMETER(P):
                return P
                # return _Prefast_unreferenced_parameter_impl_(
                #     "PREfast",
                #     (VOID(P), 0)
                # )


            def DBG_UNREFERENCED_LOCAL_VARIABLE(V):
                return V
                # return _Prefast_unreferenced_parameter_impl_(
                #     "PREfast",
                #     (VOID(V), 0)
                # )
        else:
            def UNREFERENCED_PARAMETER(P):
                return P


            def DBG_UNREFERENCED_PARAMETER(P):
                return P


            def DBG_UNREFERENCED_LOCAL_VARIABLE(V):
                return V
        # END IF   _PREFAST_
    else:
        # Note: lint - e530 says don't complain about uninitialized variables
        # for
        # this variable. Error 527 has to do with unreachable code.
        # - restore restores checking to the - save state
        def UNREFERENCED_PARAMETER(P):
            return P        # lint - save - e527 - e530 lint - restore


        def DBG_UNREFERENCED_PARAMETER(P):
            return P        # lint - save - e527 - e530 lint - restore


        def DBG_UNREFERENCED_LOCAL_VARIABLE(V):
            return V        # lint - save - e527 - e530 lint - restore
    # END IF   lint

    # end_ntoshvp
    # Macro used to eliminate compiler warning 4715 within a switch statement
    # when all possible cases have already been accounted for.
    # switch (a & 3) {
    # case 0: return 1;
    # case 1: return Foo();
    # case 2: return Bar();
    # case 3: return 1;
    # DEFAULT_UNREACHABLE;
    if _MSC_VER > 1200:
        DEFAULT_UNREACHABLE = VOID

    else:
        # Older compilers do not support __assume(), and there is no other free
        # method of eliminating the warning.
        DEFAULT_UNREACHABLE = VOID
    # END IF
    if defined(__cplusplus):
        # Define operator overloads to enable bit operations on enum values
        # that are
        # used to define flags. Use DEFINE_ENUM_FLAG_OPERATORS(YOUR_TYPE) to
        # enable these
        # operators on YOUR_TYPE.
        # Moved here from objbase.w.
        # Templates are defined here in order to avoid a dependency on C + +
        # <type_traits> header file,
        # or on compiler - specific constructs.
        _ENUM_FLAG_INTEGER_FOR_SIZE = ctypes.Structure

        # used as an approximation of std::underlying_type<T>

        if _MSC_VER >= 1900:
            _ENUM_FLAG_CONSTEXPR = VOID
        else:
            _ENUM_FLAG_CONSTEXPR = VOID
        # END IF
        def DEFINE_ENUM_FLAG_OPERATORS(ENUMTYPE):
            return 1
    else:
        def DEFINE_ENUM_FLAG_OPERATORS(ENUMTYPE):
            return 1        # NOP, C allows these operators.
    # END IF
    # Compile - time macros for initializing flag values in data.
    # When using DEFINE_ENUM_FLAG_OPERATORS for enum values you should use the
    # macros below
    # when you need to initialize global data. Without these macros the inline
    # operators
    # from DEFINE_ENUM_FLAG_OPERATORS force a runtime initialization rather
    # than a
    # compile time initialization. This applies even if you have declared the
    # data as const.
    # This is no longer necessary for compilers that support constexpr.
    def COMPILETIME_OR_2FLAGS(a, b):
        return a | b


    def COMPILETIME_OR_3FLAGS(a, b, c):
        return a | b | c


    def COMPILETIME_OR_4FLAGS(a, b, c, d):
        return a | b | c | d


    def COMPILETIME_OR_5FLAGS(a, b, c, d, e):
        return a | b | c | d | e


    def COMPILETIME_OR_6FLAGS(a, b, c, d, e, f):
        return a | b | c | d | e | f


    UMDF_USING_NTSTATUS = None
    if not defined(UMDF_USING_NTSTATUS):
        WIN32_NO_STATUS = None
        if not defined(WIN32_NO_STATUS):
            # lint - save - e767
            STATUS_WAIT_0 = 0x00000000
            STATUS_ABANDONED_WAIT_0 = 0x00000080
            STATUS_USER_APC = 0x000000C0
            STATUS_TIMEOUT = 0x00000102
            STATUS_PENDING = 0x00000103
            DBG_EXCEPTION_HANDLED = 0x00010001
            DBG_CONTINUE = 0x00010002
            STATUS_SEGMENT_NOTIFICATION = 0x40000005
            STATUS_FATAL_APP_EXIT = 0x40000015
            DBG_REPLY_LATER = 0x40010001
            DBG_TERMINATE_THREAD = 0x40010003
            DBG_TERMINATE_PROCESS = 0x40010004
            DBG_CONTROL_C = 0x40010005
            DBG_PRINTEXCEPTION_C = 0x40010006
            DBG_RIPEXCEPTION = 0x40010007
            DBG_CONTROL_BREAK = 0x40010008
            DBG_COMMAND_EXCEPTION = 0x40010009
            DBG_PRINTEXCEPTION_WIDE_C = 0x4001000A
            STATUS_GUARD_PAGE_VIOLATION = 0x80000001
            STATUS_DATATYPE_MISALIGNMENT = 0x80000002
            STATUS_BREAKPOINT = 0x80000003
            STATUS_SINGLE_STEP = 0x80000004
            STATUS_LONGJUMP = 0x80000026
            STATUS_UNWIND_CONSOLIDATE = 0x80000029
            DBG_EXCEPTION_NOT_HANDLED = 0x80010001
            STATUS_ACCESS_VIOLATION = 0xC0000005
            STATUS_IN_PAGE_ERROR = 0xC0000006
            STATUS_INVALID_HANDLE = 0xC0000008
            STATUS_INVALID_PARAMETER = 0xC000000D
            STATUS_NO_MEMORY = 0xC0000017
            STATUS_ILLEGAL_INSTRUCTION = 0xC000001D
            STATUS_NONCONTINUABLE_EXCEPTION = 0xC0000025
            STATUS_INVALID_DISPOSITION = 0xC0000026
            STATUS_ARRAY_BOUNDS_EXCEEDED = 0xC000008C
            STATUS_FLOAT_DENORMAL_OPERAND = 0xC000008D
            STATUS_FLOAT_DIVIDE_BY_ZERO = 0xC000008E
            STATUS_FLOAT_INEXACT_RESULT = 0xC000008F
            STATUS_FLOAT_INVALID_OPERATION = 0xC0000090
            STATUS_FLOAT_OVERFLOW = 0xC0000091
            STATUS_FLOAT_STACK_CHECK = 0xC0000092
            STATUS_FLOAT_UNDERFLOW = 0xC0000093
            STATUS_INTEGER_DIVIDE_BY_ZERO = 0xC0000094
            STATUS_INTEGER_OVERFLOW = 0xC0000095
            STATUS_PRIVILEGED_INSTRUCTION = 0xC0000096
            STATUS_STACK_OVERFLOW = 0xC00000FD
            STATUS_DLL_NOT_FOUND = 0xC0000135
            STATUS_ORDINAL_NOT_FOUND = 0xC0000138
            STATUS_ENTRYPOINT_NOT_FOUND = 0xC0000139
            STATUS_CONTROL_C_EXIT = 0xC000013A
            STATUS_DLL_INIT_FAILED = 0xC0000142
            STATUS_FLOAT_MULTIPLE_FAULTS = 0xC00002B4
            STATUS_FLOAT_MULTIPLE_TRAPS = 0xC00002B5
            STATUS_REG_NAT_CONSUMPTION = 0xC00002C9
            STATUS_HEAP_CORRUPTION = 0xC0000374
            STATUS_STACK_BUFFER_OVERRUN = 0xC0000409
            STATUS_INVALID_CRUNTIME_PARAMETER = 0xC0000417
            STATUS_ASSERTION_FAILURE = 0xC0000420
            STATUS_ENCLAVE_VIOLATION = 0xC00004A2
            STATUS_SUCCESS = 0x0000000
            if (
                defined(STATUS_SUCCESS) or
                _WIN32_WINNT > 0x0500 or
                _WIN32_FUSION >= 0x0100
            ):
                STATUS_SXS_EARLY_DEACTIVATION = 0xC015000F
                STATUS_SXS_INVALID_DEACTIVATION = 0xC0150010
            # END IF
            # lint - restore        # END IF
    # END IF  UMDF_USING_NTSTATUS
    MAXIMUM_WAIT_OBJECTS = 64    # Maximum number of wait objects
    MAXIMUM_SUSPEND_COUNT = MAXCHAR    # Maximum times thread can be suspended

    # begin_ntoshvp
    # Define 128 - bit 16 - byte aligned xmm register type.
    _M128A._fields_ = [
        ('Low', ULONGLONG),
        ('High', LONGLONG),
    ]

    # Format of data for (F)XSAVE/(F)XRSTOR instruction
    _TEMP__XSAVE_FORMAT = [
        ('ControlWord', WORD),
        ('StatusWord', WORD),
        ('TagWord', BYTE),
        ('Reserved1', BYTE),
        ('ErrorOpcode', WORD),
        ('ErrorOffset', DWORD),
        ('ErrorSelector', WORD),
        ('Reserved2', WORD),
        ('DataOffset', DWORD),
        ('DataSelector', WORD),
        ('Reserved3', WORD),
        ('MxCsr', DWORD),
        ('MxCsr_Mask', DWORD),
        ('FloatRegisters', M128A * 8),
    ]
    if defined(_WIN64):
        _TEMP__XSAVE_FORMAT += [
            ('XmmRegisters', M128A * 16),
            ('Reserved4', BYTE * 96),
        ]
    else:
        _TEMP__XSAVE_FORMAT += [
            ('XmmRegisters', M128A * 8),
            ('Reserved4', BYTE * 224),
        ]
    # END IF

    _XSAVE_FORMAT._fields_ = _TEMP__XSAVE_FORMAT

    # end_ntoshvp
    _XSAVE_AREA_HEADER._fields_ = [
        ('Mask', DWORD64),
        ('CompactionMask', DWORD64),
        ('Reserved2', DWORD64 * 6),
    ]

    _XSAVE_AREA._fields_ = [
        ('LegacyState', XSAVE_FORMAT),
        ('Header', XSAVE_AREA_HEADER),
    ]

    _TEMP__XSTATE_CONTEXT = [
        ('Mask', DWORD64),
        ('Length', DWORD),
        ('Reserved1', DWORD),
        ('Area', PXSAVE_AREA),
    ]
    if defined(_X86_):
        _TEMP__XSTATE_CONTEXT += [
            ('Reserved2', DWORD),
        ]
    # END IF
    _TEMP__XSTATE_CONTEXT += [
        ('Buffer', PVOID),
    ]
    if defined(_X86_):
        _TEMP__XSTATE_CONTEXT += [
            ('Reserved3', DWORD),
        ]
    # END IF
    _XSTATE_CONTEXT._fields_ = _TEMP__XSTATE_CONTEXT

    # Scope table structure definition.
    class ScopeRecord(ctypes.Structure):
        pass


    ScopeRecord._fields_ = [
        ('BeginAddress', DWORD),
        ('EndAddress', DWORD),
        ('HandlerAddress', DWORD),
        ('JumpTarget', DWORD),
    ]
    _SCOPE_TABLE_AMD64.ScopeRecord = ScopeRecord

    _SCOPE_TABLE_AMD64._fields_ = [
        ('Count', DWORD),
        ('ScopeRecord', _SCOPE_TABLE_AMD64.ScopeRecord * 1),
    ]

    # begin_ntoshvp
    if defined(_AMD64_):
        if defined(_M_AMD64) and not defined(RC_INVOKED) and not defined(MIDL_PASS):
            # Define bit test intrinsics.
            if defined(__cplusplus):
                pass
            # END IF
            # end_ntoshvp
            # Define extended CPUID intrinsic.

            _MM_HINT_T0 = 1
            _MM_HINT_T1 = 2
            _MM_HINT_T2 = 3
            _MM_HINT_NTA = 0

            # PreFetchCacheLine level defines.
            PF_TEMPORAL_LEVEL_1 = _MM_HINT_T0
            PF_TEMPORAL_LEVEL_2 = _MM_HINT_T1
            PF_TEMPORAL_LEVEL_3 = _MM_HINT_T2
            PF_NON_TEMPORAL_LEVEL_ALL = _MM_HINT_NTA
        # END IF   defined(_M_AMD64) and not defined(RC_INVOKED) and not defined(MIDL_PASS)

        # end_ntoshvp
        # The following values specify the type of access in the first
        # parameter
        # of the exception record whan the exception code specifies an
        # access
        # violation.
        EXCEPTION_READ_FAULT = 0                # exception caused by a read
        EXCEPTION_WRITE_FAULT = 1                # exception caused by a write
        EXCEPTION_EXECUTE_FAULT = 8  # exception caused by an instruction fetch

        # begin_wx86
        # The following flags control the contents of the CONTEXT
        # structure.
        if not defined(RC_INVOKED):
            CONTEXT_AMD64 = 0x00100000

            # end_wx86
            CONTEXT_CONTROL = CONTEXT_AMD64 | 0x00000001
            CONTEXT_INTEGER = CONTEXT_AMD64 | 0x00000002
            CONTEXT_SEGMENTS = CONTEXT_AMD64 | 0x00000004
            CONTEXT_FLOATING_POINT = CONTEXT_AMD64 | 0x00000008
            CONTEXT_DEBUG_REGISTERS = CONTEXT_AMD64 | 0x00000010
            CONTEXT_FULL = (
                CONTEXT_CONTROL |
                CONTEXT_INTEGER |
                CONTEXT_FLOATING_POINT
            )
            CONTEXT_ALL = (
                CONTEXT_CONTROL |
                CONTEXT_INTEGER |
                CONTEXT_SEGMENTS |
                CONTEXT_FLOATING_POINT |
                CONTEXT_DEBUG_REGISTERS
            )
            CONTEXT_XSTATE = CONTEXT_AMD64 | 0x00000040

            XBOX_SYSTEMOS = None

            if defined(XBOX_SYSTEMOS):
                CONTEXT_KERNEL_DEBUGGER = 0x04000000
            # END IF
            CONTEXT_EXCEPTION_ACTIVE = 0x08000000
            CONTEXT_SERVICE_ACTIVE = 0x10000000
            CONTEXT_EXCEPTION_REQUEST = 0x40000000
            CONTEXT_EXCEPTION_REPORTING = 0x80000000

            # begin_wx86
        # END IF   not defined(RC_INVOKED)

        # Define initial MxCsr and FpCsr control.
        INITIAL_MXCSR = 0x1F80  # initial MXCSR value
        INITIAL_FPCSR = 0x027F  # initial FPCSR value

        XMM_SAVE_AREA32 = XSAVE_FORMAT
        PXMM_SAVE_AREA32 = POINTER(XSAVE_FORMAT)
        # end_ntddk
        # begin_wdm begin_ntosp
        # begin_ntoshvp
        # end_wdm end_ntosp
        # begin_ntddk
        # Context Frame
        # This frame has a several purposes:
        # 1) it is used as an argument to
        # NtContinue,
        # 2) it is used to constuct a call frame for APC delivery,
        # and 3) it is used in the user level thread creation routines.
        # The flags field within this record controls the contents of
        # a CONTEXT
        # record.
        # If the context record is used as an input parameter, then
        # for each
        # portion of the context record controlled by a flag whose
        # value is
        # set, it is assumed that that portion of the context record
        # contains
        # valid context. If the context record is being used to modify
        # a threads
        # context, then only that portion of the threads context is
        # modified.
        # If the context record is used as an output parameter to
        # capture the
        # context of a thread, then only those portions of the
        # thread's context
        # corresponding to set flags will be returned.
        # CONTEXT_CONTROL specifies SegSs, Rsp, SegCs, Rip, and EFlags.
        # CONTEXT_INTEGER specifies Rax, Rcx, Rdx, Rbx, Rbp, Rsi, Rdi,
        # and R8 - R15.
        # CONTEXT_SEGMENTS specifies SegDs, SegEs, SegFs, and SegGs.
        # CONTEXT_FLOATING_POINT specifies Xmm0 - Xmm15.
        # CONTEXT_DEBUG_REGISTERS specifies Dr0 - Dr3 and Dr6 - Dr7.
        class DUMMYUNIONNAME(ctypes.Union):
            pass


        class DUMMYSTRUCTNAME(ctypes.Structure):
            pass


        DUMMYSTRUCTNAME._fields_ = [
            ('Header', M128A * 2),
            ('Legacy', M128A * 8),
            ('Xmm0', M128A),
            ('Xmm1', M128A),
            ('Xmm2', M128A),
            ('Xmm3', M128A),
            ('Xmm4', M128A),
            ('Xmm5', M128A),
            ('Xmm6', M128A),
            ('Xmm7', M128A),
            ('Xmm8', M128A),
            ('Xmm9', M128A),
            ('Xmm10', M128A),
            ('Xmm11', M128A),
            ('Xmm12', M128A),
            ('Xmm13', M128A),
            ('Xmm14', M128A),
            ('Xmm15', M128A),
        ]
        DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME

        DUMMYUNIONNAME._fields_ = [
            ('FltSave', XMM_SAVE_AREA32),
            ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
        ]
        _CONTEXT.DUMMYUNIONNAME = DUMMYUNIONNAME

        _CONTEXT._fields_ = [
            # context record in the future.
            ('P1Home', DWORD64),
            ('P2Home', DWORD64),
            ('P3Home', DWORD64),
            ('P4Home', DWORD64),
            ('P5Home', DWORD64),
            ('P6Home', DWORD64),
            # Control flags.
            ('ContextFlags', DWORD),
            ('MxCsr', DWORD),
            # Segment Registers and processor flags.
            ('SegCs', WORD),
            ('SegDs', WORD),
            ('SegEs', WORD),
            ('SegFs', WORD),
            ('SegGs', WORD),
            ('SegSs', WORD),
            ('EFlags', DWORD),
            # Debug registers
            ('Dr0', DWORD64),
            ('Dr1', DWORD64),
            ('Dr2', DWORD64),
            ('Dr3', DWORD64),
            ('Dr6', DWORD64),
            ('Dr7', DWORD64),
            # Integer registers.
            ('Rax', DWORD64),
            ('Rcx', DWORD64),
            ('Rdx', DWORD64),
            ('Rbx', DWORD64),
            ('Rsp', DWORD64),
            ('Rbp', DWORD64),
            ('Rsi', DWORD64),
            ('Rdi', DWORD64),
            ('R8', DWORD64),
            ('R9', DWORD64),
            ('R10', DWORD64),
            ('R11', DWORD64),
            ('R12', DWORD64),
            ('R13', DWORD64),
            ('R14', DWORD64),
            ('R15', DWORD64),
            # Program counter.
            ('Rip', DWORD64),
            # Floating point state.
            ('DUMMYUNIONNAME', _CONTEXT.DUMMYUNIONNAME),
            # Vector registers.
            ('VectorRegister', M128A * 26),
            ('VectorControl', DWORD64),
            # Special debug control registers.
            ('DebugControl', DWORD64),
            ('LastBranchToRip', DWORD64),
            ('LastBranchFromRip', DWORD64),
            ('LastExceptionToRip', DWORD64),
            ('LastExceptionFromRip', DWORD64),
        ]

        # end_ntoshvp
        # Select platform - specific definitions
        RUNTIME_FUNCTION = _IMAGE_RUNTIME_FUNCTION_ENTRY
        PRUNTIME_FUNCTION = POINTER(_IMAGE_RUNTIME_FUNCTION_ENTRY)

        SCOPE_TABLE = SCOPE_TABLE_AMD64
        PSCOPE_TABLE = POINTER(SCOPE_TABLE_AMD64)

        RUNTIME_FUNCTION_INDIRECT = 0x1

        # Define unwind information flags.
        UNW_FLAG_NHANDLER = 0x0
        UNW_FLAG_EHANDLER = 0x1
        UNW_FLAG_UHANDLER = 0x2
        UNW_FLAG_CHAININFO = 0x4
        UNW_FLAG_NO_EPILOGUE = 0x80000000  # Software only flag

        # Define unwind history table structure.
        UNWIND_HISTORY_TABLE_SIZE = 12

        _UNWIND_HISTORY_TABLE_ENTRY._fields_ = [
            ('ImageBase', DWORD64),
            ('FunctionEntry', PRUNTIME_FUNCTION),
        ]

        _UNWIND_HISTORY_TABLE._fields_ = [
            ('Count', DWORD),
            ('LocalHint', BYTE),
            ('GlobalHint', BYTE),
            ('Search', BYTE),
            ('Once', BYTE),
            ('LowAddress', DWORD64),
            ('HighAddress', DWORD64),
            ('Entry',
            UNWIND_HISTORY_TABLE_ENTRY * UNWIND_HISTORY_TABLE_SIZE),
        ]

        # Define dynamic function table entry.
        # _Function_class_(GET_RUNTIME_FUNCTION_CALLBACK)
        # PRUNTIME_FUNCTION
        # GET_RUNTIME_FUNCTION_CALLBACK (
        # _In_ DWORD64 ControlPc,
        # _In_opt_ PVOID Context
        # );
        GET_RUNTIME_FUNCTION_CALLBACK = CALLBACK(
            PRUNTIME_FUNCTION,
            DWORD64,
            PVOID
        )

        # _Function_class_(OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK)
        # DWORD
        # OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK (
        # _In_ HANDLE Process,
        # _In_ PVOID TableAddress,
        # _Out_ PDWORD Entries,
        # _Out_ PRUNTIME_FUNCTION* Functions
        # );
        OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK = CALLBACK(
            DWORD,
            HANDLE,
            PVOID,
            PDWORD
        )

        OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME = (
            "OutOfProcessFunctionTableCallback"
        )

        # Define exception dispatch context structure.
        _DISPATCHER_CONTEXT._fields_ = [
            ('ControlPc', DWORD64),
            ('ImageBase', DWORD64),
            ('FunctionEntry', PRUNTIME_FUNCTION),
            ('EstablisherFrame', DWORD64),
            ('TargetIp', DWORD64),
            ('ContextRecord', PCONTEXT),
            ('LanguageHandler', PEXCEPTION_ROUTINE),
            ('HandlerData', PVOID),
            ('HistoryTable', PUNWIND_HISTORY_TABLE),
            ('ScopeIndex', DWORD),
            ('Fill0', DWORD),
        ]

        # Define exception filter and termination handler function
        # types.
        _EXCEPTION_POINTERS = ctypes.Structure

        # LONG
        # (*PEXCEPTION_FILTER) (
        # struct _EXCEPTION_POINTERS *ExceptionPointers,
        # PVOID EstablisherFrame
        # );
        PEXCEPTION_FILTER = CALLBACK(
            LONG,
            POINTER(_EXCEPTION_POINTERS),
            PVOID
        )

        # VOID
        # (*PTERMINATION_HANDLER) (
        # BOOLEAN AbnormalTermination,
        # PVOID EstablisherFrame
        # );
        PTERMINATION_HANDLER = CALLBACK(
            VOID,
            BOOLEAN,
            PVOID
        )


        # Nonvolatile context pointer record.
        class DUMMYUNIONNAME(ctypes.Union):
            pass


        class DUMMYSTRUCTNAME(ctypes.Structure):
            pass


        DUMMYSTRUCTNAME._fields_ = [
            ('Xmm0', PM128A),
            ('Xmm1', PM128A),
            ('Xmm2', PM128A),
            ('Xmm3', PM128A),
            ('Xmm4', PM128A),
            ('Xmm5', PM128A),
            ('Xmm6', PM128A),
            ('Xmm7', PM128A),
            ('Xmm8', PM128A),
            ('Xmm9', PM128A),
            ('Xmm10', PM128A),
            ('Xmm11', PM128A),
            ('Xmm12', PM128A),
            ('Xmm13', PM128A),
            ('Xmm14', PM128A),
            ('Xmm15', PM128A),
        ]
        DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME

        DUMMYUNIONNAME._fields_ = [
            ('FloatingContext', PM128A * 16),
            ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
        ]
        _KNONVOLATILE_CONTEXT_POINTERS.DUMMYUNIONNAME = DUMMYUNIONNAME


        class DUMMYUNIONNAME2(ctypes.Union):
            pass


        class DUMMYSTRUCTNAME(ctypes.Structure):
            pass


        DUMMYSTRUCTNAME._fields_ = [
            ('Rax', PDWORD64),
            ('Rcx', PDWORD64),
            ('Rdx', PDWORD64),
            ('Rbx', PDWORD64),
            ('Rsp', PDWORD64),
            ('Rbp', PDWORD64),
            ('Rsi', PDWORD64),
            ('Rdi', PDWORD64),
            ('R8', PDWORD64),
            ('R9', PDWORD64),
            ('R10', PDWORD64),
            ('R11', PDWORD64),
            ('R12', PDWORD64),
            ('R13', PDWORD64),
            ('R14', PDWORD64),
            ('R15', PDWORD64),
        ]
        DUMMYUNIONNAME2.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME

        DUMMYUNIONNAME2._fields_ = [
            ('IntegerContext', PDWORD64 * 16),
            ('DUMMYSTRUCTNAME', DUMMYUNIONNAME2.DUMMYSTRUCTNAME),
        ]
        _KNONVOLATILE_CONTEXT_POINTERS.DUMMYUNIONNAME2 = DUMMYUNIONNAME2

        _KNONVOLATILE_CONTEXT_POINTERS._fields_ = [
            ('DUMMYUNIONNAME',
            _KNONVOLATILE_CONTEXT_POINTERS.DUMMYUNIONNAME),
            ('DUMMYUNIONNAME2',
            _KNONVOLATILE_CONTEXT_POINTERS.DUMMYUNIONNAME2),
        ]
    # END IF   _AMD64_
    # Scope table structure definition.

    class ScopeRecord(ctypes.Structure):
        pass


    ScopeRecord._fields_ = [
        ('BeginAddress', DWORD),
        ('EndAddress', DWORD),
        ('HandlerAddress', DWORD),
        ('JumpTarget', DWORD),
    ]

    _SCOPE_TABLE_ARM.ScopeRecord = ScopeRecord

    _SCOPE_TABLE_ARM._fields_ = [
        ('Count', DWORD),
        ('ScopeRecord', _SCOPE_TABLE_ARM.ScopeRecord * 1),
    ]
    if defined(_ARM_):
        if (
            defined(_M_ARM) and
            not defined(RC_INVOKED) and
            not defined(MIDL_PASS)
        ):
            from pyWinAPI.km.crt.intrin_h import *  # NOQA

            if not defined(_M_CEE_PURE):
                if defined(__cplusplus):
                    pass
                # END IF
                # Memory barriers and prefetch intrinsics.
                if _MSC_FULL_VER >= 170040825:
                    pass
                else:
                    def __dmb(x):
                        pass # return {__emit0xF3BF; __emit0x8F5F;}

                    def __dsb(x):
                        pass # return {__emit0xF3BF; __emit0x8F4F;}

                    def __isb(x):
                        pass # return {__emit0xF3BF; __emit0x8F6F;}
                # END IF

                # begin_wdm begin_ntndis begin_ntosp begin_ntminiport
                # Define coprocessor access intrinsics. Coprocessor 15
                # contains
                # registers for the MMU, cache, TLB, feature bits, core
                # identification and performance counters.
                CP15_PMSELR = 15, 0, 9, 12, 5  # Event Counter Selection Register
                CP15_PMXEVCNTR = 15, 0, 9, 13, 2  # Event Count Register
                CP15_TPIDRURW = 15, 0, 13, 0, 2  # Software Thread ID Register, User Read/Write
                CP15_TPIDRURO = 15, 0, 13, 0, 3  # Software Thread ID Register, User Read Only
                CP15_TPIDRPRW = 15, 0, 13, 0, 4  # Software Thread ID Register, Privileged Only


                # Coprocessor registers for synchronization
                def _InvalidateBTAC():
                    return _MoveToCoprocessor0, CP15_BPIALL


                # PreFetchCacheLine level defines.
                PF_TEMPORAL_LEVEL_1 = 0
                PF_TEMPORAL_LEVEL_2 = 1
                PF_TEMPORAL_LEVEL_3 = 2
                PF_NON_TEMPORAL_LEVEL_ALL = 3

                # Define function to read the value of the time stamp
                # counter which
                # ARM doesn't have.
                if defined(__cplusplus):
                    pass
                # END IF

            # END IF   not defined(_M_CEE_PURE)
        # END IF   defined(_M_ARM) and not defined(RC_INVOKED) and not defined(MIDL_PASS) and not defined(_M_CEE_PURE)
        if defined(_M_CEE_PURE):
            pass
        # END IF

        # The following values specify the type of access in the first
        # parameter
        # of the exception record whan the exception code specifies an
        # access
        # violation.
        EXCEPTION_READ_FAULT = 0  # exception caused by a read
        EXCEPTION_WRITE_FAULT = 1  # exception caused by a write
        EXCEPTION_EXECUTE_FAULT = 8  # exception caused by an instruction fetch

        # begin_wx86
        # The following flags control the contents of the CONTEXT
        # structure.
        if not defined(RC_INVOKED):
            CONTEXT_ARM = 0x00200000

            # end_wx86
            CONTEXT_CONTROL = CONTEXT_ARM | 0x1
            CONTEXT_INTEGER = CONTEXT_ARM | 0x2
            CONTEXT_FLOATING_POINT = CONTEXT_ARM | 0x4
            CONTEXT_DEBUG_REGISTERS = CONTEXT_ARM | 0x8
            CONTEXT_FULL = (
                CONTEXT_CONTROL |
                CONTEXT_INTEGER |
                CONTEXT_FLOATING_POINT
            )
            CONTEXT_ALL = (
                CONTEXT_CONTROL |
                CONTEXT_INTEGER |
                CONTEXT_FLOATING_POINT |
                CONTEXT_DEBUG_REGISTERS
            )
            CONTEXT_EXCEPTION_ACTIVE = 0x8000000
            CONTEXT_SERVICE_ACTIVE = 0x10000000
            CONTEXT_EXCEPTION_REQUEST = 0x40000000
            CONTEXT_EXCEPTION_REPORTING = 0x80000000

            # This flag is set by the unwinder if it has unwound to a call
            # site, and cleared whenever it unwinds through a trap frame.
            # It is used by language - specific exception handlers to help
            # differentiate exception scopes during dispatching.
            CONTEXT_UNWOUND_TO_CALL = 0x20000000

            # begin_wx86
        # END IF   not defined(RC_INVOKED)

        # Define initial Cpsr/Fpscr value
        INITIAL_CPSR = 0x10
        INITIAL_FPSCR = 0

        # Specify the number of breakpoints and watchpoints that the OS
        # will track. Architecturally, ARM supports up to 16. In practice,
        # however, almost no one implements more than 4 of each.
        ARM_MAX_BREAKPOINTS = 8
        ARM_MAX_WATCHPOINTS = 1

        # Context Frame
        # This frame has a several purposes:
        # 1) it is used as an argument to
        # NtContinue,
        # 2) it is used to constuct a call frame for APC delivery,
        # and 3) it is used in the user level thread creation routines.
        # The flags field within this record controls the contents of a
        # CONTEXT
        # record.
        # If the context record is used as an input parameter, then for
        # each
        # portion of the context record controlled by a flag whose value is
        # set, it is assumed that that portion of the context record
        # contains
        # valid context. If the context record is being used to modify a
        # threads
        # context, then only that portion of the threads context is
        # modified.
        # If the context record is used as an output parameter to capture
        # the
        # context of a thread, then only those portions of the thread's
        # context
        # corresponding to set flags will be returned.
        # CONTEXT_CONTROL specifies Sp, Lr, Pc, and Cpsr
        # CONTEXT_INTEGER specifies R0 - R12
        # CONTEXT_FLOATING_POINT specifies Q0 - Q15 / D0 - D31 / S0 - S31
        # CONTEXT_DEBUG_REGISTERS specifies up to 16 of DBGBVR, DBGBCR,
        # DBGWVR,
        # DBGWCR.
        _NEON128._fields_ = [
            ('Low', ULONGLONG),
            ('High', LONGLONG),
        ]
        # Select platform - specific definitions

        class DUMMYUNIONNAME(ctypes.Union):
            pass


        DUMMYUNIONNAME._fields_ = [
            ('Q', NEON128 * 16),
            ('D', ULONGLONG * 32),
            ('S', DWORD * 32),
        ]
        _CONTEXT.DUMMYUNIONNAME = DUMMYUNIONNAME

        _CONTEXT._fields_ = [
            # Control flags.
            ('ContextFlags', DWORD),
            # Integer registers
            ('R0', DWORD),
            ('R1', DWORD),
            ('R2', DWORD),
            ('R3', DWORD),
            ('R4', DWORD),
            ('R5', DWORD),
            ('R6', DWORD),
            ('R7', DWORD),
            ('R8', DWORD),
            ('R9', DWORD),
            ('R10', DWORD),
            ('R11', DWORD),
            ('R12', DWORD),
            # Control Registers
            ('Sp', DWORD),
            ('Lr', DWORD),
            ('Pc', DWORD),
            ('Cpsr', DWORD),
            # Floating Point/NEON Registers
            ('Fpscr', DWORD),
            ('Padding', DWORD),
            ('DUMMYUNIONNAME', _CONTEXT.DUMMYUNIONNAME),
            # Debug registers
            ('Bvr', DWORD * ARM_MAX_BREAKPOINTS),
            ('Bcr', DWORD * ARM_MAX_BREAKPOINTS),
            ('Wvr', DWORD * ARM_MAX_WATCHPOINTS),
            ('Wcr', DWORD * ARM_MAX_WATCHPOINTS),
            ('Padding2', DWORD * 2),
        ]

        RUNTIME_FUNCTION = _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY
        PRUNTIME_FUNCTION = POINTER(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY)

        SCOPE_TABLE = SCOPE_TABLE_ARM
        PSCOPE_TABLE = POINTER(SCOPE_TABLE_ARM)

        # Define unwind information flags.
        UNW_FLAG_NHANDLER = 0x0  # any handler
        UNW_FLAG_EHANDLER = 0x1  # filter handler
        UNW_FLAG_UHANDLER = 0x2  # unwind handler
        # Define unwind history table structure.
        UNWIND_HISTORY_TABLE_SIZE = 12

        _UNWIND_HISTORY_TABLE_ENTRY._fields_ = [
            ('ImageBase', DWORD),
            ('FunctionEntry', PRUNTIME_FUNCTION),
        ]

        _UNWIND_HISTORY_TABLE._fields_ = [
            ('Count', DWORD),
            ('LocalHint', BYTE),
            ('GlobalHint', BYTE),
            ('Search', BYTE),
            ('Once', BYTE),
            ('LowAddress', DWORD),
            ('HighAddress', DWORD),
            ('Entry', UNWIND_HISTORY_TABLE_ENTRY * UNWIND_HISTORY_TABLE_SIZE),
        ]

        _DISPATCHER_CONTEXT._fields_ = [
            ('ControlPc', DWORD),
            ('ImageBase', DWORD),
            ('FunctionEntry', PRUNTIME_FUNCTION),
            ('EstablisherFrame', DWORD),
            ('TargetPc', DWORD),
            ('ContextRecord', PCONTEXT),
            ('LanguageHandler', PEXCEPTION_ROUTINE),
            ('HandlerData', PVOID),
            ('HistoryTable', PUNWIND_HISTORY_TABLE),
            ('ScopeIndex', DWORD),
            ('ControlPcIsUnwound', BOOLEAN),
            ('NonVolatileRegisters', PBYTE),
            ('Reserved', DWORD),
        ]
        # Define exception dispatch context structure.
        # Define exception filter and termination handler function types.
        # N.B. These functions use a custom calling convention.
        _EXCEPTION_POINTERS = ctypes.Structure
        # LONG
        # (*PEXCEPTION_FILTER) (
        # struct _EXCEPTION_POINTERS *ExceptionPointers,
        # DWORD EstablisherFrame
        # );
        PEXCEPTION_FILTER = CALLBACK(
            LONG,
            POINTER(_EXCEPTION_POINTERS),
            DWORD
        )
        # VOID
        # (*PTERMINATION_HANDLER) (
        # BOOLEAN AbnormalTermination,
        # DWORD EstablisherFrame
        # );
        PTERMINATION_HANDLER = CALLBACK(
            VOID,
            BOOLEAN,
            DWORD
        )
        # Define dynamic function table entry.
        # _Function_class_(GET_RUNTIME_FUNCTION_CALLBACK)
        # PRUNTIME_FUNCTION
        # GET_RUNTIME_FUNCTION_CALLBACK (
        # _In_ DWORD ControlPc,
        # _In_opt_ PVOID Context
        # );
        GET_RUNTIME_FUNCTION_CALLBACK = CALLBACK(
            PRUNTIME_FUNCTION,
            DWORD,
            PVOID
        )
        # _Function_class_(OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK)
        # DWORD
        # OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK (
        # _In_ HANDLE Process,
        # _In_ PVOID TableAddress,
        # _Out_ PDWORD Entries,
        # _Out_ PRUNTIME_FUNCTION* Functions
        # );
        OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK = CALLBACK(
            DWORD,
            HANDLE,
            PVOID,
            PDWORD,
            POINTER(PRUNTIME_FUNCTION)
        )
        OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME = (
            "OutOfProcessFunctionTableCallback"
        )

        _KNONVOLATILE_CONTEXT_POINTERS._fields_ = [
            ('R4', PDWORD),
            ('R5', PDWORD),
            ('R6', PDWORD),
            ('R7', PDWORD),
            ('R8', PDWORD),
            ('R9', PDWORD),
            ('R10', PDWORD),
            ('R11', PDWORD),
            ('Lr', PDWORD),
            ('D8', PULONGLONG),
            ('D9', PULONGLONG),
            ('D10', PULONGLONG),
            ('D11', PULONGLONG),
            ('D12', PULONGLONG),
            ('D13', PULONGLONG),
            ('D14', PULONGLONG),
            ('D15', PULONGLONG),
        ]

        # Nonvolatile context pointer record.
    # END IF   _ARM_

    # Scope table structure definition.

    class ScopeRecord(ctypes.Structure):
        pass


    ScopeRecord._fields_ = [
        ('BeginAddress', DWORD),
        ('EndAddress', DWORD),
        ('HandlerAddress', DWORD),
        ('JumpTarget', DWORD),
    ]

    _SCOPE_TABLE_ARM64.ScopeRecord = ScopeRecord

    _SCOPE_TABLE_ARM64._fields_ = [
        ('Count', DWORD),
        ('ScopeRecord', _SCOPE_TABLE_ARM64.ScopeRecord * 1),
    ]
    # begin_ntddk begin_wdm begin_nthal begin_ntminiport begin_wx86
    _ARM64_ = None
    _CHPE_X86_ARM64_ = None

    if defined(_ARM64_) or defined(_CHPE_X86_ARM64_):
        # end_ntddk end_wdm end_nthal end_ntminiport end_wx86
        if not defined(_M_CEE_PURE):
            if not defined(RC_INVOKED) and not defined(MIDL_PASS):
                from pyWinAPI.km.crt.intrin_h import * # NOQA
                if defined(_M_ARM64):
                    pass

                # END IF   defined(_M_ARM64)
                if defined(_M_ARM64) or defined(_M_HYBRID_X86_ARM64):
                    # Memory barriers and prefetch intrinsics.

                    # Define accessors for volatile loads and stores.
                    # end_wdm end_ntndis end_ntosp end_ntminiport
                    # end_ntoshvp
                    if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP):
                        # begin_wdm begin_ntndis begin_ntosp
                        # begin_ntminiport begin_ntoshvp
                        # end_wdm end_ntndis end_ntosp end_ntminiport
                        # end_ntoshvp
                        pass
                    #  END IF   WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

                    # begin_wdm begin_ntndis begin_ntosp begin_ntminiport
                    # begin_ntoshvp
                    # Define coprocessor access intrinsics. Coprocessor 15
                    # contains
                    # registers for the MMU, cache, TLB, feature bits, core
                    # identification and performance counters.
                    # op0=2/3 encodings, use with _Read/WriteStatusReg
                    def ARM64_SYSREG(op0, op1, crn, crm, op2):
                        return (
                            ((op0 & 1) << 14) |
                            ((op1 & 7) << 11) |
                            ((crn & 15) << 7) |
                            ((crm & 15) << 3) |
                            ((op2 & 7) << 0)
                        )

                    # op0=1 encodings, use with __sys
                    def ARM64_SYSINSTR(op0, op1, crn, crm, op2):
                        return (
                            ((op1 & 7) << 11) |
                            ((crn & 15) << 7) |
                            ((crm & 15) << 3) |
                            ((op2 & 7) << 0)
                        )


                    def ARM64_SYSREG_OP1(_Reg_):
                        return (_Reg_ >> 11) & 7


                    def ARM64_SYSREG_CRN(_Reg_):
                        return (_Reg_ >> 7) & 15


                    def ARM64_SYSREG_CRM(_Reg_):
                        return (_Reg_ >> 3) & 15


                    def ARM64_SYSREG_OP2(_Reg_):
                        return _Reg_ & 7


                    ARM64_CNTVCT = ARM64_SYSREG(3,3,14, 0,2) # Generic Timer counter register
                    ARM64_PMCCNTR_EL0 = ARM64_SYSREG(3,3, 9,13,0) # Cycle Count Register [CP15_PMCCNTR]
                    ARM64_PMSELR_EL0 = ARM64_SYSREG(3,3, 9,12,5) # Event Counter Selection Register [CP15_PMSELR]
                    ARM64_PMXEVCNTR_EL0 = ARM64_SYSREG(3,3, 9,13,2) # Event Count Register [CP15_PMXEVCNTR]

                    def ARM64_PMXEVCNTRn_EL0(n):
                        return ARM64_SYSREG(3, 3, 14, 8 + (n / 8), n % 8) # Direct Event Count Register [n/a]


                    ARM64_TPIDR_EL0 = ARM64_SYSREG(3, 3, 13, 0, 2) # Thread ID Register, User Read/Write [CP15_TPIDRURW]
                    ARM64_TPIDRRO_EL0 = ARM64_SYSREG(3, 3, 13, 0, 3) # Thread ID Register, User Read Only [CP15_TPIDRURO]
                    ARM64_TPIDR_EL1 = ARM64_SYSREG(3, 0, 13, 0, 4) # Thread ID Register, Privileged Only [CP15_TPIDRPRW]

                    # PreFetchCacheLine level defines.
                    PF_TEMPORAL_LEVEL_1 = 0
                    PF_TEMPORAL_LEVEL_2 = 1
                    PF_TEMPORAL_LEVEL_3 = 2
                    PF_NON_TEMPORAL_LEVEL_ALL = 3
                    if defined(_M_HYBRID_X86_ARM64):
                        pass
                    # END IF
                    # Define function to read the value of the time stamp
                    # counter.
                    if defined(_M_HYBRID_X86_ARM64):
                        pass
                    # END IF
                    if defined(_M_HYBRID_X86_ARM64):
                        # Call into the emulator to return the same value
                        # as the x86 RDTSC
                        # instruction.
                        pass
                    else:
                        pass
                    # END IF
                    # ARM64_WORKITEM: These can be directly accessed, but
                    # given our usage, it that any benefit? We need to know
                    # the register index at compile time, though atomicity
                    # benefits would still be good if needed, even if we
                    # went with a big switch statement.
                    # Define functions to capture the high 64 - bits of a
                    # 128 - bit multiply.
                    # MultiplyHigh = __mulh
                    # UnsignedMultiplyHigh = __umulh
                # END IF   defined(_M_ARM64) or defined(_M_HYBRID_X86_ARM64)
            # END IF   not defined(RC_INVOKED) and not defined(MIDL_PASS)

        else:
            from pyWinAPI.km.crt.intrin_h import * # NOQA

        # END IF   not defined(_M_CEE_PURE)

        if defined(_M_CEE_PURE):
            pass
        # END IF
        # The following values specify the type of access in the first
        # parameter
        # of the exception record whan the exception code specifies an
        # access
        # violation.
        EXCEPTION_READ_FAULT = 0            # exception caused by a read
        EXCEPTION_WRITE_FAULT = 1            # exception caused by a write
        EXCEPTION_EXECUTE_FAULT = 8            # exception caused by an instruction fetch

        # begin_wx86
        # Define initial Cpsr/Fpscr value
        INITIAL_CPSR = 0x10
        INITIAL_FPSCR = 0

        # end_wx86
        # begin_wx86
        # The following flags control the contents of the CONTEXT
        # structure.
        if not defined(RC_INVOKED):
            CONTEXT_ARM64 = 0x00400000

            # end_wx86
            CONTEXT_ARM64_CONTROL = CONTEXT_ARM64 | 0x1
            CONTEXT_ARM64_INTEGER = CONTEXT_ARM64 | 0x2
            CONTEXT_ARM64_FLOATING_POINT = CONTEXT_ARM64 | 0x4
            CONTEXT_ARM64_DEBUG_REGISTERS = CONTEXT_ARM64 | 0x8
            CONTEXT_ARM64_X18 = CONTEXT_ARM64 | 0x10

            # CONTEXT_ARM64_X18 is not part of CONTEXT_ARM64_FULL because
            # in NT user - mode
            # threads, x18 contains a pointer to the TEB and should
            # generally not be set
            # without intending to.
            CONTEXT_ARM64_FULL = (
                CONTEXT_ARM64_CONTROL |
                CONTEXT_ARM64_INTEGER |
                CONTEXT_ARM64_FLOATING_POINT
            )
            CONTEXT_ARM64_ALL = (
                CONTEXT_ARM64_CONTROL |
                CONTEXT_ARM64_INTEGER |
                CONTEXT_ARM64_FLOATING_POINT |
                CONTEXT_ARM64_DEBUG_REGISTERS |
                CONTEXT_ARM64_X18
            )
            if defined(_ARM64_):
                CONTEXT_CONTROL = CONTEXT_ARM64_CONTROL
                CONTEXT_INTEGER = CONTEXT_ARM64_INTEGER
                CONTEXT_FLOATING_POINT = CONTEXT_ARM64_FLOATING_POINT
                CONTEXT_DEBUG_REGISTERS = CONTEXT_ARM64_DEBUG_REGISTERS
                CONTEXT_FULL = CONTEXT_ARM64_FULL
                CONTEXT_ALL = CONTEXT_ARM64_ALL
                CONTEXT_EXCEPTION_ACTIVE = 0x08000000
                CONTEXT_SERVICE_ACTIVE = 0x10000000
                CONTEXT_EXCEPTION_REQUEST = 0x40000000
                CONTEXT_EXCEPTION_REPORTING = 0x80000000
            # END IF
            if defined(_ARM64_) or defined(_CHPE_X86_ARM64_) or defined(_X86_):
                # This flag is set by the unwinder if it has unwound to a
                # call
                # site, and cleared whenever it unwinds through a trap
                #  frame.
                  # It is used by language - specific exception handlers to
                # help
                # differentiate exception scopes during dispatching.
                CONTEXT_UNWOUND_TO_CALL = 0x20000000
                CONTEXT_RET_TO_GUEST = 0x04000000
            # END IF
            # begin_wx86
        #  END IF   not defined(RC_INVOKED)
        # begin_ntoshvp
        # Specify the number of breakpoints and watchpoints that the OS
        # will track. Architecturally, ARM64 supports up to 16. In
        # practice,
        # however, almost no one implements more than 4 of each.
        ARM64_MAX_BREAKPOINTS = 8
        ARM64_MAX_WATCHPOINTS = 2

        # Context Frame
        # This frame has a several purposes:
        # 1) it is used as an argument to
        # NtContinue,
        # 2) it is used to constuct a call frame for APC delivery,
        # and 3) it is used in the user level thread creation routines.
        # The flags field within this record controls the contents of a
        # CONTEXT
        # record.
        # If the context record is used as an input parameter, then for
        # each
        # portion of the context record controlled by a flag whose value is
        # set, it is assumed that that portion of the context record
        # contains
        # valid context. If the context record is being used to modify a
        # threads
        # context, then only that portion of the threads context is
        # modified.
        # If the context record is used as an output parameter to capture
        # the
        # context of a thread, then only those portions of the thread's
        # context
           # corresponding to set flags will be returned.
        # CONTEXT_CONTROL specifies FP, LR, SP, PC, and CPSR
        # CONTEXT_INTEGER specifies X0 - X28
        # CONTEXT_FLOATING_POINT specifies Fpcr, Fpsr and Q0 - Q31 / D0 -
        # D31 / S0 - S31
        # CONTEXT_DEBUG_REGISTERS specifies up to 16 of DBGBVR, DBGBCR,
        # DBGWVR,
        # DBGWCR.
        class DUMMYSTRUCTNAME(ctypes.Structure):
            pass


        DUMMYSTRUCTNAME._fields_ = [
            ('Low', ULONGLONG),
            ('High', LONGLONG),
        ]
        _ARM64_NT_NEON128.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME

        _ARM64_NT_NEON128._fields_ = [
            ('DUMMYSTRUCTNAME', _ARM64_NT_NEON128.DUMMYSTRUCTNAME),
            ('D', DOUBLE * 2),
            ('S', FLOAT * 4),
            ('H', WORD * 8),
            ('B', BYTE * 16),
        ]
        if defined(_ARM64_):
            NEON128 = ARM64_NT_NEON128
            PNEON128 = POINTER(ARM64_NT_NEON128)
        # END IF

        if defined(_ARM64_):
            _ARM64_NT_CONTEXT = _CONTEXT
            ARM64_NT_NEON128 = NEON128
        # END IF

        class DUMMYUNIONNAME(ctypes.Union):
            pass


        class DUMMYSTRUCTNAME(ctypes.Structure):
            pass


        DUMMYSTRUCTNAME._fields_ = [
            # + 0x008
            ('X0', DWORD64),
            ('X1', DWORD64),
            ('X2', DWORD64),
            ('X3', DWORD64),
            ('X4', DWORD64),
            ('X5', DWORD64),
            ('X6', DWORD64),
            ('X7', DWORD64),
            ('X8', DWORD64),
            ('X9', DWORD64),
            ('X10', DWORD64),
            ('X11', DWORD64),
            ('X12', DWORD64),
            ('X13', DWORD64),
            ('X14', DWORD64),
            ('X15', DWORD64),
            ('X16', DWORD64),
            ('X17', DWORD64),
            ('X18', DWORD64),
            ('X19', DWORD64),
            ('X20', DWORD64),
            ('X21', DWORD64),
            ('X22', DWORD64),
            ('X23', DWORD64),
            ('X24', DWORD64),
            ('X25', DWORD64),
            ('X26', DWORD64),
            ('X27', DWORD64),
            ('X28', DWORD64),
            # + 0x0f0
            ('Fp', DWORD64),
            # + 0x0f8
            ('Lr', DWORD64),
        ]

        DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME

        DUMMYUNIONNAME._fields_ = [
            ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
            ('X', DWORD64 * 31),
        ]
        _ARM64_NT_CONTEXT.DUMMYUNIONNAME = DUMMYUNIONNAME

        _ARM64_NT_CONTEXT._fields_ = [
            # + 0x000
            ('ContextFlags', DWORD),
            # +0x004 NZVF + DAIF + CurrentEL + SPSel
            ('Cpsr', DWORD),
            # + 0x008
            ('DUMMYUNIONNAME', _ARM64_NT_CONTEXT.DUMMYUNIONNAME),
            # + 0x100
            ('Sp', DWORD64),
            # + 0x108
            ('Pc', DWORD64),
            # + 0x110
            ('V', ARM64_NT_NEON128 * 32),
            # + 0x310
            ('Fpcr', DWORD),
            # + 0x314
            ('Fpsr', DWORD),
            # + 0x318
            ('Bcr', DWORD * ARM64_MAX_BREAKPOINTS),
            # + 0x338
            ('Bvr', DWORD64 * ARM64_MAX_BREAKPOINTS),
            # + 0x378
            ('Wcr', DWORD * ARM64_MAX_WATCHPOINTS),
            # + 0x380
            ('Wvr', DWORD64 * ARM64_MAX_WATCHPOINTS),
        ]
        if defined(_ARM64_):
            CONTEXT = ARM64_NT_CONTEXT
            PCONTEXT = POINTER(ARM64_NT_CONTEXT)
            ARM64_NT_NEON128 = None
            _ARM64_NT_CONTEXT = None

        # END IF

        # end_ntoshvp
        # end_wx86
        # Select platform - specific definitions
        if defined(_ARM64_):
            RUNTIME_FUNCTION = _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY
            PRUNTIME_FUNCTION = POINTER(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY)

        # END IF
        ARM64_RUNTIME_FUNCTION = _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY
        PARM64_RUNTIME_FUNCTION = POINTER(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY)

        SCOPE_TABLE = SCOPE_TABLE_ARM64
        PSCOPE_TABLE = POINTER(SCOPE_TABLE_ARM64)

        # Define unwind information flags.
        UNW_FLAG_NHANDLER = 0x0            # any handler
        UNW_FLAG_EHANDLER = 0x1            # filter handler
        UNW_FLAG_UHANDLER = 0x2            # unwind handler

        # Define unwind history table structure.
        UNWIND_HISTORY_TABLE_SIZE = 12

        _UNWIND_HISTORY_TABLE_ENTRY._fields_ = [
            ('ImageBase', DWORD64),
            ('FunctionEntry', PARM64_RUNTIME_FUNCTION),
        ]

        _UNWIND_HISTORY_TABLE._fields_ = [
            ('Count', DWORD),
            ('LocalHint', BYTE),
            ('GlobalHint', BYTE),
            ('Search', BYTE),
            ('Once', BYTE),
            ('LowAddress', DWORD64),
            ('HighAddress', DWORD64),
            ('Entry', UNWIND_HISTORY_TABLE_ENTRY * UNWIND_HISTORY_TABLE_SIZE),
        ]

        if defined(_ARM64_) or defined(_CHPE_X86_ARM64_):
            _DISPATCHER_CONTEXT_ARM64 = _DISPATCHER_CONTEXT
        # END IF
        # Define exception dispatch context structure.
        _DISPATCHER_CONTEXT_ARM64._fields_ = [
            ('ControlPc', ULONG_PTR),
            ('ImageBase', ULONG_PTR),
            ('FunctionEntry', PARM64_RUNTIME_FUNCTION),
            ('EstablisherFrame', ULONG_PTR),
            ('TargetPc', ULONG_PTR),
            ('ContextRecord', PARM64_NT_CONTEXT),
            ('LanguageHandler', PEXCEPTION_ROUTINE),
            ('HandlerData', PVOID),
            ('HistoryTable', PUNWIND_HISTORY_TABLE),
            ('ScopeIndex', DWORD),
            ('ControlPcIsUnwound', BOOLEAN),
            ('NonVolatileRegisters', PBYTE),
        ]
        if defined(_ARM64_) or defined(_CHPE_X86_ARM64_):
            pass
        # END IF

        if defined(_ARM64_) or defined(_CHPE_X86_ARM64_):
            # Define exception filter and termination handler function
            # types.
            # N.B. These functions use a custom calling convention.
            _EXCEPTION_POINTERS = ctypes.Structure

            # LONG
            # (*PEXCEPTION_FILTER) (
            # struct _EXCEPTION_POINTERS *ExceptionPointers,
            # DWORD64 EstablisherFrame
            # );
            PEXCEPTION_FILTER = CALLBACK(
                LONG,
                POINTER(_EXCEPTION_POINTERS),
                DWORD64
            )

            # VOID
            # (*PTERMINATION_HANDLER) (
            # BOOLEAN AbnormalTermination,
            # DWORD64 EstablisherFrame
            # );
            PTERMINATION_HANDLER = CALLBACK(
                VOID,
                BOOLEAN,
                DWORD64
            )

        # END IF   defined(_ARM64_) or defined(_CHPE_X86_ARM64_)

        if defined(_ARM64_):
            # Define dynamic function table entry.
            # _Function_class_(GET_RUNTIME_FUNCTION_CALLBACK)
            # PARM64_RUNTIME_FUNCTION
            # GET_RUNTIME_FUNCTION_CALLBACK (
            # _In_ DWORD64 ControlPc,
            # _In_opt_ PVOID Context
            # );
            GET_RUNTIME_FUNCTION_CALLBACK = CALLBACK(
                PARM64_RUNTIME_FUNCTION,
                DWORD64,
                PVOID
            )

            # _Function_class_(OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK)
            # DWORD
            # OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK (
            # _In_ HANDLE Process,
            # _In_ PVOID TableAddress,
            # _Out_ PDWORD Entries,
            # _Out_ PARM64_RUNTIME_FUNCTION* Functions
            # );
            OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK = CALLBACK(
                DWORD,
                HANDLE,
                PVOID,
                PDWORD,
                POINTER(PARM64_RUNTIME_FUNCTION)
            )

            OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME = (
                "OutOfProcessFunctionTableCallback"
            )
        # END IF   defined(_ARM64_)
            # begin_ntoshvp
    # END IF   defined(_ARM64_) or defined(_CHPE_X86_ARM64_)
    # end_ntoshvp
    # Nonvolatile context pointer record.
    _KNONVOLATILE_CONTEXT_POINTERS_ARM64._fields_ = [
        ('X19', PDWORD64),
        ('X20', PDWORD64),
        ('X21', PDWORD64),
        ('X22', PDWORD64),
        ('X23', PDWORD64),
        ('X24', PDWORD64),
        ('X25', PDWORD64),
        ('X26', PDWORD64),
        ('X27', PDWORD64),
        ('X28', PDWORD64),
        ('Fp', PDWORD64),
        ('Lr', PDWORD64),
        ('D8', PDWORD64),
        ('D9', PDWORD64),
        ('D10', PDWORD64),
        ('D11', PDWORD64),
        ('D12', PDWORD64),
        ('D13', PDWORD64),
        ('D14', PDWORD64),
        ('D15', PDWORD64),
    ]
    if defined(_ARM64_):
        KNONVOLATILE_CONTEXT_POINTERS = KNONVOLATILE_CONTEXT_POINTERS_ARM64
        PKNONVOLATILE_CONTEXT_POINTERS = POINTER(KNONVOLATILE_CONTEXT_POINTERS_ARM64)
    # END IF
    if defined(_CHPE_X86_ARM64_):
        # The following typedef works - around the fact that the dummy
        # NV_C_P for x86
        # is defined in i386.h, which is incorrect because it doesn't have
        # the
        # correct scope. This will not be needed after fixing that: moving
        # the
        # definition to nti386_x.w with the same scoping as other
        # architectures.
        class _KNONVOLATILE_CONTEXT_POINTERS(ctypes.Structure):
            pass


        PKNONVOLATILE_CONTEXT_POINTERS = POINTER(_KNONVOLATILE_CONTEXT_POINTERS_ARM64)
    # END IF
    # begin_wudfwdm
    if defined(__cplusplus):
        pass
    # END IF
    # Assert exception.
    _DBGRAISEASSERTIONFAILURE_ = None

    if not defined(_DBGRAISEASSERTIONFAILURE_) and not defined(RC_INVOKED) and not defined(MIDL_PASS):
        _DBGRAISEASSERTIONFAILURE_ = 1
        if defined(_PREFAST_):
            pass
        # END IF

        if defined(_AMD64_):
            if defined(_M_AMD64):
                if not defined(_PREFAST_):
                    pass
                # END IF   not defined(_PREFAST_)
            # END IF   defined(_M_AMD64)

        elif defined(_X86_) and not defined(_M_HYBRID_X86_ARM64):
            if defined(_M_IX86) and not defined(_M_HYBRID_X86_ARM64):
                if _MSC_FULL_VER >= 140030222:
                    if not defined(_PREFAST_):
                        pass
                    # END IF   not defined(_PREFAST_)

                    if not defined(_PREFAST_):
                        pass
                    # END IF   not defined(_PREFAST_)
                else:
                    pass
                # END IF   _MSC_FULL_VER >= 140030222
            # END IF   defined(_M_IX86)

        elif defined(_IA64_):
            if defined(_M_IA64):
                BREAK_DEBUG_BASE = 0x080000
                ASSERT_BREAKPOINT = BREAK_DEBUG_BASE + 3 # Cause a STATUS_ASSERTION_FAILURE exception to be raised.

                if not defined(_PREFAST_):
                    pass
                # END IF   not defined(_PREFAST_)
            # END IF   defined(_M_IA64)

        elif defined(_ARM64_) or defined(_CHPE_X86_ARM64_):
            if defined(_M_ARM64) or defined(_M_HYBRID_X86_ARM64):
                if not defined(_PREFAST_):
                    pass
                # END IF   not defined(_PREFAST_)
            # END IF   defined(_M_ARM64) or defined(_M_HYBRID_X86_ARM64)

        elif defined(_ARM_):
            if defined(_M_ARM):
                if not defined(_PREFAST_):
                    pass
                # END IF   not defined(_PREFAST_)
            # END IF   defined(_M_ARM)
        # END IF   _AMD64_, _X86_, _IA64_, _ARM64_, _ARM_

    # END IF   not defined(_DBGRAISEASSERTIONFAILURE_) and not defined(RC_INVOKED) and not defined(MIDL_PASS)

    if defined(__cplusplus):
        pass
        # END IF
        # begin_ntoshvp
    if defined(_X86_):
        # Some intrinsics have a redundant __cdecl calling - convention
        # specifier when
        # not compiled with /clr:pure.
        if defined(_M_CEE_PURE):
            CDECL_NON_WVMPURE = 1
        else:
            CDECL_NON_WVMPURE = 1
        # END IF
        # end_ntoshvp
        # Disable these two pragmas that evaluate to "sti" "cli" on x86 so
        # that driver
        # writers to not leave them inadvertantly in their code.

        if not defined(MIDL_PASS):
            if not defined(RC_INVOKED):
                if _MSC_VER >= 1200:
                    pass
                # END IF   _MSC_VER >= 1200

                # pragma warning(disable:4164) // disable C4164 warning so
                # that apps that
                # build with /Od don't get weird errors not
                if _MSC_VER >= 1200:
                    pass
                else:
                    pass
                # END IF   _MSC_VER >= 1200
            # END IF   not defined(MIDL_PASS)
        # END IF   not defined(RC_INVOKED)
        # end_ntddk end_nthal
        # begin_ntoshvp

        if defined(_M_IX86) and not defined(RC_INVOKED) and not defined(MIDL_PASS):
            if defined(__cplusplus):
                pass
            # END IF

            if not defined(_MANAGED):
                # Define bit test intrinsics.
                pass
            # END IF   not defined(_MANAGED)
            # Interlocked intrinsic functions.
            if not defined(_MANAGED):
                pass
            # END IF   not defined(_MANAGED)

            if not defined(_MANAGED):
                if _MSC_VER >= 1600:
                    pass
                # END IF   _MSC_VER >= 1600
                if _MSC_FULL_VER >= 140041204:
                    pass
                # END IF  _MSC_FULL_VER >= 140040816
                # Define 64 - bit operations in terms of
                # InterlockedCompareExchange64

            # END IF   not defined(_MANAGED)

            if not defined(_MANAGED):
                # FS relative adds and increments.
                pass
            # END IF   not defined(_MANAGED)

            if not defined(_M_CEE_PURE):
                # end_ntoshvp
                if _MSC_VER >= 1500:
                    # Define extended CPUID intrinsic.
                    # CpuIdEx = __cpuidex
                    pass
                # END IF
                # begin_ntoshvp
                # Define FS read/write intrinsics
            # END IF   not defined(_M_CEE_PURE)
            if not defined(_MANAGED) and not defined(_M_HYBRID_X86_ARM64):
                # YieldProcessor = _mm_pause
                pass
            # END IF   not defined(_MANAGED) and not defined(_M_HYBRID_X86_ARM64)
            if defined(__cplusplus):
                pass
            # END IF
        # END IF  not defined(MIDL_PASS) or defined(_M_IX86)

        # end_ntoshvp
        # begin_ntoshvp

        if not defined(MIDL_PASS) and defined(_M_IX86):
            if not defined(_M_CEE_PURE) and not defined(_M_HYBRID_X86_ARM64):
                pass
            # END IF  not _M_CEE_PURE or not _M_HYBRID_X86_ARM64
            if not defined(_M_HYBRID_X86_ARM64):
                # Define constants for use with _mm_prefetch.
                _MM_HINT_T0 = 1
                _MM_HINT_T1 = 2
                _MM_HINT_T2 = 3
                _MM_HINT_NTA = 0

                # PreFetchCacheLine level defines.
                PF_TEMPORAL_LEVEL_1 = _MM_HINT_T0
                PF_TEMPORAL_LEVEL_2 = _MM_HINT_T1
                PF_TEMPORAL_LEVEL_3 = _MM_HINT_T2
                PF_NON_TEMPORAL_LEVEL_ALL = _MM_HINT_NTA
                if not defined(_MANAGED):
                    # Define function to read the value of a
                    # performance counter.
                    # ReadPMC = __readpmc

                    # Define function to read the value of the time
                    # stamp counter
                    pass
                # END IF   not defined(_MANAGED)
            # END IF   not defined(_M_HYBRID_X86_ARM64)

            # end_ntoshvp
            # end_ntddk
            if not defined(_MANAGED):
                pass
            # END IF   not defined(_MANAGED)

            # begin_ntddk
            # begin_ntoshvp
        # END IF   not defined(MIDL_PASS) and defined(_M_IX86)

        # end_ntoshvp
        # end_ntddk
        # The following values specify the type of failing access when
        # the status is
        # STATUS_ACCESS_VIOLATION and the first parameter in the
        # execpetion record.
        EXCEPTION_READ_FAULT = 0  # Access violation was caused by a read
        EXCEPTION_WRITE_FAULT = 1  # Access violation was caused by a write
        EXCEPTION_EXECUTE_FAULT = 8  # Access violation was caused by an instruction fetch

        # begin_wx86
        # begin_ntddk
        # begin_ntoshvp
        # Define the size of the 80387 save area, which is in the
        # context frame.
        SIZE_OF_80387_REGISTERS = 80

        # The following flags control the contents of the CONTEXT
        # structure.
        if not defined(RC_INVOKED):
            CONTEXT_i386 = 0x00010000  # this assumes that i386 and
            CONTEXT_i486 = 0x00010000  # i486 have identical context records

            # end_wx86
            CONTEXT_CONTROL = CONTEXT_i386 | 0x00000001  # SS:SP, CS:IP, FLAGS, BP
            CONTEXT_INTEGER = CONTEXT_i386 | 0x00000002  # AX, BX, CX, DX, SI, DI
            CONTEXT_SEGMENTS = CONTEXT_i386 | 0x00000004  # DS, ES, FS, GS
            CONTEXT_FLOATING_POINT = CONTEXT_i386 | 0x00000008  # 387 state
            CONTEXT_DEBUG_REGISTERS = CONTEXT_i386 | 0x00000010  # DB 0 - 3,6,7
            CONTEXT_EXTENDED_REGISTERS = CONTEXT_i386 | 0x00000020  # cpu specific extensions
            CONTEXT_FULL = (
                CONTEXT_CONTROL |
                CONTEXT_INTEGER |
                CONTEXT_SEGMENTS
            )
            CONTEXT_ALL = (
                CONTEXT_CONTROL |
                CONTEXT_INTEGER |
                CONTEXT_SEGMENTS |
                CONTEXT_FLOATING_POINT |
                CONTEXT_DEBUG_REGISTERS |
                CONTEXT_EXTENDED_REGISTERS
            )
            CONTEXT_XSTATE = CONTEXT_i386 | 0x00000040
            CONTEXT_EXCEPTION_ACTIVE = 0x08000000
            CONTEXT_SERVICE_ACTIVE = 0x10000000
            CONTEXT_EXCEPTION_REQUEST = 0x40000000
            CONTEXT_EXCEPTION_REPORTING = 0x80000000

            # begin_wx86
        # END IF   not defined(RC_INVOKED)
        _FLOATING_SAVE_AREA._fields_ = [
            ('ControlWord', DWORD),
            ('StatusWord', DWORD),
            ('TagWord', DWORD),
            ('ErrorOffset', DWORD),
            ('ErrorSelector', DWORD),
            ('DataOffset', DWORD),
            ('DataSelector', DWORD),
            ('RegisterArea', BYTE * SIZE_OF_80387_REGISTERS),
            ('Spare0', DWORD),
        ]

        PFLOATING_SAVE_AREA = POINTER(FLOATING_SAVE_AREA)

        # end_ntddk
        # begin_wdm begin_ntosp
        MAXIMUM_SUPPORTED_EXTENSION = 512
        if not defined(__midl) and not defined(MIDL_PASS):
            pass
        # END IF

        # end_wdm end_ntosp
        # begin_ntddk
        from pyWinAPI.shared.pshpack4_h import *  # NOQA

        # Context Frame

        _CONTEXT._fields_ = [
            # The context record is never used as an OUT only parameter.
            ('ContextFlags', DWORD),
            # included in CONTEXT_FULL.
            ('Dr0', DWORD),
            ('Dr1', DWORD),
            ('Dr2', DWORD),
            ('Dr3', DWORD),
            ('Dr6', DWORD),
            ('Dr7', DWORD),
            # ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
            ('FloatSave', FLOATING_SAVE_AREA),
            # ContextFlags word contians the flag CONTEXT_SEGMENTS.
            ('SegGs', DWORD),
            ('SegFs', DWORD),
            ('SegEs', DWORD),
            ('SegDs', DWORD),
            # ContextFlags word contians the flag CONTEXT_INTEGER.
            ('Edi', DWORD),
            ('Esi', DWORD),
            ('Ebx', DWORD),
            ('Edx', DWORD),
            ('Ecx', DWORD),
            ('Eax', DWORD),
            # ContextFlags word contians the flag CONTEXT_CONTROL.
            ('Ebp', DWORD),
            ('Eip', DWORD),
            # MUST BE SANITIZED
            ('SegCs', DWORD),
            # MUST BE SANITIZED
            ('EFlags', DWORD),
            ('Esp', DWORD),
            ('SegSs', DWORD),
            # The format and contexts are processor specific
            ('ExtendedRegisters', BYTE * MAXIMUM_SUPPORTED_EXTENSION),
        ]

        PCONTEXT = POINTER(CONTEXT)

        from pyWinAPI.shared.poppack_h import *  # NOQA
        # end_ntoshvp
        # begin_ntminiport
    # END IF  _X86_

    _LDT_ENTRY_DEFINED = None
    if not defined(_LDT_ENTRY_DEFINED):
        _LDT_ENTRY_DEFINED = 1


        class HighWord(ctypes.Union):
            pass


        class Bytes(ctypes.Structure):
            pass


        Bytes._fields_ = [
            ('BaseMid', BYTE),
            # Declare as bytes to avoid alignment
            ('Flags1', BYTE),
            # Problems.
            ('Flags2', BYTE),
            ('BaseHi', BYTE),
        ]
        HighWord.Bytes = Bytes


        class Bits(ctypes.Structure):
            pass


        Bits._fields_ = [
            ('BaseMid', DWORD, 8),
            ('Type', DWORD, 5),
            ('Dpl', DWORD, 2),
            ('Pres', DWORD, 1),
            ('LimitHi', DWORD, 4),
            ('Sys', DWORD, 1),
            ('Reserved_0', DWORD, 1),
            ('Default_Big', DWORD, 1),
            ('Granularity', DWORD, 1),
            ('BaseHi', DWORD, 8),
        ]
        HighWord.Bits = Bits

        HighWord._fields_ = [
            ('Bytes', HighWord.Bytes),
            ('Bits', HighWord.Bits),
        ]
        _LDT_ENTRY.HighWord = HighWord

        _LDT_ENTRY._fields_ = [
            ('LimitLow', WORD),
            ('BaseLow', WORD),
            ('HighWord', _LDT_ENTRY.HighWord),
        ]
    # END IF

    if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP):
        # begin_wdm begin_ntminiport

        if not defined(RC_INVOKED) and not defined(MIDL_PASS):
            if (
                (
                    (defined(_M_AMD64) or defined(_M_IX86)) and
                    not defined(_M_HYBRID_X86_ARM64)
                ) or
                defined(_M_CEE_PURE)
            ):
                if defined(__cplusplus):
                    pass
                # END IF
                if defined(__cplusplus):
                    pass
                # END IF
            # END IF   defined(_M_AMD64) or defined(_M_IX86) or defined(_M_CEE_PURE)

            # Define "raw" operations which have no ordering or
            # atomicity semantics.
            # Define explicit read and write operations for derived
            # types.

            if not defined(_WIN64):
                pass
            else:
                pass
            # END IF   not defined(_WIN64)
        # END IF   not defined(RC_INVOKED) and not defined(MIDL_PASS)

        # end_ntddk end_wdm end_ntminiport
    # END IF   WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
    if not defined(RC_INVOKED):
        WOW64_CONTEXT_i386 = 0x00010000  # this assumes that i386 and
        WOW64_CONTEXT_i486 = 0x00010000  # i486 have identical context records
        WOW64_CONTEXT_CONTROL = WOW64_CONTEXT_i386 | 0x00000001  # SS:SP, CS:IP, FLAGS, BP
        WOW64_CONTEXT_INTEGER = WOW64_CONTEXT_i386 | 0x00000002  # AX, BX, CX, DX, SI, DI
        WOW64_CONTEXT_SEGMENTS = WOW64_CONTEXT_i386 | 0x00000004  # DS, ES, FS, GS
        WOW64_CONTEXT_FLOATING_POINT = WOW64_CONTEXT_i386 | 0x00000008  # 387 state
        WOW64_CONTEXT_DEBUG_REGISTERS = WOW64_CONTEXT_i386 | 0x00000010  # DB 0 - 3,6,7
        WOW64_CONTEXT_EXTENDED_REGISTERS = (
            WOW64_CONTEXT_i386 |
            0x00000020
        )  # cpu specific extensions
        WOW64_CONTEXT_FULL = (
            WOW64_CONTEXT_CONTROL |
            WOW64_CONTEXT_INTEGER |
            WOW64_CONTEXT_SEGMENTS
        )
        WOW64_CONTEXT_ALL = (
            WOW64_CONTEXT_CONTROL |
            WOW64_CONTEXT_INTEGER |
            WOW64_CONTEXT_SEGMENTS |
            WOW64_CONTEXT_FLOATING_POINT |
            WOW64_CONTEXT_DEBUG_REGISTERS |
            WOW64_CONTEXT_EXTENDED_REGISTERS
        )
        WOW64_CONTEXT_XSTATE = WOW64_CONTEXT_i386 | 0x00000040
        WOW64_CONTEXT_EXCEPTION_ACTIVE = 0x08000000
        WOW64_CONTEXT_SERVICE_ACTIVE = 0x10000000
        WOW64_CONTEXT_EXCEPTION_REQUEST = 0x40000000
        WOW64_CONTEXT_EXCEPTION_REPORTING = 0x80000000
    # END IF   not defined(RC_INVOKED)

    # Define the size of the 80387 save area, which is in the context
    # frame.
    WOW64_SIZE_OF_80387_REGISTERS = 80
    WOW64_MAXIMUM_SUPPORTED_EXTENSION = 512

    _WOW64_FLOATING_SAVE_AREA._fields_ = [
        ('ControlWord', DWORD),
        ('StatusWord', DWORD),
        ('TagWord', DWORD),
        ('ErrorOffset', DWORD),
        ('ErrorSelector', DWORD),
        ('DataOffset', DWORD),
        ('DataSelector', DWORD),
        ('RegisterArea', BYTE * WOW64_SIZE_OF_80387_REGISTERS),
        ('Cr0NpxState', DWORD),
    ]

    PWOW64_FLOATING_SAVE_AREA = POINTER(WOW64_FLOATING_SAVE_AREA)


    from pyWinAPI.shared.pshpack4_h import *  # NOQA


    # Context Frame
    # This frame has a several purposes:
    # 1) it is used as an argument to
    # NtContinue,
    # 2) is is used to constuct a call frame for APC delivery,
    # and 3) it is used in the user level thread creation routines.
    # The layout of the record conforms to a standard call frame.

    _WOW64_CONTEXT._fields_ = [
        # The context record is never used as an OUT only parameter.
        ('ContextFlags', DWORD),
        # included in CONTEXT_FULL.
        ('Dr0', DWORD),
        ('Dr1', DWORD),
        ('Dr2', DWORD),
        ('Dr3', DWORD),
        ('Dr6', DWORD),
        ('Dr7', DWORD),
        # ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
        ('FloatSave', WOW64_FLOATING_SAVE_AREA),
        # ContextFlags word contians the flag CONTEXT_SEGMENTS.
        ('SegGs', DWORD),
        ('SegFs', DWORD),
        ('SegEs', DWORD),
        ('SegDs', DWORD),
        # ContextFlags word contians the flag CONTEXT_INTEGER.
        ('Edi', DWORD),
        ('Esi', DWORD),
        ('Ebx', DWORD),
        ('Edx', DWORD),
        ('Ecx', DWORD),
        ('Eax', DWORD),
        # ContextFlags word contians the flag CONTEXT_CONTROL.
        ('Ebp', DWORD),
        ('Eip', DWORD),
        # MUST BE SANITIZED
        ('SegCs', DWORD),
        # MUST BE SANITIZED
        ('EFlags', DWORD),
        ('Esp', DWORD),
        ('SegSs', DWORD),
        # The format and contexts are processor specific
        ('ExtendedRegisters', BYTE * WOW64_MAXIMUM_SUPPORTED_EXTENSION),
    ]

    PWOW64_CONTEXT = POINTER(WOW64_CONTEXT)


    from pyWinAPI.shared.poppack_h import *  # NOQA


    class HighWord(ctypes.Union):
        pass


    class Bytes(ctypes.Structure):
        pass


    Bytes._fields_ = [
        ('BaseMid', BYTE),
        # Declare as bytes to avoid alignment
        ('Flags1', BYTE),
        # Problems.
        ('Flags2', BYTE),
        ('BaseHi', BYTE),
    ]
    HighWord.Bytes = Bytes


    class Bits(ctypes.Structure):
        pass


    Bits._fields_ = [
        ('BaseMid', DWORD, 8),
        ('Type', DWORD, 5),
        ('Dpl', DWORD, 2),
        ('Pres', DWORD, 1),
        ('LimitHi', DWORD, 4),
        ('Sys', DWORD, 1),
        ('Reserved_0', DWORD, 1),
        ('Default_Big', DWORD, 1),
        ('Granularity', DWORD, 1),
        ('BaseHi', DWORD, 8),
    ]
    HighWord.Bits = Bits

    HighWord._fields_ = [
        ('Bytes', HighWord.Bytes),
        ('Bits', HighWord.Bits),
    ]
    _WOW64_LDT_ENTRY.HighWord = HighWord

    _WOW64_LDT_ENTRY._fields_ = [
        ('LimitLow', WORD),
        ('BaseLow', WORD),
        ('HighWord', _WOW64_LDT_ENTRY.HighWord),
    ]

    _WOW64_DESCRIPTOR_TABLE_ENTRY._fields_ = [
        ('Selector', DWORD),
        ('Descriptor', WOW64_LDT_ENTRY),
    ]

    EXCEPTION_NONCONTINUABLE = 0x1  # Noncontinuable exception
    EXCEPTION_UNWINDING = 0x2  # Unwind is in progress
    EXCEPTION_EXIT_UNWIND = 0x4  # Exit unwind is in progress
    EXCEPTION_STACK_INVALID = 0x8  # Stack out of limits or unaligned
    EXCEPTION_NESTED_CALL = 0x10  # Nested exception handler call
    EXCEPTION_TARGET_UNWIND = 0x20  # Target unwind in progress
    EXCEPTION_COLLIDED_UNWIND = 0x40  # Collided exception handler call
    EXCEPTION_UNWIND = (
        EXCEPTION_UNWINDING |
        EXCEPTION_EXIT_UNWIND |
        EXCEPTION_TARGET_UNWIND |
        EXCEPTION_COLLIDED_UNWIND
    )


    def IS_UNWINDING(Flag):
        return (Flag & EXCEPTION_UNWIND) != 0


    def IS_DISPATCHING(Flag):
        return (Flag & EXCEPTION_UNWIND) == 0


    def IS_TARGET_UNWIND(Flag):
        return Flag & EXCEPTION_TARGET_UNWIND


    EXCEPTION_MAXIMUM_PARAMETERS = 15  # maximum number of exception parameters

    # Exception record definition.
    _EXCEPTION_RECORD._fields_ = [
        ('ExceptionCode', DWORD),
        ('ExceptionFlags', DWORD),
        ('ExceptionRecord', POINTER(_EXCEPTION_RECORD)),
        ('ExceptionAddress', PVOID),
        ('NumberParameters', DWORD),
        ('ExceptionInformation', ULONG_PTR * EXCEPTION_MAXIMUM_PARAMETERS),
    ]

    PEXCEPTION_RECORD = POINTER(EXCEPTION_RECORD)

    _EXCEPTION_RECORD32._fields_ = [
        ('ExceptionCode', DWORD),
        ('ExceptionFlags', DWORD),
        ('ExceptionRecord', DWORD),
        ('ExceptionAddress', DWORD),
        ('NumberParameters', DWORD),
        ('ExceptionInformation', DWORD * EXCEPTION_MAXIMUM_PARAMETERS),
    ]

    _EXCEPTION_RECORD64._fields_ = [
        ('ExceptionCode', DWORD),
        ('ExceptionFlags', DWORD),
        ('ExceptionRecord', DWORD64),
        ('ExceptionAddress', DWORD64),
        ('NumberParameters', DWORD),
        ('ExceptionInformation', DWORD64 * EXCEPTION_MAXIMUM_PARAMETERS),
    ]

    # Typedef for pointer returned by exception_info()
    _EXCEPTION_POINTERS._fields_ = [
        ('ExceptionRecord', PEXCEPTION_RECORD),
        ('ContextRecord', PCONTEXT),
    ]

    # end_ntoshvp
    # end_wdm

    if defined(_IA64_):
        kernel32 = ctypes.windll.KERNEL32
        # NTSYSAPI
        # VOID
        # NTAPI
        # RtlUnwind2(
        # _In_opt_ FRAME_POINTERS TargetFrame,
        # _In_opt_ PVOID TargetIp,
        # _In_opt_ PEXCEPTION_RECORD ExceptionRecord,
        # _In_ PVOID ReturnValue,
        # _In_ PCONTEXT ContextRecord
        # );
        RtlUnwind2 = kernel32.RtlUnwind2
        RtlUnwind2.restype = VOID

    # END IF


    PACCESS_TOKEN = PVOID
    PSECURITY_DESCRIPTOR = PVOID
    PSID = PVOID
    PCLAIMS_BLOB = PVOID

    # //////////////////////////////////////////////////////////////////////
    #
    # //
    # ACCESS MASK     //
    # //
    # //////////////////////////////////////////////////////////////////////
    #
    # Define the access mask as a longword sized structure divided up
    # as
    # follows:
    # 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
    # 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    # + - - - - - - - - - - - - - - - + - - - - - - - - - - - - - - -
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    # | G | G | G | G | Res'd | A| StandardRights|  SpecificRights  |
    # | R | W | E | A| | S|   |      |
    # + - + - - - - - - - - - - - - - + - - - - - - - - - - - - - - -
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    # typedef struct _ACCESS_MASK {
    # WORD SpecificRights;
    # BYTE StandardRights;
    # BYTE AccessSystemAcl : 1;
    # BYTE Reserved : 3;
    # BYTE GenericAll : 1;
    # BYTE GenericExecute : 1;
    # BYTE GenericWrite : 1;
    # BYTE GenericRead : 1;
    # } ACCESS_MASK;
    # typedef ACCESS_MASK *PACCESS_MASK;
    # but to make life simple for programmer's we'll allow them to
    # specify
    # a desired access mask by simply OR'ing together mulitple single
    # rights
    # and treat an access mask as a DWORD. For example
    # DesiredAccess = DELETE | READ_CONTROL
    # So we'll declare ACCESS_MASK as DWORD
    # begin_wdm
    # begin_ntoshvp
    ACCESS_MASK = DWORD
    PACCESS_MASK = POINTER(ACCESS_MASK)

    # end_ntoshvp
    # begin_access
    # //////////////////////////////////////////////////////////////////////
    #
    # //
    # ACCESS TYPES     //
    # //
    # //////////////////////////////////////////////////////////////////////
    #
    # begin_wdm
    # The following are masks for the predefined standard access types
    DELETE = 0x00010000
    READ_CONTROL = 0x00020000
    WRITE_DAC = 0x00040000
    WRITE_OWNER = 0x00080000
    SYNCHRONIZE = 0x00100000
    STANDARD_RIGHTS_REQUIRED = 0x000F0000
    STANDARD_RIGHTS_READ = READ_CONTROL
    STANDARD_RIGHTS_WRITE = READ_CONTROL
    STANDARD_RIGHTS_EXECUTE = READ_CONTROL
    STANDARD_RIGHTS_ALL = 0x001F0000
    SPECIFIC_RIGHTS_ALL = 0x0000FFFF

    # AccessSystemAcl access type
    ACCESS_SYSTEM_SECURITY = 0x01000000

    # MaximumAllowed access type
    MAXIMUM_ALLOWED = 0x02000000

    # These are the generic rights.
    GENERIC_READ = 0x80000000
    GENERIC_WRITE = 0x40000000
    GENERIC_EXECUTE = 0x20000000
    GENERIC_ALL = 0x10000000

    # Define the generic mapping array. This is used to denote the
    # mapping of each generic access right to a specific access mask.
    _GENERIC_MAPPING._fields_ = [
        ('GenericRead', ACCESS_MASK),
        ('GenericWrite', ACCESS_MASK),
        ('GenericExecute', ACCESS_MASK),
        ('GenericAll', ACCESS_MASK),
    ]

    PGENERIC_MAPPING = POINTER(GENERIC_MAPPING)

    # //////////////////////////////////////////////////////////////////////
    #
    # //
    # LUID_AND_ATTRIBUTES     //
    # //
    # //////////////////////////////////////////////////////////////////////
    #
    from pyWinAPI.shared.pshpack4_h import *  # NOQA


    _LUID_AND_ATTRIBUTES._fields_ = [
        ('Luid', LUID),
        ('Attributes', DWORD),
    ]

    LUID_AND_ATTRIBUTES_ARRAY = LUID_AND_ATTRIBUTES * ANYSIZE_ARRAY
    PLUID_AND_ATTRIBUTES_ARRAY = POINTER(LUID_AND_ATTRIBUTES_ARRAY)

    from pyWinAPI.shared.poppack_h import *  # NOQA


    # //////////////////////////////////////////////////////////////////////
    #
    # //
    # Security Id  (SID)      //
    # //
    # //////////////////////////////////////////////////////////////////////
    #
    # Pictorially the structure of an SID is as follows:
    # 1 1 1 1 1 1
    # 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    # | SubAuthorityCount  | Reserved1 (SBZ)| Revision  |
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    # |    IdentifierAuthority[0]     |
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    # |    IdentifierAuthority[1]     |
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    # |    IdentifierAuthority[2]     |
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    # |           |
    # + - - - - - - - - SubAuthority[] - - - - - - - - - +
    # |           |
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    # begin_ntifs
    SID_IDENTIFIER_AUTHORITY_DEFINED = None

    if not defined(SID_IDENTIFIER_AUTHORITY_DEFINED):
        SID_IDENTIFIER_AUTHORITY_DEFINED = 1
        _SID_IDENTIFIER_AUTHORITY._fields_ = [
            ('Value', BYTE * 6),
        ]
    # END IF

    SID_DEFINED = None
    if not defined(SID_DEFINED):
        SID_DEFINED = 1

        _TEMP__SID = [
            ('Revision', BYTE),
            ('SubAuthorityCount', BYTE),
            ('IdentifierAuthority', SID_IDENTIFIER_AUTHORITY),
        ]

        if defined(MIDL_PASS):
            _TEMP__SID += [
                ('SubAuthority', DWORD * ctypes.sizeof(BYTE)),
            ]
        else:  # MIDL_PASS
            _TEMP__SID += [
                ('SubAuthority', DWORD * ANYSIZE_ARRAY),
            ]
        # END IF   MIDL_PASS
        _SID._fields_ = _TEMP__SID
    # END IF

    SID_REVISION = 1  # Current revision level
    SID_MAX_SUB_AUTHORITIES = 15
    SID_RECOMMENDED_SUB_AUTHORITIES = 1  # Will change to around 6

    # in a future release.
    if not defined(MIDL_PASS):
        SECURITY_MAX_SID_SIZE = (
            ctypes.sizeof(SID) -
            (
                ctypes.sizeof(DWORD) +
                (SID_MAX_SUB_AUTHORITIES * ctypes.sizeof(DWORD))
            )
        )


        def SECURITY_SID_SIZE(SubAuthorityCount_):
            return (
                ctypes.sizeof(SID) -
                ctypes.sizeof(DWORD) +
                SubAuthorityCount_ *
                ctypes.sizeof(DWORD)
            )

        # 2 (S - )
        # 4 (Rev(max: 255) - )
        # 15 (
        # If (Auth < 2^32): Auth(max:4294967295) -
        # Else:   0xAuth(max:FFFFFFFFFFFF) -
        # )
        # (11 * SID_MAX_SUB_AUTHORITIES) (SubN(max:4294967295) - )
        # 1 (NULL character)
        # = 187 (assuming SID_MAX_SUB_AUTHORITIES = 15)
        SECURITY_MAX_SID_STRING_CHARACTERS = (
            2 + 4 + 15 + (11 * SID_MAX_SUB_AUTHORITIES) + 1
        )
        # Union which can hold any valid sid.
        _SE_SID._fields_ = [
            ('Sid', SID),
            ('Buffer', BYTE * SECURITY_MAX_SID_SIZE),
        ]


    # END IF   MIDL_PASS

    class _SID_NAME_USE(ENUM):
        SidTypeUser = 1
        SidTypeGroup = 2
        SidTypeDomain = 3
        SidTypeAlias = 4
        SidTypeWellKnownGroup = 5
        SidTypeDeletedAccount = 6
        SidTypeInvalid = 7
        SidTypeUnknown = 8
        SidTypeComputer = 9
        SidTypeLabel = 10
        SidTypeLogonSession = 11


    SID_NAME_USE = _SID_NAME_USE
    PSID_NAME_USE = POINTER(_SID_NAME_USE)

    _TEMP__SID_AND_ATTRIBUTES = [
    ]

    if defined(MIDL_PASS):
        _TEMP__SID_AND_ATTRIBUTES += [
            ('Sid', PISID),
        ]
    else:  # MIDL_PASS
        _TEMP__SID_AND_ATTRIBUTES += [
            ('Sid', PSID),
        ]
    # END IF   MIDL_PASS
    _TEMP__SID_AND_ATTRIBUTES += [
        ('Attributes', DWORD),
    ]
    _SID_AND_ATTRIBUTES._fields_ = _TEMP__SID_AND_ATTRIBUTES

    SID_HASH_SIZE = 32

    SID_HASH_ENTRY = ULONG_PTR
    PSID_HASH_ENTRY = POINTER(ULONG_PTR)

    _SID_AND_ATTRIBUTES_HASH._fields_ = [
        ('SidCount', DWORD),
        ('SidAttr', PSID_AND_ATTRIBUTES),
        ('Hash', SID_HASH_ENTRY * SID_HASH_SIZE),
    ]

    # ///////////////////////////////////////////////////////////////////////////
    #
    # //
    # Universal well - known SIDs         //
    # //
    # Null SID    S - 1 - 0 - 0      //
    # World    S - 1 - 1 - 0      //
    # Local    S - 1 - 2 - 0      //
    # Creator Owner ID   S - 1 - 3 - 0      //
    # Creator Group ID   S - 1 - 3 - 1      //
    # Creator Owner Server ID S - 1 - 3 - 2      //
    # Creator Group Server ID S - 1 - 3 - 3      //
    # //
    # (Non - unique IDs)   S - 1 - 4      //
    # //
    # ///////////////////////////////////////////////////////////////////////////
    #
    SECURITY_NULL_SID_AUTHORITY = [0, 0, 0, 0, 0, 0]
    SECURITY_WORLD_SID_AUTHORITY = [0, 0, 0, 0, 0, 1]
    SECURITY_LOCAL_SID_AUTHORITY = [0, 0, 0, 0, 0, 2]
    SECURITY_CREATOR_SID_AUTHORITY = [0, 0, 0, 0, 0, 3]
    SECURITY_NON_UNIQUE_AUTHORITY = [0, 0, 0, 0, 0, 4]
    SECURITY_RESOURCE_MANAGER_AUTHORITY = [0, 0, 0, 0, 0, 9]
    SECURITY_NULL_RID = 0x00000000
    SECURITY_WORLD_RID = 0x00000000
    SECURITY_LOCAL_RID = 0x00000000
    SECURITY_LOCAL_LOGON_RID = 0x00000001
    SECURITY_CREATOR_OWNER_RID = 0x00000000
    SECURITY_CREATOR_GROUP_RID = 0x00000001
    SECURITY_CREATOR_OWNER_SERVER_RID = 0x00000002
    SECURITY_CREATOR_GROUP_SERVER_RID = 0x00000003
    SECURITY_CREATOR_OWNER_RIGHTS_RID = 0x00000004

    # /////////////////////////////////////////////////////////////////////////////
    #
    # //
    # NT well - known SIDs          //
    # //
    # NT Authority  S - 1 - 5        //
    # Dialup   S - 1 - 5 - 1       //
    # //
    # Network    S - 1 - 5 - 2       //
    # Batch    S - 1 - 5 - 3       //
    # Interactive   S - 1 - 5 - 4       //
    # (Logon IDs)   S - 1 - 5 - 5 - X - Y       //
    # Service    S - 1 - 5 - 6       //
    # AnonymousLogon  S - 1 - 5 - 7  (aka null logon session)  //
    # Proxy    S - 1 - 5 - 8       //
    # Enterprise DC (EDC)  S - 1 - 5 - 9
    # (aka domain controller account) //
    # Self    S - 1 - 5 - 10 (self RID)    //
    # Authenticated User S - 1 - 5 - 11 (Authenticated user somewhere)
    # //
    # Restricted Code  S - 1 - 5 - 12 (Running restricted code)  //
    # Terminal Server  S - 1 - 5 - 13 (Running on Terminal Server) //
    # Remote Logon  S - 1 - 5 - 14 (Remote Interactive Logon) //
    # This Organization  S - 1 - 5 - 15       //
    # //
    # IUser    S - 1 - 5 - 17
    # Local System  S - 1 - 5 - 18       //
    # Local Service   S - 1 - 5 - 19       //
    # Network Service  S - 1 - 5 - 20       //
    # //
    # (NT non - unique IDs)  S - 1 - 5 - 0x15 - ... (NT Domain Sids)
    # //
    # //
    # (Built - in domain)  S - 1 - 5 - 0x20      //
    # //
    # (Security Package IDs) S - 1 - 5 - 0x40      //
    # NTLM Authentication  S - 1 - 5 - 0x40 - 10      //
    # SChannel Authentication S - 1 - 5 - 0x40 - 14      //
    # Digest Authentication S - 1 - 5 - 0x40 - 21      //
    # //
    # Other Organization S - 1 - 5 - 1000
    # ( >= 1000 can not be filtered) //
    # //
    # //
    # NOTE: the relative identifier values (RIDs) determine which
    # security //
    # boundaries the SID is allowed to cross. Before adding new RIDs,
    # //
    # a determination needs to be made regarding which range they
    # should //
    # be added to in order to ensure proper "SID filtering"   //
    # //
    # /////////////////////////////////////////////////////////////////////////////
    #
    SECURITY_NT_AUTHORITY = [0, 0, 0, 0, 0, 5]  # ntifs
    SECURITY_DIALUP_RID = 0x00000001
    SECURITY_NETWORK_RID = 0x00000002
    SECURITY_BATCH_RID = 0x00000003
    SECURITY_INTERACTIVE_RID = 0x00000004
    SECURITY_LOGON_IDS_RID = 0x00000005
    SECURITY_LOGON_IDS_RID_COUNT = 3
    SECURITY_SERVICE_RID = 0x00000006
    SECURITY_ANONYMOUS_LOGON_RID = 0x00000007
    SECURITY_PROXY_RID = 0x00000008
    SECURITY_ENTERPRISE_CONTROLLERS_RID = 0x00000009
    SECURITY_SERVER_LOGON_RID = SECURITY_ENTERPRISE_CONTROLLERS_RID
    SECURITY_PRINCIPAL_SELF_RID = 0x0000000A
    SECURITY_AUTHENTICATED_USER_RID = 0x0000000B
    SECURITY_RESTRICTED_CODE_RID = 0x0000000C
    SECURITY_TERMINAL_SERVER_RID = 0x0000000D
    SECURITY_REMOTE_LOGON_RID = 0x0000000E
    SECURITY_THIS_ORGANIZATION_RID = 0x0000000F
    SECURITY_IUSER_RID = 0x00000011
    SECURITY_LOCAL_SYSTEM_RID = 0x00000012
    SECURITY_LOCAL_SERVICE_RID = 0x00000013
    SECURITY_NETWORK_SERVICE_RID = 0x00000014
    SECURITY_NT_NON_UNIQUE = 0x00000015
    SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT = 3
    SECURITY_ENTERPRISE_READONLY_CONTROLLERS_RID = 0x00000016
    SECURITY_BUILTIN_DOMAIN_RID = 0x00000020
    SECURITY_WRITE_RESTRICTED_CODE_RID = 0x00000021
    SECURITY_PACKAGE_BASE_RID = 0x00000040
    SECURITY_PACKAGE_RID_COUNT = 2
    SECURITY_PACKAGE_NTLM_RID = 0x0000000A
    SECURITY_PACKAGE_SCHANNEL_RID = 0x0000000E
    SECURITY_PACKAGE_DIGEST_RID = 0x00000015
    SECURITY_CRED_TYPE_BASE_RID = 0x00000041
    SECURITY_CRED_TYPE_RID_COUNT = 2
    SECURITY_CRED_TYPE_THIS_ORG_CERT_RID = 0x00000001
    SECURITY_MIN_BASE_RID = 0x00000050
    SECURITY_SERVICE_ID_BASE_RID = 0x00000050
    SECURITY_SERVICE_ID_RID_COUNT = 6
    SECURITY_RESERVED_ID_BASE_RID = 0x00000051
    SECURITY_APPPOOL_ID_BASE_RID = 0x00000052
    SECURITY_APPPOOL_ID_RID_COUNT = 6
    SECURITY_VIRTUALSERVER_ID_BASE_RID = 0x00000053
    SECURITY_VIRTUALSERVER_ID_RID_COUNT = 6
    SECURITY_USERMODEDRIVERHOST_ID_BASE_RID = 0x00000054
    SECURITY_USERMODEDRIVERHOST_ID_RID_COUNT = 6
    SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_BASE_RID = 0x00000055
    SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_RID_COUNT = 6
    SECURITY_WMIHOST_ID_BASE_RID = 0x00000056
    SECURITY_WMIHOST_ID_RID_COUNT = 6
    SECURITY_TASK_ID_BASE_RID = 0x00000057
    SECURITY_NFS_ID_BASE_RID = 0x00000058
    SECURITY_COM_ID_BASE_RID = 0x00000059
    SECURITY_WINDOW_MANAGER_BASE_RID = 0x0000005A
    SECURITY_RDV_GFX_BASE_RID = 0x0000005B
    SECURITY_DASHOST_ID_BASE_RID = 0x0000005C
    SECURITY_DASHOST_ID_RID_COUNT = 6
    SECURITY_USERMANAGER_ID_BASE_RID = 0x0000005D
    SECURITY_USERMANAGER_ID_RID_COUNT = 6
    SECURITY_WINRM_ID_BASE_RID = 0x0000005E
    SECURITY_WINRM_ID_RID_COUNT = 6
    SECURITY_CCG_ID_BASE_RID = 0x0000005F
    SECURITY_UMFD_BASE_RID = 0x00000060
    SECURITY_VIRTUALACCOUNT_ID_RID_COUNT = 6
    SECURITY_MAX_BASE_RID = 0x0000006F
    SECURITY_MAX_ALWAYS_FILTERED = 0x000003E7
    SECURITY_MIN_NEVER_FILTERED = 0x000003E8
    SECURITY_OTHER_ORGANIZATION_RID = 0x000003E8

    # Service SID type RIDs are in the range 0x50- 0x6F. Therefore, we
    # are giving the next available RID to Windows Mobile team.
    SECURITY_WINDOWSMOBILE_ID_BASE_RID = 0x00000070

    # Installer Capability Group Sid related. Currently Base RID is
    # same as LOCAL DOMAIN.
    SECURITY_INSTALLER_GROUP_CAPABILITY_BASE = 0x20
    SECURITY_INSTALLER_GROUP_CAPABILITY_RID_COUNT = 9

    # Note: This is because the App Capability Rid is S - 1 - 15 - 3 -
    # 1024 - ...
    # whereas the service group rid is  S - 1 - 5 - 32 - ...
    # The number of RIDs from hash (8) are the same for both
    SECURITY_INSTALLER_CAPABILITY_RID_COUNT = 10

    # Well - known group for local accounts
    SECURITY_LOCAL_ACCOUNT_RID = 0x00000071
    SECURITY_LOCAL_ACCOUNT_AND_ADMIN_RID = 0x00000072

    # ///////////////////////////////////////////////////////////////////////////
    #
    # //
    # well - known domain relative sub - authority values (RIDs)...
    # //
    # //
    # ///////////////////////////////////////////////////////////////////////////
    #
    DOMAIN_GROUP_RID_AUTHORIZATION_DATA_IS_COMPOUNDED = 0x000001F0
    DOMAIN_GROUP_RID_AUTHORIZATION_DATA_CONTAINS_CLAIMS = 0x000001F1
    DOMAIN_GROUP_RID_ENTERPRISE_READONLY_DOMAIN_CONTROLLERS = (
        0x000001F2
    )
    FOREST_USER_RID_MAX = 0x000001F3

    # Well - known users ...
    DOMAIN_USER_RID_ADMIN = 0x000001F4
    DOMAIN_USER_RID_GUEST = 0x000001F5
    DOMAIN_USER_RID_KRBTGT = 0x000001F6
    DOMAIN_USER_RID_DEFAULT_ACCOUNT = 0x000001F7
    DOMAIN_USER_RID_WDAG_ACCOUNT = 0x000001F8
    DOMAIN_USER_RID_MAX = 0x000003E7

    # well - known groups ...
    DOMAIN_GROUP_RID_ADMINS = 0x00000200
    DOMAIN_GROUP_RID_USERS = 0x00000201
    DOMAIN_GROUP_RID_GUESTS = 0x00000202
    DOMAIN_GROUP_RID_COMPUTERS = 0x00000203
    DOMAIN_GROUP_RID_CONTROLLERS = 0x00000204
    DOMAIN_GROUP_RID_CERT_ADMINS = 0x00000205
    DOMAIN_GROUP_RID_SCHEMA_ADMINS = 0x00000206
    DOMAIN_GROUP_RID_ENTERPRISE_ADMINS = 0x00000207
    DOMAIN_GROUP_RID_POLICY_ADMINS = 0x00000208
    DOMAIN_GROUP_RID_READONLY_CONTROLLERS = 0x00000209
    DOMAIN_GROUP_RID_CLONEABLE_CONTROLLERS = 0x0000020A
    DOMAIN_GROUP_RID_CDC_RESERVED = 0x0000020C
    DOMAIN_GROUP_RID_PROTECTED_USERS = 0x0000020D
    DOMAIN_GROUP_RID_KEY_ADMINS = 0x0000020E
    DOMAIN_GROUP_RID_ENTERPRISE_KEY_ADMINS = 0x0000020F

    # well - known aliases ...
    DOMAIN_ALIAS_RID_ADMINS = 0x00000220
    DOMAIN_ALIAS_RID_USERS = 0x00000221
    DOMAIN_ALIAS_RID_GUESTS = 0x00000222
    DOMAIN_ALIAS_RID_POWER_USERS = 0x00000223
    DOMAIN_ALIAS_RID_ACCOUNT_OPS = 0x00000224
    DOMAIN_ALIAS_RID_SYSTEM_OPS = 0x00000225
    DOMAIN_ALIAS_RID_PRINT_OPS = 0x00000226
    DOMAIN_ALIAS_RID_BACKUP_OPS = 0x00000227
    DOMAIN_ALIAS_RID_REPLICATOR = 0x00000228
    DOMAIN_ALIAS_RID_RAS_SERVERS = 0x00000229
    DOMAIN_ALIAS_RID_PREW2KCOMPACCESS = 0x0000022A
    DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS = 0x0000022B
    DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS = 0x0000022C
    DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS = 0x0000022D
    DOMAIN_ALIAS_RID_MONITORING_USERS = 0x0000022E
    DOMAIN_ALIAS_RID_LOGGING_USERS = 0x0000022F
    DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS = 0x00000230
    DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS = 0x00000231
    DOMAIN_ALIAS_RID_DCOM_USERS = 0x00000232
    DOMAIN_ALIAS_RID_IUSERS = 0x00000238
    DOMAIN_ALIAS_RID_CRYPTO_OPERATORS = 0x00000239
    DOMAIN_ALIAS_RID_CACHEABLE_PRINCIPALS_GROUP = 0x0000023B
    DOMAIN_ALIAS_RID_NON_CACHEABLE_PRINCIPALS_GROUP = 0x0000023C
    DOMAIN_ALIAS_RID_EVENT_LOG_READERS_GROUP = 0x0000023D
    DOMAIN_ALIAS_RID_CERTSVC_DCOM_ACCESS_GROUP = 0x0000023E
    DOMAIN_ALIAS_RID_RDS_REMOTE_ACCESS_SERVERS = 0x0000023F
    DOMAIN_ALIAS_RID_RDS_ENDPOINT_SERVERS = 0x00000240
    DOMAIN_ALIAS_RID_RDS_MANAGEMENT_SERVERS = 0x00000241
    DOMAIN_ALIAS_RID_HYPER_V_ADMINS = 0x00000242
    DOMAIN_ALIAS_RID_ACCESS_CONTROL_ASSISTANCE_OPS = 0x00000243
    DOMAIN_ALIAS_RID_REMOTE_MANAGEMENT_USERS = 0x00000244
    DOMAIN_ALIAS_RID_DEFAULT_ACCOUNT = 0x00000245
    DOMAIN_ALIAS_RID_STORAGE_REPLICA_ADMINS = 0x00000246
    DOMAIN_ALIAS_RID_DEVICE_OWNERS = 0x00000247

    # Application Package Authority.
    SECURITY_APP_PACKAGE_AUTHORITY = [0, 0, 0, 0, 0, 15]
    SECURITY_APP_PACKAGE_BASE_RID = 0x00000002
    SECURITY_BUILTIN_APP_PACKAGE_RID_COUNT = 2
    SECURITY_APP_PACKAGE_RID_COUNT = 8
    SECURITY_CAPABILITY_BASE_RID = 0x00000003
    SECURITY_CAPABILITY_APP_RID = 0x000000400
    SECURITY_BUILTIN_CAPABILITY_RID_COUNT = 2
    SECURITY_CAPABILITY_RID_COUNT = 5
    SECURITY_PARENT_PACKAGE_RID_COUNT = SECURITY_APP_PACKAGE_RID_COUNT
    SECURITY_CHILD_PACKAGE_RID_COUNT = 12

    # Built - in Packages.
    SECURITY_BUILTIN_PACKAGE_ANY_PACKAGE = 0x00000001
    SECURITY_BUILTIN_PACKAGE_ANY_RESTRICTED_PACKAGE = 0x00000002

    # Built - in Capabilities.
    SECURITY_CAPABILITY_INTERNET_CLIENT = 0x00000001
    SECURITY_CAPABILITY_INTERNET_CLIENT_SERVER = 0x00000002
    SECURITY_CAPABILITY_PRIVATE_NETWORK_CLIENT_SERVER = 0x00000003
    SECURITY_CAPABILITY_PICTURES_LIBRARY = 0x00000004
    SECURITY_CAPABILITY_VIDEOS_LIBRARY = 0x00000005
    SECURITY_CAPABILITY_MUSIC_LIBRARY = 0x00000006
    SECURITY_CAPABILITY_DOCUMENTS_LIBRARY = 0x00000007
    SECURITY_CAPABILITY_ENTERPRISE_AUTHENTICATION = 0x00000008
    SECURITY_CAPABILITY_SHARED_USER_CERTIFICATES = 0x00000009
    SECURITY_CAPABILITY_REMOVABLE_STORAGE = 0x0000000A
    SECURITY_CAPABILITY_APPOINTMENTS = 0x0000000B
    SECURITY_CAPABILITY_CONTACTS = 0x0000000C
    SECURITY_CAPABILITY_INTERNET_EXPLORER = 0x00001000

    # Mandatory Label Authority.
    SECURITY_MANDATORY_LABEL_AUTHORITY = [0, 0, 0, 0, 0, 16]
    SECURITY_MANDATORY_UNTRUSTED_RID = 0x00000000
    SECURITY_MANDATORY_LOW_RID = 0x00001000
    SECURITY_MANDATORY_MEDIUM_RID = 0x00002000
    SECURITY_MANDATORY_MEDIUM_PLUS_RID = (
        SECURITY_MANDATORY_MEDIUM_RID + 0x100
    )
    SECURITY_MANDATORY_HIGH_RID = 0x00003000
    SECURITY_MANDATORY_SYSTEM_RID = 0x00004000
    SECURITY_MANDATORY_PROTECTED_PROCESS_RID = 0x00005000

    # SECURITY_MANDATORY_MAXIMUM_USER_RID is the highest RID that
    # can be set by a usermode caller.
    SECURITY_MANDATORY_MAXIMUM_USER_RID = SECURITY_MANDATORY_SYSTEM_RID


    def MANDATORY_LEVEL_TO_MANDATORY_RID(IL):
        return IL * 0x1000


    SECURITY_SCOPED_POLICY_ID_AUTHORITY = [0, 0, 0, 0, 0, 17]

    # Authentication Authority
    SECURITY_AUTHENTICATION_AUTHORITY = [0, 0, 0, 0, 0, 18]
    SECURITY_AUTHENTICATION_AUTHORITY_RID_COUNT = 1
    SECURITY_AUTHENTICATION_AUTHORITY_ASSERTED_RID = 0x00000001
    SECURITY_AUTHENTICATION_SERVICE_ASSERTED_RID = 0x00000002
    SECURITY_AUTHENTICATION_FRESH_KEY_AUTH_RID = 0x00000003
    SECURITY_AUTHENTICATION_KEY_TRUST_RID = 0x00000004
    SECURITY_AUTHENTICATION_KEY_PROPERTY_MFA_RID = 0x00000005
    SECURITY_AUTHENTICATION_KEY_PROPERTY_ATTESTATION_RID = 0x00000006

    # Process Trust Authority
    SECURITY_PROCESS_TRUST_AUTHORITY = [0, 0, 0, 0, 0, 19]
    SECURITY_PROCESS_TRUST_AUTHORITY_RID_COUNT = 2
    SECURITY_PROCESS_PROTECTION_TYPE_FULL_RID = 0x00000400
    SECURITY_PROCESS_PROTECTION_TYPE_LITE_RID = 0x00000200
    SECURITY_PROCESS_PROTECTION_TYPE_NONE_RID = 0x00000000
    SECURITY_PROCESS_PROTECTION_LEVEL_WINTCB_RID = 0x00002000
    SECURITY_PROCESS_PROTECTION_LEVEL_WINDOWS_RID = 0x00001000
    SECURITY_PROCESS_PROTECTION_LEVEL_APP_RID = 0x00000800
    SECURITY_PROCESS_PROTECTION_LEVEL_ANTIMALWARE_RID = 0x00000600
    SECURITY_PROCESS_PROTECTION_LEVEL_AUTHENTICODE_RID = 0x00000400
    SECURITY_PROCESS_PROTECTION_LEVEL_NONE_RID = 0x00000000

    # Trusted Installer RIDs
    SECURITY_TRUSTED_INSTALLER_RID1 = 956008885
    SECURITY_TRUSTED_INSTALLER_RID2 = 3418522649
    SECURITY_TRUSTED_INSTALLER_RID3 = 1831038044
    SECURITY_TRUSTED_INSTALLER_RID4 = 1853292631
    SECURITY_TRUSTED_INSTALLER_RID5 = 2271478464


    # Well known SID definitions for lookup.
    class WELL_KNOWN_SID_TYPE(ENUM):
        WinNullSid = 0
        WinWorldSid = 1
        WinLocalSid = 2
        WinCreatorOwnerSid = 3
        WinCreatorGroupSid = 4
        WinCreatorOwnerServerSid = 5
        WinCreatorGroupServerSid = 6
        WinNtAuthoritySid = 7
        WinDialupSid = 8
        WinNetworkSid = 9
        WinBatchSid = 10
        WinInteractiveSid = 11
        WinServiceSid = 12
        WinAnonymousSid = 13
        WinProxySid = 14
        WinEnterpriseControllersSid = 15
        WinSelfSid = 16
        WinAuthenticatedUserSid = 17
        WinRestrictedCodeSid = 18
        WinTerminalServerSid = 19
        WinRemoteLogonIdSid = 20
        WinLogonIdsSid = 21
        WinLocalSystemSid = 22
        WinLocalServiceSid = 23
        WinNetworkServiceSid = 24
        WinBuiltinDomainSid = 25
        WinBuiltinAdministratorsSid = 26
        WinBuiltinUsersSid = 27
        WinBuiltinGuestsSid = 28
        WinBuiltinPowerUsersSid = 29
        WinBuiltinAccountOperatorsSid = 30
        WinBuiltinSystemOperatorsSid = 31
        WinBuiltinPrintOperatorsSid = 32
        WinBuiltinBackupOperatorsSid = 33
        WinBuiltinReplicatorSid = 34
        WinBuiltinPreWindows2000CompatibleAccessSid = 35
        WinBuiltinRemoteDesktopUsersSid = 36
        WinBuiltinNetworkConfigurationOperatorsSid = 37
        WinAccountAdministratorSid = 38
        WinAccountGuestSid = 39
        WinAccountKrbtgtSid = 40
        WinAccountDomainAdminsSid = 41
        WinAccountDomainUsersSid = 42
        WinAccountDomainGuestsSid = 43
        WinAccountComputersSid = 44
        WinAccountControllersSid = 45
        WinAccountCertAdminsSid = 46
        WinAccountSchemaAdminsSid = 47
        WinAccountEnterpriseAdminsSid = 48
        WinAccountPolicyAdminsSid = 49
        WinAccountRasAndIasServersSid = 50
        WinNTLMAuthenticationSid = 51
        WinDigestAuthenticationSid = 52
        WinSChannelAuthenticationSid = 53
        WinThisOrganizationSid = 54
        WinOtherOrganizationSid = 55
        WinBuiltinIncomingForestTrustBuildersSid = 56
        WinBuiltinPerfMonitoringUsersSid = 57
        WinBuiltinPerfLoggingUsersSid = 58
        WinBuiltinAuthorizationAccessSid = 59
        WinBuiltinTerminalServerLicenseServersSid = 60
        WinBuiltinDCOMUsersSid = 61
        WinBuiltinIUsersSid = 62
        WinIUserSid = 63
        WinBuiltinCryptoOperatorsSid = 64
        WinUntrustedLabelSid = 65
        WinLowLabelSid = 66
        WinMediumLabelSid = 67
        WinHighLabelSid = 68
        WinSystemLabelSid = 69
        WinWriteRestrictedCodeSid = 70
        WinCreatorOwnerRightsSid = 71
        WinCacheablePrincipalsGroupSid = 72
        WinNonCacheablePrincipalsGroupSid = 73
        WinEnterpriseReadonlyControllersSid = 74
        WinAccountReadonlyControllersSid = 75
        WinBuiltinEventLogReadersGroup = 76
        WinNewEnterpriseReadonlyControllersSid = 77
        WinBuiltinCertSvcDComAccessGroup = 78
        WinMediumPlusLabelSid = 79
        WinLocalLogonSid = 80
        WinConsoleLogonSid = 81
        WinThisOrganizationCertificateSid = 82
        WinApplicationPackageAuthoritySid = 83
        WinBuiltinAnyPackageSid = 84
        WinCapabilityInternetClientSid = 85
        WinCapabilityInternetClientServerSid = 86
        WinCapabilityPrivateNetworkClientServerSid = 87
        WinCapabilityPicturesLibrarySid = 88
        WinCapabilityVideosLibrarySid = 89
        WinCapabilityMusicLibrarySid = 90
        WinCapabilityDocumentsLibrarySid = 91
        WinCapabilitySharedUserCertificatesSid = 92
        WinCapabilityEnterpriseAuthenticationSid = 93
        WinCapabilityRemovableStorageSid = 94
        WinBuiltinRDSRemoteAccessServersSid = 95
        WinBuiltinRDSEndpointServersSid = 96
        WinBuiltinRDSManagementServersSid = 97
        WinUserModeDriversSid = 98
        WinBuiltinHyperVAdminsSid = 99
        WinAccountCloneableControllersSid = 100
        WinBuiltinAccessControlAssistanceOperatorsSid = 101
        WinBuiltinRemoteManagementUsersSid = 102
        WinAuthenticationAuthorityAssertedSid = 103
        WinAuthenticationServiceAssertedSid = 104
        WinLocalAccountSid = 105
        WinLocalAccountAndAdministratorSid = 106
        WinAccountProtectedUsersSid = 107
        WinCapabilityAppointmentsSid = 108
        WinCapabilityContactsSid = 109
        WinAccountDefaultSystemManagedSid = 110
        WinBuiltinDefaultSystemManagedGroupSid = 111
        WinBuiltinStorageReplicaAdminsSid = 112
        WinAccountKeyAdminsSid = 113
        WinAccountEnterpriseKeyAdminsSid = 114
        WinAuthenticationKeyTrustSid = 115
        WinAuthenticationKeyPropertyMFASid = 116
        WinAuthenticationKeyPropertyAttestationSid = 117
        WinAuthenticationFreshKeyAuthSid = 118
        WinBuiltinDeviceOwnersSid = 119


    WinNullSid = WELL_KNOWN_SID_TYPE.WinNullSid
    WinWorldSid = WELL_KNOWN_SID_TYPE.WinWorldSid
    WinLocalSid = WELL_KNOWN_SID_TYPE.WinLocalSid
    WinCreatorOwnerSid = WELL_KNOWN_SID_TYPE.WinCreatorOwnerSid
    WinCreatorGroupSid = WELL_KNOWN_SID_TYPE.WinCreatorGroupSid
    WinCreatorOwnerServerSid = WELL_KNOWN_SID_TYPE.WinCreatorOwnerServerSid
    WinCreatorGroupServerSid = WELL_KNOWN_SID_TYPE.WinCreatorGroupServerSid
    WinNtAuthoritySid = WELL_KNOWN_SID_TYPE.WinNtAuthoritySid
    WinDialupSid = WELL_KNOWN_SID_TYPE.WinDialupSid
    WinNetworkSid = WELL_KNOWN_SID_TYPE.WinNetworkSid
    WinBatchSid = WELL_KNOWN_SID_TYPE.WinBatchSid
    WinInteractiveSid = WELL_KNOWN_SID_TYPE.WinInteractiveSid
    WinServiceSid = WELL_KNOWN_SID_TYPE.WinServiceSid
    WinAnonymousSid = WELL_KNOWN_SID_TYPE.WinAnonymousSid
    WinProxySid = WELL_KNOWN_SID_TYPE.WinProxySid
    WinEnterpriseControllersSid = WELL_KNOWN_SID_TYPE.WinEnterpriseControllersSid
    WinSelfSid = WELL_KNOWN_SID_TYPE.WinSelfSid
    WinAuthenticatedUserSid = WELL_KNOWN_SID_TYPE.WinAuthenticatedUserSid
    WinRestrictedCodeSid = WELL_KNOWN_SID_TYPE.WinRestrictedCodeSid
    WinTerminalServerSid = WELL_KNOWN_SID_TYPE.WinTerminalServerSid
    WinRemoteLogonIdSid = WELL_KNOWN_SID_TYPE.WinRemoteLogonIdSid
    WinLogonIdsSid = WELL_KNOWN_SID_TYPE.WinLogonIdsSid
    WinLocalSystemSid = WELL_KNOWN_SID_TYPE.WinLocalSystemSid
    WinLocalServiceSid = WELL_KNOWN_SID_TYPE.WinLocalServiceSid
    WinNetworkServiceSid = WELL_KNOWN_SID_TYPE.WinNetworkServiceSid
    WinBuiltinDomainSid = WELL_KNOWN_SID_TYPE.WinBuiltinDomainSid
    WinBuiltinAdministratorsSid = WELL_KNOWN_SID_TYPE.WinBuiltinAdministratorsSid
    WinBuiltinUsersSid = WELL_KNOWN_SID_TYPE.WinBuiltinUsersSid
    WinBuiltinGuestsSid = WELL_KNOWN_SID_TYPE.WinBuiltinGuestsSid
    WinBuiltinPowerUsersSid = WELL_KNOWN_SID_TYPE.WinBuiltinPowerUsersSid
    WinBuiltinAccountOperatorsSid = WELL_KNOWN_SID_TYPE.WinBuiltinAccountOperatorsSid
    WinBuiltinSystemOperatorsSid = WELL_KNOWN_SID_TYPE.WinBuiltinSystemOperatorsSid
    WinBuiltinPrintOperatorsSid = WELL_KNOWN_SID_TYPE.WinBuiltinPrintOperatorsSid
    WinBuiltinBackupOperatorsSid = WELL_KNOWN_SID_TYPE.WinBuiltinBackupOperatorsSid
    WinBuiltinReplicatorSid = WELL_KNOWN_SID_TYPE.WinBuiltinReplicatorSid
    WinBuiltinPreWindows2000CompatibleAccessSid = WELL_KNOWN_SID_TYPE.WinBuiltinPreWindows2000CompatibleAccessSid
    WinBuiltinRemoteDesktopUsersSid = WELL_KNOWN_SID_TYPE.WinBuiltinRemoteDesktopUsersSid
    WinBuiltinNetworkConfigurationOperatorsSid = WELL_KNOWN_SID_TYPE.WinBuiltinNetworkConfigurationOperatorsSid
    WinAccountAdministratorSid = WELL_KNOWN_SID_TYPE.WinAccountAdministratorSid
    WinAccountGuestSid = WELL_KNOWN_SID_TYPE.WinAccountGuestSid
    WinAccountKrbtgtSid = WELL_KNOWN_SID_TYPE.WinAccountKrbtgtSid
    WinAccountDomainAdminsSid = WELL_KNOWN_SID_TYPE.WinAccountDomainAdminsSid
    WinAccountDomainUsersSid = WELL_KNOWN_SID_TYPE.WinAccountDomainUsersSid
    WinAccountDomainGuestsSid = WELL_KNOWN_SID_TYPE.WinAccountDomainGuestsSid
    WinAccountComputersSid = WELL_KNOWN_SID_TYPE.WinAccountComputersSid
    WinAccountControllersSid = WELL_KNOWN_SID_TYPE.WinAccountControllersSid
    WinAccountCertAdminsSid = WELL_KNOWN_SID_TYPE.WinAccountCertAdminsSid
    WinAccountSchemaAdminsSid = WELL_KNOWN_SID_TYPE.WinAccountSchemaAdminsSid
    WinAccountEnterpriseAdminsSid = WELL_KNOWN_SID_TYPE.WinAccountEnterpriseAdminsSid
    WinAccountPolicyAdminsSid = WELL_KNOWN_SID_TYPE.WinAccountPolicyAdminsSid
    WinAccountRasAndIasServersSid = WELL_KNOWN_SID_TYPE.WinAccountRasAndIasServersSid
    WinNTLMAuthenticationSid = WELL_KNOWN_SID_TYPE.WinNTLMAuthenticationSid
    WinDigestAuthenticationSid = WELL_KNOWN_SID_TYPE.WinDigestAuthenticationSid
    WinSChannelAuthenticationSid = WELL_KNOWN_SID_TYPE.WinSChannelAuthenticationSid
    WinThisOrganizationSid = WELL_KNOWN_SID_TYPE.WinThisOrganizationSid
    WinOtherOrganizationSid = WELL_KNOWN_SID_TYPE.WinOtherOrganizationSid
    WinBuiltinIncomingForestTrustBuildersSid = WELL_KNOWN_SID_TYPE.WinBuiltinIncomingForestTrustBuildersSid
    WinBuiltinPerfMonitoringUsersSid = WELL_KNOWN_SID_TYPE.WinBuiltinPerfMonitoringUsersSid
    WinBuiltinPerfLoggingUsersSid = WELL_KNOWN_SID_TYPE.WinBuiltinPerfLoggingUsersSid
    WinBuiltinAuthorizationAccessSid = WELL_KNOWN_SID_TYPE.WinBuiltinAuthorizationAccessSid
    WinBuiltinTerminalServerLicenseServersSid = WELL_KNOWN_SID_TYPE.WinBuiltinTerminalServerLicenseServersSid
    WinBuiltinDCOMUsersSid = WELL_KNOWN_SID_TYPE.WinBuiltinDCOMUsersSid
    WinBuiltinIUsersSid = WELL_KNOWN_SID_TYPE.WinBuiltinIUsersSid
    WinIUserSid = WELL_KNOWN_SID_TYPE.WinIUserSid
    WinBuiltinCryptoOperatorsSid = WELL_KNOWN_SID_TYPE.WinBuiltinCryptoOperatorsSid
    WinUntrustedLabelSid = WELL_KNOWN_SID_TYPE.WinUntrustedLabelSid
    WinLowLabelSid = WELL_KNOWN_SID_TYPE.WinLowLabelSid
    WinMediumLabelSid = WELL_KNOWN_SID_TYPE.WinMediumLabelSid
    WinHighLabelSid = WELL_KNOWN_SID_TYPE.WinHighLabelSid
    WinSystemLabelSid = WELL_KNOWN_SID_TYPE.WinSystemLabelSid
    WinWriteRestrictedCodeSid = WELL_KNOWN_SID_TYPE.WinWriteRestrictedCodeSid
    WinCreatorOwnerRightsSid = WELL_KNOWN_SID_TYPE.WinCreatorOwnerRightsSid
    WinCacheablePrincipalsGroupSid = WELL_KNOWN_SID_TYPE.WinCacheablePrincipalsGroupSid
    WinNonCacheablePrincipalsGroupSid = WELL_KNOWN_SID_TYPE.WinNonCacheablePrincipalsGroupSid
    WinEnterpriseReadonlyControllersSid = WELL_KNOWN_SID_TYPE.WinEnterpriseReadonlyControllersSid
    WinAccountReadonlyControllersSid = WELL_KNOWN_SID_TYPE.WinAccountReadonlyControllersSid
    WinBuiltinEventLogReadersGroup = WELL_KNOWN_SID_TYPE.WinBuiltinEventLogReadersGroup
    WinNewEnterpriseReadonlyControllersSid = WELL_KNOWN_SID_TYPE.WinNewEnterpriseReadonlyControllersSid
    WinBuiltinCertSvcDComAccessGroup = WELL_KNOWN_SID_TYPE.WinBuiltinCertSvcDComAccessGroup
    WinMediumPlusLabelSid = WELL_KNOWN_SID_TYPE.WinMediumPlusLabelSid
    WinLocalLogonSid = WELL_KNOWN_SID_TYPE.WinLocalLogonSid
    WinConsoleLogonSid = WELL_KNOWN_SID_TYPE.WinConsoleLogonSid
    WinThisOrganizationCertificateSid = WELL_KNOWN_SID_TYPE.WinThisOrganizationCertificateSid
    WinApplicationPackageAuthoritySid = WELL_KNOWN_SID_TYPE.WinApplicationPackageAuthoritySid
    WinBuiltinAnyPackageSid = WELL_KNOWN_SID_TYPE.WinBuiltinAnyPackageSid
    WinCapabilityInternetClientSid = WELL_KNOWN_SID_TYPE.WinCapabilityInternetClientSid
    WinCapabilityInternetClientServerSid = WELL_KNOWN_SID_TYPE.WinCapabilityInternetClientServerSid
    WinCapabilityPrivateNetworkClientServerSid = WELL_KNOWN_SID_TYPE.WinCapabilityPrivateNetworkClientServerSid
    WinCapabilityPicturesLibrarySid = WELL_KNOWN_SID_TYPE.WinCapabilityPicturesLibrarySid
    WinCapabilityVideosLibrarySid = WELL_KNOWN_SID_TYPE.WinCapabilityVideosLibrarySid
    WinCapabilityMusicLibrarySid = WELL_KNOWN_SID_TYPE.WinCapabilityMusicLibrarySid
    WinCapabilityDocumentsLibrarySid = WELL_KNOWN_SID_TYPE.WinCapabilityDocumentsLibrarySid
    WinCapabilitySharedUserCertificatesSid = WELL_KNOWN_SID_TYPE.WinCapabilitySharedUserCertificatesSid
    WinCapabilityEnterpriseAuthenticationSid = WELL_KNOWN_SID_TYPE.WinCapabilityEnterpriseAuthenticationSid
    WinCapabilityRemovableStorageSid = WELL_KNOWN_SID_TYPE.WinCapabilityRemovableStorageSid
    WinBuiltinRDSRemoteAccessServersSid = WELL_KNOWN_SID_TYPE.WinBuiltinRDSRemoteAccessServersSid
    WinBuiltinRDSEndpointServersSid = WELL_KNOWN_SID_TYPE.WinBuiltinRDSEndpointServersSid
    WinBuiltinRDSManagementServersSid = WELL_KNOWN_SID_TYPE.WinBuiltinRDSManagementServersSid
    WinUserModeDriversSid = WELL_KNOWN_SID_TYPE.WinUserModeDriversSid
    WinBuiltinHyperVAdminsSid = WELL_KNOWN_SID_TYPE.WinBuiltinHyperVAdminsSid
    WinAccountCloneableControllersSid = WELL_KNOWN_SID_TYPE.WinAccountCloneableControllersSid
    WinBuiltinAccessControlAssistanceOperatorsSid = WELL_KNOWN_SID_TYPE.WinBuiltinAccessControlAssistanceOperatorsSid
    WinBuiltinRemoteManagementUsersSid = WELL_KNOWN_SID_TYPE.WinBuiltinRemoteManagementUsersSid
    WinAuthenticationAuthorityAssertedSid = WELL_KNOWN_SID_TYPE.WinAuthenticationAuthorityAssertedSid
    WinAuthenticationServiceAssertedSid = WELL_KNOWN_SID_TYPE.WinAuthenticationServiceAssertedSid
    WinLocalAccountSid = WELL_KNOWN_SID_TYPE.WinLocalAccountSid
    WinLocalAccountAndAdministratorSid = WELL_KNOWN_SID_TYPE.WinLocalAccountAndAdministratorSid
    WinAccountProtectedUsersSid = WELL_KNOWN_SID_TYPE.WinAccountProtectedUsersSid
    WinCapabilityAppointmentsSid = WELL_KNOWN_SID_TYPE.WinCapabilityAppointmentsSid
    WinCapabilityContactsSid = WELL_KNOWN_SID_TYPE.WinCapabilityContactsSid
    WinAccountDefaultSystemManagedSid = WELL_KNOWN_SID_TYPE.WinAccountDefaultSystemManagedSid
    WinBuiltinDefaultSystemManagedGroupSid = WELL_KNOWN_SID_TYPE.WinBuiltinDefaultSystemManagedGroupSid
    WinBuiltinStorageReplicaAdminsSid = WELL_KNOWN_SID_TYPE.WinBuiltinStorageReplicaAdminsSid
    WinAccountKeyAdminsSid = WELL_KNOWN_SID_TYPE.WinAccountKeyAdminsSid
    WinAccountEnterpriseKeyAdminsSid = WELL_KNOWN_SID_TYPE.WinAccountEnterpriseKeyAdminsSid
    WinAuthenticationKeyTrustSid = WELL_KNOWN_SID_TYPE.WinAuthenticationKeyTrustSid
    WinAuthenticationKeyPropertyMFASid = WELL_KNOWN_SID_TYPE.WinAuthenticationKeyPropertyMFASid
    WinAuthenticationKeyPropertyAttestationSid = WELL_KNOWN_SID_TYPE.WinAuthenticationKeyPropertyAttestationSid
    WinAuthenticationFreshKeyAuthSid = WELL_KNOWN_SID_TYPE.WinAuthenticationFreshKeyAuthSid
    WinBuiltinDeviceOwnersSid = WELL_KNOWN_SID_TYPE.WinBuiltinDeviceOwnersSid

    # Allocate the System Luid. The first 1000 LUIDs are reserved.
    # Use 999 here (0x3e7 = 999)
    SYSTEM_LUID = [0x3E7, 0x0]
    ANONYMOUS_LOGON_LUID = [0x3E6, 0x0]
    LOCALSERVICE_LUID = [0x3E5, 0x0]
    NETWORKSERVICE_LUID = [0x3E4, 0x0]
    IUSER_LUID = [0x3E3, 0x0]

    # end_ntifs
    # //////////////////////////////////////////////////////////////////////
    #
    # //
    # User and Group related SID attributes  //
    # //
    # //////////////////////////////////////////////////////////////////////
    #
    # Group attributes
    SE_GROUP_MANDATORY = 0x00000001
    SE_GROUP_ENABLED_BY_DEFAULT = 0x00000002
    SE_GROUP_ENABLED = 0x00000004
    SE_GROUP_OWNER = 0x00000008
    SE_GROUP_USE_FOR_DENY_ONLY = 0x00000010
    SE_GROUP_INTEGRITY = 0x00000020
    SE_GROUP_INTEGRITY_ENABLED = 0x00000040
    SE_GROUP_LOGON_ID = 0xC0000000
    SE_GROUP_RESOURCE = 0x20000000
    SE_GROUP_VALID_ATTRIBUTES = (
        SE_GROUP_MANDATORY |
        SE_GROUP_ENABLED_BY_DEFAULT |
        SE_GROUP_ENABLED |
        SE_GROUP_OWNER |
        SE_GROUP_USE_FOR_DENY_ONLY |
        SE_GROUP_LOGON_ID |
        SE_GROUP_RESOURCE |
        SE_GROUP_INTEGRITY |
        SE_GROUP_INTEGRITY_ENABLED
    )

    # User attributes
    # (None yet defined.)
    # //////////////////////////////////////////////////////////////////////
    #
    # //
    # ACL and ACE     //
    # //
    # //////////////////////////////////////////////////////////////////////
    #
    # Define an ACL and the ACE format. The structure of an ACL header
    # followed by one or more ACEs. Pictorally the structure of an ACL
    # header
    # is as follows:
    # 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
    # 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # + - - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - +
    # |  AclSize  | Sbz1  | AclRevision |
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # + - - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - +
    # |   Sbz2   |   AceCount   |
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # +
    # The current AclRevision is defined to be ACL_REVISION.
    # AclSize is the size, in bytes, allocated for the ACL. This
    # includes
    # the ACL header, ACES, and remaining free space in the buffer.
    # AceCount is the number of ACES in the ACL.
    # begin_wdm
    # This is the *current* ACL revision
    ACL_REVISION = 2
    ACL_REVISION_DS = 4

    # This is the history of ACL revisions. Add a new one whenever
    # ACL_REVISION is updated
    ACL_REVISION1 = 1
    MIN_ACL_REVISION = ACL_REVISION2
    ACL_REVISION2 = 2
    ACL_REVISION3 = 3
    ACL_REVISION4 = 4
    MAX_ACL_REVISION = ACL_REVISION4

    _ACL._fields_ = [
        ('AclRevision', BYTE),
        ('Sbz1', BYTE),
        ('AclSize', WORD),
        ('AceCount', WORD),
        ('Sbz2', WORD),
    ]

    PACL = POINTER(ACL)
    # end_wdm
    # begin_ntifs
    # The structure of an ACE is a common ace header followed by ace
    # type
    # specific data. Pictorally the structure of the common ace header
    # is
    # as follows:
    # 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
    # 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    # + - - - - - - - - - - - - - - - + - - - - - - - + - - - - - - -
    # + - - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - +
    # |  AceSize  | AceFlags |  AceType |
    # + - - - - - - - - - - - - - - - + - - - - - - - + - - - - - - -
    # + - - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - +
    # AceType denotes the type of the ace, there are some predefined
    # ace
    # types
    # AceSize is the size, in bytes, of ace.
    # AceFlags are the Ace flags for audit and inheritance, defined
    # shortly.
    _ACE_HEADER._fields_ = [
        ('AceType', BYTE),
        ('AceFlags', BYTE),
        ('AceSize', WORD),
    ]

    PACE_HEADER = POINTER(ACE_HEADER)
    # The following are the predefined ace types that go into the
    # AceType
    # field of an Ace header.
    ACCESS_MIN_MS_ACE_TYPE = 0x0
    ACCESS_ALLOWED_ACE_TYPE = 0x0
    ACCESS_DENIED_ACE_TYPE = 0x1
    SYSTEM_AUDIT_ACE_TYPE = 0x2
    SYSTEM_ALARM_ACE_TYPE = 0x3
    ACCESS_MAX_MS_V2_ACE_TYPE = 0x3
    ACCESS_ALLOWED_COMPOUND_ACE_TYPE = 0x4
    ACCESS_MAX_MS_V3_ACE_TYPE = 0x4
    ACCESS_MIN_MS_OBJECT_ACE_TYPE = 0x5
    ACCESS_ALLOWED_OBJECT_ACE_TYPE = 0x5
    ACCESS_DENIED_OBJECT_ACE_TYPE = 0x6
    SYSTEM_AUDIT_OBJECT_ACE_TYPE = 0x7
    SYSTEM_ALARM_OBJECT_ACE_TYPE = 0x8
    ACCESS_MAX_MS_OBJECT_ACE_TYPE = 0x8
    ACCESS_MAX_MS_V4_ACE_TYPE = 0x8
    ACCESS_MAX_MS_ACE_TYPE = 0x8
    ACCESS_ALLOWED_CALLBACK_ACE_TYPE = 0x9
    ACCESS_DENIED_CALLBACK_ACE_TYPE = 0xA
    ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE = 0xB
    ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE = 0xC
    SYSTEM_AUDIT_CALLBACK_ACE_TYPE = 0xD
    SYSTEM_ALARM_CALLBACK_ACE_TYPE = 0xE
    SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE = 0xF
    SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE = 0x10
    SYSTEM_MANDATORY_LABEL_ACE_TYPE = 0x11
    SYSTEM_RESOURCE_ATTRIBUTE_ACE_TYPE = 0x12
    SYSTEM_SCOPED_POLICY_ID_ACE_TYPE = 0x13
    SYSTEM_PROCESS_TRUST_LABEL_ACE_TYPE = 0x14
    SYSTEM_ACCESS_FILTER_ACE_TYPE = 0x15
    ACCESS_MAX_MS_V5_ACE_TYPE = 0x15

    # The following are the inherit flags that go into the AceFlags
    # field
    # of an Ace header.
    OBJECT_INHERIT_ACE = 0x1
    CONTAINER_INHERIT_ACE = 0x2
    NO_PROPAGATE_INHERIT_ACE = 0x4
    INHERIT_ONLY_ACE = 0x8
    INHERITED_ACE = 0x10
    VALID_INHERIT_FLAGS = 0x1F

    # The following are the currently defined ACE flags that go into
    # the
    # AceFlags field of an ACE header. Each ACE type has its own set of
    # AceFlags.
    # SYSTEM_AUDIT and SYSTEM_ALARM AceFlags
    # These control the signaling of audit and alarms for success or
    # failure.
    # SUCCESSFUL_ACCESS_ACE_FLAG - used only with system audit and
    # alarm ACE
    # types to indicate that a message is generated for successful
    # accesses.
    # FAILED_ACCESS_ACE_FLAG - used only with system audit and alarm
    # ACE types
    # to indicate that a message is generated for failed accesses.
    SUCCESSFUL_ACCESS_ACE_FLAG = 0x40
    FAILED_ACCESS_ACE_FLAG = 0x80

    # SYSTEM_ACCESS_FILTER_ACE AceFlags
    # These control the behaviour of SYSTEM_ACCESS_FILTER_ACE .
    # TRUST_PROTECTED_FILTER_ACE_FLAG - used only with
    # SYSTEM_FILTERING_ACE_TYPE
    # ACEs to indicate that this ACE may not be deleted/modified
    # except when the,
    # the current Trust Level dominates the one specified in the Ace
    # SID.
    # If this flag is set then the SID in the ACE should be a valid
    # TrustLevelSid.
    TRUST_PROTECTED_FILTER_ACE_FLAG = 0x40

    # We'll define the structure of the predefined ACE types.
    # Pictorally
    # the structure of the predefined ACE's is as follows:
    # 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
    # 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    # + - - - - - - - - - - - - - - - + - - - - - - - + - - - - - - -
    # + - - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - +
    # | AceFlags | Resd | Inherit| AceSize |  AceType |
    # + - - - - - - - - - - - - - - - + - - - - - - - + - - - - - - -
    # + - - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - +
    # |     Mask     |
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    # |           |
    # +           +
    # |           |
    # +     Sid      +
    # |           |
    # +           +
    # |           |
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    # Mask is the access mask associated with the ACE. This is either
    # the
    # access allowed, access denied, audit, or alarm mask.
    # Sid is the Sid associated with the ACE.
    # The following are the four predefined ACE types.
    # Examine the AceType field in the Header to determine
    # which structure is appropriate to use for casting.
    _ACCESS_ALLOWED_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('SidStart', DWORD),
    ]

    PACCESS_ALLOWED_ACE = POINTER(ACCESS_ALLOWED_ACE)

    _ACCESS_DENIED_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('SidStart', DWORD),
    ]

    PACCESS_DENIED_ACE = POINTER(ACCESS_DENIED_ACE)

    _SYSTEM_AUDIT_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('SidStart', DWORD),
    ]

    PSYSTEM_AUDIT_ACE = POINTER(SYSTEM_AUDIT_ACE)

    _SYSTEM_ALARM_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('SidStart', DWORD),
    ]

    PSYSTEM_ALARM_ACE = POINTER(SYSTEM_ALARM_ACE)

    _SYSTEM_RESOURCE_ATTRIBUTE_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('SidStart', DWORD),
    ]

    _SYSTEM_SCOPED_POLICY_ID_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('SidStart', DWORD),
    ]

    _SYSTEM_MANDATORY_LABEL_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('SidStart', DWORD),
    ]

    _SYSTEM_PROCESS_TRUST_LABEL_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('SidStart', DWORD),
    ]

    _SYSTEM_ACCESS_FILTER_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('SidStart', DWORD),
    ]

    SYSTEM_MANDATORY_LABEL_NO_WRITE_UP = 0x1
    SYSTEM_MANDATORY_LABEL_NO_READ_UP = 0x2
    SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP = 0x4
    SYSTEM_MANDATORY_LABEL_VALID_MASK = (
        SYSTEM_MANDATORY_LABEL_NO_WRITE_UP |
        SYSTEM_MANDATORY_LABEL_NO_READ_UP |
        SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP
    )

    # Placeholder value that allows all ranges
    SYSTEM_PROCESS_TRUST_LABEL_VALID_MASK = 0x00FFFFFF
    SYSTEM_PROCESS_TRUST_NOCONSTRAINT_MASK = 0xFFFFFFFF
    SYSTEM_ACCESS_FILTER_VALID_MASK = 0x00FFFFFF
    SYSTEM_ACCESS_FILTER_NOCONSTRAINT_MASK = 0xFFFFFFFF

    # end_ntifs
    _ACCESS_ALLOWED_OBJECT_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('Flags', DWORD),
        ('ObjectType', GUID),
        ('InheritedObjectType', GUID),
        ('SidStart', DWORD),
    ]

    _ACCESS_DENIED_OBJECT_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('Flags', DWORD),
        ('ObjectType', GUID),
        ('InheritedObjectType', GUID),
        ('SidStart', DWORD),
    ]

    _SYSTEM_AUDIT_OBJECT_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('Flags', DWORD),
        ('ObjectType', GUID),
        ('InheritedObjectType', GUID),
        ('SidStart', DWORD),
    ]

    _SYSTEM_ALARM_OBJECT_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('Flags', DWORD),
        ('ObjectType', GUID),
        ('InheritedObjectType', GUID),
        ('SidStart', DWORD),
    ]

    # Callback ace support in post Win2000.
    # Resource managers can put their own data after Sidstart + Length
    # of the sid
    _ACCESS_ALLOWED_CALLBACK_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('SidStart', DWORD),
    ]

    _ACCESS_DENIED_CALLBACK_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('SidStart', DWORD),
    ]

    _SYSTEM_AUDIT_CALLBACK_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('SidStart', DWORD),
    ]

    _SYSTEM_ALARM_CALLBACK_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('SidStart', DWORD),
    ]

    _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('Flags', DWORD),
        ('ObjectType', GUID),
        ('InheritedObjectType', GUID),
        ('SidStart', DWORD),
    ]

    _ACCESS_DENIED_CALLBACK_OBJECT_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('Flags', DWORD),
        ('ObjectType', GUID),
        ('InheritedObjectType', GUID),
        ('SidStart', DWORD),
    ]

    _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('Flags', DWORD),
        ('ObjectType', GUID),
        ('InheritedObjectType', GUID),
        ('SidStart', DWORD),
    ]

    _SYSTEM_ALARM_CALLBACK_OBJECT_ACE._fields_ = [
        ('Header', ACE_HEADER),
        ('Mask', ACCESS_MASK),
        ('Flags', DWORD),
        ('ObjectType', GUID),
        ('InheritedObjectType', GUID),
        ('SidStart', DWORD),
    ]

    # Currently define Flags for "OBJECT" ACE types.
    ACE_OBJECT_TYPE_PRESENT = 0x1
    ACE_INHERITED_OBJECT_TYPE_PRESENT = 0x2


    # The following declarations are used for setting and querying
    # information
    # about and ACL. First are the various information classes
    # available to
    # the user.
    class _ACL_INFORMATION_CLASS(ENUM):
        AclRevisionInformation = 1
        AclSizeInformation = 2


    ACL_INFORMATION_CLASS = _ACL_INFORMATION_CLASS

    # This record is returned/sent if the user is requesting/setting
    # the
    # AclRevisionInformation
    _ACL_REVISION_INFORMATION._fields_ = [
        ('AclRevision', DWORD),
    ]

    PACL_REVISION_INFORMATION = POINTER(ACL_REVISION_INFORMATION)

    # This record is returned if the user is requesting
    # AclSizeInformation
    _ACL_SIZE_INFORMATION._fields_ = [
        ('AceCount', DWORD),
        ('AclBytesInUse', DWORD),
        ('AclBytesFree', DWORD),
    ]

    PACL_SIZE_INFORMATION = POINTER(ACL_SIZE_INFORMATION)

    # //////////////////////////////////////////////////////////////////////
    #
    # //
    # SECURITY_DESCRIPTOR    //
    # //
    # //////////////////////////////////////////////////////////////////////
    #
    # Define the Security Descriptor and related data types.
    # This is an opaque data structure.
    # begin_wdm
    # Current security descriptor revision value
    SECURITY_DESCRIPTOR_REVISION = 1
    SECURITY_DESCRIPTOR_REVISION1 = 1

    # end_wdm
    # begin_ntifs
    SECURITY_DESCRIPTOR_MIN_LENGTH = ctypes.sizeof(SECURITY_DESCRIPTOR)

    SECURITY_DESCRIPTOR_CONTROL = WORD
    PSECURITY_DESCRIPTOR_CONTROL = POINTER(WORD)

    SE_OWNER_DEFAULTED = 0x0001
    SE_GROUP_DEFAULTED = 0x0002
    SE_DACL_PRESENT = 0x0004
    SE_DACL_DEFAULTED = 0x0008
    SE_SACL_PRESENT = 0x0010
    SE_SACL_DEFAULTED = 0x0020
    SE_DACL_AUTO_INHERIT_REQ = 0x0100
    SE_SACL_AUTO_INHERIT_REQ = 0x0200
    SE_DACL_AUTO_INHERITED = 0x0400
    SE_SACL_AUTO_INHERITED = 0x0800
    SE_DACL_PROTECTED = 0x1000
    SE_SACL_PROTECTED = 0x2000
    SE_RM_CONTROL_VALID = 0x4000
    SE_SELF_RELATIVE = 0x8000
    # Where:
    # SE_OWNER_DEFAULTED - This BOOLEAN flag, when set, indicates that
    # the
    # SID pointed to by the Owner field was provided by a
    # defaulting mechanism rather than explicitly provided by the
    # original provider of the security descriptor. This may
    # affect the treatment of the SID with respect to inheritence
    # of an owner.
    # SE_GROUP_DEFAULTED - This BOOLEAN flag, when set, indicates that
    # the
    # SID in the Group field was provided by a defaulting mechanism
    # rather than explicitly provided by the original provider of
    # the security descriptor. This may affect the treatment of
    # the SID with respect to inheritence of a primary group.
    # SE_DACL_PRESENT - This BOOLEAN flag, when set, indicates that the
    # security descriptor contains a discretionary ACL. If this
    # flag is set and the Dacl field of the SECURITY_DESCRIPTOR is
    # null, then a null ACL is explicitly being specified.
    # SE_DACL_DEFAULTED - This BOOLEAN flag, when set, indicates that
    # the
    # ACL pointed to by the Dacl field was provided by a defaulting
    # mechanism rather than explicitly provided by the original
    # provider of the security descriptor. This may affect the
    # treatment of the ACL with respect to inheritence of an ACL.
    # This flag is ignored if the DaclPresent flag is not set.
    # SE_SACL_PRESENT - This BOOLEAN flag, when set, indicates that the
    # security descriptor contains a system ACL pointed to by the
    # Sacl field. If this flag is set and the Sacl field of the
    # SECURITY_DESCRIPTOR is null, then an empty (but present)
    # ACL is being specified.
    # SE_SACL_DEFAULTED - This BOOLEAN flag, when set, indicates that
    # the
    # ACL pointed to by the Sacl field was provided by a defaulting
    # mechanism rather than explicitly provided by the original
    # provider of the security descriptor. This may affect the
    # treatment of the ACL with respect to inheritence of an ACL.
    # This flag is ignored if the SaclPresent flag is not set.
    # SE_SELF_RELATIVE - This BOOLEAN flag, when set, indicates that
    # the
    # security descriptor is in self - relative form. In this form,
    # all fields of the security descriptor are contiguous in memory
    # and all pointer fields are expressed as offsets from the
    # beginning of the security descriptor. This form is useful
    # for treating security descriptors as opaque data structures
    # for transmission in communication protocol or for storage on
    # secondary media.
    # Pictorially the structure of a security descriptor is as follows:
    # 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
    # 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    # |  Control   | Reserved1 (SBZ)| Revision  |
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    # |     Owner      |
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    # |     Group      |
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    # |     Sacl      |
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    # |     Dacl      |
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    # In general, this data structure should be treated opaquely to
    # ensure future
    # compatibility.
    _SECURITY_DESCRIPTOR_RELATIVE._fields_ = [
        ('Revision', BYTE),
        ('Sbz1', BYTE),
        ('Control', SECURITY_DESCRIPTOR_CONTROL),
        ('Owner', DWORD),
        ('Group', DWORD),
        ('Sacl', DWORD),
        ('Dacl', DWORD),
    ]

    _SECURITY_DESCRIPTOR._fields_ = [
        ('Revision', BYTE),
        ('Sbz1', BYTE),
        ('Control', SECURITY_DESCRIPTOR_CONTROL),
        ('Owner', PSID),
        ('Group', PSID),
        ('Sacl', PACL),
        ('Dacl', PACL),
    ]

    _SECURITY_OBJECT_AI_PARAMS._fields_ = [
        # Set to (ctypes.sizeof(SECURITY_OBJECT_AI_PARAMS)
        ('Size', DWORD),
        ('ConstraintMask', DWORD),
    ]

    # end_ntifs
    # Where:
    # Revision - Contains the revision level of the security
    # descriptor. This allows this structure to be passed between
    # systems or stored on disk even though it is expected to
    # change in the future.
    # Control - A set of flags which qualify the meaning of the
    # security descriptor or individual fields of the security
    # descriptor.
    # Owner - is a pointer to an SID representing an object's owner.
    # If this field is null, then no owner SID is present in the
    # security descriptor. If the security descriptor is in
    # self - relative form, then this field contains an offset to
    # the SID, rather than a pointer.
    # Group - is a pointer to an SID representing an object's primary
    # group. If this field is null, then no primary group SID is
    # present in the security descriptor. If the security descriptor
    # is in self - relative form, then this field contains an offset to
    # the SID, rather than a pointer.
    # Sacl - is a pointer to a system ACL. This field value is only
    # valid if the DaclPresent control flag is set. If the
    # SaclPresent flag is set and this field is null, then a null
    # ACL is specified. If the security descriptor is in
    # self - relative form, then this field contains an offset to
    # the ACL, rather than a pointer.
    # Dacl - is a pointer to a discretionary ACL. This field value is
    # only valid if the DaclPresent control flag is set. If the
    # DaclPresent flag is set and this field is null, then a null
    # ACL (unconditionally granting access) is specified. If the
    # security descriptor is in self - relative form, then this field
    # contains an offset to the ACL, rather than a pointer.
    # //////////////////////////////////////////////////////////////////////
    #
    # //
    # Object Type list for AccessCheckByType   //
    # //
    # //////////////////////////////////////////////////////////////////////
    #
    _OBJECT_TYPE_LIST._fields_ = [
        ('Level', WORD),
        ('Sbz', WORD),
        ('ObjectType', POINTER(GUID)),
    ]
    # DS values for Level
    ACCESS_OBJECT_GUID = 0
    ACCESS_PROPERTY_SET_GUID = 1
    ACCESS_PROPERTY_GUID = 2
    ACCESS_MAX_LEVEL = 4
    # Parameters to NtAccessCheckByTypeAndAditAlarm


    class _AUDIT_EVENT_TYPE(ENUM):
        AuditEventObjectAccess = 1
        AuditEventDirectoryServiceAccess = 2


    AUDIT_EVENT_TYPE = _AUDIT_EVENT_TYPE
    PAUDIT_EVENT_TYPE = POINTER(_AUDIT_EVENT_TYPE)
    AUDIT_ALLOW_NO_PRIVILEGE = 0x1

    # DS values for Source and ObjectTypeName
    ACCESS_DS_SOURCE_A = "DS"
    ACCESS_DS_SOURCE_W = "DS"
    ACCESS_DS_OBJECT_TYPE_NAME_A = "Directory Service Object"
    ACCESS_DS_OBJECT_TYPE_NAME_W = "Directory Service Object"

    # //////////////////////////////////////////////////////////////////////
    #
    # //
    # Privilege Related Data Structures    //
    # //
    # //////////////////////////////////////////////////////////////////////
    #
    # end_ntifs
    # begin_wdm
    # Privilege attributes
    SE_PRIVILEGE_ENABLED_BY_DEFAULT = 0x00000001
    SE_PRIVILEGE_ENABLED = 0x00000002
    SE_PRIVILEGE_REMOVED = 0x00000004
    SE_PRIVILEGE_USED_FOR_ACCESS = 0x80000000
    SE_PRIVILEGE_VALID_ATTRIBUTES = (
        SE_PRIVILEGE_ENABLED_BY_DEFAULT |
        SE_PRIVILEGE_ENABLED |
        SE_PRIVILEGE_REMOVED |
        SE_PRIVILEGE_USED_FOR_ACCESS
    )

    # Privilege Set Control flags
    PRIVILEGE_SET_ALL_NECESSARY = 1

    # Privilege Set - This is defined for a privilege set of one.
    # If more than one privilege is needed, then this structure
    # will need to be allocated with more space.
    # Note: don't change this structure without fixing the
    # INITIAL_PRIVILEGE_SET
    # structure (defined in se.h)
    _PRIVILEGE_SET._fields_ = [
        ('PrivilegeCount', DWORD),
        ('Control', DWORD),
        ('Privilege', LUID_AND_ATTRIBUTES * ANYSIZE_ARRAY),
    ]

    # Values for different access granted\denied reasons:
    # AccessReasonAceN = AccessReasonAce + N.
    # AccessReasonPrivilegeN = AccessReasonPrivilege + N.
    ACCESS_REASON_TYPE_MASK = 0x00FF0000
    ACCESS_REASON_DATA_MASK = 0x0000FFFF
    ACCESS_REASON_STAGING_MASK = 0x80000000
    ACCESS_REASON_EXDATA_MASK = 0x7F000000


    class _ACCESS_REASON_TYPE(ENUM):

        # Indicate no reason for the bit. The bit may not be checked,
        # or just no known reason.
        AccessReasonNone = 0x00000000
        AccessReasonAllowedAce = 0x00010000
        AccessReasonDeniedAce = 0x00020000
        AccessReasonAllowedParentAce = 0x00030000
        AccessReasonDeniedParentAce = 0x00040000
        AccessReasonNotGrantedByCape = 0x00050000
        AccessReasonNotGrantedByParentCape = 0x00060000
        AccessReasonNotGrantedToAppContainer = 0x00070000
        AccessReasonMissingPrivilege = 0x00100000
        AccessReasonFromPrivilege = 0x00200000
        AccessReasonIntegrityLevel = 0x00300000
        AccessReasonOwnership = 0x00400000
        AccessReasonNullDacl = 0x00500000
        AccessReasonEmptyDacl = 0x00600000
        AccessReasonNoSD = 0x00700000
        AccessReasonNoGrant = 0x00800000
        AccessReasonTrustLabel = 0x00900000
        AccessReasonFilterAce = 0x00A00000


    ACCESS_REASON_TYPE = _ACCESS_REASON_TYPE

    # Structure to hold access denied\granted reason for every bit of
    # ACCESS_MASK.
    # There are 32 - bits in ACCESS_MASK and only 27 - bits are
    # actually valid on
    # return from AccessCheck because MAXIMUM_ALLOWED, GENERIC_READ,
    # GENERIC_WRITE, GENERIC_EXECUTE, and GENERIC_ALL are never
    # returned.
    # The content in Data fields depends on the Access Reason, for
    # example,
    # if the reason is AccessReasonAce, the Data will be the ACE ID.
    # If there are more than one reason (more than one bit is set),
    # the array size
    # of the Data is equal to the number of bits set
    # (or number of reasons).
    # The Data could be null for a particular reason.

    ACCESS_REASON = DWORD

    _ACCESS_REASONS._fields_ = [
        ('Data', ACCESS_REASON * 32),
    ]

    # /* The following data structures are defined to consolidate
    # various falvors of access check functions. In particular for
    # Windows 7, the new access check function will enable security
    # attribute check, plus returning the reason for a access check
    # result. The new access check function based on these data
    # structures will form the foundation to reimplement other flavors
    # of access check functions.
    # Structure to hold pointer to security descriptor and its unique
    # id, which
    # can be used for caching access check results.
    # (NOTE NOTE) The cache key can be constructed by
    # SecurityDescriptorId, Token and
    # PrincipalSelfSid. Watch how GenericMapping affects the cache
    # results.
    SE_SECURITY_DESCRIPTOR_FLAG_NO_OWNER_ACE = 0x00000001
    SE_SECURITY_DESCRIPTOR_FLAG_NO_LABEL_ACE = 0x00000002
    SE_SECURITY_DESCRIPTOR_FLAG_NO_ACCESS_FILTER_ACE = 0x00000004
    SE_SECURITY_DESCRIPTOR_VALID_FLAGS = 0x00000007

    _SE_SECURITY_DESCRIPTOR._fields_ = [
        ('Size', DWORD),
        ('Flags', DWORD),
        ('SecurityDescriptor', PSECURITY_DESCRIPTOR),
    ]

    _SE_ACCESS_REQUEST._fields_ = [
        ('Size', DWORD),
        ('SeSecurityDescriptor', PSE_SECURITY_DESCRIPTOR),
        ('DesiredAccess', ACCESS_MASK),
        ('PreviouslyGrantedAccess', ACCESS_MASK),
        # Need to watch how this field affects the cache.
        ('PrincipalSelfSid', PSID),
        ('GenericMapping', PGENERIC_MAPPING),
        ('ObjectTypeListCount', DWORD),
        ('ObjectTypeList', POBJECT_TYPE_LIST),
    ]

    _SE_ACCESS_REPLY._fields_ = [
        ('Size', DWORD),
        # Indicate the array size of GrantedAccess and AccessStatus,
        # it only can be either 1 or ObjectTypeListCount.
        ('ResultListCount', DWORD),
        ('GrantedAccess', PACCESS_MASK),
        ('AccessStatus', PDWORD),
        ('AccessReason', PACCESS_REASONS),
        ('Privileges', POINTER(PPRIVILEGE_SET)),
    ]

    # //////////////////////////////////////////////////////////////////////
    #
    # //
    # NT Defined Privileges      //
    # //
    # //////////////////////////////////////////////////////////////////////
    #
    SE_CREATE_TOKEN_NAME = TEXT("SeCreateTokenPrivilege")
    SE_ASSIGNPRIMARYTOKEN_NAME = TEXT("SeAssignPrimaryTokenPrivilege")
    SE_LOCK_MEMORY_NAME = TEXT("SeLockMemoryPrivilege")
    SE_INCREASE_QUOTA_NAME = TEXT("SeIncreaseQuotaPrivilege")
    SE_UNSOLICITED_INPUT_NAME = TEXT("SeUnsolicitedInputPrivilege")
    SE_MACHINE_ACCOUNT_NAME = TEXT("SeMachineAccountPrivilege")
    SE_TCB_NAME = TEXT("SeTcbPrivilege")
    SE_SECURITY_NAME = TEXT("SeSecurityPrivilege")
    SE_TAKE_OWNERSHIP_NAME = TEXT("SeTakeOwnershipPrivilege")
    SE_LOAD_DRIVER_NAME = TEXT("SeLoadDriverPrivilege")
    SE_SYSTEM_PROFILE_NAME = TEXT("SeSystemProfilePrivilege")
    SE_SYSTEMTIME_NAME = TEXT("SeSystemtimePrivilege")
    SE_PROF_SINGLE_PROCESS_NAME = (
        TEXT("SeProfileSingleProcessPrivilege")
    )
    SE_INC_BASE_PRIORITY_NAME = TEXT("SeIncreaseBasePriorityPrivilege")
    SE_CREATE_PAGEFILE_NAME = TEXT("SeCreatePagefilePrivilege")
    SE_CREATE_PERMANENT_NAME = TEXT("SeCreatePermanentPrivilege")
    SE_BACKUP_NAME = TEXT("SeBackupPrivilege")
    SE_RESTORE_NAME = TEXT("SeRestorePrivilege")
    SE_SHUTDOWN_NAME = TEXT("SeShutdownPrivilege")
    SE_DEBUG_NAME = TEXT("SeDebugPrivilege")
    SE_AUDIT_NAME = TEXT("SeAuditPrivilege")
    SE_SYSTEM_ENVIRONMENT_NAME = TEXT("SeSystemEnvironmentPrivilege")
    SE_CHANGE_NOTIFY_NAME = TEXT("SeChangeNotifyPrivilege")
    SE_REMOTE_SHUTDOWN_NAME = TEXT("SeRemoteShutdownPrivilege")
    SE_UNDOCK_NAME = TEXT("SeUndockPrivilege")
    SE_SYNC_AGENT_NAME = TEXT("SeSyncAgentPrivilege")
    SE_ENABLE_DELEGATION_NAME = TEXT("SeEnableDelegationPrivilege")
    SE_MANAGE_VOLUME_NAME = TEXT("SeManageVolumePrivilege")
    SE_IMPERSONATE_NAME = TEXT("SeImpersonatePrivilege")
    SE_CREATE_GLOBAL_NAME = TEXT("SeCreateGlobalPrivilege")
    SE_TRUSTED_CREDMAN_ACCESS_NAME = (
        TEXT("SeTrustedCredManAccessPrivilege")
    )
    SE_RELABEL_NAME = TEXT("SeRelabelPrivilege")
    SE_INC_WORKING_SET_NAME = TEXT("SeIncreaseWorkingSetPrivilege")
    SE_TIME_ZONE_NAME = TEXT("SeTimeZonePrivilege")
    SE_CREATE_SYMBOLIC_LINK_NAME = (
        TEXT("SeCreateSymbolicLinkPrivilege")
    )
    SE_DELEGATE_SESSION_USER_IMPERSONATE_NAME = (
        TEXT("SeDelegateSessionUserImpersonatePrivilege")
    )

    # begin_ntosifs
    # List Of String Capabilities.
    SE_ACTIVATE_AS_USER_CAPABILITY = "activateAsUser"
    SE_CONSTRAINED_IMPERSONATION_CAPABILITY = (
        "constrainedImpersonation"
    )
    SE_SESSION_IMPERSONATION_CAPABILITY = "sessionImpersonation"
    SE_MUMA_CAPABILITY = "muma"
    SE_DEVELOPMENT_MODE_NETWORK_CAPABILITY = "developmentModeNetwork"


    # end_ntosifs
    # //////////////////////////////////////////////////////////////////
    #
    # //
    # Security Quality Of Service     //
    # //
    # //
    # //////////////////////////////////////////////////////////////////
    #
    # begin_wdm
    # Impersonation Level
    # Impersonation level is represented by a pair of bits in Windows.
    # If a new impersonation level is added or lowest value is changed
    # from
    # 0 to something else, fix the Windows CreateFile call.
    class _SECURITY_IMPERSONATION_LEVEL(ENUM):
        SecurityAnonymous = 1
        SecurityIdentification = 2
        SecurityImpersonation = 3
        SecurityDelegation = 4


    SECURITY_IMPERSONATION_LEVEL = _SECURITY_IMPERSONATION_LEVEL
    PSECURITY_IMPERSONATION_LEVEL = POINTER(_SECURITY_IMPERSONATION_LEVEL)
    SECURITY_MAX_IMPERSONATION_LEVEL = _SECURITY_IMPERSONATION_LEVEL.SecurityDelegation
    SECURITY_MIN_IMPERSONATION_LEVEL = _SECURITY_IMPERSONATION_LEVEL.SecurityAnonymous
    DEFAULT_IMPERSONATION_LEVEL = _SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation


    def VALID_IMPERSONATION_LEVEL(L):
        return SECURITY_MIN_IMPERSONATION_LEVEL <= L <= SECURITY_MAX_IMPERSONATION_LEVEL


    # //////////////////////////////////////////////////////////////////
    #
    # //
    # Token Object Definitions      //
    # //
    # //
    # //////////////////////////////////////////////////////////////////
    #
    # begin_access
    # Token Specific Access Rights.
    TOKEN_ASSIGN_PRIMARY = 0x0001
    TOKEN_DUPLICATE = 0x0002
    TOKEN_IMPERSONATE = 0x0004
    TOKEN_QUERY = 0x0008
    TOKEN_QUERY_SOURCE = 0x0010
    TOKEN_ADJUST_PRIVILEGES = 0x0020
    TOKEN_ADJUST_GROUPS = 0x0040
    TOKEN_ADJUST_DEFAULT = 0x0080
    TOKEN_ADJUST_SESSIONID = 0x0100
    TOKEN_ALL_ACCESS_P = (
        STANDARD_RIGHTS_REQUIRED |
        TOKEN_ASSIGN_PRIMARY |
        TOKEN_DUPLICATE |
        TOKEN_IMPERSONATE |
        TOKEN_QUERY |
        TOKEN_QUERY_SOURCE |
        TOKEN_ADJUST_PRIVILEGES |
        TOKEN_ADJUST_GROUPS |
        TOKEN_ADJUST_DEFAULT
    )
    if (
        (defined(_WIN32_WINNT) and (_WIN32_WINNT > 0x0400)) or
        not defined(_WIN32_WINNT)
    ):
        TOKEN_ALL_ACCESS = TOKEN_ALL_ACCESS_P | TOKEN_ADJUST_SESSIONID
    else:
        TOKEN_ALL_ACCESS = TOKEN_ALL_ACCESS_P
    # END IF
    TOKEN_READ = STANDARD_RIGHTS_READ | TOKEN_QUERY
    TOKEN_WRITE = (
        STANDARD_RIGHTS_WRITE |
        TOKEN_ADJUST_PRIVILEGES |
        TOKEN_ADJUST_GROUPS |
        TOKEN_ADJUST_DEFAULT
    )
    TOKEN_EXECUTE = STANDARD_RIGHTS_EXECUTE
    TOKEN_TRUST_CONSTRAINT_MASK = (
        STANDARD_RIGHTS_READ |
        TOKEN_QUERY |
        TOKEN_QUERY_SOURCE
    )
    if NTDDI_VERSION >= NTDDI_WIN8:
        TOKEN_ACCESS_PSEUDO_HANDLE_WIN8 = (
            TOKEN_QUERY |
            TOKEN_QUERY_SOURCE
        )
        TOKEN_ACCESS_PSEUDO_HANDLE = TOKEN_ACCESS_PSEUDO_HANDLE_WIN8


    # END IF
    # end_access
    # Token Types
    class _TOKEN_TYPE(ENUM):
        TokenPrimary = 1
        TokenImpersonation = 2


    TOKEN_TYPE = _TOKEN_TYPE
    PTOKEN_TYPE = POINTER(TOKEN_TYPE)

    # Token elevation values describe the relative strength of a given
    # token.
    # A full token is a token with all groups and privileges to which
    # the principal
    # is authorized. A limited token is one with some groups or
    # privileges removed.
    class _TOKEN_ELEVATION_TYPE(ENUM):
        TokenElevationTypeDefault = 1
        TokenElevationTypeFull = 2
        TokenElevationTypeLimited = 3


    TOKEN_ELEVATION_TYPE = _TOKEN_ELEVATION_TYPE
    PTOKEN_ELEVATION_TYPE = POINTER(_TOKEN_ELEVATION_TYPE)


    # Token Information Classes.
    class _TOKEN_INFORMATION_CLASS(ENUM):
        TokenUser = 1
        TokenGroups = 2
        TokenPrivileges = 3
        TokenOwner = 4
        TokenPrimaryGroup = 5
        TokenDefaultDacl = 6
        TokenSource = 7
        TokenType = 8
        TokenImpersonationLevel = 9
        TokenStatistics = 10
        TokenRestrictedSids = 11
        TokenSessionId = 12
        TokenGroupsAndPrivileges = 13
        TokenSessionReference = 14
        TokenSandBoxInert = 15
        TokenAuditPolicy = 16
        TokenOrigin = 17
        TokenElevationType = 18
        TokenLinkedToken = 19
        TokenElevation = 20
        TokenHasRestrictions = 21
        TokenAccessInformation = 22
        TokenVirtualizationAllowed = 23
        TokenVirtualizationEnabled = 24
        TokenIntegrityLevel = 25
        TokenUIAccess = 26
        TokenMandatoryPolicy = 27
        TokenLogonSid = 28
        TokenIsAppContainer = 29
        TokenCapabilities = 30
        TokenAppContainerSid = 31
        TokenAppContainerNumber = 32
        TokenUserClaimAttributes = 33
        TokenDeviceClaimAttributes = 34
        TokenRestrictedUserClaimAttributes = 35
        TokenRestrictedDeviceClaimAttributes = 36
        TokenDeviceGroups = 37
        TokenRestrictedDeviceGroups = 38
        TokenSecurityAttributes = 39
        TokenIsRestricted = 40
        TokenProcessTrustLevel = 41
        TokenPrivateNameSpace = 42
        TokenSingletonAttributes = 43
        TokenBnoIsolation = 44
        TokenChildProcessFlags = 45
        MaxTokenInfoClass = 46


    TOKEN_INFORMATION_CLASS = _TOKEN_INFORMATION_CLASS
    PTOKEN_INFORMATION_CLASS = POINTER(_TOKEN_INFORMATION_CLASS)

    # Token information class structures
    _TOKEN_USER._fields_ = [
        ('User', SID_AND_ATTRIBUTES),
    ]
    if not defined(MIDL_PASS):
        class DUMMYUNIONNAME(ctypes.Union):
            pass


        DUMMYUNIONNAME._fields_ = [
            ('TokenUser', TOKEN_USER),
            ('User', SID_AND_ATTRIBUTES),
        ]
        _SE_TOKEN_USER.DUMMYUNIONNAME = DUMMYUNIONNAME


        class DUMMYUNIONNAME2(ctypes.Union):
            pass


        DUMMYUNIONNAME2._fields_ = [
            ('Sid', SID),
            ('Buffer', BYTE * SECURITY_MAX_SID_SIZE),
        ]
        _SE_TOKEN_USER.DUMMYUNIONNAME2 = DUMMYUNIONNAME2

        _SE_TOKEN_USER._fields_ = [
            ('DUMMYUNIONNAME', _SE_TOKEN_USER.DUMMYUNIONNAME),
            ('DUMMYUNIONNAME2', _SE_TOKEN_USER.DUMMYUNIONNAME2),
        ]
        TOKEN_USER_MAX_SIZE = (
            ctypes.sizeof(TOKEN_USER) + SECURITY_MAX_SID_SIZE
        )
    # END IF

    _TEMP__TOKEN_GROUPS = [
        ('GroupCount', DWORD),
    ]
    if defined(MIDL_PASS):
        _TEMP__TOKEN_GROUPS += [
            ('Groups', SID_AND_ATTRIBUTES * ctypes.sizeof(DWORD)),
        ]
    else:  # MIDL_PASS
        _TEMP__TOKEN_GROUPS += [
            ('Groups', SID_AND_ATTRIBUTES * ANYSIZE_ARRAY),
        ]
    # END IF   MIDL_PASS
    _TOKEN_GROUPS._fields_ = _TEMP__TOKEN_GROUPS

    _TOKEN_PRIVILEGES._fields_ = [
        ('PrivilegeCount', DWORD),
        ('Privileges', LUID_AND_ATTRIBUTES * ANYSIZE_ARRAY),
    ]

    _TOKEN_OWNER._fields_ = [
        ('Owner', PSID),
    ]
    if not defined(MIDL_PASS):
        TOKEN_OWNER_MAX_SIZE = (
            ctypes.sizeof(TOKEN_OWNER) + SECURITY_MAX_SID_SIZE
        )
    # END IF
    _TOKEN_PRIMARY_GROUP._fields_ =[
        ('PrimaryGroup', PSID),
    ]
    _TOKEN_DEFAULT_DACL._fields_ = [
        ('DefaultDacl', PACL),
    ]
    _TOKEN_USER_CLAIMS._fields_ = [
        ('UserClaims', PCLAIMS_BLOB),
    ]
    _TOKEN_DEVICE_CLAIMS._fields_ = [
        ('DeviceClaims', PCLAIMS_BLOB),
    ]
    _TOKEN_GROUPS_AND_PRIVILEGES._fields_ = [
        ('SidCount', DWORD),
        ('SidLength', DWORD),
        ('Sids', PSID_AND_ATTRIBUTES),
        ('RestrictedSidCount', DWORD),
        ('RestrictedSidLength', DWORD),
        ('RestrictedSids', PSID_AND_ATTRIBUTES),
        ('PrivilegeCount', DWORD),
        ('PrivilegeLength', DWORD),
        ('Privileges', PLUID_AND_ATTRIBUTES),
        ('AuthenticationId', LUID),
    ]
    _TOKEN_LINKED_TOKEN._fields_ = [
        ('LinkedToken', HANDLE),
    ]
    _TOKEN_ELEVATION._fields_ = [
        ('TokenIsElevated', DWORD),
    ]
    _TOKEN_MANDATORY_LABEL._fields_ = [
        ('Label', SID_AND_ATTRIBUTES),
    ]
    TOKEN_MANDATORY_POLICY_OFF = 0x0
    TOKEN_MANDATORY_POLICY_NO_WRITE_UP = 0x1
    TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN = 0x2
    TOKEN_MANDATORY_POLICY_VALID_MASK = (
        TOKEN_MANDATORY_POLICY_NO_WRITE_UP |
        TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN
    )
    if not defined(MIDL_PASS):
        TOKEN_INTEGRITY_LEVEL_MAX_SIZE = (
            (
                (
                    ctypes.sizeof(TOKEN_MANDATORY_LABEL) +
                    ctypes.sizeof(PVOID) -
                    1
                ) &
                ~(ctypes.sizeof(PVOID) - 1)
            ) +
            SECURITY_MAX_SID_SIZE
        )
    # END IF

    _TOKEN_MANDATORY_POLICY._fields_ = [
        ('Policy', DWORD),
    ]

    PSECURITY_ATTRIBUTES_OPAQUE = PVOID

    _TOKEN_ACCESS_INFORMATION._fields_ = [
        ('SidHash', PSID_AND_ATTRIBUTES_HASH),
        ('RestrictedSidHash', PSID_AND_ATTRIBUTES_HASH),
        ('Privileges', PTOKEN_PRIVILEGES),
        ('AuthenticationId', LUID),
        ('TokenType', TOKEN_TYPE),
        ('ImpersonationLevel', SECURITY_IMPERSONATION_LEVEL),
        ('MandatoryPolicy', TOKEN_MANDATORY_POLICY),
        ('Flags', DWORD),
        ('AppContainerNumber', DWORD),
        ('PackageSid', PSID),
        ('CapabilitiesHash', PSID_AND_ATTRIBUTES_HASH),
        ('TrustLevelSid', PSID),
        ('SecurityAttributes', PSECURITY_ATTRIBUTES_OPAQUE),
    ]
    # Valid bits for each TOKEN_AUDIT_POLICY policy mask field.
    POLICY_AUDIT_SUBCATEGORY_COUNT = 59

    _TOKEN_AUDIT_POLICY._fields_ = [
        ('PerUserPolicy', BYTE * ((POLICY_AUDIT_SUBCATEGORY_COUNT >> 1) + 1)),
    ]

    TOKEN_SOURCE_LENGTH = 8

    _TOKEN_SOURCE._fields_ = [
        ('SourceName', CHAR * TOKEN_SOURCE_LENGTH),
        ('SourceIdentifier', LUID),
    ]
    _TOKEN_STATISTICS._fields_ = [
        ('TokenId', LUID),
        ('AuthenticationId', LUID),
        ('ExpirationTime', LARGE_INTEGER),
        ('TokenType', TOKEN_TYPE),
        ('ImpersonationLevel', SECURITY_IMPERSONATION_LEVEL),
        ('DynamicCharged', DWORD),
        ('DynamicAvailable', DWORD),
        ('GroupCount', DWORD),
        ('PrivilegeCount', DWORD),
        ('ModifiedId', LUID),
    ]
    _TOKEN_CONTROL._fields_ = [
        ('TokenId', LUID),
        ('AuthenticationId', LUID),
        ('ModifiedId', LUID),
        ('TokenSource', TOKEN_SOURCE),
    ]
    _TOKEN_ORIGIN._fields_ = [
        ('OriginatingLogonSession', LUID),
    ]


    class _MANDATORY_LEVEL(ENUM):
        MandatoryLevelUntrusted = 0
        MandatoryLevelLow = 1
        MandatoryLevelMedium = 2
        MandatoryLevelHigh = 3
        MandatoryLevelSystem = 4
        MandatoryLevelSecureProcess = 5
        MandatoryLevelCount = 6


    MANDATORY_LEVEL = _MANDATORY_LEVEL
    PMANDATORY_LEVEL = POINTER(_MANDATORY_LEVEL)

    _TOKEN_APPCONTAINER_INFORMATION._fields_ = [
        ('TokenAppContainer', PSID),
    ]
    if not defined(MIDL_PASS):
        TOKEN_APPCONTAINER_SID_MAX_SIZE = (
            ctypes.sizeof(TOKEN_APPCONTAINER_INFORMATION) + SECURITY_MAX_SID_SIZE
         )
    # END IF
    _TOKEN_SID_INFORMATION._fields_ =[
        ('Sid', PSID),
    ]
    _TOKEN_BNO_ISOLATION_INFORMATION._fields_ = [
        ('IsolationPrefix', PWSTR),
        ('IsolationEnabled', BOOLEAN),
    ]
    # *** Claim Security attributes ***
    # These defines and data structures (almost) exactly mirror
    # the Token_XXX definitions (except for PWSTR/PUNICODE changes)
    # in ntseapi.w as well as AUTHZ_XXX in authz.w.
    # Keep them in sync.
    # Security attribute data types ...
    CLAIM_SECURITY_ATTRIBUTE_TYPE_INVALID = 0x00
    CLAIM_SECURITY_ATTRIBUTE_TYPE_INT64 = 0x01
    CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64 = 0x02
    # Case insensitive attribute value string by default.
    # Unless the flag CLAIM_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE
    # is set indicating otherwise.
    CLAIM_SECURITY_ATTRIBUTE_TYPE_STRING = 0x03
    # Fully - qualified binary name.
    _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE._fields_ = [
        ('Version', DWORD64),
        ('Name', PWSTR),
    ]
    CLAIM_SECURITY_ATTRIBUTE_TYPE_FQBN = 0x04
    CLAIM_SECURITY_ATTRIBUTE_TYPE_SID = 0x05
    CLAIM_SECURITY_ATTRIBUTE_TYPE_BOOLEAN = 0x06

    _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE._fields_ = [
        # Pointer is BYTE aligned.
        ('pValue', PVOID),
        # In bytes
        ('ValueLength', DWORD),
    ]
    CLAIM_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING = 0x10
    # Attribute Flags
    # Attribute must not be inherited across process spawns.
    CLAIM_SECURITY_ATTRIBUTE_NON_INHERITABLE = 0x0001
    # Attribute value is compared in a case sensitive way. It is valid
    # with string value
    # or composite type containing string value. For other types of
    # value, this flag
    # will be ignored. Currently, it is valid with the two types:
    # CLAIM_SECURITY_ATTRIBUTE_TYPE_STRING and
    # CLAIM_SECURITY_ATTRIBUTE_TYPE_FQBN.
    CLAIM_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE = 0x0002
    # Attribute is considered only for Deny Aces.
    CLAIM_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY = 0x0004
    # Attribute is disabled by default.
    CLAIM_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT = 0x0008
    # Attribute is disabled.
    CLAIM_SECURITY_ATTRIBUTE_DISABLED = 0x0010
    # Attribute is mandatory.
    CLAIM_SECURITY_ATTRIBUTE_MANDATORY = 0x0020
    CLAIM_SECURITY_ATTRIBUTE_VALID_FLAGS = (
        CLAIM_SECURITY_ATTRIBUTE_NON_INHERITABLE |
        CLAIM_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE |
        CLAIM_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY |
        CLAIM_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT |
        CLAIM_SECURITY_ATTRIBUTE_DISABLED |
        CLAIM_SECURITY_ATTRIBUTE_MANDATORY
    )
    # Reserve upper 16 bits for custom flags. These should be
    # preserved but not
    # validated as they do not affect security in any way.
    CLAIM_SECURITY_ATTRIBUTE_CUSTOM_FLAGS = 0xFFFF0000
    # An individual security attribute.


    class Values(ctypes.Union):
        pass


    Values._fields_ = [
        ('pInt64', PLONG64),
        ('pUint64', PDWORD64),
        ('ppString', POINTER(PWSTR)),
        ('pFqbn', PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE),
        ('pOctetString', PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE),
    ]
    _CLAIM_SECURITY_ATTRIBUTE_V1.Values = Values

    _CLAIM_SECURITY_ATTRIBUTE_V1._fields_ = [
        # Case insensitive Unicode string.
        ('Name', PWSTR),
        # Data type of attribute.
        ('ValueType', WORD),
        # a get operation.
        ('Reserved', WORD),
        # Attribute Flags
        ('Flags', DWORD),
        # Number of values.
        ('ValueCount', DWORD),
        # The actual value itself.
        ('Values', _CLAIM_SECURITY_ATTRIBUTE_V1.Values),
    ]


    # Relative form of the security attribute.
    class Values(ctypes.Union):
        pass


    Values._fields_ = [
        ('pInt64', DWORD * ANYSIZE_ARRAY),
        ('pUint64', DWORD * ANYSIZE_ARRAY),
        ('ppString', DWORD * ANYSIZE_ARRAY),
        ('pFqbn', DWORD * ANYSIZE_ARRAY),
        ('pOctetString', DWORD * ANYSIZE_ARRAY),
    ]
    _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1.Values = Values

    _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1._fields_ = [
        # Offset from beginning of structure.
        ('Name', DWORD),
        # Data type of attribute.
        ('ValueType', WORD),
        # a get operation.
        ('Reserved', WORD),
        # Attribute Flags
        ('Flags', DWORD),
        # Number of values.
        ('ValueCount', DWORD),
        # The actual value itself.
        ('Values', _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1.Values),
    ]

    # Set of security attributes.
    # Versioning. The interpretation of the pointers in the
    # Attribute field below is dependent on the version field.
    # Get operations return the version while the set operation
    # MUST specify the version of the data structure passed in.
    CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1 = 1
    CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION = (
        CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1
    )


    class Attribute(ctypes.Union):
        pass


    Attribute._fields_ = [
        ('pAttributeV1', PCLAIM_SECURITY_ATTRIBUTE_V1),
    ]
    _CLAIM_SECURITY_ATTRIBUTES_INFORMATION.Attribute = Attribute

    _CLAIM_SECURITY_ATTRIBUTES_INFORMATION._fields_ = [
        # MUST BE first.
        ('Version', WORD),
        # Pass 0 in set operations and ignore on get operations.
        ('Reserved', WORD),
        ('AttributeCount', DWORD),
        ('Attribute', _CLAIM_SECURITY_ATTRIBUTES_INFORMATION.Attribute),
    ]

    # Security Tracking Mode
    SECURITY_DYNAMIC_TRACKING = TRUE
    SECURITY_STATIC_TRACKING = FALSE

    SECURITY_CONTEXT_TRACKING_MODE = BOOLEAN
    PSECURITY_CONTEXT_TRACKING_MODE = POINTER(BOOLEAN)

    # Quality Of Service
    _SECURITY_QUALITY_OF_SERVICE._fields_ = [
        ('Length', DWORD),
        ('ImpersonationLevel', SECURITY_IMPERSONATION_LEVEL),
        ('ContextTrackingMode', SECURITY_CONTEXT_TRACKING_MODE),
        ('EffectiveOnly', BOOLEAN),
    ]

    # Used to represent information related to a thread impersonation
    _SE_IMPERSONATION_STATE._fields_ = [
        ('Token', PACCESS_TOKEN),
        ('CopyOnOpen', BOOLEAN),
        ('EffectiveOnly', BOOLEAN),
        ('Level', SECURITY_IMPERSONATION_LEVEL),
    ]
    DISABLE_MAX_PRIVILEGE = 0x1
    SANDBOX_INERT = 0x2
    LUA_TOKEN = 0x4
    WRITE_RESTRICTED = 0x8

    SECURITY_INFORMATION = DWORD
    PSECURITY_INFORMATION = POINTER(DWORD)

    OWNER_SECURITY_INFORMATION = 0x00000001
    GROUP_SECURITY_INFORMATION = 0x00000002
    DACL_SECURITY_INFORMATION = 0x00000004
    SACL_SECURITY_INFORMATION = 0x00000008
    LABEL_SECURITY_INFORMATION = 0x00000010
    ATTRIBUTE_SECURITY_INFORMATION = 0x00000020
    SCOPE_SECURITY_INFORMATION = 0x00000040
    PROCESS_TRUST_LABEL_SECURITY_INFORMATION = 0x00000080
    ACCESS_FILTER_SECURITY_INFORMATION = 0x00000100
    BACKUP_SECURITY_INFORMATION = 0x00010000
    PROTECTED_DACL_SECURITY_INFORMATION = 0x80000000
    PROTECTED_SACL_SECURITY_INFORMATION = 0x40000000
    UNPROTECTED_DACL_SECURITY_INFORMATION = 0x20000000
    UNPROTECTED_SACL_SECURITY_INFORMATION = 0x10000000

    SE_SIGNING_LEVEL = BYTE
    PSE_SIGNING_LEVEL = POINTER(BYTE)

    # Base signing levels.
    SE_SIGNING_LEVEL_UNCHECKED = 0x00000000
    SE_SIGNING_LEVEL_UNSIGNED = 0x00000001
    SE_SIGNING_LEVEL_ENTERPRISE = 0x00000002
    SE_SIGNING_LEVEL_CUSTOM_1 = 0x00000003
    SE_SIGNING_LEVEL_AUTHENTICODE = 0x00000004
    SE_SIGNING_LEVEL_CUSTOM_2 = 0x00000005
    SE_SIGNING_LEVEL_STORE = 0x00000006
    SE_SIGNING_LEVEL_CUSTOM_3 = 0x00000007
    SE_SIGNING_LEVEL_ANTIMALWARE = SE_SIGNING_LEVEL_CUSTOM_3
    SE_SIGNING_LEVEL_MICROSOFT = 0x00000008
    SE_SIGNING_LEVEL_CUSTOM_4 = 0x00000009
    SE_SIGNING_LEVEL_CUSTOM_5 = 0x0000000A
    SE_SIGNING_LEVEL_DYNAMIC_CODEGEN = 0x0000000B
    SE_SIGNING_LEVEL_WINDOWS = 0x0000000C
    SE_SIGNING_LEVEL_CUSTOM_7 = 0x0000000D
    SE_SIGNING_LEVEL_WINDOWS_TCB = 0x0000000E
    SE_SIGNING_LEVEL_CUSTOM_6 = 0x0000000F


    # Image signature types.
    class _SE_IMAGE_SIGNATURE_TYPE(ENUM):
        SeImageSignatureNone = 0
        SeImageSignatureEmbedded = 1
        SeImageSignatureCache = 2
        SeImageSignatureCatalogCached = 3
        SeImageSignatureCatalogNotCached = 4
        SeImageSignatureCatalogHint = 5
        SeImageSignaturePackageCatalog = 6


    SE_IMAGE_SIGNATURE_TYPE = _SE_IMAGE_SIGNATURE_TYPE
    PSE_IMAGE_SIGNATURE_TYPE = POINTER(_SE_IMAGE_SIGNATURE_TYPE)


    # Learning Mode Types.
    class _SE_LEARNING_MODE_DATA_TYPE(ENUM):
        SeLearningModeInvalidType = 0
        SeLearningModeSettings = 1
        SeLearningModeMax = 2


    SE_LEARNING_MODE_DATA_TYPE = _SE_LEARNING_MODE_DATA_TYPE
    SE_LEARNING_MODE_FLAG_PERMISSIVE = 0x00000001

    _TEMP__SECURITY_CAPABILITIES = [
    ]
    if defined(MIDL_PASS):
        _TEMP__SECURITY_CAPABILITIES += [
            ('AppContainerSid', PISID),
            ('Capabilities', PSID_AND_ATTRIBUTES),
        ]
    else:  # MIDL_PASS
        _TEMP__SECURITY_CAPABILITIES += [
            ('AppContainerSid', PSID),
            ('Capabilities', PSID_AND_ATTRIBUTES),
        ]
        # END IF   MIDL_PASS
        _TEMP__SECURITY_CAPABILITIES += [
            ('CapabilityCount', DWORD),
            ('Reserved', DWORD),
        ]
    _SECURITY_CAPABILITIES._fields_ = _TEMP__SECURITY_CAPABILITIES

    PROCESS_TERMINATE = 0x0001
    PROCESS_CREATE_THREAD = 0x0002
    PROCESS_SET_SESSIONID = 0x0004
    PROCESS_VM_OPERATION = 0x0008
    PROCESS_VM_READ = 0x0010
    PROCESS_VM_WRITE = 0x0020
    PROCESS_DUP_HANDLE = 0x0040
    PROCESS_CREATE_PROCESS = 0x0080
    PROCESS_SET_QUOTA = 0x0100
    PROCESS_SET_INFORMATION = 0x0200
    PROCESS_QUERY_INFORMATION = 0x0400
    PROCESS_SUSPEND_RESUME = 0x0800
    PROCESS_QUERY_LIMITED_INFORMATION = 0x1000
    PROCESS_SET_LIMITED_INFORMATION = 0x2000
    if NTDDI_VERSION >= NTDDI_VISTA:
        PROCESS_ALL_ACCESS = (
            STANDARD_RIGHTS_REQUIRED |
            SYNCHRONIZE |
            0xFFFF
        )
    else:
        PROCESS_ALL_ACCESS = (
            STANDARD_RIGHTS_REQUIRED |
            SYNCHRONIZE |
            0xFFF
        )
    # END IF
    THREAD_TERMINATE = 0x0001
    THREAD_SUSPEND_RESUME = 0x0002
    THREAD_GET_CONTEXT = 0x0008
    THREAD_SET_CONTEXT = 0x0010
    THREAD_QUERY_INFORMATION = 0x0040
    THREAD_SET_INFORMATION = 0x0020
    THREAD_SET_THREAD_TOKEN = 0x0080
    THREAD_IMPERSONATE = 0x0100
    THREAD_DIRECT_IMPERSONATION = 0x0200

    # begin_wdm
    THREAD_SET_LIMITED_INFORMATION = 0x0400            # winnt
    THREAD_QUERY_LIMITED_INFORMATION = 0x0800            # winnt
    THREAD_RESUME = 0x1000            # winnt
    if NTDDI_VERSION >= NTDDI_VISTA:
        THREAD_ALL_ACCESS = (
            STANDARD_RIGHTS_REQUIRED |
            SYNCHRONIZE |
            0xFFFF
        )
    else:
        THREAD_ALL_ACCESS = (
            STANDARD_RIGHTS_REQUIRED |
            SYNCHRONIZE |
            0x3FF
        )
    # END IF
    JOB_OBJECT_ASSIGN_PROCESS = 0x0001
    JOB_OBJECT_SET_ATTRIBUTES = 0x0002
    JOB_OBJECT_QUERY = 0x0004
    JOB_OBJECT_TERMINATE = 0x0008
    JOB_OBJECT_SET_SECURITY_ATTRIBUTES = 0x0010
    JOB_OBJECT_IMPERSONATE = 0x0020
    JOB_OBJECT_ALL_ACCESS = (
        STANDARD_RIGHTS_REQUIRED |
        SYNCHRONIZE |
        0x3F
    )

    # end_access
    _JOB_SET_ARRAY._fields_ = [
        # Handle to job object to insert
        ('JobHandle', HANDLE),
        # Level of this job in the set. Must be > 0. Can be sparse.
        ('MemberLevel', DWORD),
        # Unused. Must be zero
        ('Flags', DWORD),
    ]
    FLS_MAXIMUM_AVAILABLE = 128
    TLS_MINIMUM_AVAILABLE = 64

    _EXCEPTION_REGISTRATION_RECORD._fields_ = [
        ('Next', POINTER(_EXCEPTION_REGISTRATION_RECORD)),
        ('Handler', PEXCEPTION_ROUTINE),
    ]

    PEXCEPTION_REGISTRATION_RECORD = POINTER(EXCEPTION_REGISTRATION_RECORD)

    if defined(_MSC_EXTENSIONS):
        class _Union_1(ctypes.Union):
            pass


        _Union_1._fields_ = [
            ('FiberData', PVOID),
            ('Version', DWORD),
        ]
        _NT_TIB._Union_1 = _Union_1

        _NT_TIB._anonymous_ = (
            '_Union_1',
        )

    _TEMP__NT_TIB = [
        ('ExceptionList', POINTER(_EXCEPTION_REGISTRATION_RECORD)),
        ('StackBase', PVOID),
        ('StackLimit', PVOID),
        ('SubSystemTib', PVOID),
    ]
    if defined(_MSC_EXTENSIONS):
        _TEMP__NT_TIB += [
            ('_Union_1', _NT_TIB._Union_1),
        ]
    else:
        _TEMP__NT_TIB += [
            ('FiberData', PVOID),
        ]
    # END IF

    _TEMP__NT_TIB += [
        ('ArbitraryUserPointer', PVOID),
        ('Self', POINTER(_NT_TIB)),
    ]
    _NT_TIB._fields_ = _TEMP__NT_TIB

    # 32 and 64 bit specific version for wow64 and the debugger
    if defined(_MSC_EXTENSIONS):
        class _Union_2(ctypes.Union):
            pass


        _Union_2._fields_ = [
            ('FiberData', DWORD),
            ('Version', DWORD),
        ]
        _NT_TIB32._Union_2 = _Union_2

        _NT_TIB32._anonymous_ = (
            '_Union_2',
        )

    _TEMP__NT_TIB32 = [
        ('ExceptionList', DWORD),
        ('StackBase', DWORD),
        ('StackLimit', DWORD),
        ('SubSystemTib', DWORD),
    ]
    if defined(_MSC_EXTENSIONS):
        _TEMP__NT_TIB32 += [
            ('_Union_2', _NT_TIB32._Union_2),
        ]
    else:
        _TEMP__NT_TIB32 += [
            ('FiberData', DWORD),
        ]
    # END IF

    _TEMP__NT_TIB32 += [
        ('ArbitraryUserPointer', DWORD),
        ('Self', DWORD),
    ]
    _NT_TIB32._fields_ = _TEMP__NT_TIB32

    if defined(_MSC_EXTENSIONS):
        class _Union_3(ctypes.Union):
            pass

        _Union_3._fields_ = [
            ('FiberData', DWORD64),
            ('Version', DWORD),
        ]
        _NT_TIB64._Union_3 = _Union_3

        _NT_TIB64._anonymous_ = (
            '_Union_3',
        )

    _TEMP__NT_TIB64 = [
        ('ExceptionList', DWORD64),
        ('StackBase', DWORD64),
        ('StackLimit', DWORD64),
        ('SubSystemTib', DWORD64),
    ]
    if defined(_MSC_EXTENSIONS):
        _TEMP__NT_TIB64 += [
            ('_Union_3', _NT_TIB64._Union_3),
        ]
    else:
        _TEMP__NT_TIB64 += [
            ('FiberData', DWORD64),
        ]
    # END IF

    _TEMP__NT_TIB64 += [
        ('ArbitraryUserPointer', DWORD64),
        ('Self', DWORD64),
    ]
    _NT_TIB64._fields_ = _TEMP__NT_TIB64

    THREAD_DYNAMIC_CODE_ALLOW = 1            # Opt - out of dynamic code generation.
    THREAD_BASE_PRIORITY_LOWRT = 15            # value that gets a thread to LowRealtime - 1
    THREAD_BASE_PRIORITY_MAX = 2            # maximum thread base priority boost
    THREAD_BASE_PRIORITY_MIN = - 2            # minimum thread base priority boost
    THREAD_BASE_PRIORITY_IDLE = - 15            # value that gets a thread to idle


    _UMS_CREATE_THREAD_ATTRIBUTES._fields_ = [
        ('UmsVersion', DWORD),
        ('UmsContext', PVOID),
        ('UmsCompletionList', PVOID),
    ]

    _WOW64_ARCHITECTURE_INFORMATION._fields_ = [
        ('Machine', DWORD, 16),
        ('KernelMode', DWORD, 1),
        ('UserMode', DWORD, 1),
        ('Native', DWORD, 1),
        ('Process', DWORD, 1),
        ('ReservedZero0', DWORD, 12),
    ]


    # Page/memory priorities.
    MEMORY_PRIORITY_LOWEST = 0
    MEMORY_PRIORITY_VERY_LOW = 1
    MEMORY_PRIORITY_LOW = 2
    MEMORY_PRIORITY_MEDIUM = 3
    MEMORY_PRIORITY_BELOW_NORMAL = 4
    MEMORY_PRIORITY_NORMAL = 5


    _QUOTA_LIMITS._fields_ = [
        ('PagedPoolLimit', SIZE_T),
        ('NonPagedPoolLimit', SIZE_T),
        ('MinimumWorkingSetSize', SIZE_T),
        ('MaximumWorkingSetSize', SIZE_T),
        ('PagefileLimit', SIZE_T),
        ('TimeLimit', LARGE_INTEGER),
    ]
    QUOTA_LIMITS_HARDWS_MIN_ENABLE = 0x00000001
    QUOTA_LIMITS_HARDWS_MIN_DISABLE = 0x00000002
    QUOTA_LIMITS_HARDWS_MAX_ENABLE = 0x00000004
    QUOTA_LIMITS_HARDWS_MAX_DISABLE = 0x00000008
    QUOTA_LIMITS_USE_DEFAULT_LIMITS = 0x00000010


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('RatePercent', DWORD, 7),
        ('Reserved0', DWORD, 25),
    ]
    _RATE_QUOTA_LIMIT.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


    _RATE_QUOTA_LIMIT._fields_ = [
        ('RateData', DWORD),
        ('DUMMYSTRUCTNAME', _RATE_QUOTA_LIMIT.DUMMYSTRUCTNAME),
    ]

    _QUOTA_LIMITS_EX._fields_ = [
        ('PagedPoolLimit', SIZE_T),
        ('NonPagedPoolLimit', SIZE_T),
        ('MinimumWorkingSetSize', SIZE_T),
        ('MaximumWorkingSetSize', SIZE_T),
        # Limit expressed in pages
        ('PagefileLimit', SIZE_T),
        ('TimeLimit', LARGE_INTEGER),
        # Limit expressed in pages
        ('WorkingSetLimit', SIZE_T),
        ('Reserved2', SIZE_T),
        ('Reserved3', SIZE_T),
        ('Reserved4', SIZE_T),
        ('Flags', DWORD),
        ('CpuRateLimit', RATE_QUOTA_LIMIT),
    ]

    _IO_COUNTERS._fields_ = [
        ('ReadOperationCount', ULONGLONG),
        ('WriteOperationCount', ULONGLONG),
        ('OtherOperationCount', ULONGLONG),
        ('ReadTransferCount', ULONGLONG),
        ('WriteTransferCount', ULONGLONG),
        ('OtherTransferCount', ULONGLONG),
    ]
    MAX_HW_COUNTERS = 16
    THREAD_PROFILING_FLAG_DISPATCH = 0x00000001


    class _HARDWARE_COUNTER_TYPE(ENUM):
        PMCCounter = 1
        MaxHardwareCounterType = 2

    HARDWARE_COUNTER_TYPE = _HARDWARE_COUNTER_TYPE
    PHARDWARE_COUNTER_TYPE = POINTER(_HARDWARE_COUNTER_TYPE)


    class _PROCESS_MITIGATION_POLICY(ENUM):
        ProcessDEPPolicy = 1
        ProcessASLRPolicy = 2
        ProcessDynamicCodePolicy = 3
        ProcessStrictHandleCheckPolicy = 4
        ProcessSystemCallDisablePolicy = 5
        ProcessMitigationOptionsMask = 6
        ProcessExtensionPointDisablePolicy = 7
        ProcessControlFlowGuardPolicy = 8
        ProcessSignaturePolicy = 9
        ProcessFontDisablePolicy = 10
        ProcessImageLoadPolicy = 11
        ProcessSystemCallFilterPolicy = 12
        ProcessPayloadRestrictionPolicy = 13
        ProcessChildProcessPolicy = 14
        MaxProcessMitigationPolicy = 15

    PROCESS_MITIGATION_POLICY = _PROCESS_MITIGATION_POLICY
    PPROCESS_MITIGATION_POLICY = POINTER(_PROCESS_MITIGATION_POLICY)


    # N.B. High entropy mode is read only and can only be set at
    # creation time
    # and not via the ProcessMitigationPolicy APIs.
    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('EnableBottomUpRandomization', DWORD, 1),
        ('EnableForceRelocateImages', DWORD, 1),
        ('EnableHighEntropy', DWORD, 1),
        ('DisallowStrippedImages', DWORD, 1),
        ('ReservedFlags', DWORD, 28),
    ]
    DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


    DUMMYUNIONNAME._fields_ = [
        ('Flags', DWORD),
        ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
    ]
    _PROCESS_MITIGATION_ASLR_POLICY.DUMMYUNIONNAME = DUMMYUNIONNAME


    _PROCESS_MITIGATION_ASLR_POLICY._fields_ = [
        ('DUMMYUNIONNAME', _PROCESS_MITIGATION_ASLR_POLICY.DUMMYUNIONNAME),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('Enable', DWORD, 1),
        ('DisableAtlThunkEmulation', DWORD, 1),
        ('ReservedFlags', DWORD, 30),
    ]
    DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


    DUMMYUNIONNAME._fields_ = [
        ('Flags', DWORD),
        ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
    ]
    _PROCESS_MITIGATION_DEP_POLICY.DUMMYUNIONNAME = DUMMYUNIONNAME


    _PROCESS_MITIGATION_DEP_POLICY._fields_ = [
        ('DUMMYUNIONNAME', _PROCESS_MITIGATION_DEP_POLICY.DUMMYUNIONNAME),
        ('Permanent', BOOLEAN),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('RaiseExceptionOnInvalidHandleReference', DWORD, 1),
        ('HandleExceptionsPermanentlyEnabled', DWORD, 1),
        ('ReservedFlags', DWORD, 30),
    ]
    DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


    DUMMYUNIONNAME._fields_ = [
        ('Flags', DWORD),
        ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
    ]
    _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY.DUMMYUNIONNAME = DUMMYUNIONNAME


    _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY._fields_ = [
        ('DUMMYUNIONNAME', _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY.DUMMYUNIONNAME),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('DisallowWin32kSystemCalls', DWORD, 1),
        ('AuditDisallowWin32kSystemCalls', DWORD, 1),
        ('ReservedFlags', DWORD, 30),
    ]
    DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


    DUMMYUNIONNAME._fields_ = [
        ('Flags', DWORD),
        ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
    ]
    _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY.DUMMYUNIONNAME = DUMMYUNIONNAME


    _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY._fields_ = [
        ('DUMMYUNIONNAME', _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY.DUMMYUNIONNAME),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('DisableExtensionPoints', DWORD, 1),
        ('ReservedFlags', DWORD, 31),
    ]
    DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


    DUMMYUNIONNAME._fields_ = [
        ('Flags', DWORD),
        ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
    ]
    _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY.DUMMYUNIONNAME = DUMMYUNIONNAME


    _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY._fields_ = [
        ('DUMMYUNIONNAME', _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY.DUMMYUNIONNAME),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('ProhibitDynamicCode', DWORD, 1),
        ('AllowThreadOptOut', DWORD, 1),
        ('AllowRemoteDowngrade', DWORD, 1),
        ('AuditProhibitDynamicCode', DWORD, 1),
        ('ReservedFlags', DWORD, 28),
    ]
    DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


    DUMMYUNIONNAME._fields_ = [
        ('Flags', DWORD),
        ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
    ]
    _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY.DUMMYUNIONNAME = DUMMYUNIONNAME


    _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY._fields_ = [
        ('DUMMYUNIONNAME', _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY.DUMMYUNIONNAME),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('EnableControlFlowGuard', DWORD, 1),
        ('EnableExportSuppression', DWORD, 1),
        ('StrictMode', DWORD, 1),
        ('ReservedFlags', DWORD, 29),
    ]
    DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


    DUMMYUNIONNAME._fields_ = [
        ('Flags', DWORD),
        ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
    ]
    _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY.DUMMYUNIONNAME = DUMMYUNIONNAME


    _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY._fields_ = [
        ('DUMMYUNIONNAME', _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY.DUMMYUNIONNAME),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('MicrosoftSignedOnly', DWORD, 1),
        ('StoreSignedOnly', DWORD, 1),
        ('MitigationOptIn', DWORD, 1),
        ('AuditMicrosoftSignedOnly', DWORD, 1),
        ('AuditStoreSignedOnly', DWORD, 1),
        ('ReservedFlags', DWORD, 27),
    ]
    DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


    DUMMYUNIONNAME._fields_ = [
        ('Flags', DWORD),
        ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
    ]
    _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY.DUMMYUNIONNAME = DUMMYUNIONNAME


    _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY._fields_ = [
        ('DUMMYUNIONNAME', _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY.DUMMYUNIONNAME),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('DisableNonSystemFonts', DWORD, 1),
        ('AuditNonSystemFontLoading', DWORD, 1),
        ('ReservedFlags', DWORD, 30),
    ]
    DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


    DUMMYUNIONNAME._fields_ = [
        ('Flags', DWORD),
        ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
    ]
    _PROCESS_MITIGATION_FONT_DISABLE_POLICY.DUMMYUNIONNAME = DUMMYUNIONNAME


    _PROCESS_MITIGATION_FONT_DISABLE_POLICY._fields_ = [
        ('DUMMYUNIONNAME', _PROCESS_MITIGATION_FONT_DISABLE_POLICY.DUMMYUNIONNAME),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('NoRemoteImages', DWORD, 1),
        ('NoLowMandatoryLabelImages', DWORD, 1),
        ('PreferSystem32Images', DWORD, 1),
        ('AuditNoRemoteImages', DWORD, 1),
        ('AuditNoLowMandatoryLabelImages', DWORD, 1),
        ('ReservedFlags', DWORD, 27),
    ]
    DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


    DUMMYUNIONNAME._fields_ = [
        ('Flags', DWORD),
        ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
    ]
    _PROCESS_MITIGATION_IMAGE_LOAD_POLICY.DUMMYUNIONNAME = DUMMYUNIONNAME


    _PROCESS_MITIGATION_IMAGE_LOAD_POLICY._fields_ = [
        ('DUMMYUNIONNAME', _PROCESS_MITIGATION_IMAGE_LOAD_POLICY.DUMMYUNIONNAME),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('FilterId', DWORD, 4),
        ('ReservedFlags', DWORD, 28),
    ]
    DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


    DUMMYUNIONNAME._fields_ = [
        ('Flags', DWORD),
        ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
    ]
    _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY.DUMMYUNIONNAME = DUMMYUNIONNAME


    _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY._fields_ = [
        ('DUMMYUNIONNAME', _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY.DUMMYUNIONNAME),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('EnableExportAddressFilter', DWORD, 1),
        ('AuditExportAddressFilter', DWORD, 1),
        ('EnableExportAddressFilterPlus', DWORD, 1),
        ('AuditExportAddressFilterPlus', DWORD, 1),
        ('EnableImportAddressFilter', DWORD, 1),
        ('AuditImportAddressFilter', DWORD, 1),
        ('EnableRopStackPivot', DWORD, 1),
        ('AuditRopStackPivot', DWORD, 1),
        ('EnableRopCallerCheck', DWORD, 1),
        ('AuditRopCallerCheck', DWORD, 1),
        ('EnableRopSimExec', DWORD, 1),
        ('AuditRopSimExec', DWORD, 1),
        ('ReservedFlags', DWORD, 20),
    ]
    DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


    DUMMYUNIONNAME._fields_ = [
        ('Flags', DWORD),
        ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
    ]
    _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY.DUMMYUNIONNAME = DUMMYUNIONNAME


    _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY._fields_ = [
        ('DUMMYUNIONNAME', _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY.DUMMYUNIONNAME),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('NoChildProcessCreation', DWORD, 1),
        ('AuditNoChildProcessCreation', DWORD, 1),
        ('AllowSecureProcessCreation', DWORD, 1),
        ('ReservedFlags', DWORD, 29),
    ]
    DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


    DUMMYUNIONNAME._fields_ = [
        ('Flags', DWORD),
        ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
    ]
    _PROCESS_MITIGATION_CHILD_PROCESS_POLICY.DUMMYUNIONNAME = DUMMYUNIONNAME


    _PROCESS_MITIGATION_CHILD_PROCESS_POLICY._fields_ = [
        ('DUMMYUNIONNAME', _PROCESS_MITIGATION_CHILD_PROCESS_POLICY.DUMMYUNIONNAME),
    ]

    _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION._fields_ = [
        ('TotalUserTime', LARGE_INTEGER),
        ('TotalKernelTime', LARGE_INTEGER),
        ('ThisPeriodTotalUserTime', LARGE_INTEGER),
        ('ThisPeriodTotalKernelTime', LARGE_INTEGER),
        ('TotalPageFaultCount', DWORD),
        ('TotalProcesses', DWORD),
        ('ActiveProcesses', DWORD),
        ('TotalTerminatedProcesses', DWORD),
    ]

    _JOBOBJECT_BASIC_LIMIT_INFORMATION._fields_ = [
        ('PerProcessUserTimeLimit', LARGE_INTEGER),
        ('PerJobUserTimeLimit', LARGE_INTEGER),
        ('LimitFlags', DWORD),
        ('MinimumWorkingSetSize', SIZE_T),
        ('MaximumWorkingSetSize', SIZE_T),
        ('ActiveProcessLimit', DWORD),
        ('Affinity', ULONG_PTR),
        ('PriorityClass', DWORD),
        ('SchedulingClass', DWORD),
    ]

    _JOBOBJECT_EXTENDED_LIMIT_INFORMATION._fields_ = [
        ('BasicLimitInformation', JOBOBJECT_BASIC_LIMIT_INFORMATION),
        ('IoInfo', IO_COUNTERS),
        ('ProcessMemoryLimit', SIZE_T),
        ('JobMemoryLimit', SIZE_T),
        ('PeakProcessMemoryUsed', SIZE_T),
        ('PeakJobMemoryUsed', SIZE_T),
    ]

    _JOBOBJECT_BASIC_PROCESS_ID_LIST._fields_ = [
        ('NumberOfAssignedProcesses', DWORD),
        ('NumberOfProcessIdsInList', DWORD),
        ('ProcessIdList', ULONG_PTR * 1),
    ]

    _JOBOBJECT_BASIC_UI_RESTRICTIONS._fields_ = [
        ('UIRestrictionsClass', DWORD),
    ]


    # N.B. The JOBOBJECT_SECURITY_LIMIT_INFORMATION information class
    # is no longer supported.
    _JOBOBJECT_SECURITY_LIMIT_INFORMATION._fields_ = [
        ('SecurityLimitFlags', DWORD),
        ('JobToken', HANDLE),
        ('SidsToDisable', PTOKEN_GROUPS),
        ('PrivilegesToDelete', PTOKEN_PRIVILEGES),
        ('RestrictedSids', PTOKEN_GROUPS),
    ]

    _JOBOBJECT_END_OF_JOB_TIME_INFORMATION._fields_ = [
        ('EndOfJobTimeAction', DWORD),
    ]

    _JOBOBJECT_ASSOCIATE_COMPLETION_PORT._fields_ = [
        ('CompletionKey', PVOID),
        ('CompletionPort', HANDLE),
    ]

    _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION._fields_ = [
        ('BasicInfo', JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
        ('IoInfo', IO_COUNTERS),
    ]

    _JOBOBJECT_JOBSET_INFORMATION._fields_ = [
        ('MemberLevel', DWORD),
    ]


    class _JOBOBJECT_RATE_CONTROL_TOLERANCE(ENUM):
        ToleranceLow = 1
        ToleranceMedium = 2
        ToleranceHigh = 3

    JOBOBJECT_RATE_CONTROL_TOLERANCE = _JOBOBJECT_RATE_CONTROL_TOLERANCE
    PJOBOBJECT_RATE_CONTROL_TOLERANCE = POINTER(_JOBOBJECT_RATE_CONTROL_TOLERANCE)


    class _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL(ENUM):
        ToleranceIntervalShort = 1
        ToleranceIntervalMedium = 2
        ToleranceIntervalLong = 3
        #~#~#~ *PJOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL;
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL = _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL
    PJOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL = POINTER(_JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL)

    _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION._fields_ = [
        ('IoReadBytesLimit', DWORD64),
        ('IoWriteBytesLimit', DWORD64),
        ('PerJobUserTimeLimit', LARGE_INTEGER),
        ('JobMemoryLimit', DWORD64),
        ('RateControlTolerance', JOBOBJECT_RATE_CONTROL_TOLERANCE),
        ('RateControlToleranceInterval', JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL),
        ('LimitFlags', DWORD),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    DUMMYUNIONNAME._fields_ = [
        ('JobHighMemoryLimit', DWORD64),
        ('JobMemoryLimit', DWORD64),
    ]
    JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2.DUMMYUNIONNAME = DUMMYUNIONNAME


    class DUMMYUNIONNAME2(ctypes.Union):
        pass


    DUMMYUNIONNAME2._fields_ = [
        ('RateControlTolerance', JOBOBJECT_RATE_CONTROL_TOLERANCE),
        ('CpuRateControlTolerance', JOBOBJECT_RATE_CONTROL_TOLERANCE),
    ]
    JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2.DUMMYUNIONNAME2 = DUMMYUNIONNAME2


    class DUMMYUNIONNAME3(ctypes.Union):
        pass


    DUMMYUNIONNAME3._fields_ = [
        ('RateControlToleranceInterval', JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL),
    ]
    JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2.DUMMYUNIONNAME3 = DUMMYUNIONNAME3


    JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2._fields_ = [
        ('IoReadBytesLimit', DWORD64),
        ('IoWriteBytesLimit', DWORD64),
        ('PerJobUserTimeLimit', LARGE_INTEGER),
        ('DUMMYUNIONNAME', JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2.DUMMYUNIONNAME),
        ('DUMMYUNIONNAME2', JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2.DUMMYUNIONNAME2),
        ('DUMMYUNIONNAME3', JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2.DUMMYUNIONNAME3),
        ('LimitFlags', DWORD),
        ('IoRateControlTolerance', JOBOBJECT_RATE_CONTROL_TOLERANCE),
        ('JobLowMemoryLimit', DWORD64),
        ('IoRateControlToleranceInterval', JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL),
        ('NetRateControlTolerance', JOBOBJECT_RATE_CONTROL_TOLERANCE),
        ('NetRateControlToleranceInterval', JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL),
    ]

    _JOBOBJECT_LIMIT_VIOLATION_INFORMATION._fields_ = [
        ('LimitFlags', DWORD),
        ('ViolationLimitFlags', DWORD),
        ('IoReadBytes', DWORD64),
        ('IoReadBytesLimit', DWORD64),
        ('IoWriteBytes', DWORD64),
        ('IoWriteBytesLimit', DWORD64),
        ('PerJobUserTime', LARGE_INTEGER),
        ('PerJobUserTimeLimit', LARGE_INTEGER),
        ('JobMemory', DWORD64),
        ('JobMemoryLimit', DWORD64),
        ('RateControlTolerance', JOBOBJECT_RATE_CONTROL_TOLERANCE),
        ('RateControlToleranceLimit', JOBOBJECT_RATE_CONTROL_TOLERANCE),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    DUMMYUNIONNAME._fields_ = [
        ('JobHighMemoryLimit', DWORD64),
        ('JobMemoryLimit', DWORD64),
    ]
    JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2.DUMMYUNIONNAME = DUMMYUNIONNAME


    class DUMMYUNIONNAME2(ctypes.Union):
        pass


    DUMMYUNIONNAME2._fields_ = [
        ('RateControlTolerance', JOBOBJECT_RATE_CONTROL_TOLERANCE),
        ('CpuRateControlTolerance', JOBOBJECT_RATE_CONTROL_TOLERANCE),
    ]
    JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2.DUMMYUNIONNAME2 = DUMMYUNIONNAME2


    class DUMMYUNIONNAME3(ctypes.Union):
        pass


    DUMMYUNIONNAME3._fields_ = [
        ('RateControlToleranceLimit', JOBOBJECT_RATE_CONTROL_TOLERANCE),
        ('CpuRateControlToleranceLimit', JOBOBJECT_RATE_CONTROL_TOLERANCE),
    ]
    JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2.DUMMYUNIONNAME3 = DUMMYUNIONNAME3


    JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2._fields_ = [
        ('LimitFlags', DWORD),
        ('ViolationLimitFlags', DWORD),
        ('IoReadBytes', DWORD64),
        ('IoReadBytesLimit', DWORD64),
        ('IoWriteBytes', DWORD64),
        ('IoWriteBytesLimit', DWORD64),
        ('PerJobUserTime', LARGE_INTEGER),
        ('PerJobUserTimeLimit', LARGE_INTEGER),
        ('JobMemory', DWORD64),
        ('DUMMYUNIONNAME', JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2.DUMMYUNIONNAME),
        ('DUMMYUNIONNAME2', JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2.DUMMYUNIONNAME2),
        ('DUMMYUNIONNAME3', JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2.DUMMYUNIONNAME3),
        ('JobLowMemoryLimit', DWORD64),
        ('IoRateControlTolerance', JOBOBJECT_RATE_CONTROL_TOLERANCE),
        ('IoRateControlToleranceLimit', JOBOBJECT_RATE_CONTROL_TOLERANCE),
        ('NetRateControlTolerance', JOBOBJECT_RATE_CONTROL_TOLERANCE),
        ('NetRateControlToleranceLimit', JOBOBJECT_RATE_CONTROL_TOLERANCE),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('MinRate', WORD),
        ('MaxRate', WORD),
    ]
    DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


    DUMMYUNIONNAME._fields_ = [
        ('CpuRate', DWORD),
        ('Weight', DWORD),
        ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
    ]
    _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION.DUMMYUNIONNAME = DUMMYUNIONNAME


    _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION._fields_ = [
        ('ControlFlags', DWORD),
        ('DUMMYUNIONNAME', _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION.DUMMYUNIONNAME),
    ]


    # Control flags for network rate control.
    class JOB_OBJECT_NET_RATE_CONTROL_FLAGS(ENUM):
        JOB_OBJECT_NET_RATE_CONTROL_ENABLE = 0x1
        JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH = 0x2
        JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG = 0x4
        JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS = 0x7

    if not defined(SORTPP_PASS) and not defined(MIDL_PASS) and not defined(RC_INVOKED):
        pass
    # END IF
    JOB_OBJECT_NET_RATE_CONTROL_MAX_DSCP_TAG = 64


    JOBOBJECT_NET_RATE_CONTROL_INFORMATION._fields_ = [
        ('MaxBandwidth', DWORD64),
        ('ControlFlags', JOB_OBJECT_NET_RATE_CONTROL_FLAGS),
        ('DscpTag', BYTE),
    ]


    # Control flags for IO rate control.
    # begin_ntosifs


    class JOB_OBJECT_IO_RATE_CONTROL_FLAGS(ENUM):
        JOB_OBJECT_IO_RATE_CONTROL_ENABLE = 0x1
        JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME = 0x2
        JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL = 0x4
        JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP = 0x8
        JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS = (
            JOB_OBJECT_IO_RATE_CONTROL_ENABLE  |
            JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME  |
            JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL  |
            JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP
        )

    if not defined(SORTPP_PASS) and not defined(MIDL_PASS) and not defined(RC_INVOKED):
        pass
    # END IF

    JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE._fields_ = [
        ('MaxIops', LONG64),
        ('MaxBandwidth', LONG64),
        ('ReservationIops', LONG64),
        ('VolumeName', PWSTR),
        ('BaseIoSize', DWORD),
        ('ControlFlags', JOB_OBJECT_IO_RATE_CONTROL_FLAGS),
        ('VolumeNameLength', WORD),
    ]

    JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2._fields_ = [
        ('MaxIops', LONG64),
        ('MaxBandwidth', LONG64),
        ('ReservationIops', LONG64),
        ('VolumeName', PWSTR),
        ('BaseIoSize', DWORD),
        ('ControlFlags', JOB_OBJECT_IO_RATE_CONTROL_FLAGS),
        ('VolumeNameLength', WORD),
        ('CriticalReservationIops', LONG64),
        ('ReservationBandwidth', LONG64),
        ('CriticalReservationBandwidth', LONG64),
        ('MaxTimePercent', LONG64),
        ('ReservationTimePercent', LONG64),
        ('CriticalReservationTimePercent', LONG64),
    ]

    JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3._fields_ = [
        ('MaxIops', LONG64),
        ('MaxBandwidth', LONG64),
        ('ReservationIops', LONG64),
        ('VolumeName', PWSTR),
        ('BaseIoSize', DWORD),
        ('ControlFlags', JOB_OBJECT_IO_RATE_CONTROL_FLAGS),
        ('VolumeNameLength', WORD),
        ('CriticalReservationIops', LONG64),
        ('ReservationBandwidth', LONG64),
        ('CriticalReservationBandwidth', LONG64),
        ('MaxTimePercent', LONG64),
        ('ReservationTimePercent', LONG64),
        ('CriticalReservationTimePercent', LONG64),
        ('SoftMaxIops', LONG64),
        ('SoftMaxBandwidth', LONG64),
        ('SoftMaxTimePercent', LONG64),
        ('LimitExcessNotifyIops', LONG64),
        ('LimitExcessNotifyBandwidth', LONG64),
        ('LimitExcessNotifyTimePercent', LONG64),
    ]

    # end_ntosifs
    class JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS(ENUM):
        JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE = 0x1
        JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE = 0x2
        JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS = 0x3

    _JOBOBJECT_IO_ATTRIBUTION_STATS._fields_ = [
        ('IoCount', ULONG_PTR),
        ('TotalNonOverlappedQueueTime', ULONGLONG),
        ('TotalNonOverlappedServiceTime', ULONGLONG),
        ('TotalSize', ULONGLONG),
    ]

    _JOBOBJECT_IO_ATTRIBUTION_INFORMATION._fields_ = [
        ('ControlFlags', DWORD),
        ('ReadStats', JOBOBJECT_IO_ATTRIBUTION_STATS),
        ('WriteStats', JOBOBJECT_IO_ATTRIBUTION_STATS),
    ]
    JOB_OBJECT_TERMINATE_AT_END_OF_JOB = 0
    JOB_OBJECT_POST_AT_END_OF_JOB = 1


    # Completion Port Messages for job objects
    # These values are returned via the lpNumberOfBytesTransferred
    # parameter
    JOB_OBJECT_MSG_END_OF_JOB_TIME = 1
    JOB_OBJECT_MSG_END_OF_PROCESS_TIME = 2
    JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT = 3
    JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO = 4
    JOB_OBJECT_MSG_NEW_PROCESS = 6
    JOB_OBJECT_MSG_EXIT_PROCESS = 7
    JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS = 8
    JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT = 9
    JOB_OBJECT_MSG_JOB_MEMORY_LIMIT = 10
    JOB_OBJECT_MSG_NOTIFICATION_LIMIT = 11
    JOB_OBJECT_MSG_JOB_CYCLE_TIME_LIMIT = 12
    JOB_OBJECT_MSG_SILO_TERMINATED = 13

    # Define the valid notification filter values.
    JOB_OBJECT_MSG_MINIMUM = 1
    JOB_OBJECT_MSG_MAXIMUM = 13
    JOB_OBJECT_VALID_COMPLETION_FILTER = (
        ((1 << (JOB_OBJECT_MSG_MAXIMUM + 1)) - 1) -
        ((1 << JOB_OBJECT_MSG_MINIMUM) - 1)
    )

    # Basic Limits
    JOB_OBJECT_LIMIT_WORKINGSET = 0x00000001
    JOB_OBJECT_LIMIT_PROCESS_TIME = 0x00000002
    JOB_OBJECT_LIMIT_JOB_TIME = 0x00000004
    JOB_OBJECT_LIMIT_ACTIVE_PROCESS = 0x00000008
    JOB_OBJECT_LIMIT_AFFINITY = 0x00000010
    JOB_OBJECT_LIMIT_PRIORITY_CLASS = 0x00000020
    JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME = 0x00000040
    JOB_OBJECT_LIMIT_SCHEDULING_CLASS = 0x00000080

    # Extended Limits
    JOB_OBJECT_LIMIT_PROCESS_MEMORY = 0x00000100
    JOB_OBJECT_LIMIT_JOB_MEMORY = 0x00000200
    JOB_OBJECT_LIMIT_JOB_MEMORY_HIGH = JOB_OBJECT_LIMIT_JOB_MEMORY
    JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION = 0x00000400
    JOB_OBJECT_LIMIT_BREAKAWAY_OK = 0x00000800
    JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK = 0x00001000
    JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE = 0x00002000
    JOB_OBJECT_LIMIT_SUBSET_AFFINITY = 0x00004000
    JOB_OBJECT_LIMIT_JOB_MEMORY_LOW = 0x00008000

    # Notification Limits
    JOB_OBJECT_LIMIT_JOB_READ_BYTES = 0x00010000
    JOB_OBJECT_LIMIT_JOB_WRITE_BYTES = 0x00020000
    JOB_OBJECT_LIMIT_RATE_CONTROL = 0x00040000
    JOB_OBJECT_LIMIT_CPU_RATE_CONTROL = JOB_OBJECT_LIMIT_RATE_CONTROL
    JOB_OBJECT_LIMIT_IO_RATE_CONTROL = 0x00080000
    JOB_OBJECT_LIMIT_NET_RATE_CONTROL = 0x00100000

    # Valid Job Object Limits
    JOB_OBJECT_LIMIT_VALID_FLAGS = 0x0007FFFF
    JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS = 0x000000FF
    JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS = 0x00007FFF
    JOB_OBJECT_NOTIFICATION_LIMIT_VALID_FLAGS = (
        JOB_OBJECT_LIMIT_JOB_READ_BYTES |
        JOB_OBJECT_LIMIT_JOB_WRITE_BYTES |
        JOB_OBJECT_LIMIT_JOB_TIME |
        JOB_OBJECT_LIMIT_JOB_MEMORY_LOW |
        JOB_OBJECT_LIMIT_JOB_MEMORY_HIGH |
        JOB_OBJECT_LIMIT_CPU_RATE_CONTROL |
        JOB_OBJECT_LIMIT_IO_RATE_CONTROL |
        JOB_OBJECT_LIMIT_NET_RATE_CONTROL
    )

    # UI restrictions for jobs
    JOB_OBJECT_UILIMIT_NONE = 0x00000000
    JOB_OBJECT_UILIMIT_HANDLES = 0x00000001
    JOB_OBJECT_UILIMIT_READCLIPBOARD = 0x00000002
    JOB_OBJECT_UILIMIT_WRITECLIPBOARD = 0x00000004
    JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 0x00000008
    JOB_OBJECT_UILIMIT_DISPLAYSETTINGS = 0x00000010
    JOB_OBJECT_UILIMIT_GLOBALATOMS = 0x00000020
    JOB_OBJECT_UILIMIT_DESKTOP = 0x00000040
    JOB_OBJECT_UILIMIT_EXITWINDOWS = 0x00000080
    JOB_OBJECT_UILIMIT_ALL = 0x000000FF
    JOB_OBJECT_UI_VALID_FLAGS = 0x000000FF
    JOB_OBJECT_SECURITY_NO_ADMIN = 0x00000001
    JOB_OBJECT_SECURITY_RESTRICTED_TOKEN = 0x00000002
    JOB_OBJECT_SECURITY_ONLY_TOKEN = 0x00000004
    JOB_OBJECT_SECURITY_FILTER_TOKENS = 0x00000008
    JOB_OBJECT_SECURITY_VALID_FLAGS = 0x0000000F

    # Control flags for CPU rate control.
    JOB_OBJECT_CPU_RATE_CONTROL_ENABLE = 0x1
    JOB_OBJECT_CPU_RATE_CONTROL_WEIGHT_BASED = 0x2
    JOB_OBJECT_CPU_RATE_CONTROL_HARD_CAP = 0x4
    JOB_OBJECT_CPU_RATE_CONTROL_NOTIFY = 0x8
    JOB_OBJECT_CPU_RATE_CONTROL_MIN_MAX_RATE = 0x10
    JOB_OBJECT_CPU_RATE_CONTROL_VALID_FLAGS = 0x1F


    class _JOBOBJECTINFOCLASS(ENUM):
        JobObjectBasicAccountingInformation = 1
        JobObjectBasicLimitInformation = 2
        JobObjectBasicProcessIdList = 3
        JobObjectBasicUIRestrictions = 4
        JobObjectSecurityLimitInformation = 5
        JobObjectEndOfJobTimeInformation = 6
        JobObjectAssociateCompletionPortInformation = 7
        JobObjectBasicAndIoAccountingInformation = 8
        JobObjectExtendedLimitInformation = 9
        JobObjectJobSetInformation = 10
        JobObjectGroupInformation = 11
        JobObjectNotificationLimitInformation = 12
        JobObjectLimitViolationInformation = 13
        JobObjectGroupInformationEx = 14
        JobObjectCpuRateControlInformation = 15
        JobObjectCompletionFilter = 16
        JobObjectCompletionCounter = 17
        JobObjectReserved1Information = 18
        JobObjectReserved2Information = 19
        JobObjectReserved3Information = 20
        JobObjectReserved4Information = 21
        JobObjectReserved5Information = 22
        JobObjectReserved6Information = 23
        JobObjectReserved7Information = 24
        JobObjectReserved8Information = 25
        JobObjectReserved9Information = 26
        JobObjectReserved10Information = 27
        JobObjectReserved11Information = 28
        JobObjectReserved12Information = 29
        JobObjectReserved13Information = 30
        JobObjectReserved14Information = 31
        JobObjectNetRateControlInformation = 32
        JobObjectNotificationLimitInformation2 = 33
        JobObjectLimitViolationInformation2 = 34
        JobObjectCreateSilo = 35
        JobObjectSiloBasicInformation = 36
        JobObjectReserved15Information = 37
        JobObjectReserved16Information = 38
        JobObjectReserved17Information = 39
        JobObjectReserved18Information = 40
        JobObjectReserved19Information = 41
        JobObjectReserved20Information = 42
        JobObjectReserved21Information = 43
        JobObjectReserved22Information = 44
        JobObjectReserved23Information = 45
        JobObjectReserved24Information = 46
        JobObjectReserved25Information = 47
        MaxJobObjectInfoClass = 48

    JOBOBJECTINFOCLASS = _JOBOBJECTINFOCLASS

    _SILOOBJECT_BASIC_INFORMATION._fields_ = [
        ('SiloId', DWORD),
        ('SiloParentId', DWORD),
        ('NumberOfProcesses', DWORD),
        ('IsInServerSilo', BOOLEAN),
        ('Reserved', BYTE * 3),
    ]


    class _SERVERSILO_STATE(ENUM):
        SERVERSILO_INITING = 0
        SERVERSILO_STARTED = 1
        SERVERSILO_SHUTTING_DOWN = 2
        SERVERSILO_TERMINATING = 3
        SERVERSILO_TERMINATED = 4

    SERVERSILO_STATE = _SERVERSILO_STATE
    PSERVERSILO_STATE = POINTER(_SERVERSILO_STATE)

    _SERVERSILO_BASIC_INFORMATION._fields_ = [
        ('ServiceSessionId', DWORD),
        ('State', SERVERSILO_STATE),
        ('ExitStatus', DWORD),
    ]


    class _FIRMWARE_TYPE(ENUM):
        FirmwareTypeUnknown = 1
        FirmwareTypeBios = 2
        FirmwareTypeUefi = 3
        FirmwareTypeMax = 4

    FIRMWARE_TYPE = _FIRMWARE_TYPE
    PFIRMWARE_TYPE = POINTER(_FIRMWARE_TYPE)
    EVENT_MODIFY_STATE = 0x0002
    EVENT_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x3

    # Mutant Specific Access Rights
    MUTANT_QUERY_STATE = 0x0001
    MUTANT_ALL_ACCESS = (
        STANDARD_RIGHTS_REQUIRED |
        SYNCHRONIZE |
        MUTANT_QUERY_STATE
    )
    SEMAPHORE_MODIFY_STATE = 0x0002
    SEMAPHORE_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x3

    # Timer Specific Access Rights.
    TIMER_QUERY_STATE = 0x0001
    TIMER_MODIFY_STATE = 0x0002
    TIMER_ALL_ACCESS = (
        STANDARD_RIGHTS_REQUIRED |
        SYNCHRONIZE |
        TIMER_QUERY_STATE |
        TIMER_MODIFY_STATE
    )

    # begin_nthal
    TIME_ZONE_ID_UNKNOWN = 0
    TIME_ZONE_ID_STANDARD = 1
    TIME_ZONE_ID_DAYLIGHT = 2

    # end_nthal
    class _LOGICAL_PROCESSOR_RELATIONSHIP(ENUM):
        RelationProcessorCore = 1
        RelationNumaNode = 2
        RelationCache = 3
        RelationProcessorPackage = 4
        RelationGroup = 5
        RelationAll = 0xFFFF

    LOGICAL_PROCESSOR_RELATIONSHIP = _LOGICAL_PROCESSOR_RELATIONSHIP
    LTP_PC_SMT = 0x1


    class _PROCESSOR_CACHE_TYPE(ENUM):
        CacheUnified = 1
        CacheInstruction = 2
        CacheData = 3
        CacheTrace = 4

    PROCESSOR_CACHE_TYPE = _PROCESSOR_CACHE_TYPE
    CACHE_FULLY_ASSOCIATIVE = 0xFF


    _CACHE_DESCRIPTOR._fields_ = [
        ('Level', BYTE),
        ('Associativity', BYTE),
        ('LineSize', WORD),
        ('Size', DWORD),
        ('Type', PROCESSOR_CACHE_TYPE),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class ProcessorCore(ctypes.Structure):
        pass


    ProcessorCore._fields_ = [
        ('Flags', BYTE),
    ]
    DUMMYUNIONNAME.ProcessorCore = ProcessorCore


    class NumaNode(ctypes.Structure):
        pass


    NumaNode._fields_ = [
        ('NodeNumber', DWORD),
    ]
    DUMMYUNIONNAME.NumaNode = NumaNode


    DUMMYUNIONNAME._fields_ = [
        ('ProcessorCore', DUMMYUNIONNAME.ProcessorCore),
        ('NumaNode', DUMMYUNIONNAME.NumaNode),
        ('Cache', CACHE_DESCRIPTOR),
        ('Reserved', ULONGLONG * 2),
    ]
    _SYSTEM_LOGICAL_PROCESSOR_INFORMATION.DUMMYUNIONNAME = DUMMYUNIONNAME


    _SYSTEM_LOGICAL_PROCESSOR_INFORMATION._fields_ = [
        ('ProcessorMask', ULONG_PTR),
        ('Relationship', LOGICAL_PROCESSOR_RELATIONSHIP),
        ('DUMMYUNIONNAME', _SYSTEM_LOGICAL_PROCESSOR_INFORMATION.DUMMYUNIONNAME),
    ]

    _PROCESSOR_RELATIONSHIP._fields_ = [
        ('Flags', BYTE),
        ('EfficiencyClass', BYTE),
        ('Reserved', BYTE * 20),
        ('GroupCount', WORD),
        ('GroupMask', GROUP_AFFINITY * ANYSIZE_ARRAY),
    ]

    _NUMA_NODE_RELATIONSHIP._fields_ = [
        ('NodeNumber', DWORD),
        ('Reserved', BYTE * 20),
        ('GroupMask', GROUP_AFFINITY),
    ]

    _CACHE_RELATIONSHIP._fields_ = [
        ('Level', BYTE),
        ('Associativity', BYTE),
        ('LineSize', WORD),
        ('CacheSize', DWORD),
        ('Type', PROCESSOR_CACHE_TYPE),
        ('Reserved', BYTE * 20),
        ('GroupMask', GROUP_AFFINITY),
    ]

    _PROCESSOR_GROUP_INFO._fields_ = [
        ('MaximumProcessorCount', BYTE),
        ('ActiveProcessorCount', BYTE),
        ('Reserved', BYTE * 38),
        ('ActiveProcessorMask', KAFFINITY),
    ]

    _GROUP_RELATIONSHIP._fields_ = [
        ('MaximumGroupCount', WORD),
        ('ActiveGroupCount', WORD),
        ('Reserved', BYTE * 20),
        ('GroupInfo', PROCESSOR_GROUP_INFO * ANYSIZE_ARRAY),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    DUMMYUNIONNAME._fields_ = [
        ('Processor', PROCESSOR_RELATIONSHIP),
        ('NumaNode', NUMA_NODE_RELATIONSHIP),
        ('Cache', CACHE_RELATIONSHIP),
        ('Group', GROUP_RELATIONSHIP),
    ]
    _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX.DUMMYUNIONNAME = DUMMYUNIONNAME


    _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX._fields_ = [
        ('Relationship', LOGICAL_PROCESSOR_RELATIONSHIP),
        ('Size', DWORD),
        ('DUMMYUNIONNAME', _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX.DUMMYUNIONNAME),
    ]

    SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX
    PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = POINTER(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)


    class _CPU_SET_INFORMATION_TYPE(ENUM):
        CpuSetInformation = 1

    CPU_SET_INFORMATION_TYPE = _CPU_SET_INFORMATION_TYPE
    PCPU_SET_INFORMATION_TYPE = POINTER(_CPU_SET_INFORMATION_TYPE)


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class CpuSet(ctypes.Structure):
        pass


    class DUMMYUNIONNAME2(ctypes.Union):
        pass

    SYSTEM_CPU_SET_INFORMATION_PARKED = 0x1
    SYSTEM_CPU_SET_INFORMATION_ALLOCATED = 0x2
    SYSTEM_CPU_SET_INFORMATION_ALLOCATED_TO_TARGET_PROCESS = 0x4
    SYSTEM_CPU_SET_INFORMATION_REALTIME = 0x8


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('Parked', BYTE, 1),
        ('Allocated', BYTE, 1),
        ('AllocatedToTargetProcess', BYTE, 1),
        ('RealTime', BYTE, 1),
        ('ReservedFlags', BYTE, 4),
    ]
    DUMMYUNIONNAME2.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


    DUMMYUNIONNAME2._fields_ = [
        ('AllFlags', BYTE),
        ('DUMMYSTRUCTNAME', DUMMYUNIONNAME2.DUMMYSTRUCTNAME),
    ]
    CpuSet.DUMMYUNIONNAME2 = DUMMYUNIONNAME2


    class _Union_4(ctypes.Union):
        pass


    _Union_4._fields_ = [
        ('Reserved', DWORD),
        ('SchedulingClass', BYTE),
    ]
    CpuSet._Union_4 = _Union_4

    CpuSet._anonymous_ = (
        '_Union_4',
    )

    CpuSet._fields_ = [
        ('Id', DWORD),
        ('Group', WORD),
        ('LogicalProcessorIndex', BYTE),
        ('CoreIndex', BYTE),
        ('LastLevelCacheIndex', BYTE),
        ('NumaNodeIndex', BYTE),
        ('EfficiencyClass', BYTE),
        ('DUMMYUNIONNAME2', CpuSet.DUMMYUNIONNAME2),
        ('_Union_4', CpuSet._Union_4),
        ('AllocationTag', DWORD64),
    ]
    DUMMYUNIONNAME.CpuSet = CpuSet


    DUMMYUNIONNAME._fields_ = [
        ('CpuSet', DUMMYUNIONNAME.CpuSet),
    ]
    _SYSTEM_CPU_SET_INFORMATION.DUMMYUNIONNAME = DUMMYUNIONNAME


    _SYSTEM_CPU_SET_INFORMATION._fields_ = [
        ('Size', DWORD),
        ('Type', CPU_SET_INFORMATION_TYPE),
        ('DUMMYUNIONNAME', _SYSTEM_CPU_SET_INFORMATION.DUMMYUNIONNAME),
    ]

    SYSTEM_CPU_SET_INFORMATION = _SYSTEM_CPU_SET_INFORMATION
    PSYSTEM_CPU_SET_INFORMATION = POINTER(_SYSTEM_CPU_SET_INFORMATION)


    # end_wdm end_ntminiport
    _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION._fields_ = [
        ('CycleTime', DWORD64),
    ]
    PROCESSOR_INTEL_386 = 386
    PROCESSOR_INTEL_486 = 486
    PROCESSOR_INTEL_PENTIUM = 586
    PROCESSOR_INTEL_IA64 = 2200
    PROCESSOR_AMD_X8664 = 8664
    PROCESSOR_MIPS_R4000 = 4000            # incl R4101 & R3910 for Windows CE
    PROCESSOR_ALPHA_21064 = 21064
    PROCESSOR_PPC_601 = 601
    PROCESSOR_PPC_603 = 603
    PROCESSOR_PPC_604 = 604
    PROCESSOR_PPC_620 = 620
    PROCESSOR_HITACHI_SH3 = 10003            # Windows CE
    PROCESSOR_HITACHI_SH3E = 10004            # Windows CE
    PROCESSOR_HITACHI_SH4 = 10005            # Windows CE
    PROCESSOR_MOTOROLA_821 = 821            # Windows CE
    PROCESSOR_SHx_SH3 = 103            # Windows CE
    PROCESSOR_SHx_SH4 = 104            # Windows CE
    PROCESSOR_STRONGARM = 2577            # Windows CE - 0xA11
    PROCESSOR_ARM720 = 1824            # Windows CE - 0x720
    PROCESSOR_ARM820 = 2080            # Windows CE - 0x820
    PROCESSOR_ARM920 = 2336            # Windows CE - 0x920
    PROCESSOR_ARM_7TDMI = 70001            # Windows CE
    PROCESSOR_OPTIL = 0x494F            # MSIL
    PROCESSOR_ARCHITECTURE_INTEL = 0
    PROCESSOR_ARCHITECTURE_MIPS = 1
    PROCESSOR_ARCHITECTURE_ALPHA = 2
    PROCESSOR_ARCHITECTURE_PPC = 3
    PROCESSOR_ARCHITECTURE_SHX = 4
    PROCESSOR_ARCHITECTURE_ARM = 5
    PROCESSOR_ARCHITECTURE_IA64 = 6
    PROCESSOR_ARCHITECTURE_ALPHA64 = 7
    PROCESSOR_ARCHITECTURE_MSIL = 8
    PROCESSOR_ARCHITECTURE_AMD64 = 9
    PROCESSOR_ARCHITECTURE_IA32_ON_WIN64 = 10
    PROCESSOR_ARCHITECTURE_NEUTRAL = 11
    PROCESSOR_ARCHITECTURE_ARM64 = 12
    PROCESSOR_ARCHITECTURE_ARM32_ON_WIN64 = 13
    PROCESSOR_ARCHITECTURE_IA32_ON_ARM64 = 14
    PROCESSOR_ARCHITECTURE_UNKNOWN = 0xFFFF
    PF_FLOATING_POINT_PRECISION_ERRATA = 0
    PF_FLOATING_POINT_EMULATED = 1
    PF_COMPARE_EXCHANGE_DOUBLE = 2
    PF_MMX_INSTRUCTIONS_AVAILABLE = 3
    PF_PPC_MOVEMEM_64BIT_OK = 4
    PF_ALPHA_BYTE_INSTRUCTIONS = 5
    PF_XMMI_INSTRUCTIONS_AVAILABLE = 6
    PF_3DNOW_INSTRUCTIONS_AVAILABLE = 7
    PF_RDTSC_INSTRUCTION_AVAILABLE = 8
    PF_PAE_ENABLED = 9
    PF_XMMI64_INSTRUCTIONS_AVAILABLE = 10
    PF_SSE_DAZ_MODE_AVAILABLE = 11
    PF_NX_ENABLED = 12
    PF_SSE3_INSTRUCTIONS_AVAILABLE = 13
    PF_COMPARE_EXCHANGE128 = 14
    PF_COMPARE64_EXCHANGE128 = 15
    PF_CHANNELS_ENABLED = 16
    PF_XSAVE_ENABLED = 17
    PF_ARM_VFP_32_REGISTERS_AVAILABLE = 18
    PF_ARM_NEON_INSTRUCTIONS_AVAILABLE = 19
    PF_SECOND_LEVEL_ADDRESS_TRANSLATION = 20
    PF_VIRT_FIRMWARE_ENABLED = 21
    PF_RDWRFSGSBASE_AVAILABLE = 22
    PF_FASTFAIL_AVAILABLE = 23
    PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE = 24
    PF_ARM_64BIT_LOADSTORE_ATOMIC = 25
    PF_ARM_EXTERNAL_CACHE_AVAILABLE = 26
    PF_ARM_FMAC_INSTRUCTIONS_AVAILABLE = 27
    PF_RDRAND_INSTRUCTION_AVAILABLE = 28
    PF_ARM_V8_INSTRUCTIONS_AVAILABLE = 29
    PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE = 30
    PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE = 31
    PF_RDTSCP_INSTRUCTION_AVAILABLE = 32

    # Known extended CPU state feature BITs
    # 0 x87
    # 1 SSE
    # 2 AVX
    # 3 BNDREGS (B0.LB - B3.LB B0.UB - B3.UB)
    # 4 BNDCSR (BNDCFGU + BNDSTATUS)  Persistent
    # 5 KMASK (KMASK [63:0][0 - 7])
    # 6 ZMM_H (ZMM_H[511:256][0 - 15])
    # 7 ZMM  (ZMM[511:0][16 - 31])
    # 8 IPT      Supervisor
    # 62 LWP      Persistent
    # 63 RZ0      Reserved
    XSTATE_LEGACY_FLOATING_POINT = 0
    XSTATE_LEGACY_SSE = 1
    XSTATE_GSSE = 2
    XSTATE_AVX = XSTATE_GSSE
    XSTATE_MPX_BNDREGS = 3
    XSTATE_MPX_BNDCSR = 4
    XSTATE_AVX512_KMASK = 5
    XSTATE_AVX512_ZMM_H = 6
    XSTATE_AVX512_ZMM = 7
    XSTATE_IPT = 8
    XSTATE_LWP = 62
    MAXIMUM_XSTATE_FEATURES = 64


    # Known extended CPU state feature MASKs
    XSTATE_MASK_LEGACY_FLOATING_POINT = 1 << XSTATE_LEGACY_FLOATING_POINT
    XSTATE_MASK_LEGACY_SSE = 1 << XSTATE_LEGACY_SSE
    XSTATE_MASK_LEGACY = (
        XSTATE_MASK_LEGACY_FLOATING_POINT |
        XSTATE_MASK_LEGACY_SSE
    )
    XSTATE_MASK_GSSE = 1 << XSTATE_GSSE
    XSTATE_MASK_AVX = XSTATE_MASK_GSSE
    XSTATE_MASK_MPX = (
        (1 << XSTATE_MPX_BNDREGS) |
        (1 << XSTATE_MPX_BNDCSR)
    )
    XSTATE_MASK_AVX512 = (
        (1 << XSTATE_AVX512_KMASK) |
        (1 << XSTATE_AVX512_ZMM_H) |
        (1 << XSTATE_AVX512_ZMM)
    )
    XSTATE_MASK_IPT = 1 << XSTATE_IPT
    XSTATE_MASK_LWP = 1 << XSTATE_LWP
    XSTATE_MASK_ALLOWED = (
        XSTATE_MASK_LEGACY |
        XSTATE_MASK_AVX |
        XSTATE_MASK_MPX |
        XSTATE_MASK_AVX512 |
        XSTATE_MASK_IPT |
        XSTATE_MASK_LWP
    )
    XSTATE_MASK_PERSISTENT = (1 << XSTATE_MPX_BNDCSR) | XSTATE_MASK_LWP

    # Flags associated with compaction mask
    XSTATE_COMPACTION_ENABLE = 63
    XSTATE_COMPACTION_ENABLE_MASK = 1 << XSTATE_COMPACTION_ENABLE
    XSTATE_ALIGN_BIT = 1
    XSTATE_ALIGN_MASK = 1 << XSTATE_ALIGN_BIT
    XSTATE_CONTROLFLAG_XSAVEOPT_MASK = 1
    XSTATE_CONTROLFLAG_XSAVEC_MASK = 2
    XSTATE_CONTROLFLAG_VALID_MASK = (
        XSTATE_CONTROLFLAG_XSAVEOPT_MASK |
        XSTATE_CONTROLFLAG_XSAVEC_MASK
    )


    # Extended processor state configuration
    _XSTATE_FEATURE._fields_ = [
        ('Offset', DWORD),
        ('Size', DWORD),
    ]


    class _Union_4(ctypes.Union):
        pass


    _Union_4._fields_ = [
        ('ControlFlags', DWORD),
        ('OptimizedSave', DWORD, 1),
        ('CompactionEnabled', DWORD, 1),
    ]
    _XSTATE_CONFIGURATION._Union_4 = _Union_4

    _XSTATE_CONFIGURATION._anonymous_ = (
        '_Union_4',
    )

    _XSTATE_CONFIGURATION._fields_ = [
        # Mask of all enabled features
        ('EnabledFeatures', DWORD64),
        # Mask of volatile enabled features
        ('EnabledVolatileFeatures', DWORD64),
        # Total size of the save area for user states
        ('Size', DWORD),
        # Control Flags
        ('_Union_4', _XSTATE_CONFIGURATION._Union_4),
        # List of features
        ('Features', XSTATE_FEATURE * MAXIMUM_XSTATE_FEATURES),
        # Mask of all supervisor features
        ('EnabledSupervisorFeatures', DWORD64),
        # Mask of features that require start address to be 64 byte
        # aligned
        ('AlignedFeatures', DWORD64),
        # Total size of the save area for user and supervisor states
        ('AllFeatureSize', DWORD),
        # List which holds size of each user and supervisor state
        # supported by CPU
        ('AllFeatures', DWORD * MAXIMUM_XSTATE_FEATURES),
    ]

    # begin_ntifs
    _MEMORY_BASIC_INFORMATION._fields_ = [
        ('BaseAddress', PVOID),
        ('AllocationBase', PVOID),
        ('AllocationProtect', DWORD),
        ('RegionSize', SIZE_T),
        ('State', DWORD),
        ('Protect', DWORD),
        ('Type', DWORD),
    ]

    # end_ntifs
    _MEMORY_BASIC_INFORMATION32._fields_ = [
        ('BaseAddress', DWORD),
        ('AllocationBase', DWORD),
        ('AllocationProtect', DWORD),
        ('RegionSize', DWORD),
        ('State', DWORD),
        ('Protect', DWORD),
        ('Type', DWORD),
    ]

    _MEMORY_BASIC_INFORMATION64._fields_ = [
        ('BaseAddress', ULONGLONG),
        ('AllocationBase', ULONGLONG),
        ('AllocationProtect', DWORD),
        ('__alignment1', DWORD),
        ('RegionSize', ULONGLONG),
        ('State', DWORD),
        ('Protect', DWORD),
        ('Type', DWORD),
        ('__alignment2', DWORD),
    ]


    # Define flags for setting process CFG valid call target entries.
    # Call target should be made valid. If not set, the call target is
    # made
    # invalid. Input flag.
    CFG_CALL_TARGET_VALID = 0x00000001


    # Call target has been successfully processed. Used to report to
    # the caller
    # how much progress has been made. Output flag.
    CFG_CALL_TARGET_PROCESSED = 0x00000002


    # Call target should be made valid only if it is suppressed export.
    # What this flag means is that it can *only* be used on a cell
    # which is
    # currently in the CFG export suppressed state
    # (only considered for export
    # suppressed processes and not legacy CFG processesnot
    # ), and it is also
    # allowed to be used even if the process is a restricted
    # (i.e. no ACG) process.
    CFG_CALL_TARGET_CONVERT_EXPORT_SUPPRESSED_TO_VALID = 0x00000004


    _CFG_CALL_TARGET_INFO._fields_ = [
        ('Offset', ULONG_PTR),
        ('Flags', ULONG_PTR),
    ]
    SECTION_QUERY = 0x0001
    SECTION_MAP_WRITE = 0x0002
    SECTION_MAP_READ = 0x0004
    SECTION_MAP_EXECUTE = 0x0008
    SECTION_EXTEND_SIZE = 0x0010
    SECTION_MAP_EXECUTE_EXPLICIT = 0x0020            # not included in SECTION_ALL_ACCESS
    SECTION_ALL_ACCESS = (
        STANDARD_RIGHTS_REQUIRED |
        SECTION_QUERY |
        SECTION_MAP_WRITE |
        SECTION_MAP_READ |
        SECTION_MAP_EXECUTE |
        SECTION_EXTEND_SIZE
    )


    # Session Specific Access Rights.
    SESSION_QUERY_ACCESS = 0x0001
    SESSION_MODIFY_ACCESS = 0x0002
    SESSION_ALL_ACCESS = (
        STANDARD_RIGHTS_REQUIRED |
        SESSION_QUERY_ACCESS |
        SESSION_MODIFY_ACCESS
    )

    # end_access
    PAGE_NOACCESS = 0x01
    PAGE_READONLY = 0x02
    PAGE_READWRITE = 0x04
    PAGE_WRITECOPY = 0x08
    PAGE_EXECUTE = 0x10
    PAGE_EXECUTE_READ = 0x20
    PAGE_EXECUTE_READWRITE = 0x40
    PAGE_EXECUTE_WRITECOPY = 0x80
    PAGE_GUARD = 0x100
    PAGE_NOCACHE = 0x200
    PAGE_WRITECOMBINE = 0x400
    PAGE_ENCLAVE_THREAD_CONTROL = 0x80000000
    PAGE_REVERT_TO_FILE_MAP = 0x80000000
    PAGE_TARGETS_NO_UPDATE = 0x40000000
    PAGE_TARGETS_INVALID = 0x40000000
    PAGE_ENCLAVE_UNVALIDATED = 0x20000000
    PAGE_ENCLAVE_DECOMMIT = 0x10000000
    MEM_COMMIT = 0x00001000
    MEM_RESERVE = 0x00002000
    MEM_REPLACE_PLACEHOLDER = 0x00004000
    MEM_RESERVE_PLACEHOLDER = 0x00040000
    MEM_RESET = 0x00080000
    MEM_TOP_DOWN = 0x00100000
    MEM_WRITE_WATCH = 0x00200000
    MEM_PHYSICAL = 0x00400000
    MEM_ROTATE = 0x00800000
    MEM_DIFFERENT_IMAGE_BASE_OK = 0x00800000
    MEM_RESET_UNDO = 0x01000000
    MEM_LARGE_PAGES = 0x20000000
    MEM_4MB_PAGES = 0x80000000
    MEM_64K_PAGES = MEM_LARGE_PAGES | MEM_PHYSICAL
    MEM_UNMAP_WITH_TRANSIENT_BOOST = 0x00000001
    MEM_COALESCE_PLACEHOLDERS = 0x00000001
    MEM_PRESERVE_PLACEHOLDER = 0x00000002
    MEM_DECOMMIT = 0x00004000
    MEM_RELEASE = 0x00008000
    MEM_FREE = 0x00010000


    MEM_ADDRESS_REQUIREMENTS._fields_ = [
        ('LowestStartingAddress', PVOID),
        ('HighestEndingAddress', PVOID),
        ('Alignment', SIZE_T),
    ]


    class MEM_EXTENDED_PARAMETER_TYPE(ENUM):
        MemExtendedParameterInvalidType = 0
        MemExtendedParameterAddressRequirements = 1
        MemExtendedParameterNumaNode = 2
        MemExtendedParameterPartitionHandle = 3
        MemExtendedParameterMax = 4

    PMEM_EXTENDED_PARAMETER_TYPE = POINTER(MEM_EXTENDED_PARAMETER_TYPE)
    MEM_EXTENDED_PARAMETER_TYPE_BITS = 8


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('Type', DWORD64, MEM_EXTENDED_PARAMETER_TYPE_BITS),
        ('Reserved', DWORD64, 64 - MEM_EXTENDED_PARAMETER_TYPE_BITS),
    ]
    MEM_EXTENDED_PARAMETER.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    DUMMYUNIONNAME._fields_ = [
        ('ULong64', DWORD64),
        ('Pointer', PVOID),
        ('Size', SIZE_T),
        ('Handle', HANDLE),
        ('ULong', DWORD),
    ]
    MEM_EXTENDED_PARAMETER.DUMMYUNIONNAME = DUMMYUNIONNAME


    MEM_EXTENDED_PARAMETER._fields_ = [
        ('DUMMYSTRUCTNAME', MEM_EXTENDED_PARAMETER.DUMMYSTRUCTNAME),
        ('DUMMYUNIONNAME', MEM_EXTENDED_PARAMETER.DUMMYUNIONNAME),
    ]
    SEC_PARTITION_OWNER_HANDLE = 0x00040000
    SEC_64K_PAGES = 0x00080000
    SEC_FILE = 0x00800000
    SEC_IMAGE = 0x01000000
    SEC_PROTECTED_IMAGE = 0x02000000
    SEC_RESERVE = 0x04000000
    SEC_COMMIT = 0x08000000
    SEC_NOCACHE = 0x10000000
    SEC_WRITECOMBINE = 0x40000000
    SEC_LARGE_PAGES = 0x80000000
    SEC_IMAGE_NO_EXECUTE = SEC_IMAGE | SEC_NOCACHE
    MEM_PRIVATE = 0x00020000
    MEM_MAPPED = 0x00040000
    MEM_IMAGE = 0x01000000
    WRITE_WATCH_FLAG_RESET = 0x01
    ENCLAVE_TYPE_SGX = 0x00000001
    ENCLAVE_TYPE_SGX2 = 0x00000002


    _ENCLAVE_CREATE_INFO_SGX._fields_ = [
        ('Secs', BYTE * 4096),
    ]

    _ENCLAVE_INIT_INFO_SGX._fields_ = [
        ('SigStruct', BYTE * 1808),
        ('Reserved1', BYTE * 240),
        ('EInitToken', BYTE * 304),
        ('Reserved2', BYTE * 1744),
    ]
    ENCLAVE_TYPE_VBS = 0x00000010


    _ENCLAVE_CREATE_INFO_VBS._fields_ = [
        ('Flags', DWORD),
        ('OwnerID', BYTE * 32),
    ]
    ENCLAVE_VBS_FLAG_DEBUG = 0x00000001


    _ENCLAVE_INIT_INFO_VBS._fields_ = [
        ('Length', DWORD),
        ('ThreadCount', DWORD),
    ]
    if not defined(SORTPP_PASS) and not defined(MIDL_PASS) and not defined(RC_INVOKED):
        # typedef PVOID (ENCLAVE_TARGET_FUNCTION)(PVOID);
        ENCLAVE_TARGET_FUNCTION = CALLBACK(PVOID)

        # typedef ENCLAVE_TARGET_FUNCTION (*PENCLAVE_TARGET_FUNCTION);
        PENCLAVE_TARGET_FUNCTION = POINTER(ENCLAVE_TARGET_FUNCTION)


    # END IF
    # begin_access
    # Define access rights to files and directories
    # The FILE_READ_DATA and FILE_WRITE_DATA constants are also
    # defined in
    # devioctl.h as FILE_READ_ACCESS and FILE_WRITE_ACCESS. The values
    # for these
    # constants *MUST* always be in sync.
    # The values are redefined in devioctl.h because they must be
    # available to
    # both DOS and NT.
    FILE_READ_DATA = 0x0001            # file & pipe
    FILE_LIST_DIRECTORY = 0x0001            # directory
    FILE_WRITE_DATA = 0x0002            # file & pipe
    FILE_ADD_FILE = 0x0002            # directory
    FILE_APPEND_DATA = 0x0004            # file
    FILE_ADD_SUBDIRECTORY = 0x0004            # directory
    FILE_CREATE_PIPE_INSTANCE = 0x0004            # named pipe
    FILE_READ_EA = 0x0008            # file & directory
    FILE_WRITE_EA = 0x0010            # file & directory
    FILE_EXECUTE = 0x0020            # file
    FILE_TRAVERSE = 0x0020            # directory
    FILE_DELETE_CHILD = 0x0040            # directory
    FILE_READ_ATTRIBUTES = 0x0080            # all
    FILE_WRITE_ATTRIBUTES = 0x0100            # all
    FILE_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1FF
    FILE_GENERIC_READ = (
        STANDARD_RIGHTS_READ |
        FILE_READ_DATA |
        FILE_READ_ATTRIBUTES |
        FILE_READ_EA |
        SYNCHRONIZE
    )
    FILE_GENERIC_WRITE = (
        STANDARD_RIGHTS_WRITE |
        FILE_WRITE_DATA |
        FILE_WRITE_ATTRIBUTES |
        FILE_WRITE_EA |
        FILE_APPEND_DATA |
        SYNCHRONIZE
    )
    FILE_GENERIC_EXECUTE = (
        STANDARD_RIGHTS_EXECUTE |
        FILE_READ_ATTRIBUTES |
        FILE_EXECUTE |
        SYNCHRONIZE
    )

    # end_access
    FILE_SHARE_READ = 0x00000001
    FILE_SHARE_WRITE = 0x00000002
    FILE_SHARE_DELETE = 0x00000004
    FILE_ATTRIBUTE_READONLY = 0x00000001
    FILE_ATTRIBUTE_HIDDEN = 0x00000002
    FILE_ATTRIBUTE_SYSTEM = 0x00000004
    FILE_ATTRIBUTE_DIRECTORY = 0x00000010
    FILE_ATTRIBUTE_ARCHIVE = 0x00000020
    FILE_ATTRIBUTE_DEVICE = 0x00000040
    FILE_ATTRIBUTE_NORMAL = 0x00000080
    FILE_ATTRIBUTE_TEMPORARY = 0x00000100
    FILE_ATTRIBUTE_SPARSE_FILE = 0x00000200
    FILE_ATTRIBUTE_REPARSE_POINT = 0x00000400
    FILE_ATTRIBUTE_COMPRESSED = 0x00000800
    FILE_ATTRIBUTE_OFFLINE = 0x00001000
    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 0x00002000
    FILE_ATTRIBUTE_ENCRYPTED = 0x00004000
    FILE_ATTRIBUTE_INTEGRITY_STREAM = 0x00008000
    FILE_ATTRIBUTE_VIRTUAL = 0x00010000
    FILE_ATTRIBUTE_NO_SCRUB_DATA = 0x00020000
    FILE_ATTRIBUTE_EA = 0x00040000
    FILE_ATTRIBUTE_PINNED = 0x00080000
    FILE_ATTRIBUTE_UNPINNED = 0x00100000
    FILE_ATTRIBUTE_RECALL_ON_OPEN = 0x00040000
    FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS = 0x00400000
    TREE_CONNECT_ATTRIBUTE_PRIVACY = 0x00004000
    TREE_CONNECT_ATTRIBUTE_INTEGRITY = 0x00008000
    TREE_CONNECT_ATTRIBUTE_GLOBAL = 0x00000004
    FILE_ATTRIBUTE_STRICTLY_SEQUENTIAL = 0x20000000
    FILE_NOTIFY_CHANGE_FILE_NAME = 0x00000001
    FILE_NOTIFY_CHANGE_DIR_NAME = 0x00000002
    FILE_NOTIFY_CHANGE_ATTRIBUTES = 0x00000004
    FILE_NOTIFY_CHANGE_SIZE = 0x00000008
    FILE_NOTIFY_CHANGE_LAST_WRITE = 0x00000010
    FILE_NOTIFY_CHANGE_LAST_ACCESS = 0x00000020
    FILE_NOTIFY_CHANGE_CREATION = 0x00000040
    FILE_NOTIFY_CHANGE_SECURITY = 0x00000100
    FILE_ACTION_ADDED = 0x00000001
    FILE_ACTION_REMOVED = 0x00000002
    FILE_ACTION_MODIFIED = 0x00000003
    FILE_ACTION_RENAMED_OLD_NAME = 0x00000004
    FILE_ACTION_RENAMED_NEW_NAME = 0x00000005
    MAILSLOT_NO_MESSAGE = -1
    MAILSLOT_WAIT_FOREVER = -1
    FILE_CASE_SENSITIVE_SEARCH = 0x00000001
    FILE_CASE_PRESERVED_NAMES = 0x00000002
    FILE_UNICODE_ON_DISK = 0x00000004
    FILE_PERSISTENT_ACLS = 0x00000008
    FILE_FILE_COMPRESSION = 0x00000010
    FILE_VOLUME_QUOTAS = 0x00000020
    FILE_SUPPORTS_SPARSE_FILES = 0x00000040
    FILE_SUPPORTS_REPARSE_POINTS = 0x00000080
    FILE_SUPPORTS_REMOTE_STORAGE = 0x00000100
    FILE_RETURNS_CLEANUP_RESULT_INFO = 0x00000200
    FILE_SUPPORTS_POSIX_UNLINK_RENAME = 0x00000400
    FILE_VOLUME_IS_COMPRESSED = 0x00008000
    FILE_SUPPORTS_OBJECT_IDS = 0x00010000
    FILE_SUPPORTS_ENCRYPTION = 0x00020000
    FILE_NAMED_STREAMS = 0x00040000
    FILE_READ_ONLY_VOLUME = 0x00080000
    FILE_SEQUENTIAL_WRITE_ONCE = 0x00100000
    FILE_SUPPORTS_TRANSACTIONS = 0x00200000
    FILE_SUPPORTS_HARD_LINKS = 0x00400000
    FILE_SUPPORTS_EXTENDED_ATTRIBUTES = 0x00800000
    FILE_SUPPORTS_OPEN_BY_FILE_ID = 0x01000000
    FILE_SUPPORTS_USN_JOURNAL = 0x02000000
    FILE_SUPPORTS_INTEGRITY_STREAMS = 0x04000000
    FILE_SUPPORTS_BLOCK_REFCOUNTING = 0x08000000
    FILE_SUPPORTS_SPARSE_VDL = 0x10000000
    FILE_DAX_VOLUME = 0x20000000
    FILE_SUPPORTS_GHOSTING = 0x40000000
    FILE_INVALID_FILE_ID = -1


    _FILE_ID_128._fields_ = [
        ('Identifier', BYTE * 16),
    ]

    # Define the file notification information structure
    _FILE_NOTIFY_INFORMATION._fields_ = [
        ('NextEntryOffset', DWORD),
        ('Action', DWORD),
        ('FileNameLength', DWORD),
        ('FileName', WCHAR * 1),
    ]
    if _WIN32_WINNT >= _WIN32_WINNT_WIN10_RS3:
        _FILE_NOTIFY_EXTENDED_INFORMATION._fields_ = [
            ('NextEntryOffset', DWORD),
            ('Action', DWORD),
            ('CreationTime', LARGE_INTEGER),
            ('LastModificationTime', LARGE_INTEGER),
            ('LastChangeTime', LARGE_INTEGER),
            ('LastAccessTime', LARGE_INTEGER),
            ('AllocatedLength', LARGE_INTEGER),
            ('FileSize', LARGE_INTEGER),
            ('FileAttributes', DWORD),
            ('ReparsePointTag', DWORD),
            ('FileId', LARGE_INTEGER),
            ('ParentFileId', LARGE_INTEGER),
            ('FileNameLength', DWORD),
            ('FileName', WCHAR * 1),
        ]
    # END IF

    # Define segement buffer structure for scatter/gather read/write.
    _FILE_SEGMENT_ELEMENT._fields_ = [
        ('Buffer', PVOID64),
        ('Alignment', ULONGLONG),
    ]

    if NTDDI_VERSION >= NTDDI_WIN8:
        # Flag defintions for NtFlushBuffersFileEx
        # If none of the below flags are specified the following will
        # occur for a
        # given file handle:
        # - Write any modified data for the given file from the
        # Windows in - memory
        # cache.
        # - Commit all pending metadata changes for the given file
        # from the
        # Windows in - memory cache.
        # - Send a SYNC command to the underlying storage device to
        # commit all
        # written data in the devices cache to persistent storage.
        # If a volume handle is specified:
        # - Write all modified data for all files on the volume from
        # the Windows
        # in - memory cache.
        # - Commit all pending metadata changes for all files on the
        # volume from
        # the Windows in - memory cache.
        # - Send a SYNC command to the underlying storage device to
        # commit all
        # written data in the devices cache to persistent storage.
        # This is equivalent to how NtFlushBuffersFile has always
        # worked.
        # If set, this operation will write the data for the given
        # file from the
        # Windows in - memory cache. This will NOT commit any
        # associated metadata
        # changes. This will NOT send a SYNC to the storage device to
        # flush its
        # cache. Not supported on volume handles. Only supported by
        # the NTFS
        # filesystem.
        FLUSH_FLAGS_FILE_DATA_ONLY = 0x00000001

        # If set, this operation will commit both the data and
        # metadata changes for
        # the given file from the Windows in - memory cache. This will
        # NOT send a SYNC
        # to the storage device to flush its cache. Not supported on
        # volume handles.
        # Only supported by the NTFS filesystem.
        FLUSH_FLAGS_NO_SYNC = 0x00000002
    # END IF   (NTDDI_VERSION >= NTDDI_WIN8)

    if NTDDI_VERSION >= NTDDI_WIN10_RS1:
        # If set, this operation will write the data for the given
        # file from the
        # Windows in - memory cache. It will also try to skip updating
        # the timestamp
        # as much as possible. This will send a SYNC to the storage
        # device to flush its
        # cache. Not supported on volume or directory handles. Only
        # supported by the NTFS
        # filesystem.
        FLUSH_FLAGS_FILE_DATA_SYNC_ONLY = 0x00000004
    # END IF   (NTDDI_VERSION >= NTDDI_WIN10_RS1)

    # The reparse GUID structure is used by all 3rd party layered
    # drivers to
    # store data in a reparse point. For non - Microsoft tags, The
    # GUID field
    # cannot be GUID_NULL.
    # The constraints on reparse tags are defined below.
    # Microsoft tags can also be used with this format of the reparse
    # point buffer.
    class GenericReparseBuffer(ctypes.Structure):
        pass


    GenericReparseBuffer._fields_ = [
        ('DataBuffer', BYTE * 1),
    ]
    _REPARSE_GUID_DATA_BUFFER.GenericReparseBuffer = GenericReparseBuffer


    _REPARSE_GUID_DATA_BUFFER._fields_ = [
        ('ReparseTag', DWORD),
        ('ReparseDataLength', WORD),
        ('Reserved', WORD),
        ('ReparseGuid', GUID),
        ('GenericReparseBuffer', _REPARSE_GUID_DATA_BUFFER.GenericReparseBuffer),
    ]
    REPARSE_GUID_DATA_BUFFER_HEADER_SIZE = (
        UFIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, 'GenericReparseBuffer')
    )

    # Maximum allowed size of the reparse data.
    MAXIMUM_REPARSE_DATA_BUFFER_SIZE = 16 * 1024

    # Predefined reparse tags.
    # These tags need to avoid conflicting with IO_REMOUNT defined in
    # ntos\inc\io.h
    IO_REPARSE_TAG_RESERVED_ZERO = 0
    IO_REPARSE_TAG_RESERVED_ONE = 1
    IO_REPARSE_TAG_RESERVED_TWO = 2

    # The value of the following constant needs to satisfy the
    # following conditions:
    # (1) Be at least as large as the largest of the reserved tags.
    # (2) Be strictly smaller than all the tags in use.
    IO_REPARSE_TAG_RESERVED_RANGE = IO_REPARSE_TAG_RESERVED_TWO

    # The reparse tags are a DWORD. The 32 bits are laid out as
    # follows:
    # 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
    # 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    # + - + - + - + - + - - - - - - - - - - - - - - - - - - - - - - -
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    # | M | R | N | D|  Reserved bits  |  Reparse Tag Value  |
    # + - + - + - + - + - - - - - - - - - - - - - - - - - - - - - - -
    # + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    # M is the Microsoft bit. When set to 1, it denotes a tag owned by
    # Microsoft.
    # All ISVs must use a tag with a 0 in this position.
    # Note: If a Microsoft tag is used by non - Microsoft software, the
    # behavior is not defined.
    # R is reserved. Must be zero for non - Microsoft tags.
    # N is name surrogate. When set to 1, the file represents another
    # named
    # entity in the system.
    # D is the directory bit. When set to 1, indicates that any
    # directory
    # with this reparse tag can have children. Has no special meaning
    # when used
    # on a non - directory file. Not compatible with the name
    # surrogate bit.
    # The M and N bits are OR - able.
    # The following macros check for the M and N bit values:
    # Macro to determine whether a reparse point tag corresponds to a
    # tag
    # owned by Microsoft.
    def IsReparseTagMicrosoft(_tag):
        return _tag & 0x80000000

    # Macro to determine whether a reparse point tag is a name
    # surrogate
    def IsReparseTagNameSurrogate(_tag):
        return _tag & 0x20000000

    # Macro to determine whether a directory with this reparse point
    # can have
    # children.
    def IsReparseTagDirectory(_tag):
        return _tag & 0x10000000


    IO_REPARSE_TAG_MOUNT_POINT = 0xA0000003
    IO_REPARSE_TAG_HSM = 0xC0000004
    IO_REPARSE_TAG_HSM2 = 0x80000006
    IO_REPARSE_TAG_SIS = 0x80000007
    IO_REPARSE_TAG_WIM = 0x80000008
    IO_REPARSE_TAG_CSV = 0x80000009
    IO_REPARSE_TAG_DFS = 0x8000000A
    IO_REPARSE_TAG_SYMLINK = 0xA000000C
    IO_REPARSE_TAG_DFSR = 0x80000012
    IO_REPARSE_TAG_DEDUP = 0x80000013
    IO_REPARSE_TAG_NFS = 0x80000014
    IO_REPARSE_TAG_FILE_PLACEHOLDER = 0x80000015
    IO_REPARSE_TAG_WOF = 0x80000017
    IO_REPARSE_TAG_WCI = 0x80000018
    IO_REPARSE_TAG_WCI_1 = 0x90001018
    IO_REPARSE_TAG_GLOBAL_REPARSE = 0xA0000019
    IO_REPARSE_TAG_CLOUD = 0x9000001A
    IO_REPARSE_TAG_CLOUD_1 = 0x9000101A
    IO_REPARSE_TAG_CLOUD_2 = 0x9000201A
    IO_REPARSE_TAG_CLOUD_3 = 0x9000301A
    IO_REPARSE_TAG_CLOUD_4 = 0x9000401A
    IO_REPARSE_TAG_CLOUD_5 = 0x9000501A
    IO_REPARSE_TAG_CLOUD_6 = 0x9000601A
    IO_REPARSE_TAG_CLOUD_7 = 0x9000701A
    IO_REPARSE_TAG_CLOUD_8 = 0x9000801A
    IO_REPARSE_TAG_CLOUD_9 = 0x9000901A
    IO_REPARSE_TAG_CLOUD_A = 0x9000A01A
    IO_REPARSE_TAG_CLOUD_B = 0x9000B01A
    IO_REPARSE_TAG_CLOUD_C = 0x9000C01A
    IO_REPARSE_TAG_CLOUD_D = 0x9000D01A
    IO_REPARSE_TAG_CLOUD_E = 0x9000E01A
    IO_REPARSE_TAG_CLOUD_F = 0x9000F01A
    IO_REPARSE_TAG_CLOUD_MASK = 0x0000F000
    IO_REPARSE_TAG_APPEXECLINK = 0x8000001B
    IO_REPARSE_TAG_PROJFS = 0x9000001C
    IO_REPARSE_TAG_STORAGE_SYNC = 0x8000001E
    IO_REPARSE_TAG_WCI_TOMBSTONE = 0xA000001F
    IO_REPARSE_TAG_UNHANDLED = 0x80000020
    IO_REPARSE_TAG_ONEDRIVE = 0x80000021
    IO_REPARSE_TAG_PROJFS_TOMBSTONE = 0xA0000022
    IO_REPARSE_TAG_AF_UNIX = 0x80000023
    if _WIN32_WINNT >= _WIN32_WINNT_WIN8:
        # == == == == == == == == == == == = FSCTL_SCRUB_DATA == == ==
        # == == == == == == == == == == == =
        SCRUB_DATA_INPUT_FLAG_RESUME = 0x00000001
        SCRUB_DATA_INPUT_FLAG_SKIP_IN_SYNC = 0x00000002
        SCRUB_DATA_INPUT_FLAG_SKIP_NON_INTEGRITY_DATA = 0x00000004
        SCRUB_DATA_INPUT_FLAG_IGNORE_REDUNDANCY = 0x00000008
        SCRUB_DATA_INPUT_FLAG_SKIP_DATA = 0x00000010
        SCRUB_DATA_INPUT_FLAG_SCRUB_BY_OBJECT_ID = 0x00000020
        SCRUB_DATA_OUTPUT_FLAG_INCOMPLETE = 0x00000001
        SCRUB_DATA_OUTPUT_FLAG_NON_USER_DATA_RANGE = 0x00010000
        if _WIN32_WINNT >= _WIN32_WINNT_WINBLUE:
            SCRUB_DATA_OUTPUT_FLAG_PARITY_EXTENT_DATA_RETURNED = (
                0x00020000
            )
            SCRUB_DATA_OUTPUT_FLAG_RESUME_CONTEXT_LENGTH_SPECIFIED = (
                0x00040000
            )
        # END IF  _WIN32_WINNT >= _WIN32_WINNT_WINBLUE
        _SCRUB_DATA_INPUT._fields_ = [
            # (ctypes.sizeof(SCRUB_DATA_INPUT)
            ('Size', DWORD),
            # ResumeContext is provided from the previous call
            ('Flags', DWORD),
            # operation takes too long.
            ('MaximumIos', DWORD),
            # preserve previous alignment.
            ('ObjectId', DWORD * 4),
            # Reserved
            ('Reserved', DWORD * 13),
            # at Flags field.
            ('ResumeContext', BYTE * 816),
        ]
        if _WIN32_WINNT >= _WIN32_WINNT_WINBLUE:
            _SCRUB_PARITY_EXTENT._fields_ = [
                ('Offset', LONGLONG),
                ('Length', ULONGLONG),
            ]

            _SCRUB_PARITY_EXTENT_DATA._fields_ = [
                # (ctypes.sizeof(SCRUB_PARITY_EXTENT_DATA)
                ('Size', WORD),
                # Reserved
                ('Flags', WORD),
                # Number of parity extents
                ('NumberOfParityExtents', WORD),
                # Maximum number of parity extents in ParityExtents
                # buffer
                ('MaximumNumberOfParityExtents', WORD),
                # Output buffer for parity extents
                ('ParityExtents', SCRUB_PARITY_EXTENT * ANYSIZE_ARRAY),
            ]
        # END IF  (_WIN32_WINNT >= _WIN32_WINNT_WINBLUE)
        _TEMP__SCRUB_DATA_OUTPUT = [
            # (ctypes.sizeof(SCRUB_DATA_OUTPUT)
            ('Size', DWORD),
            # call.
            ('Flags', DWORD),
            # Operational status
            ('Status', DWORD),
            # This value may be - 1 if the error were found in non -
            # user data area
            ('ErrorFileOffset', ULONGLONG),
            # This value may be 0 if the error were found in non -
            # user data area
            ('ErrorLength', ULONGLONG),
            # Number of bytes successfully repaired in the operational
            # error range
            ('NumberOfBytesRepaired', ULONGLONG),
            # Number of bytes failed due to an error in the
            # operational error range
            ('NumberOfBytesFailed', ULONGLONG),
            # Reference number for the file system specific internal
            # file
            ('InternalFileReference', ULONGLONG),
        ]
        if _WIN32_WINNT >= _WIN32_WINNT_WINBLUE:
            _TEMP__SCRUB_DATA_OUTPUT += [
                # is specified in the Flags.
                ('ResumeContextLength', WORD),
                # is specified in the Flags.
                ('ParityExtentDataOffset', WORD),
                # Reserved
                ('Reserved', DWORD * 5),
            ]
        else: #  (_WIN32_WINNT >= _WIN32_WINNT_WINBLUE)
            _TEMP__SCRUB_DATA_OUTPUT += [
                # Reserved
                ('Reserved', DWORD * 6),
            ]
        # END IF   (_WIN32_WINNT >= _WIN32_WINNT_WINBLUE)
        _TEMP__SCRUB_DATA_OUTPUT += [
            # is set.
            ('ResumeContext', BYTE * 816),
        ]
        _SCRUB_DATA_OUTPUT._fields_ = _TEMP__SCRUB_DATA_OUTPUT
    # END IF  _WIN32_WINNT >= _WIN32_WINNT_WIN8

    if _WIN32_WINNT >= _WIN32_WINNT_WINBLUE:
        # == == == == == == == =
        # FSCTL_QUERY_SHARED_VIRTUAL_DISK_SUPPORT = == ==
        # Whether the file system supports shared virtual disks.
        class _SharedVirtualDiskSupportType(ENUM):
            SharedVirtualDisksUnsupported = 0
            SharedVirtualDisksSupported = 1
            SharedVirtualDiskSnapshotsSupported = 3
            SharedVirtualDiskCDPSnapshotsSupported = 7

        SharedVirtualDiskSupportType = _SharedVirtualDiskSupportType


        class _SharedVirtualDiskHandleState(ENUM):
            SharedVirtualDiskHandleStateNone = 0
            SharedVirtualDiskHandleStateFileShared = 1
            SharedVirtualDiskHandleStateHandleShared = 3

        SharedVirtualDiskHandleState = _SharedVirtualDiskHandleState

        # Response to FSCTL_QUERY_SHARED_VIRTUAL_DISK_SUPPORT that
        # indicates the level
        # of support for shared virtual disks on the target file
        # system.
        _SHARED_VIRTUAL_DISK_SUPPORT._fields_ = [
            # level of shared virtual disk support on this file system.
            ('SharedVirtualDiskSupport', SharedVirtualDiskSupportType),
            # above SharedVirtualDiskHandleState flags.
            ('HandleState', SharedVirtualDiskHandleState),
        ]

        # Determines if the provided virtual disk handle state, from
        # FSCTL_QUERY_SHARED_VIRTUAL_DISK_SUPPORT,
        # indicates that the target virtual disk file is opened in
        # shared mode.
        def IsVirtualDiskFileShared(HandleState):
            return (
                (
                    HandleState &
                    _SharedVirtualDiskHandleState.SharedVirtualDiskHandleStateFileShared
                ) != 0
            )
    # END IF   (_WIN32_WINNT >= _WIN32_WINNT_WINBLUE)

    # begin_access
    # I/O Completion Specific Access Rights.
    IO_COMPLETION_MODIFY_STATE = 0x0002
    IO_COMPLETION_ALL_ACCESS = (
        STANDARD_RIGHTS_REQUIRED |
        SYNCHRONIZE |
        0x3
    )
    IO_QOS_MAX_RESERVATION = 1000000000

    # Some applications include both ntioapi_x.h and winioctl.h
    SMB_CCF_APP_INSTANCE_EA_NAME = None
    if not defined(SMB_CCF_APP_INSTANCE_EA_NAME):
        SMB_CCF_APP_INSTANCE_EA_NAME = "ClusteredApplicationInstance"
    # END IF  SMB_CCF_APP_INSTANCE_EA_NAME

    _NETWORK_APP_INSTANCE_EA_DEFINED = None
    if not defined(_NETWORK_APP_INSTANCE_EA_DEFINED):
        _NETWORK_APP_INSTANCE_EA_DEFINED = 1
        if NTDDI_VERSION >= NTDDI_WIN10:
            # Define the SMB Cluster Client Failover AppInstance
            # Extended Attribute name
            # newer version of input payload assumes that EA is not
            # just a GUID,
            # but instead is a structure that contains additional
            # information
            # Is used only when file is opened directly on CSVFS. This
            # flag is ignored when file
            # is opened over SMB.
            # Tells CSVFS that this file open should be valid only on
            # coordinating node.
            # If open comes to CSVFS, and this node is not a
            # coordinating then open would fail.
            # If file is opened, and coordinating node is moved then
            # file open will be invalidated
            NETWORK_APP_INSTANCE_CSV_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR = None
            if not defined(NETWORK_APP_INSTANCE_CSV_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR):
                NETWORK_APP_INSTANCE_CSV_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR = (
                    0x00000001
                )
            # END IF  NETWORK_APP_INSTANCE_CSV_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR

            _NETWORK_APP_INSTANCE_EA._fields_ = [
                # the application.
                ('AppInstanceID', GUID),
                # Combination of the NETWORK_APP_INSTANCE_CSV_FLAGS_*
                # flags
                ('CsvFlags', DWORD),
            ]
        # END IF   (NTDDI_VERSION >= NTDDI_WIN10)
    # END IF  _NETWORK_APP_INSTANCE_EA_DEFINED

    # begin_access
    # Object Manager Symbolic Link Specific Access Rights.
    DUPLICATE_CLOSE_SOURCE = 0x00000001
    DUPLICATE_SAME_ACCESS = 0x00000002

    # == == == == == == == == == == == == == == == == == == == == =
    # Define GUIDs which represent well - known power schemes
    # == == == == == == == == == == == == == == == == == == == == =
    # Maximum Power Savings - indicates that very aggressive power
    # savings measures will be used to help
    # stretch battery life.
    # {a1841308 - 3541 - 4fab - bc81 - f71556f20b4a}
    GUID_MAX_POWER_SAVINGS = DEFINE_GUID(
        0xA1841308,
        0x3541,
        0x4FAB,
        0xBC,
        0x81,
        0xF7,
        0x15,
        0x56,
        0xF2,
        0x0B,
        0x4A
    )


    # No Power Savings - indicates that almost no power savings
    # measures will be used.
    # {8c5e7fda - e8bf - 4a96 - 9a85 - a6e23a8c635c}
    GUID_MIN_POWER_SAVINGS = DEFINE_GUID(
        0x8C5E7FDA,
        0xE8BF,
        0x4A96,
        0x9A,
        0x85,
        0xA6,
        0xE2,
        0x3A,
        0x8C,
        0x63,
        0x5C
    )

    # Typical Power Savings - indicates that fairly aggressive power
    # savings measures will be used.
    # {381b4222 - f694 - 41f0 - 9685 - ff5bb260df2e}
    GUID_TYPICAL_POWER_SAVINGS = DEFINE_GUID(
        0x381B4222,
        0xF694,
        0x41F0,
        0x96,
        0x85,
        0xFF,
        0x5B,
        0xB2,
        0x60,
        0xDF,
        0x2E
    )


    # This is a special GUID that represents "no subgroup" of
    # settings. That is, it indicates
    # that settings that are in the root of the power policy hierarchy
    # as opposed to settings
    # that are buried under a subgroup of settings. This should be
    # used when querying for
    # power settings that may not fall into a subgroup.
    NO_SUBGROUP_GUID = DEFINE_GUID(
        0xFEA3413E,
        0x7E05,
        0x4911,
        0x9A,
        0x71,
        0x70,
        0x03,
        0x31,
        0xF1,
        0xC2,
        0x94
    )


    # This is a special GUID that represents "every power scheme".
    # That is, it indicates
    # that any write to this power scheme should be reflected to every
    # scheme present.
    # This allows users to write a single setting once and have it
    # apply to all schemes. They
    # can then apply custom settings to specific power schemes that
    # they care about.
    ALL_POWERSCHEMES_GUID = DEFINE_GUID(
        0x68A1E95E,
        0x13EA,
        0x41E1,
        0x80,
        0x11,
        0x0C,
        0x49,
        0x6C,
        0xA4,
        0x90,
        0xB0
    )


    # This is a special GUID that represents a 'personality' that each
    # power scheme will have.
    # In other words, each power scheme will have this key indicating
    # "I'm most like *this* base
    # power
    # scheme." This individual setting will have one of three settings:
    # GUID_MAX_POWER_SAVINGS
    # GUID_MIN_POWER_SAVINGS
    # GUID_TYPICAL_POWER_SAVINGS
    # This allows several features:
    # 1. Drivers and applications can register for notification of
    # this GUID. So when this power
    # scheme is activiated, this GUID's setting will be sent across
    # the system and drivers/applications
    # can see "GUID_MAX_POWER_SAVINGS" which will tell them in a
    # generic fashion "get real aggressive
    # about conserving power".
    # 2. UserB may install a driver or application which creates power
    # settings, and UserB may modify
    # those power settings. Now UserA logs in. How does he see those
    # settings? They simply don't
    # exist in his private power key. Well they do exist over in the
    # system power key. When we
    # enumerate all the power settings in this system power key and
    # don't find a corresponding entry
    # in the user's private power key, then we can go look at this
    # "personality" key in the users
    # power scheme. We can then go get a default value for the power
    # setting, depending on which
    # "personality" power scheme is being operated on. Here's an
    # example:
    # A. UserB installs an application that creates a power setting
    # Seetting1
    # B. UserB changes Setting1 to have a value of 50 because that's
    # one of the possible settings
    # available for setting1.
    # C. UserB logs out
    # D. UserA logs in and his active power scheme is some custom
    # scheme that was derived from
    # the GUID_TYPICAL_POWER_SAVINGS. But remember that UserA has no
    # setting1 in his
    # private power key.
    # E. When activating UserA's selected power scheme, all power
    # settings in the system power key will
    # be enumerated (including Setting1).
    # F. The power manager will see that UserA has no Setting1 power
    # setting in his private power scheme.
    # G. The power manager will query UserA's power scheme for its
    # personality and retrieve
    # GUID_TYPICAL_POWER_SAVINGS.
    # H. The power manager then looks in Setting1 in the system power
    # key and looks in its set of default
    # values for the corresponding value for
    # GUID_TYPICAL_POWER_SAVINGS power schemes.
    # I. This derived power setting is applied.
    GUID_POWERSCHEME_PERSONALITY = DEFINE_GUID(
        0x245D8541,
        0x3943,
        0x4422,
        0xB0,
        0x25,
        0x13,
        0xA7,
        0x84,
        0xF6,
        0x79,
        0xB7
    )


    # Define a special GUID which will be used to define the active
    # power scheme.
    # User will register for this power setting GUID, and when the
    # active power
    # scheme changes, they'll get a callback where the payload is the
    # GUID
    # representing the active powerscheme.
    # ( 31F9F286 - 5084 - 42FE - B720 - 2B0264993763 }
    GUID_ACTIVE_POWERSCHEME = DEFINE_GUID(
        0x31F9F286,
        0x5084,
        0x42FE,
        0xB7,
        0x20,
        0x2B,
        0x02,
        0x64,
        0x99,
        0x37,
        0x63
    )


    # == == == == == == == == == == == == == == == == == == == == =
    # Define GUIDs which represent well - known power settings
    # == == == == == == == == == == == == == == == == == == == == =
    # Idle resiliency settings
    # - - - - - - - - - - - - - - - - - - - - - - - - -
    # Specifies the subgroup which will contain all of the idle
    # resiliency
    # settings for a single policy.
    # {2E601130 - 5351 - 4d9d - 8E04 - 252966BAD054}
    GUID_IDLE_RESILIENCY_SUBGROUP = DEFINE_GUID(
        0x2E601130,
        0x5351,
        0x4D9D,
        0x8E,
        0x4,
        0x25,
        0x29,
        0x66,
        0xBA,
        0xD0,
        0x54
    )


    # Specifies the maximum clock interrupt period (in ms)
    # N.B. This power setting is DEPRECATED.
    # {C42B79AA - AA3A - 484b - A98F - 2CF32AA90A28}
    GUID_IDLE_RESILIENCY_PERIOD = DEFINE_GUID(
        0xC42B79AA,
        0xAA3A,
        0x484B,
        0xA9,
        0x8F,
        0x2C,
        0xF3,
        0x2A,
        0xA9,
        0xA,
        0x28
    )

    # Specifies the deep sleep policy setting.
    # This is intended to override the GUID_IDLE_RESILIENCY_PERIOD
    # {d502f7ee - 1dc7 - 4efd - a55d - f04b6f5c0545}
    GUID_DEEP_SLEEP_ENABLED = DEFINE_GUID(
        0xD502F7EE,
        0x1DC7,
        0x4EFD,
        0xA5,
        0x5D,
        0xF0,
        0x4B,
        0x6F,
        0x5C,
        0x5,
        0x45
    )


    # Specifies the platform idle state index associated with idle
    # resiliency
    # period.
    # N.B. This power setting is DEPRECATED.
    # {D23F2FB8 - 9536 - 4038 - 9C94 - 1CE02E5C2152}
    GUID_DEEP_SLEEP_PLATFORM_STATE = DEFINE_GUID(
        0xD23F2FB8,
        0x9536,
        0x4038,
        0x9C,
        0x94,
        0x1C,
        0xE0,
        0x2E,
        0x5C,
        0x21,
        0x52
    )

    # Specifies (in milliseconds) how LONG we wait after the last disk
    # access
    # before we power off the disk in case when IO coalescing is
    # active.
    # {C36F0EB4 - 2988 - 4a70 - 8EEE - 0884FC2C2433}
    GUID_DISK_COALESCING_POWERDOWN_TIMEOUT = DEFINE_GUID(
        0xC36F0EB4,
        0x2988,
        0x4A70,
        0x8E,
        0xEE,
        0x8,
        0x84,
        0xFC,
        0x2C,
        0x24,
        0x33
    )

    # Specifies (in seconds) how LONG we wait after the CS Enter before
    # we deactivate execution required request.
    # 0 : implies execution power requests are disabled and have no
    # effect
    # - 1 : implies execution power requests are never deactivated
    # Note: Execution required power requests are mapped into system
    # required
    # power requests on non - AoAc machines and this value has no
    # effect.
    # {3166BC41 - 7E98 - 4e03 - B34E - EC0F5F2B218E}
    GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT = DEFINE_GUID(
        0x3166BC41,
        0x7E98,
        0x4E03,
        0xB3,
        0x4E,
        0xEC,
        0xF,
        0x5F,
        0x2B,
        0x21,
        0x8E
    )

    # Video settings
    # - - - - - - - - - - - - - -
    # Specifies the subgroup which will contain all of the video
    # settings for a single policy.
    # {7516b95f - f776 - 4464 - 8c53 - 06167f40cc99}
    GUID_VIDEO_SUBGROUP = DEFINE_GUID(
        0x7516B95F,
        0xF776,
        0x4464,
        0x8C,
        0x53,
        0x06,
        0x16,
        0x7F,
        0x40,
        0xCC,
        0x99
    )


    # Specifies (in seconds) how LONG we wait after the last user
    # input has been
    # received before we power off the video.
    # {3c0bc021 - c8a8 - 4e07 - a973 - 6b14cbcb2b7e}
    GUID_VIDEO_POWERDOWN_TIMEOUT = DEFINE_GUID(
        0x3C0BC021,
        0xC8A8,
        0x4E07,
        0xA9,
        0x73,
        0x6B,
        0x14,
        0xCB,
        0xCB,
        0x2B,
        0x7E
    )

    # Specifies whether adaptive display dimming is turned on or off.
    # N.B. This setting is DEPRECATED in Windows 8.1
    # {82DBCF2D - CD67 - 40C5 - BFDC - 9F1A5CCD4663}
    GUID_VIDEO_ANNOYANCE_TIMEOUT = DEFINE_GUID(
        0x82DBCF2D,
        0xCD67,
        0x40C5,
        0xBF,
        0xDC,
        0x9F,
        0x1A,
        0x5C,
        0xCD,
        0x46,
        0x63
    )

    # Specifies how much adaptive dim time out will be increased by.
    # N.B. This setting is DEPRECATED in Windows 8.1
    # {EED904DF - B142 - 4183 - B10B - 5A1197A37864}
    GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE = DEFINE_GUID(
        0xEED904DF,
        0xB142,
        0x4183,
        0xB1,
        0x0B,
        0x5A,
        0x11,
        0x97,
        0xA3,
        0x78,
        0x64
    )

    # Specifies (in seconds) how LONG we wait after the last user
    # input has been
    # received before we dim the video.
    # {17aaa29b - 8b43 - 4b94 - aafe - 35f64daaf1ee}
    GUID_VIDEO_DIM_TIMEOUT = DEFINE_GUID(
        0x17AAA29B,
        0x8B43,
        0x4B94,
        0xAA,
        0xFE,
        0x35,
        0xF6,
        0x4D,
        0xAA,
        0xF1,
        0xEE
    )


    # Specifies if the operating system should use adaptive timers
    # (based on
    # previous behavior) to power down the video.
    # {90959d22 - d6a1 - 49b9 - af93 - bce885ad335b}
    GUID_VIDEO_ADAPTIVE_POWERDOWN = DEFINE_GUID(
        0x90959D22,
        0xD6A1,
        0x49B9,
        0xAF,
        0x93,
        0xBC,
        0xE8,
        0x85,
        0xAD,
        0x33,
        0x5B
    )

    # Specifies if the monitor is currently being powered or not.
    # {02731015 - 4510 - 4526 - 99E6 - E5A17EBD1AEA}
    GUID_MONITOR_POWER_ON = DEFINE_GUID(
        0x02731015,
        0x4510,
        0x4526,
        0x99,
        0xE6,
        0xE5,
        0xA1,
        0x7E,
        0xBD,
        0x1A,
        0xEA
    )


    # Monitor brightness policy when in normal state.
    # {aded5e82 - b909 - 4619 - 9949 - f5d71dac0bcb}
    GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS = DEFINE_GUID(
        0xADED5E82,
        0xB909,
        0x4619,
        0x99,
        0x49,
        0xF5,
        0xD7,
        0x1D,
        0xAC,
        0x0B,
        0xCB
    )

    # Monitor brightness policy when in dim state.
    # {f1fbfde2 - a960 - 4165 - 9f88 - 50667911ce96}
    GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS = DEFINE_GUID(
        0xF1FBFDE2,
        0xA960,
        0x4165,
        0x9F,
        0x88,
        0x50,
        0x66,
        0x79,
        0x11,
        0xCE,
        0x96
    )


    # Current monitor brightness.
    # {8ffee2c6 - 2d01 - 46be - adb9 - 398addc5b4ff}
    GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS = DEFINE_GUID(
        0x8FFEE2C6,
        0x2D01,
        0x46BE,
        0xAD,
        0xB9,
        0x39,
        0x8A,
        0xDD,
        0xC5,
        0xB4,
        0xFF
    )

    # Specifies if the operating system should use ambient light
    # sensor to change
    # adaptively the display's brightness.
    # {FBD9AA66 - 9553 - 4097 - BA44 - ED6E9D65EAB8}
    GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS = DEFINE_GUID(
        0xFBD9AA66,
        0x9553,
        0x4097,
        0xBA,
        0x44,
        0xED,
        0x6E,
        0x9D,
        0x65,
        0xEA,
        0xB8
    )


    # Specifies a change in the current monitor's display state.
    # {6fe69556 - 704a - 47a0 - 8f24 - c28d936fda47}
    GUID_CONSOLE_DISPLAY_STATE = DEFINE_GUID(
        0x6FE69556,
        0x704A,
        0x47A0,
        0x8F,
        0x24,
        0xC2,
        0x8D,
        0x93,
        0x6F,
        0xDA,
        0x47
    )

    # Defines a guid for enabling/disabling the ability to create
    # display required
    # power requests.
    # {A9CEB8DA - CD46 - 44FB - A98B - 02AF69DE4623}
    GUID_ALLOW_DISPLAY_REQUIRED = DEFINE_GUID(
        0xA9CEB8DA,
        0xCD46,
        0x44FB,
        0xA9,
        0x8B,
        0x02,
        0xAF,
        0x69,
        0xDE,
        0x46,
        0x23
    )


    # Specifies the video power down timeout (in seconds) after the
    # interactive
    # console is locked (and sensors indicate UserNotPresent). Value 0
    # effectively disables this feature.
    # {8EC4B3A5 - 6868 - 48c2 - BE75 - 4F3044BE88A7}
    GUID_VIDEO_CONSOLE_LOCK_TIMEOUT = DEFINE_GUID(
        0x8EC4B3A5,
        0x6868,
        0x48C2,
        0xBE,
        0x75,
        0x4F,
        0x30,
        0x44,
        0xBE,
        0x88,
        0xA7
    )

    # Adaptive power behavior settings
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # {8619B916 - E004 - 4dd8 - 9B66 - DAE86F806698}
    GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP = DEFINE_GUID(
        0x8619B916,
        0xE004,
        0x4DD8,
        0x9B,
        0x66,
        0xDA,
        0xE8,
        0x6F,
        0x80,
        0x66,
        0x98
    )


    # Specifies the input timeout (in seconds) to be used to indicate
    # UserUnkown.
    # Value 0 effectively disables this feature.
    # {5ADBBFBC - 074E - 4da1 - BA38 - DB8B36B2C8F3}
    GUID_NON_ADAPTIVE_INPUT_TIMEOUT = DEFINE_GUID(
        0x5ADBBFBC,
        0x74E,
        0x4DA1,
        0xBA,
        0x38,
        0xDB,
        0x8B,
        0x36,
        0xB2,
        0xC8,
        0xF3
    )


    # Specifies a change in the input controller(s) global system's
    # state:
    # e.g. enabled, suppressed, filtered.
    # {0E98FAE9 - F45A - 4DE1 - A757 - 6031F197F6EA}
    GUID_ADAPTIVE_INPUT_CONTROLLER_STATE = DEFINE_GUID(
        0xE98FAE9,
        0xF45A,
        0x4DE1,
        0xA7,
        0x57,
        0x60,
        0x31,
        0xF1,
        0x97,
        0xF6,
        0xEA
    )

    # Harddisk settings
    # - - - - - - - - - - - - - - - - -
    # Specifies the subgroup which will contain all of the harddisk
    # settings for a single policy.
    GUID_DISK_SUBGROUP = DEFINE_GUID(
        0x0012EE47,
        0x9041,
        0x4B5D,
        0x9B,
        0x77,
        0x53,
        0x5F,
        0xBA,
        0x8B,
        0x14,
        0x42
    )


    # Specifies a maximum power consumption level.
    GUID_DISK_MAX_POWER = DEFINE_GUID(
        0x51DEA550,
        0xBB38,
        0x4BC4,
        0x99,
        0x1B,
        0xEA,
        0xCF,
        0x37,
        0xBE,
        0x5E,
        0xC8
    )


    # Specifies (in seconds) how LONG we wait after the last disk
    # access
    # before we power off the disk.
    GUID_DISK_POWERDOWN_TIMEOUT = DEFINE_GUID(
        0x6738E2C4,
        0xE8A5,
        0x4A42,
        0xB1,
        0x6A,
        0xE0,
        0x40,
        0xE7,
        0x69,
        0x75,
        0x6E
    )


    # Specifies (in milliseconds) how LONG we wait after the last disk
    # access
    # before we power off the disk taking into account if IO
    # coalescing is active.
    # {58E39BA8 - B8E6 - 4EF6 - 90D0 - 89AE32B258D6}
    GUID_DISK_IDLE_TIMEOUT = DEFINE_GUID(
        0x58E39BA8,
        0xB8E6,
        0x4EF6,
        0x90,
        0xD0,
        0x89,
        0xAE,
        0x32,
        0xB2,
        0x58,
        0xD6
    )


    # Specifies the amount of contiguous disk activity time to ignore
    # when
    # calculating disk idleness.
    # 80e3c60e - bb94 - 4ad8 - bbe0 - 0d3195efc663
    GUID_DISK_BURST_IGNORE_THRESHOLD = DEFINE_GUID(
        0x80E3C60E,
        0xBB94,
        0x4AD8,
        0xBB,
        0xE0,
        0x0D,
        0x31,
        0x95,
        0xEF,
        0xC6,
        0x63
    )

    # Specifies if the operating system should use adaptive timers
    # (based on
    # previous behavior) to power down the disk,
    GUID_DISK_ADAPTIVE_POWERDOWN = DEFINE_GUID(
        0x396A32E1,
        0x499A,
        0x40B2,
        0x91,
        0x24,
        0xA9,
        0x6A,
        0xFE,
        0x70,
        0x76,
        0x67
    )

    # System sleep settings
    # - - - - - - - - - - - - - - - - - - - - -
    # Specifies the subgroup which will contain all of the sleep
    # settings for a single policy.
    # { 238C9FA8 - 0AAD - 41ED - 83F4 - 97BE242C8F20 }
    GUID_SLEEP_SUBGROUP = DEFINE_GUID(
        0x238C9FA8,
        0x0AAD,
        0x41ED,
        0x83,
        0xF4,
        0x97,
        0xBE,
        0x24,
        0x2C,
        0x8F,
        0x20
    )

    # Specifies an idle treshold percentage (0 - 100). The system must
    # be this idle
    # over a period of time in order to idle to sleep.
    # N.B. DEPRECATED IN WINDOWS 6.1
    GUID_SLEEP_IDLE_THRESHOLD = DEFINE_GUID(
        0x81CD32E0,
        0x7833,
        0x44F3,
        0x87,
        0x37,
        0x70,
        0x81,
        0xF3,
        0x8D,
        0x1F,
        0x70
    )


    # Specifies (in seconds) how LONG we wait after the system is
    # deemed
    # "idle" before moving to standby (S1, S2 or S3).
    GUID_STANDBY_TIMEOUT = DEFINE_GUID(
        0x29F6C1DB,
        0x86DA,
        0x48C5,
        0x9F,
        0xDB,
        0xF2,
        0xB6,
        0x7B,
        0x1F,
        0x44,
        0xDA
    )


    # Specifies (in seconds) how LONG the system should go back to
    # sleep after
    # waking unattended. 0 indicates that the standard
    # standby/hibernate idle
    # policy should be used instead.
    # {7bc4a2f9 - d8fc - 4469 - b07b - 33eb785aaca0}
    GUID_UNATTEND_SLEEP_TIMEOUT = DEFINE_GUID(
        0x7BC4A2F9,
        0xD8FC,
        0x4469,
        0xB0,
        0x7B,
        0x33,
        0xEB,
        0x78,
        0x5A,
        0xAC,
        0xA0
    )

    # Specifies (in seconds) how LONG we wait after the system is
    # deemed
    # "idle" before moving to hibernate (S4).
    GUID_HIBERNATE_TIMEOUT = DEFINE_GUID(
        0x9D7815A6,
        0x7EE4,
        0x497E,
        0x88,
        0x88,
        0x51,
        0x5A,
        0x05,
        0xF0,
        0x23,
        0x64
    )

    # Specifies whether or not Fast S4 should be enabled if the system
    # supports it
    # 94AC6D29 - 73CE - 41A6 - 809F - 6363BA21B47E
    GUID_HIBERNATE_FASTS4_POLICY = DEFINE_GUID(
        0x94AC6D29,
        0x73CE,
        0x41A6,
        0x80,
        0x9F,
        0x63,
        0x63,
        0xBA,
        0x21,
        0xB4,
        0x7E
    )

    # Define a GUID for controlling the criticality of sleep state
    # transitions.
    # Critical sleep transitions do not query applications, services
    # or drivers
    # before transitioning the platform to a sleep state.
    # {B7A27025 - E569 - 46c2 - A504 - 2B96CAD225A1}
    GUID_CRITICAL_POWER_TRANSITION = DEFINE_GUID(
        0xB7A27025,
        0xE569,
        0x46C2,
        0xA5,
        0x04,
        0x2B,
        0x96,
        0xCA,
        0xD2,
        0x25,
        0xA1
    )


    # Specifies if the system is entering or exiting 'away mode'.
    # 98A7F580 - 01F7 - 48AA - 9C0F - 44352C29E5C0
    GUID_SYSTEM_AWAYMODE = DEFINE_GUID(
        0x98A7F580,
        0x01F7,
        0x48AA,
        0x9C,
        0x0F,
        0x44,
        0x35,
        0x2C,
        0x29,
        0xE5,
        0xC0
    )


    # Specify whether away mode is allowed
    # {25DFA149 - 5DD1 - 4736 - B5AB - E8A37B5B8187}
    GUID_ALLOW_AWAYMODE = DEFINE_GUID(
        0x25DFA149,
        0x5DD1,
        0x4736,
        0xB5,
        0xAB,
        0xE8,
        0xA3,
        0x7B,
        0x5B,
        0x81,
        0x87
    )

    # Defines a guid to control User Presence Prediction mode.
    # {82011705 - FB95 - 4D46 - 8D35 - 4042B1D20DEF}
    GUID_USER_PRESENCE_PREDICTION = DEFINE_GUID(
        0x82011705,
        0xFB95,
        0x4D46,
        0x8D,
        0x35,
        0x40,
        0x42,
        0xB1,
        0xD2,
        0xD,
        0xEF
    )


    # Defines a guid to control Standby Budget Grace Period.
    # {60C07FE1 - 0556 - 45CF - 9903 - D56E32210242}
    GUID_STANDBY_BUDGET_GRACE_PERIOD = DEFINE_GUID(
        0x60C07FE1,
        0x0556,
        0x45CF,
        0x99,
        0x03,
        0xD5,
        0x6E,
        0x32,
        0x21,
        0x2,
        0x42
    )

    # Defines a guid to control Standby Budget Percent.
    # {9FE527BE - 1B70 - 48DA - 930D - 7BCF17B44990}
    GUID_STANDBY_BUDGET_PERCENT = DEFINE_GUID(
        0x9FE527BE,
        0x1B70,
        0x48DA,
        0x93,
        0x0D,
        0x7B,
        0xCF,
        0x17,
        0xB4,
        0x49,
        0x90
    )


    # Defines a guid to control Standby Reserve Grace Period.
    # {C763EE92 - 71E8 - 4127 - 84EB - F6ED043A3E3D}
    GUID_STANDBY_RESERVE_GRACE_PERIOD = DEFINE_GUID(
        0xC763EE92,
        0x71E8,
        0x4127,
        0x84,
        0xEB,
        0xF6,
        0xED,
        0x04,
        0x3A,
        0x3E,
        0x3D
    )

    # Defines a guid to control Standby Reserve Time.
    # {468FE7E5 - 1158 - 46EC - 88BC - 5B96C9E44FD0}
    GUID_STANDBY_RESERVE_TIME = DEFINE_GUID(
        0x468FE7E5,
        0x1158,
        0x46EC,
        0x88,
        0xBC,
        0x5B,
        0x96,
        0xC9,
        0xE4,
        0x4F,
        0xD0
    )


    # Defines a guid to control Standby Reset Percentage.
    # {49CB11A5 - 56E2 - 4AFB - 9D38 - 3DF47872E21B}
    GUID_STANDBY_RESET_PERCENT = DEFINE_GUID(
        0x49CB11A5,
        0x56E2,
        0x4AFB,
        0x9D,
        0x38,
        0x3D,
        0xF4,
        0x78,
        0x72,
        0xE2,
        0x1B
    )

    # Defines a guid for enabling/disabling standby (S1 - S3) states.
    # This does not
    # affect hibernation (S4).
    # {abfc2519 - 3608 - 4c2a - 94ea - 171b0ed546ab}
    GUID_ALLOW_STANDBY_STATES = DEFINE_GUID(
        0xABFC2519,
        0x3608,
        0x4C2A,
        0x94,
        0xEA,
        0x17,
        0x1B,
        0x0E,
        0xD5,
        0x46,
        0xAB
    )


    # Defines a guid for enabling/disabling the ability to wake via
    # RTC.
    # {BD3B718A - 0680 - 4D9D - 8AB2 - E1D2B4AC806D}
    GUID_ALLOW_RTC_WAKE = DEFINE_GUID(
        0xBD3B718A,
        0x0680,
        0x4D9D,
        0x8A,
        0xB2,
        0xE1,
        0xD2,
        0xB4,
        0xAC,
        0x80,
        0x6D
    )

    # Defines a guid for enabling/disabling legacy RTC mitigations.
    # {1A34BDC3 - 7E6B - 442E - A9D0 - 64B6EF378E84}
    GUID_LEGACY_RTC_MITIGATION = DEFINE_GUID(
        0x1A34BDC3,
        0x7E6B,
        0x442E,
        0xA9,
        0xD0,
        0x64,
        0xB6,
        0xEF,
        0x37,
        0x8E,
        0x84
    )


    # Defines a guid for enabling/disabling the ability to create
    # system required
    # power requests.
    # {A4B195F5 - 8225 - 47D8 - 8012 - 9D41369786E2}
    GUID_ALLOW_SYSTEM_REQUIRED = DEFINE_GUID(
        0xA4B195F5,
        0x8225,
        0x47D8,
        0x80,
        0x12,
        0x9D,
        0x41,
        0x36,
        0x97,
        0x86,
        0xE2
    )

    # Energy Saver settings
    # - - - - - - - - - - - - - - - - - - - - -
    # Indicates if Enegry Saver is ON or OFF.
    # {E00958C0 - C213 - 4ACE - AC77 - FECCED2EEEA5}
    GUID_POWER_SAVING_STATUS = DEFINE_GUID(
        0xE00958C0,
        0xC213,
        0x4ACE,
        0xAC,
        0x77,
        0xFE,
        0xCC,
        0xED,
        0x2E,
        0xEE,
        0xA5
    )


    # Specifies the subgroup which will contain all of the Energy
    # Saver settings
    # for a single policy.
    # {DE830923 - A562 - 41AF - A086 - E3A2C6BAD2DA}
    GUID_ENERGY_SAVER_SUBGROUP = DEFINE_GUID(
        0xDE830923,
        0xA562,
        0x41AF,
        0xA0,
        0x86,
        0xE3,
        0xA2,
        0xC6,
        0xBA,
        0xD2,
        0xDA
    )

    # Defines a guid to engage Energy Saver at specific battery charge
    # level
    # {E69653CA - CF7F - 4F05 - AA73 - CB833FA90AD4}
    GUID_ENERGY_SAVER_BATTERY_THRESHOLD = DEFINE_GUID(
        0xE69653CA,
        0xCF7F,
        0x4F05,
        0xAA,
        0x73,
        0xCB,
        0x83,
        0x3F,
        0xA9,
        0x0A,
        0xD4
    )


    # Defines a guid to specify display brightness weight when Energy
    # Saver is engaged
    # {13D09884 - F74E - 474A - A852 - B6BDE8AD03A8}
    GUID_ENERGY_SAVER_BRIGHTNESS = DEFINE_GUID(
        0x13D09884,
        0xF74E,
        0x474A,
        0xA8,
        0x52,
        0xB6,
        0xBD,
        0xE8,
        0xAD,
        0x03,
        0xA8
    )

    # Defines a guid to specify the Energy Saver policy
    # {5C5BB349 - AD29 - 4ee2 - 9D0B - 2B25270F7A81}
    GUID_ENERGY_SAVER_POLICY = DEFINE_GUID(
        0x5C5BB349,
        0xAD29,
        0x4EE2,
        0x9D,
        0xB,
        0x2B,
        0x25,
        0x27,
        0xF,
        0x7A,
        0x81
    )

    # System button actions
    # - - - - - - - - - - - - - - - - - - - - -
    # Specifies the subgroup which will contain all of the system
    # button
    # settings for a single policy.
    GUID_SYSTEM_BUTTON_SUBGROUP = DEFINE_GUID(
        0x4F971E89,
        0xEEBD,
        0x4455,
        0xA8,
        0xDE,
        0x9E,
        0x59,
        0x04,
        0x0E,
        0x73,
        0x47
    )
    POWERBUTTON_ACTION_INDEX_NOTHING = 0
    POWERBUTTON_ACTION_INDEX_SLEEP = 1
    POWERBUTTON_ACTION_INDEX_HIBERNATE = 2
    POWERBUTTON_ACTION_INDEX_SHUTDOWN = 3
    POWERBUTTON_ACTION_INDEX_TURN_OFF_THE_DISPLAY = 4

    # System button values which contain the PowerAction* value for
    # each action.
    POWERBUTTON_ACTION_VALUE_NOTHING = 0
    POWERBUTTON_ACTION_VALUE_SLEEP = 2
    POWERBUTTON_ACTION_VALUE_HIBERNATE = 3
    POWERBUTTON_ACTION_VALUE_SHUTDOWN = 6
    POWERBUTTON_ACTION_VALUE_TURN_OFF_THE_DISPLAY = 8

    # Specifies (in a POWER_ACTION_POLICY structure) the appropriate
    # action to
    # take when the system power button is pressed.
    GUID_POWERBUTTON_ACTION = DEFINE_GUID(
        0x7648EFA3,
        0xDD9C,
        0x4E3E,
        0xB5,
        0x66,
        0x50,
        0xF9,
        0x29,
        0x38,
        0x62,
        0x80
    )


    # Specifies (in a POWER_ACTION_POLICY structure) the appropriate
    # action to
    # take when the system sleep button is pressed.
    GUID_SLEEPBUTTON_ACTION = DEFINE_GUID(
        0x96996BC0,
        0xAD50,
        0x47EC,
        0x92,
        0x3B,
        0x6F,
        0x41,
        0x87,
        0x4D,
        0xD9,
        0xEB
    )


    # Specifies (in a POWER_ACTION_POLICY structure) the appropriate
    # action to
    # take when the system sleep button is pressed.
    # { A7066653 - 8D6C - 40A8 - 910E - A1F54B84C7E5 }
    GUID_USERINTERFACEBUTTON_ACTION = DEFINE_GUID(
        0xA7066653,
        0x8D6C,
        0x40A8,
        0x91,
        0x0E,
        0xA1,
        0xF5,
        0x4B,
        0x84,
        0xC7,
        0xE5
    )


    # Specifies (in a POWER_ACTION_POLICY structure) the appropriate
    # action to
    # take when the system lid is closed.
    GUID_LIDCLOSE_ACTION = DEFINE_GUID(
        0x5CA83367,
        0x6E45,
        0x459F,
        0xA2,
        0x7B,
        0x47,
        0x6B,
        0x1D,
        0x01,
        0xC9,
        0x36
    )
    GUID_LIDOPEN_POWERSTATE = DEFINE_GUID(
        0x99FF10E7,
        0x23B1,
        0x4C07,
        0xA9,
        0xD1,
        0x5C,
        0x32,
        0x06,
        0xD7,
        0x41,
        0xB4
    )

    # Battery Discharge Settings
    # - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Specifies the subgroup which will contain all of the battery
    # discharge
    # settings for a single policy.
    GUID_BATTERY_SUBGROUP = DEFINE_GUID(
        0xE73A048D,
        0xBF27,
        0x4F12,
        0x97,
        0x31,
        0x8B,
        0x20,
        0x76,
        0xE8,
        0x89,
        0x1F
    )


    # 4 battery discharge alarm settings.
    # GUID_BATTERY_DISCHARGE_ACTION_x - This is the action to take. It
    # is a value
    # of type POWER_ACTION
    # GUID_BATTERY_DISCHARGE_LEVEL_x - This is the battery level (%)
    # GUID_BATTERY_DISCHARGE_FLAGS_x - Flags defined below:
    # POWER_ACTION_POLICY - >EventCode flags
    # BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK
    # BATTERY_DISCHARGE_FLAGS_ENABLE
    GUID_BATTERY_DISCHARGE_ACTION_0 = DEFINE_GUID(
        0x637EA02F,
        0xBBCB,
        0x4015,
        0x8E,
        0x2C,
        0xA1,
        0xC7,
        0xB9,
        0xC0,
        0xB5,
        0x46
    )
    GUID_BATTERY_DISCHARGE_LEVEL_0 = DEFINE_GUID(
        0x9A66D8D7,
        0x4FF7,
        0x4EF9,
        0xB5,
        0xA2,
        0x5A,
        0x32,
        0x6C,
        0xA2,
        0xA4,
        0x69
    )
    GUID_BATTERY_DISCHARGE_FLAGS_0 = DEFINE_GUID(
        0x5DBB7C9F,
        0x38E9,
        0x40D2,
        0x97,
        0x49,
        0x4F,
        0x8A,
        0x0E,
        0x9F,
        0x64,
        0x0F
    )
    GUID_BATTERY_DISCHARGE_ACTION_1 = DEFINE_GUID(
        0xD8742DCB,
        0x3E6A,
        0x4B3C,
        0xB3,
        0xFE,
        0x37,
        0x46,
        0x23,
        0xCD,
        0xCF,
        0x06
    )
    GUID_BATTERY_DISCHARGE_LEVEL_1 = DEFINE_GUID(
        0x8183BA9A,
        0xE910,
        0x48DA,
        0x87,
        0x69,
        0x14,
        0xAE,
        0x6D,
        0xC1,
        0x17,
        0x0A
    )
    GUID_BATTERY_DISCHARGE_FLAGS_1 = DEFINE_GUID(
        0xBCDED951,
        0x187B,
        0x4D05,
        0xBC,
        0xCC,
        0xF7,
        0xE5,
        0x19,
        0x60,
        0xC2,
        0x58
    )
    GUID_BATTERY_DISCHARGE_ACTION_2 = DEFINE_GUID(
        0x421CBA38,
        0x1A8E,
        0x4881,
        0xAC,
        0x89,
        0xE3,
        0x3A,
        0x8B,
        0x04,
        0xEC,
        0xE4
    )
    GUID_BATTERY_DISCHARGE_LEVEL_2 = DEFINE_GUID(
        0x07A07CA2,
        0xADAF,
        0x40D7,
        0xB0,
        0x77,
        0x53,
        0x3A,
        0xAD,
        0xED,
        0x1B,
        0xFA
    )
    GUID_BATTERY_DISCHARGE_FLAGS_2 = DEFINE_GUID(
        0x7FD2F0C4,
        0xFEB7,
        0x4DA3,
        0x81,
        0x17,
        0xE3,
        0xFB,
        0xED,
        0xC4,
        0x65,
        0x82
    )
    GUID_BATTERY_DISCHARGE_ACTION_3 = DEFINE_GUID(
        0x80472613,
        0x9780,
        0x455E,
        0xB3,
        0x08,
        0x72,
        0xD3,
        0x00,
        0x3C,
        0xF2,
        0xF8
    )
    GUID_BATTERY_DISCHARGE_LEVEL_3 = DEFINE_GUID(
        0x58AFD5A6,
        0xC2DD,
        0x47D2,
        0x9F,
        0xBF,
        0xEF,
        0x70,
        0xCC,
        0x5C,
        0x59,
        0x65
    )
    GUID_BATTERY_DISCHARGE_FLAGS_3 = DEFINE_GUID(
        0x73613CCF,
        0xDBFA,
        0x4279,
        0x83,
        0x56,
        0x49,
        0x35,
        0xF6,
        0xBF,
        0x62,
        0xF3
    )

    # Processor power settings
    # - - - - - - - - - - - - - - - - - - - - - - - -
    # Specifies the subgroup which will contain all of the processor
    # settings for a single policy.
    # {54533251 - 82be - 4824 - 96c1 - 47b60b740d00}
    GUID_PROCESSOR_SETTINGS_SUBGROUP = DEFINE_GUID(
        0x54533251,
        0x82BE,
        0x4824,
        0x96,
        0xC1,
        0x47,
        0xB6,
        0x0B,
        0x74,
        0x0D,
        0x00
    )

    # Specifies various attributes that control processor
    # performance/throttle
    # states.
    GUID_PROCESSOR_THROTTLE_POLICY = DEFINE_GUID(
        0x57027304,
        0x4AF6,
        0x4104,
        0x92,
        0x60,
        0xE3,
        0xD9,
        0x52,
        0x48,
        0xFC,
        0x36
    )
    PERFSTATE_POLICY_CHANGE_IDEAL = 0
    PERFSTATE_POLICY_CHANGE_SINGLE = 1
    PERFSTATE_POLICY_CHANGE_ROCKET = 2
    PERFSTATE_POLICY_CHANGE_IDEAL_AGGRESSIVE = 3
    PERFSTATE_POLICY_CHANGE_DECREASE_MAX = (
        PERFSTATE_POLICY_CHANGE_ROCKET
    )
    PERFSTATE_POLICY_CHANGE_INCREASE_MAX = (
        PERFSTATE_POLICY_CHANGE_IDEAL_AGGRESSIVE
    )

    # Specifies a percentage (between 0 and 100) that the processor
    # frequency
    # should never go above. For example, if this value is set to 80,
    # then
    # the processor frequency will never be throttled above 80 percent
    # of its
    # maximum frequency by the system.
    # {bc5038f7 - 23e0 - 4960 - 96da - 33abaf5935ec}
    GUID_PROCESSOR_THROTTLE_MAXIMUM = DEFINE_GUID(
        0xBC5038F7,
        0x23E0,
        0x4960,
        0x96,
        0xDA,
        0x33,
        0xAB,
        0xAF,
        0x59,
        0x35,
        0xEC
    )


    # Specifies a percentage (between 0 and 100) that the processor
    # frequency
    # should never go above for Processor Power Efficiency Class 1.
    # For example, if this value is set to 80, then the processor
    # frequency will
    # never be throttled above 80 percent of its maximum frequency by
    # the system.
    # {bc5038f7 - 23e0 - 4960 - 96da - 33abaf5935ed}
    GUID_PROCESSOR_THROTTLE_MAXIMUM_1 = DEFINE_GUID(
        0xBC5038F7,
        0x23E0,
        0x4960,
        0x96,
        0xDA,
        0x33,
        0xAB,
        0xAF,
        0x59,
        0x35,
        0xED
    )

    # Specifies a percentage (between 0 and 100) that the processor
    # frequency
    # should not drop below. For example, if this value is set to 50,
    # then the
    # processor frequency will never be throttled below 50 percent of
    # its
    # maximum frequency by the system.
    # {893dee8e - 2bef - 41e0 - 89c6 - b55d0929964c}
    GUID_PROCESSOR_THROTTLE_MINIMUM = DEFINE_GUID(
        0x893DEE8E,
        0x2BEF,
        0x41E0,
        0x89,
        0xC6,
        0xB5,
        0x5D,
        0x09,
        0x29,
        0x96,
        0x4C
    )


    # Specifies a percentage (between 0 and 100) that the processor
    # frequency
    # should not drop below for Processor Power Efficiency Class 1.
    # For example, if this value is set to 50, then the processor
    # frequency will
    # never be throttled below 50 percent of its maximum frequency by
    # the system.
    # {893dee8e - 2bef - 41e0 - 89c6 - b55d0929964d}
    GUID_PROCESSOR_THROTTLE_MINIMUM_1 = DEFINE_GUID(
        0x893DEE8E,
        0x2BEF,
        0x41E0,
        0x89,
        0xC6,
        0xB5,
        0x5D,
        0x09,
        0x29,
        0x96,
        0x4D
    )

    # Specifies the maximum processor frequency (expresssed in MHz).
    # {75B0AE3F - BCE0 - 45a7 - 8C89 - C9611C25E100}
    GUID_PROCESSOR_FREQUENCY_LIMIT = DEFINE_GUID(
        0x75B0AE3F,
        0xBCE0,
        0x45A7,
        0x8C,
        0x89,
        0xC9,
        0x61,
        0x1C,
        0x25,
        0xE1,
        0x00
    )

    # {75B0AE3F - BCE0 - 45a7 - 8C89 - C9611C25E101}
    GUID_PROCESSOR_FREQUENCY_LIMIT_1 = DEFINE_GUID(
        0x75B0AE3F,
        0xBCE0,
        0x45A7,
        0x8C,
        0x89,
        0xC9,
        0x61,
        0x1C,
        0x25,
        0xE1,
        0x01
    )

    # Specifies whether throttle states are allowed to be used even
    # when
    # performance states are available.
    # {3b04d4fd - 1cc7 - 4f23 - ab1c - d1337819c4bb}
    GUID_PROCESSOR_ALLOW_THROTTLING = DEFINE_GUID(
        0x3B04D4FD,
        0x1CC7,
        0x4F23,
        0xAB,
        0x1C,
        0xD1,
        0x33,
        0x78,
        0x19,
        0xC4,
        0xBB
    )
    PROCESSOR_THROTTLE_DISABLED = 0
    PROCESSOR_THROTTLE_ENABLED = 1
    PROCESSOR_THROTTLE_AUTOMATIC = 2


    # Specifies processor power settings for CState policy data
    # {68F262A7 - F621 - 4069 - B9A5 - 4874169BE23C}
    GUID_PROCESSOR_IDLESTATE_POLICY = DEFINE_GUID(
        0x68F262A7,
        0xF621,
        0x4069,
        0xB9,
        0xA5,
        0x48,
        0x74,
        0x16,
        0x9B,
        0xE2,
        0x3C
    )


    # Specifies processor power settings for PerfState policy data
    # {BBDC3814 - 18E9 - 4463 - 8A55 - D197327C45C0}
    GUID_PROCESSOR_PERFSTATE_POLICY = DEFINE_GUID(
        0xBBDC3814,
        0x18E9,
        0x4463,
        0x8A,
        0x55,
        0xD1,
        0x97,
        0x32,
        0x7C,
        0x45,
        0xC0
    )


    # Specifies the increase busy percentage threshold that must be
    # met before
    # increasing the processor performance state.
    # {06cadf0e - 64ed - 448a - 8927 - ce7bf90eb35d}
    GUID_PROCESSOR_PERF_INCREASE_THRESHOLD = DEFINE_GUID(
        0x06CADF0E,
        0x64ED,
        0x448A,
        0x89,
        0x27,
        0xCE,
        0x7B,
        0xF9,
        0x0E,
        0xB3,
        0x5D
    )

    # Specifies the increase busy percentage threshold that must be
    # met before
    # increasing the processor performance state for Processor Power
    # Efficiency
    # Class 1.
    # {06cadf0e - 64ed - 448a - 8927 - ce7bf90eb35e}
    GUID_PROCESSOR_PERF_INCREASE_THRESHOLD_1 = DEFINE_GUID(
        0x06CADF0E,
        0x64ED,
        0x448A,
        0x89,
        0x27,
        0xCE,
        0x7B,
        0xF9,
        0x0E,
        0xB3,
        0x5E
    )


    # Specifies the decrease busy percentage threshold that must be
    # met before
    # decreasing the processor performance state.
    # {12a0ab44 - fe28 - 4fa9 - b3bd - 4b64f44960a6}
    GUID_PROCESSOR_PERF_DECREASE_THRESHOLD = DEFINE_GUID(
        0x12A0AB44,
        0xFE28,
        0x4FA9,
        0xB3,
        0xBD,
        0x4B,
        0x64,
        0xF4,
        0x49,
        0x60,
        0xA6
    )

    # Specifies the decrease busy percentage threshold that must be
    # met before
    # decreasing the processor performance state for Processor Power
    # Efficiency
    # Class 1.
    # {12a0ab44 - fe28 - 4fa9 - b3bd - 4b64f44960a7}
    GUID_PROCESSOR_PERF_DECREASE_THRESHOLD_1 = DEFINE_GUID(
        0x12A0AB44,
        0xFE28,
        0x4FA9,
        0xB3,
        0xBD,
        0x4B,
        0x64,
        0xF4,
        0x49,
        0x60,
        0xA7
    )


    # Specifies, either as ideal, single or rocket, how aggressive
    # performance
    # states should be selected when increasing the processor
    # performance state.
    # {465E1F50 - B610 - 473a - AB58 - 00D1077DC418}
    GUID_PROCESSOR_PERF_INCREASE_POLICY = DEFINE_GUID(
        0x465E1F50,
        0xB610,
        0x473A,
        0xAB,
        0x58,
        0x0,
        0xD1,
        0x7,
        0x7D,
        0xC4,
        0x18
    )

    # Specifies, either as ideal, single or rocket, how aggressive
    # performance
    # states should be selected when increasing the processor
    # performance state
    # for Processor Power Efficiency Class 1.
    # {465E1F50 - B610 - 473a - AB58 - 00D1077DC419}
    GUID_PROCESSOR_PERF_INCREASE_POLICY_1 = DEFINE_GUID(
        0x465E1F50,
        0xB610,
        0x473A,
        0xAB,
        0x58,
        0x0,
        0xD1,
        0x7,
        0x7D,
        0xC4,
        0x19
    )


    # Specifies, either as ideal, single or rocket, how aggressive
    # performance
    # states should be selected when decreasing the processor
    # performance state.
    # {40FBEFC7 - 2E9D - 4d25 - A185 - 0CFD8574BAC6}
    GUID_PROCESSOR_PERF_DECREASE_POLICY = DEFINE_GUID(
        0x40FBEFC7,
        0x2E9D,
        0x4D25,
        0xA1,
        0x85,
        0xC,
        0xFD,
        0x85,
        0x74,
        0xBA,
        0xC6
    )

    # Specifies, either as ideal, single or rocket, how aggressive
    # performance
    # states should be selected when decreasing the processor
    # performance state for
    # Processor Power Efficiency Class 1.
    # {40FBEFC7 - 2E9D - 4d25 - A185 - 0CFD8574BAC7}
    GUID_PROCESSOR_PERF_DECREASE_POLICY_1 = DEFINE_GUID(
        0x40FBEFC7,
        0x2E9D,
        0x4D25,
        0xA1,
        0x85,
        0xC,
        0xFD,
        0x85,
        0x74,
        0xBA,
        0xC7
    )


    # Specifies, in milliseconds, the minimum amount of time that must
    # elapse after
    # the last processor performance state change before increasing
    # the processor
    # performance state.
    # {984CF492 - 3BED - 4488 - A8F9 - 4286C97BF5AA}
    GUID_PROCESSOR_PERF_INCREASE_TIME = DEFINE_GUID(
        0x984CF492,
        0x3BED,
        0x4488,
        0xA8,
        0xF9,
        0x42,
        0x86,
        0xC9,
        0x7B,
        0xF5,
        0xAA
    )

    # Specifies, in milliseconds, the minimum amount of time that must
    # elapse after
    # the last processor performance state change before increasing
    # the processor
    # performance state for Processor Power Efficiency Class 1.
    # {984CF492 - 3BED - 4488 - A8F9 - 4286C97BF5AB}
    GUID_PROCESSOR_PERF_INCREASE_TIME_1 = DEFINE_GUID(
        0x984CF492,
        0x3BED,
        0x4488,
        0xA8,
        0xF9,
        0x42,
        0x86,
        0xC9,
        0x7B,
        0xF5,
        0xAB
    )


    # Specifies, in milliseconds, the minimum amount of time that must
    # elapse after
    # the last processor performance state change before increasing
    # the processor
    # performance state.
    # {D8EDEB9B - 95CF - 4f95 - A73C - B061973693C8}
    GUID_PROCESSOR_PERF_DECREASE_TIME = DEFINE_GUID(
        0xD8EDEB9B,
        0x95CF,
        0x4F95,
        0xA7,
        0x3C,
        0xB0,
        0x61,
        0x97,
        0x36,
        0x93,
        0xC8
    )

    # Specifies, in milliseconds, the minimum amount of time that must
    # elapse after
    # the last processor performance state change before increasing
    # the processor
    # performance state for Processor Power Efficiency Class 1.
    # {D8EDEB9B - 95CF - 4f95 - A73C - B061973693C9}
    GUID_PROCESSOR_PERF_DECREASE_TIME_1 = DEFINE_GUID(
        0xD8EDEB9B,
        0x95CF,
        0x4F95,
        0xA7,
        0x3C,
        0xB0,
        0x61,
        0x97,
        0x36,
        0x93,
        0xC9
    )


    # Specifies the time, in milliseconds, that must expire before
    # considering
    # a change in the processor performance states or parked core set.
    # {4D2B0152 - 7D5C - 498b - 88E2 - 34345392A2C5}
    GUID_PROCESSOR_PERF_TIME_CHECK = DEFINE_GUID(
        0x4D2B0152,
        0x7D5C,
        0x498B,
        0x88,
        0xE2,
        0x34,
        0x34,
        0x53,
        0x92,
        0xA2,
        0xC5
    )

    # Specifies how the processor should manage performance and
    # efficiency
    # tradeoffs when boosting frequency above the maximum.
    # {45BCC044 - D885 - 43e2 - 8605 - EE0EC6E96B59}
    GUID_PROCESSOR_PERF_BOOST_POLICY = DEFINE_GUID(
        0x45BCC044,
        0xD885,
        0x43E2,
        0x86,
        0x5,
        0xEE,
        0xE,
        0xC6,
        0xE9,
        0x6B,
        0x59
    )
    PROCESSOR_PERF_BOOST_POLICY_DISABLED = 0
    PROCESSOR_PERF_BOOST_POLICY_MAX = 100


    # Specifies how a processor opportunistically increases frequency
    # above
    # the maximum when operating contitions allow it to do so safely.
    # {BE337238 - 0D82 - 4146 - A960 - 4F3749D470C7}
    GUID_PROCESSOR_PERF_BOOST_MODE = DEFINE_GUID(
        0xBE337238,
        0xD82,
        0x4146,
        0xA9,
        0x60,
        0x4F,
        0x37,
        0x49,
        0xD4,
        0x70,
        0xC7
    )
    PROCESSOR_PERF_BOOST_MODE_DISABLED = 0
    PROCESSOR_PERF_BOOST_MODE_ENABLED = 1
    PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE = 2
    PROCESSOR_PERF_BOOST_MODE_EFFICIENT_ENABLED = 3
    PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE = 4
    PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE_AT_GUARANTEED = 5
    PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE_AT_GUARANTEED = 6
    PROCESSOR_PERF_BOOST_MODE_MAX = (
        PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE_AT_GUARANTEED
    )

    # Specifies whether or not a procesor should autonomously select
    # its
    # operating performance state.
    # {8BAA4A8A - 14C6 - 4451 - 8E8B - 14BDBD197537}
    GUID_PROCESSOR_PERF_AUTONOMOUS_MODE = DEFINE_GUID(
        0x8BAA4A8A,
        0x14C6,
        0x4451,
        0x8E,
        0x8B,
        0x14,
        0xBD,
        0xBD,
        0x19,
        0x75,
        0x37
    )
    PROCESSOR_PERF_AUTONOMOUS_MODE_DISABLED = 0
    PROCESSOR_PERF_AUTONOMOUS_MODE_ENABLED = 1


    # Specifies the tradeoff between performance and energy the
    # processor should
    # make when operating in autonomous mode.
    # {36687F9E - E3A5 - 4dbf - B1DC - 15EB381C6863}
    GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE = DEFINE_GUID(
        0x36687F9E,
        0xE3A5,
        0x4DBF,
        0xB1,
        0xDC,
        0x15,
        0xEB,
        0x38,
        0x1C,
        0x68,
        0x63
    )
    PROCESSOR_PERF_PERFORMANCE_PREFERENCE = 0xFF
    PROCESSOR_PERF_ENERGY_PREFERENCE = 0


    # Specifies the window over which the processor should observe
    # utilization when
    # operating in autonomous mode, in microseconds.
    # {CFEDA3D0 - 7697 - 4566 - A922 - A9086CD49DFA}
    GUID_PROCESSOR_PERF_AUTONOMOUS_ACTIVITY_WINDOW = DEFINE_GUID(
        0xCFEDA3D0,
        0x7697,
        0x4566,
        0xA9,
        0x22,
        0xA9,
        0x8,
        0x6C,
        0xD4,
        0x9D,
        0xFA
    )
    PROCESSOR_PERF_MINIMUM_ACTIVITY_WINDOW = 0
    PROCESSOR_PERF_MAXIMUM_ACTIVITY_WINDOW = 1270000000


    # Specifies whether the processor should perform duty cycling.
    # {4E4450B3 - 6179 - 4e91 - B8F1 - 5BB9938F81A1}
    GUID_PROCESSOR_DUTY_CYCLING = DEFINE_GUID(
        0x4E4450B3,
        0x6179,
        0x4E91,
        0xB8,
        0xF1,
        0x5B,
        0xB9,
        0x93,
        0x8F,
        0x81,
        0xA1
    )
    PROCESSOR_DUTY_CYCLING_DISABLED = 0
    PROCESSOR_DUTY_CYCLING_ENABLED = 1


    # Specifies if idle state promotion and demotion values should be
    # scaled based
    # on the current peformance state.
    # {6C2993B0 - 8F48 - 481f - BCC6 - 00DD2742AA06}
    GUID_PROCESSOR_IDLE_ALLOW_SCALING = DEFINE_GUID(
        0x6C2993B0,
        0x8F48,
        0x481F,
        0xBC,
        0xC6,
        0x0,
        0xDD,
        0x27,
        0x42,
        0xAA,
        0x6
    )

    # Specifies if idle states should be disabled.
    # {5D76A2CA - E8C0 - 402f - A133 - 2158492D58AD}
    GUID_PROCESSOR_IDLE_DISABLE = DEFINE_GUID(
        0x5D76A2CA,
        0xE8C0,
        0x402F,
        0xA1,
        0x33,
        0x21,
        0x58,
        0x49,
        0x2D,
        0x58,
        0xAD
    )


    # Specifies the deepest idle state type that should be used. If
    # this value is
    # set to zero, this setting is ignored. Values higher than
    # supported by the
    # processor then this setting has no effect.
    # {9943e905 - 9a30 - 4ec1 - 9b99 - 44dd3b76f7a2}
    GUID_PROCESSOR_IDLE_STATE_MAXIMUM = DEFINE_GUID(
        0x9943E905,
        0x9A30,
        0x4EC1,
        0x9B,
        0x99,
        0x44,
        0xDD,
        0x3B,
        0x76,
        0xF7,
        0xA2
    )

    # Specifies the time that elapsed since the last idle state
    # promotion or
    # demotion before idle states may be promoted or demoted again (in
    # microseconds).
    # {C4581C31 - 89AB - 4597 - 8E2B - 9C9CAB440E6B}
    GUID_PROCESSOR_IDLE_TIME_CHECK = DEFINE_GUID(
        0xC4581C31,
        0x89AB,
        0x4597,
        0x8E,
        0x2B,
        0x9C,
        0x9C,
        0xAB,
        0x44,
        0xE,
        0x6B
    )


    # Specifies the upper busy threshold that must be met before
    # demoting the
    # processor to a lighter idle state (in percentage).
    # {4B92D758 - 5A24 - 4851 - A470 - 815D78AEE119}
    GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD = DEFINE_GUID(
        0x4B92D758,
        0x5A24,
        0x4851,
        0xA4,
        0x70,
        0x81,
        0x5D,
        0x78,
        0xAE,
        0xE1,
        0x19
    )

    # Specifies the lower busy threshold that must be met before
    # promoting the
    # processor to a deeper idle state (in percentage).
    # {7B224883 - B3CC - 4d79 - 819F - 8374152CBE7C}
    GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD = DEFINE_GUID(
        0x7B224883,
        0xB3CC,
        0x4D79,
        0x81,
        0x9F,
        0x83,
        0x74,
        0x15,
        0x2C,
        0xBE,
        0x7C
    )


    # Specifies the utilization threshold in percent that must be
    # crossed in order to un - park cores.
    # N.B. This power setting is DEPRECATED.
    # {df142941 - 20f3 - 4edf - 9a4a - 9c83d3d717d1}
    GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD = DEFINE_GUID(
        0xDF142941,
        0x20F3,
        0x4EDF,
        0x9A,
        0x4A,
        0x9C,
        0x83,
        0xD3,
        0xD7,
        0x17,
        0xD1
    )


    # Specifies the utilization threshold in percent that must be
    # crossed in order to park cores.
    # N.B. This power setting is DEPRECATED.
    # {68dd2f27 - a4ce - 4e11 - 8487 - 3794e4135dfa}
    GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD = DEFINE_GUID(
        0x68DD2F27,
        0xA4CE,
        0x4E11,
        0x84,
        0x87,
        0x37,
        0x94,
        0xE4,
        0x13,
        0x5D,
        0xFA
    )


    # Specifies, either as ideal, single or rocket, how aggressive
    # core parking is when cores must be unparked.
    # {c7be0679 - 2817 - 4d69 - 9d02 - 519a537ed0c6}
    GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY = DEFINE_GUID(
        0xC7BE0679,
        0x2817,
        0x4D69,
        0x9D,
        0x02,
        0x51,
        0x9A,
        0x53,
        0x7E,
        0xD0,
        0xC6
    )
    CORE_PARKING_POLICY_CHANGE_IDEAL = 0
    CORE_PARKING_POLICY_CHANGE_SINGLE = 1
    CORE_PARKING_POLICY_CHANGE_ROCKET = 2
    CORE_PARKING_POLICY_CHANGE_MULTISTEP = 3
    CORE_PARKING_POLICY_CHANGE_MAX = (
        CORE_PARKING_POLICY_CHANGE_MULTISTEP
    )

    # Specifies, either as ideal, single or rocket, how aggressive
    # core parking is when cores must be parked.
    # {71021b41 - c749 - 4d21 - be74 - a00f335d582b}
    GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY = DEFINE_GUID(
        0x71021B41,
        0xC749,
        0x4D21,
        0xBE,
        0x74,
        0xA0,
        0x0F,
        0x33,
        0x5D,
        0x58,
        0x2B
    )


    # Specifies, on a per processor group basis, the maximum number of
    # cores that can be kept unparked.
    # {ea062031 - 0e34 - 4ff1 - 9b6d - eb1059334028}
    GUID_PROCESSOR_CORE_PARKING_MAX_CORES = DEFINE_GUID(
        0xEA062031,
        0x0E34,
        0x4FF1,
        0x9B,
        0x6D,
        0xEB,
        0x10,
        0x59,
        0x33,
        0x40,
        0x28
    )

    # Specifies, on a per processor group basis, the maximum number of
    # cores that
    # can be kept unparked for Processor Power Efficiency Class 1.
    # {ea062031 - 0e34 - 4ff1 - 9b6d - eb1059334029}
    GUID_PROCESSOR_CORE_PARKING_MAX_CORES_1 = DEFINE_GUID(
        0xEA062031,
        0x0E34,
        0x4FF1,
        0x9B,
        0x6D,
        0xEB,
        0x10,
        0x59,
        0x33,
        0x40,
        0x29
    )


    # Specifies, on a per processor group basis, the minimum number of
    # cores that must be kept unparked.
    # {0cc5b647 - c1df - 4637 - 891a - dec35c318583}
    GUID_PROCESSOR_CORE_PARKING_MIN_CORES = DEFINE_GUID(
        0x0CC5B647,
        0xC1DF,
        0x4637,
        0x89,
        0x1A,
        0xDE,
        0xC3,
        0x5C,
        0x31,
        0x85,
        0x83
    )

    # Specifies, on a per processor group basis, the minimum number of
    # cores that
    # must be kept unparked in Processor Power Efficiency Class 1.
    # {0cc5b647 - c1df - 4637 - 891a - dec35c318584}
    GUID_PROCESSOR_CORE_PARKING_MIN_CORES_1 = DEFINE_GUID(
        0x0CC5B647,
        0xC1DF,
        0x4637,
        0x89,
        0x1A,
        0xDE,
        0xC3,
        0x5C,
        0x31,
        0x85,
        0x84
    )


    # Specifies, in milliseconds, the minimum amount of time a core
    # must be parked before it can be unparked.
    # {2ddd5a84 - 5a71 - 437e - 912a - db0b8c788732}
    GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME = DEFINE_GUID(
        0x2DDD5A84,
        0x5A71,
        0x437E,
        0x91,
        0x2A,
        0xDB,
        0x0B,
        0x8C,
        0x78,
        0x87,
        0x32
    )

    # Specifies, in milliseconds, the minimum amount of time a core
    # must be unparked before it can be parked.
    # {dfd10d17 - d5eb - 45dd - 877a - 9a34ddd15c82}
    GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME = DEFINE_GUID(
        0xDFD10D17,
        0xD5EB,
        0x45DD,
        0x87,
        0x7A,
        0x9A,
        0x34,
        0xDD,
        0xD1,
        0x5C,
        0x82
    )


    # Specifies the factor by which to decrease affinity history on
    # each core after each check.
    # {8f7b45e3 - c393 - 480a - 878c - f67ac3d07082}
    GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR = DEFINE_GUID(
        0x8F7B45E3,
        0xC393,
        0x480A,
        0x87,
        0x8C,
        0xF6,
        0x7A,
        0xC3,
        0xD0,
        0x70,
        0x82
    )

    # Specifies the threshold above which a core is considered to have
    # had significant affinitized work scheduled to it while parked.
    # {5b33697b - e89d - 4d38 - aa46 - 9e7dfb7cd2f9}
    GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD = DEFINE_GUID(
        0x5B33697B,
        0xE89D,
        0x4D38,
        0xAA,
        0x46,
        0x9E,
        0x7D,
        0xFB,
        0x7C,
        0xD2,
        0xF9
    )


    # Specifies the weighting given to each occurence where
    # affinitized work was scheduled to a parked core.
    # {e70867f1 - fa2f - 4f4e - aea1 - 4d8a0ba23b20}
    GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING = DEFINE_GUID(
        0xE70867F1,
        0xFA2F,
        0x4F4E,
        0xAE,
        0xA1,
        0x4D,
        0x8A,
        0x0B,
        0xA2,
        0x3B,
        0x20
    )

    # Specifies the factor by which to decrease the over utilization
    # history on each core after the current performance check.
    # {1299023c - bc28 - 4f0a - 81ec - d3295a8d815d}
    GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR = DEFINE_GUID(
        0x1299023C,
        0xBC28,
        0x4F0A,
        0x81,
        0xEC,
        0xD3,
        0x29,
        0x5A,
        0x8D,
        0x81,
        0x5D
    )


    # Specifies the threshold above which a core is considered to have
    # been recently over utilized while parked.
    # {9ac18e92 - aa3c - 4e27 - b307 - 01ae37307129}
    GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD = DEFINE_GUID(
        0x9AC18E92,
        0xAA3C,
        0x4E27,
        0xB3,
        0x07,
        0x01,
        0xAE,
        0x37,
        0x30,
        0x71,
        0x29
    )

    # Specifies the weighting given to each occurence where a parked
    # core is found to be over utilized.
    # {8809c2d8 - b155 - 42d4 - bcda - 0d345651b1db}
    GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING = DEFINE_GUID(
        0x8809C2D8,
        0xB155,
        0x42D4,
        0xBC,
        0xDA,
        0x0D,
        0x34,
        0x56,
        0x51,
        0xB1,
        0xDB
    )


    # Specifies, in percentage, the busy threshold that must be met
    # before a parked core is considered over utilized.
    # {943c8cb6 - 6f93 - 4227 - ad87 - e9a3feec08d1}
    GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD = DEFINE_GUID(
        0x943C8CB6,
        0x6F93,
        0x4227,
        0xAD,
        0x87,
        0xE9,
        0xA3,
        0xFE,
        0xEC,
        0x08,
        0xD1
    )

    # Specifies if at least one processor per core should always
    # remain unparked.
    # {a55612aa - f624 - 42c6 - a443 - 7397d064c04f}
    GUID_PROCESSOR_PARKING_CORE_OVERRIDE = DEFINE_GUID(
        0xA55612AA,
        0xF624,
        0x42C6,
        0xA4,
        0x43,
        0x73,
        0x97,
        0xD0,
        0x64,
        0xC0,
        0x4F
    )


    # Specifies what performance state a processor should enter when
    # first parked.
    # {447235c7 - 6a8d - 4cc0 - 8e24 - 9eaf70b96e2b}
    GUID_PROCESSOR_PARKING_PERF_STATE = DEFINE_GUID(
        0x447235C7,
        0x6A8D,
        0x4CC0,
        0x8E,
        0x24,
        0x9E,
        0xAF,
        0x70,
        0xB9,
        0x6E,
        0x2B
    )

    # Specifies what performance state a processor should enter when
    # first parked
    # for Processor Power Efficiency Class 1.
    # {447235c7 - 6a8d - 4cc0 - 8e24 - 9eaf70b96e2c}
    GUID_PROCESSOR_PARKING_PERF_STATE_1 = DEFINE_GUID(
        0x447235C7,
        0x6A8D,
        0x4CC0,
        0x8E,
        0x24,
        0x9E,
        0xAF,
        0x70,
        0xB9,
        0x6E,
        0x2C
    )


    # Specify the busy threshold that must be met when calculating the
    # concurrency of a node's workload.
    # {2430ab6f - a520 - 44a2 - 9601 - f7f23b5134b1}
    GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD = DEFINE_GUID(
        0x2430AB6F,
        0xA520,
        0x44A2,
        0x96,
        0x01,
        0xF7,
        0xF2,
        0x3B,
        0x51,
        0x34,
        0xB1
    )

    # Specify the busy threshold that must be met by all cores in a
    # concurrency set to unpark an extra core.
    # {f735a673 - 2066 - 4f80 - a0c5 - ddee0cf1bf5d}
    GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD = DEFINE_GUID(
        0xF735A673,
        0x2066,
        0x4F80,
        0xA0,
        0xC5,
        0xDD,
        0xEE,
        0x0C,
        0xF1,
        0xBF,
        0x5D
    )


    # Specify the percentage utilization used to calculate the
    # distribution concurrency.
    # {4bdaf4e9 - d103 - 46d7 - a5f0 - 6280121616ef}
    GUID_PROCESSOR_PARKING_DISTRIBUTION_THRESHOLD = DEFINE_GUID(
        0x4BDAF4E9,
        0xD103,
        0x46D7,
        0xA5,
        0xF0,
        0x62,
        0x80,
        0x12,
        0x16,
        0x16,
        0xEF
    )

    # Specifies the number of perf time check intervals to average
    # utility over.
    # {7d24baa7 - 0b84 - 480f - 840c - 1b0743c00f5f}
    GUID_PROCESSOR_PERF_HISTORY = DEFINE_GUID(
        0x7D24BAA7,
        0x0B84,
        0x480F,
        0x84,
        0x0C,
        0x1B,
        0x07,
        0x43,
        0xC0,
        0x0F,
        0x5F
    )


    # Specifies the number of perf time check intervals to average
    # utility over in
    # Processor Power Efficiency Class 1.
    # {7d24baa7 - 0b84 - 480f - 840c - 1b0743c00f60}
    GUID_PROCESSOR_PERF_HISTORY_1 = DEFINE_GUID(
        0x7D24BAA7,
        0x0B84,
        0x480F,
        0x84,
        0x0C,
        0x1B,
        0x07,
        0x43,
        0xC0,
        0x0F,
        0x60
    )

    # Specifies the number of perf time check intervals to average
    # utility over to
    # determine performance increase.
    # N.B. This power setting is DEPRECATED.
    # {99B3EF01 - 752F - 46a1 - 80FB - 7730011F2354}
    GUID_PROCESSOR_PERF_INCREASE_HISTORY = DEFINE_GUID(
        0x99B3EF01,
        0x752F,
        0x46A1,
        0x80,
        0xFB,
        0x77,
        0x30,
        0x1,
        0x1F,
        0x23,
        0x54
    )

    # Specifies the number of perf time check intervals to average
    # utility over to
    # determine performance decrease.
    # N.B. This power setting is DEPRECATED.
    # {0300F6F8 - ABD6 - 45a9 - B74F - 4908691A40B5}
    GUID_PROCESSOR_PERF_DECREASE_HISTORY = DEFINE_GUID(
        0x300F6F8,
        0xABD6,
        0x45A9,
        0xB7,
        0x4F,
        0x49,
        0x8,
        0x69,
        0x1A,
        0x40,
        0xB5
    )

    # Specifies the number of perf time check intervals to average
    # utility over for
    # core parking.
    # N.B. This power setting is DEPRECATED.
    # {77D7F282 - 8F1A - 42cd - 8537 - 45450A839BE8}
    GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY = DEFINE_GUID(
        0x77D7F282,
        0x8F1A,
        0x42CD,
        0x85,
        0x37,
        0x45,
        0x45,
        0xA,
        0x83,
        0x9B,
        0xE8
    )

    # Specifies whether latency sensitivity hints should be taken into
    # account by
    # the perf state engine.
    # N.B. This power setting is DEPRECATED.
    # {0822df31 - 9c83 - 441c - a079 - 0de4cf009c7b}
    GUID_PROCESSOR_PERF_LATENCY_HINT = DEFINE_GUID(
        0x0822DF31,
        0x9C83,
        0x441C,
        0xA0,
        0x79,
        0x0D,
        0xE4,
        0xCF,
        0x00,
        0x9C,
        0x7B
    )

    # Specifies the processor performance state in response to latency
    # sensitivity hints.
    # {619b7505 - 003b - 4e82 - b7a6 - 4dd29c300971}
    GUID_PROCESSOR_PERF_LATENCY_HINT_PERF = DEFINE_GUID(
        0x619B7505,
        0x3B,
        0x4E82,
        0xB7,
        0xA6,
        0x4D,
        0xD2,
        0x9C,
        0x30,
        0x9,
        0x71
    )


    # Specifies the processor performance state in response to latency
    # sensitivity
    # hints for Processor Power Efficiency Class 1.
    # {619b7505 - 003b - 4e82 - b7a6 - 4dd29c300972}
    GUID_PROCESSOR_PERF_LATENCY_HINT_PERF_1 = DEFINE_GUID(
        0x619B7505,
        0x3B,
        0x4E82,
        0xB7,
        0xA6,
        0x4D,
        0xD2,
        0x9C,
        0x30,
        0x9,
        0x72
    )

    # Specifies the minimum unparked processors when a latency hint is
    # active
    # (in a percentage).
    # {616cdaa5 - 695e - 4545 - 97ad - 97dc2d1bdd88}
    GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK = DEFINE_GUID(
        0x616CDAA5,
        0x695E,
        0x4545,
        0x97,
        0xAD,
        0x97,
        0xDC,
        0x2D,
        0x1B,
        0xDD,
        0x88
    )


    # Specifies the minimum unparked processors when a latency hint is
    # active
    # for Processor Power Efficiency Class 1 (in a percentage).
    # {616cdaa5 - 695e - 4545 - 97ad - 97dc2d1bdd89}
    GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK_1 = DEFINE_GUID(
        0x616CDAA5,
        0x695E,
        0x4545,
        0x97,
        0xAD,
        0x97,
        0xDC,
        0x2D,
        0x1B,
        0xDD,
        0x89
    )

    # Specifies whether the core parking engine should distribute
    # processor
    # utility.
    # {e0007330 - f589 - 42ed - a401 - 5ddb10e785d3}
    GUID_PROCESSOR_DISTRIBUTE_UTILITY = DEFINE_GUID(
        0xE0007330,
        0xF589,
        0x42ED,
        0xA4,
        0x01,
        0x5D,
        0xDB,
        0x10,
        0xE7,
        0x85,
        0xD3
    )


    # GUIDS to control PPM settings on computer system with more than
    # one
    # Processor Power Efficiency Classes (heterogeneous system).
    # - - - - - - - - - - - - - - - - -
    # Specifies the current active heterogeneous policy.
    # {7f2f5cfa - f10c - 4823 - b5e1 - e93ae85f46b5}
    GUID_PROCESSOR_HETEROGENEOUS_POLICY = DEFINE_GUID(
        0x7F2F5CFA,
        0xF10C,
        0x4823,
        0xB5,
        0xE1,
        0xE9,
        0x3A,
        0xE8,
        0x5F,
        0x46,
        0xB5
    )


    # Specifies the number of perf check cycles required to decrease
    # the number of
    # Processor Power Efficiency Class 1 processors.
    # {7f2492b6 - 60b1 - 45e5 - ae55 - 773f8cd5caec}
    GUID_PROCESSOR_HETERO_DECREASE_TIME = DEFINE_GUID(
        0x7F2492B6,
        0x60B1,
        0x45E5,
        0xAE,
        0x55,
        0x77,
        0x3F,
        0x8C,
        0xD5,
        0xCA,
        0xEC
    )

    # Specifies the number of perf check cycles required to increase
    # the number of
    # Processor Power Efficiency Class 1 processors.
    # {4009efa7 - e72d - 4cba - 9edf - 91084ea8cbc3}
    GUID_PROCESSOR_HETERO_INCREASE_TIME = DEFINE_GUID(
        0x4009EFA7,
        0xE72D,
        0x4CBA,
        0x9E,
        0xDF,
        0x91,
        0x08,
        0x4E,
        0xA8,
        0xCB,
        0xC3
    )


    # Specifies the performance level
    # (in units of Processor Power Efficiency
    # Class 0 processor
    # performance) at which the number of Processor Power
    # Efficiency Class 1 processors is decreased.
    # {f8861c27 - 95e7 - 475c - 865b - 13c0cb3f9d6b}
    GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD = DEFINE_GUID(
        0xF8861C27,
        0x95E7,
        0x475C,
        0x86,
        0x5B,
        0x13,
        0xC0,
        0xCB,
        0x3F,
        0x9D,
        0x6B
    )

    # Specifies the performance level
    # (in units of Processor Power Efficiency
    # Class 0 processor
    # performance) at which the number of Processor Power
    # Efficiency Class 1 processors is increased.
    # {b000397d - 9b0b - 483d - 98c9 - 692a6060cfbf}
    GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD = DEFINE_GUID(
        0xB000397D,
        0x9B0B,
        0x483D,
        0x98,
        0xC9,
        0x69,
        0x2A,
        0x60,
        0x60,
        0xCF,
        0xBF
    )


    # Specifies the performance target floor of a Processor Power
    # Efficiency
    # Class 0 processor when the system unparks Processor Power
    # Efficiency Class 1
    # processor(s).
    # {fddc842b - 8364 - 4edc - 94cf - c17f60de1c80}
    GUID_PROCESSOR_CLASS0_FLOOR_PERF = DEFINE_GUID(
        0xFDDC842B,
        0x8364,
        0x4EDC,
        0x94,
        0xCF,
        0xC1,
        0x7F,
        0x60,
        0xDE,
        0x1C,
        0x80
    )

    # Specifies the initial performance target of a Processor Power
    # Efficiency
    # Class 1 processor when the system makes a transition up from
    # zero Processor
    # Power Efficiency Class 1 processors.
    # {1facfc65 - a930 - 4bc5 - 9f38 - 504ec097bbc0}
    GUID_PROCESSOR_CLASS1_INITIAL_PERF = DEFINE_GUID(
        0x1FACFC65,
        0xA930,
        0x4BC5,
        0x9F,
        0x38,
        0x50,
        0x4E,
        0xC0,
        0x97,
        0xBB,
        0xC0
    )


    # Specifies the scheduling policy for threads in a given QoS class.
    # {93B8B6DC - 0698 - 4d1c - 9EE4 - 0644E900C85D}
    GUID_PROCESSOR_THREAD_SCHEDULING_POLICY = DEFINE_GUID(
        0x93B8B6DC,
        0x698,
        0x4D1C,
        0x9E,
        0xE4,
        0x6,
        0x44,
        0xE9,
        0x0,
        0xC8,
        0x5D
    )

    # Specifies the scheduling policy for SHORT running threads in a
    # given QoS
    # class.
    # {BAE08B81 - 2D5E - 4688 - AD6A - 13243356654B}
    GUID_PROCESSOR_SHORT_THREAD_SCHEDULING_POLICY = DEFINE_GUID(
        0xBAE08B81,
        0x2D5E,
        0x4688,
        0xAD,
        0x6A,
        0x13,
        0x24,
        0x33,
        0x56,
        0x65,
        0x4B
    )


    # Specifies active vs passive cooling. Although not directly
    # related to
    # processor settings, it is the processor that gets throttled if
    # we're doing
    # passive cooling, so it is fairly strongly related.
    # {94D3A615 - A899 - 4AC5 - AE2B - E4D8F634367F}
    GUID_SYSTEM_COOLING_POLICY = DEFINE_GUID(
        0x94D3A615,
        0xA899,
        0x4AC5,
        0xAE,
        0x2B,
        0xE4,
        0xD8,
        0xF6,
        0x34,
        0x36,
        0x7F
    )

    # Lock Console on Wake
    # - - - - - - - - - - - - - - - - - - - -
    # Specifies the behavior of the system when we wake from standby or
    # hibernate. If this is set, then we will cause the console to lock
    # after we resume.
    GUID_LOCK_CONSOLE_ON_WAKE = DEFINE_GUID(
        0x0E796BDB,
        0x100D,
        0x47D6,
        0xA2,
        0xD5,
        0xF7,
        0xD2,
        0xDA,
        0xA5,
        0x1F,
        0x51
    )

    # Device idle characteristics
    # - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Specifies whether to use the "performance" or "conservative"
    # timeouts for
    # device idle management.
    # 4faab71a - 92e5 - 4726 - b531 - 224559672d19
    GUID_DEVICE_IDLE_POLICY = DEFINE_GUID(
        0x4FAAB71A,
        0x92E5,
        0x4726,
        0xB5,
        0x31,
        0x22,
        0x45,
        0x59,
        0x67,
        0x2D,
        0x19
    )
    POWER_DEVICE_IDLE_POLICY_PERFORMANCE = 0
    POWER_DEVICE_IDLE_POLICY_CONSERVATIVE = 1

    # Specifies standby connectivity preference.
    # F15576E8 - 98B7 - 4186 - B944 - EAFA664402D9
    GUID_CONNECTIVITY_IN_STANDBY = DEFINE_GUID(
        0xF15576E8,
        0x98B7,
        0x4186,
        0xB9,
        0x44,
        0xEA,
        0xFA,
        0x66,
        0x44,
        0x02,
        0xD9
    )
    POWER_CONNECTIVITY_IN_STANDBY_DISABLED = 0
    POWER_CONNECTIVITY_IN_STANDBY_ENABLED = 1
    POWER_CONNECTIVITY_IN_STANDBY_SYSTEM_MANAGED = 2

    # Specifies the mode for disconnected standby.
    # 68AFB2D9 - EE95 - 47A8 - 8F50 - 4115088073B1
    GUID_DISCONNECTED_STANDBY_MODE = DEFINE_GUID(
        0x68AFB2D9,
        0xEE95,
        0x47A8,
        0x8F,
        0x50,
        0x41,
        0x15,
        0x08,
        0x80,
        0x73,
        0xB1
    )
    POWER_DISCONNECTED_STANDBY_MODE_NORMAL = 0
    POWER_DISCONNECTED_STANDBY_MODE_AGGRESSIVE = 1

    # AC/DC power source
    # - - - - - - - - - - - - - - - - - -
    # Specifies the power source for the system. consumers may
    # register for
    # notification when the power source changes and will be notified
    # with
    # one of 3 values:
    # 0 - Indicates the system is being powered by an AC power source.
    # 1 - Indicates the system is being powered by a DC power source.
    # 2 - Indicates the system is being powered by a short - term DC
    # power
    # source. For example, this would be the case if the system is
    # being powed by a short - term battery supply in a backing UPS
    # system. When this value is recieved, the consumer should make
    # preparations for either a system hibernate or system shutdown.
    # { 5D3E9A59 - E9D5 - 4B00 - A6BD - FF34FF516548 }
    GUID_ACDC_POWER_SOURCE = DEFINE_GUID(
        0x5D3E9A59,
        0xE9D5,
        0x4B00,
        0xA6,
        0xBD,
        0xFF,
        0x34,
        0xFF,
        0x51,
        0x65,
        0x48
    )

    # Lid state changes
    # - - - - - - - - - - - - - - - - -
    # Specifies the current state of the lid (open or closed). The
    # callback won't
    # be called at all until a lid device is found and its current
    # state is known.
    # Values:
    # 0 - closed
    # 1 - opened
    # { BA3E0F4D - B817 - 4094 - A2D1 - D56379E6A0F3 }
    GUID_LIDSWITCH_STATE_CHANGE = DEFINE_GUID(
        0xBA3E0F4D,
        0xB817,
        0x4094,
        0xA2,
        0xD1,
        0xD5,
        0x63,
        0x79,
        0xE6,
        0xA0,
        0xF3
    )

    # Battery status changes
    # - - - - - - - - - - - - - - - - - - - - - -
    # Specifies the percentage of battery life remaining. The consumer
    # may register for notification in order to track battery life in
    # a fine - grained manner.
    # Once registered, the consumer can expect to be notified as the
    # battery
    # life percentage changes.
    # The consumer will recieve a value between 0 and 100 (inclusive)
    # which
    # indicates percent battery life remaining.
    # { A7AD8041 - B45A - 4CAE - 87A3 - EECBB468A9E1 }
    GUID_BATTERY_PERCENTAGE_REMAINING = DEFINE_GUID(
        0xA7AD8041,
        0xB45A,
        0x4CAE,
        0x87,
        0xA3,
        0xEE,
        0xCB,
        0xB4,
        0x68,
        0xA9,
        0xE1
    )

    # Specifies change in number of batteries present on the system.
    # The consumer
    # may register for notification in order to track change in number
    # of batteries
    # available on a system.
    # Once registered, the consumer can expect to be notified whenever
    # the
    # batteries are added or removed from the system.
    # The consumer will recieve a value indicating number of batteries
    # currently
    # present on the system.
    # {7D263F15 - FCA4 - 49E5 - 854B - A9F2BFBD5C24}
    GUID_BATTERY_COUNT = DEFINE_GUID(
        0x7D263F15,
        0xFCA4,
        0x49E5,
        0x85,
        0x4B,
        0xA9,
        0xF2,
        0xBF,
        0xBD,
        0x5C,
        0x24
    )

    # Global notification indicating to listeners user
    # activity/presence accross
    # all sessions in the system (Present, NotPresent, Inactive)
    # {786E8A1D - B427 - 4344 - 9207 - 09E70BDCBEA9}
    GUID_GLOBAL_USER_PRESENCE = DEFINE_GUID(
        0x786E8A1D,
        0xB427,
        0x4344,
        0x92,
        0x7,
        0x9,
        0xE7,
        0xB,
        0xDC,
        0xBE,
        0xA9
    )

    # Session specific notification indicating to listeners whether or
    # not the display
    # related to the given session is on/off/dim
    # N.B. This is a session - specific notification, sent only to
    # interactive
    # session registrants. Session 0 and kernel mode consumers do not
    # receive
    # this notification.
    # {2B84C20E - AD23 - 4ddf - 93DB - 05FFBD7EFCA5}
    GUID_SESSION_DISPLAY_STATUS = DEFINE_GUID(
        0x2B84C20E,
        0xAD23,
        0x4DDF,
        0x93,
        0xDB,
        0x5,
        0xFF,
        0xBD,
        0x7E,
        0xFC,
        0xA5
    )


    # Session specific notification indicating to listeners user
    # activity/presence
    # (Present, NotPresent, Inactive)
    # N.B. This is a session - specific notification, sent only to
    # interactive
    # session registrants. Session 0 and kernel mode consumers do not
    # receive
    # this notification.
    # {3C0F4548 - C03F - 4c4d - B9F2 - 237EDE686376}
    GUID_SESSION_USER_PRESENCE = DEFINE_GUID(
        0x3C0F4548,
        0xC03F,
        0x4C4D,
        0xB9,
        0xF2,
        0x23,
        0x7E,
        0xDE,
        0x68,
        0x63,
        0x76
    )

    # Notification to listeners that the system is fairly busy and
    # won't be moving
    # into an idle state any time soon. This can be used as a hint to
    # listeners
    # that now might be a good time to do background tasks.
    GUID_IDLE_BACKGROUND_TASK = DEFINE_GUID(
        0x515C31D8,
        0xF734,
        0x163D,
        0xA0,
        0xFD,
        0x11,
        0xA0,
        0x8C,
        0x91,
        0xE8,
        0xF1
    )

    # Notification to listeners that the system is fairly busy and
    # won't be moving
    # into an idle state any time soon. This can be used as a hint to
    # listeners
    # that now might be a good time to do background tasks.
    # { CF23F240 - 2A54 - 48D8 - B114 - DE1518FF052E }
    GUID_BACKGROUND_TASK_NOTIFICATION = DEFINE_GUID(
        0xCF23F240,
        0x2A54,
        0x48D8,
        0xB1,
        0x14,
        0xDE,
        0x15,
        0x18,
        0xFF,
        0x05,
        0x2E
    )

    # Define a GUID that will represent the action of a direct
    # experience button
    # on the platform. Users will register for this DPPE setting and
    # recieve
    # notification when the h/w button is pressed.
    # { 1A689231 - 7399 - 4E9A - 8F99 - B71F999DB3FA }
    GUID_APPLAUNCH_BUTTON = DEFINE_GUID(
        0x1A689231,
        0x7399,
        0x4E9A,
        0x8F,
        0x99,
        0xB7,
        0x1F,
        0x99,
        0x9D,
        0xB3,
        0xFA
    )

    # PCI Express power settings
    # - - - - - - - - - - - - - - - - - - - - - - - -
    # Specifies the subgroup which will contain all of the PCI Express
    # settings for a single policy.
    # {501a4d13 - 42af - 4429 - 9fd1 - a8218c268e20}
    GUID_PCIEXPRESS_SETTINGS_SUBGROUP = DEFINE_GUID(
        0x501A4D13,
        0x42AF,
        0x4429,
        0x9F,
        0xD1,
        0xA8,
        0x21,
        0x8C,
        0x26,
        0x8E,
        0x20
    )

    # Specifies the PCI Express ASPM power policy.
    # {ee12f906 - d277 - 404b - b6da - e5fa1a576df5}
    GUID_PCIEXPRESS_ASPM_POLICY = DEFINE_GUID(
        0xEE12F906,
        0xD277,
        0x404B,
        0xB6,
        0xDA,
        0xE5,
        0xFA,
        0x1A,
        0x57,
        0x6D,
        0xF5
    )

    # POWER Shutdown settings
    # - - - - - - - - - - - - - - - - - - - - - - - -
    # Specifies if forced shutdown should be used for all button and
    # lid initiated
    # shutdown actions.
    # {833a6b62 - dfa4 - 46d1 - 82f8 - e09e34d029d6}
    GUID_ENABLE_SWITCH_FORCED_SHUTDOWN = DEFINE_GUID(
        0x833A6B62,
        0xDFA4,
        0x46D1,
        0x82,
        0xF8,
        0xE0,
        0x9E,
        0x34,
        0xD0,
        0x29,
        0xD6
    )

    # Interrupt Steering power settings
    # - - - - - - - - - - - - - - - - - - - - - - - -
    # {48672F38 - 7A9A - 4bb2 - 8BF8 - 3D85BE19DE4E}
    GUID_INTSTEER_SUBGROUP = DEFINE_GUID(
        0x48672F38,
        0x7A9A,
        0x4BB2,
        0x8B,
        0xF8,
        0x3D,
        0x85,
        0xBE,
        0x19,
        0xDE,
        0x4E
    )

    # {2BFC24F9 - 5EA2 - 4801 - 8213 - 3DBAE01AA39D}
    GUID_INTSTEER_MODE = DEFINE_GUID(
        0x2BFC24F9,
        0x5EA2,
        0x4801,
        0x82,
        0x13,
        0x3D,
        0xBA,
        0xE0,
        0x1A,
        0xA3,
        0x9D
    )

    # {73CDE64D - D720 - 4bb2 - A860 - C755AFE77EF2}
    GUID_INTSTEER_LOAD_PER_PROC_TRIGGER = DEFINE_GUID(
        0x73CDE64D,
        0xD720,
        0x4BB2,
        0xA8,
        0x60,
        0xC7,
        0x55,
        0xAF,
        0xE7,
        0x7E,
        0xF2
    )

    # {D6BA4903 - 386F - 4c2c - 8ADB - 5C21B3328D25}
    GUID_INTSTEER_TIME_UNPARK_TRIGGER = DEFINE_GUID(
        0xD6BA4903,
        0x386F,
        0x4C2C,
        0x8A,
        0xDB,
        0x5C,
        0x21,
        0xB3,
        0x32,
        0x8D,
        0x25
    )

    # Graphics power settings
    # - - - - - - - - - - - - - - - - - - - - - - - -
    # Specified the subgroup which contains all inbox graphics
    # settings.
    # {5FB4938D - 1EE8 - 4b0f - 9A3C - 5036B0AB995C}
    GUID_GRAPHICS_SUBGROUP = DEFINE_GUID(
        0x5FB4938D,
        0x1EE8,
        0x4B0F,
        0x9A,
        0x3C,
        0x50,
        0x36,
        0xB0,
        0xAB,
        0x99,
        0x5C
    )

    # Specifies the GPU preference policy.
    # {DD848B2A - 8A5D - 4451 - 9AE2 - 39CD41658F6C}
    GUID_GPU_PREFERENCE_POLICY = DEFINE_GUID(
        0xDD848B2A,
        0x8A5D,
        0x4451,
        0x9A,
        0xE2,
        0x39,
        0xCD,
        0x41,
        0x65,
        0x8F,
        0x6C
    )

    # Other miscellaneous power notification GUIDs
    # - - - - - - - - - - - - - - - - - - - - - - - -
    # Specifies whether mixed reality mode is engaged.
    # {1E626B4E - CF04 - 4f8d - 9CC7 - C97C5B0F2391}
    GUID_MIXED_REALITY_MODE = DEFINE_GUID(
        0x1E626B4E,
        0xCF04,
        0x4F8D,
        0x9C,
        0xC7,
        0xC9,
        0x7C,
        0x5B,
        0xF,
        0x23,
        0x91
    )

    # Specifies a change (start/end) in System Power Report's Active
    # Session.
    # {0E24CE38 - C393 - 4742 - BDB1 - 744F4B9EE08E}
    GUID_SPR_ACTIVE_SESSION_CHANGE = DEFINE_GUID(
        0xE24CE38,
        0xC393,
        0x4742,
        0xBD,
        0xB1,
        0x74,
        0x4F,
        0x4B,
        0x9E,
        0xE0,
        0x8E
    )




    class _SYSTEM_POWER_STATE(ENUM):
        PowerSystemUnspecified = 0
        PowerSystemWorking = 1
        PowerSystemSleeping1 = 2
        PowerSystemSleeping2 = 3
        PowerSystemSleeping3 = 4
        PowerSystemHibernate = 5
        PowerSystemShutdown = 6
        PowerSystemMaximum = 7

    SYSTEM_POWER_STATE = _SYSTEM_POWER_STATE
    PSYSTEM_POWER_STATE = POINTER(_SYSTEM_POWER_STATE)
    POWER_SYSTEM_MAXIMUM = 7


    class POWER_ACTION(ENUM):
        PowerActionNone = 0
        PowerActionReserved = 1
        PowerActionSleep = 2
        PowerActionHibernate = 3
        PowerActionShutdown = 4
        PowerActionShutdownReset = 5
        PowerActionShutdownOff = 6
        PowerActionWarmEject = 7
        PowerActionDisplayOff = 8


    PPOWER_ACTION = POINTER(POWER_ACTION)
    PowerActionNone = POWER_ACTION.PowerActionNone
    PowerActionReserved = POWER_ACTION.PowerActionReserved
    PowerActionSleep = POWER_ACTION.PowerActionSleep
    PowerActionHibernate = POWER_ACTION.PowerActionHibernate
    PowerActionShutdown = POWER_ACTION.PowerActionShutdown
    PowerActionShutdownReset = POWER_ACTION.PowerActionShutdownReset
    PowerActionShutdownOff = POWER_ACTION.PowerActionShutdownOff
    PowerActionWarmEject = POWER_ACTION.PowerActionWarmEject
    PowerActionDisplayOff = POWER_ACTION.PowerActionDisplayOff


    class _DEVICE_POWER_STATE(ENUM):
        PowerDeviceUnspecified = 0
        PowerDeviceD0 = 1
        PowerDeviceD1 = 2
        PowerDeviceD2 = 3
        PowerDeviceD3 = 4
        PowerDeviceMaximum = 5


    DEVICE_POWER_STATE = _DEVICE_POWER_STATE
    PDEVICE_POWER_STATE = POINTER(_DEVICE_POWER_STATE)


    class _MONITOR_DISPLAY_STATE(ENUM):
        PowerMonitorOff = 0
        PowerMonitorOn = 1
        PowerMonitorDim = 2


    MONITOR_DISPLAY_STATE = _MONITOR_DISPLAY_STATE
    PMONITOR_DISPLAY_STATE = POINTER(_MONITOR_DISPLAY_STATE)


    class _USER_ACTIVITY_PRESENCE(ENUM):
        PowerUserPresent = 0
        PowerUserNotPresent = 1
        PowerUserInactive = 2
        PowerUserMaximum = 3
        PowerUserInvalid = PowerUserMaximum


    USER_ACTIVITY_PRESENCE = _USER_ACTIVITY_PRESENCE
    PUSER_ACTIVITY_PRESENCE = POINTER(_USER_ACTIVITY_PRESENCE)
    ES_SYSTEM_REQUIRED = 0x00000001
    ES_DISPLAY_REQUIRED = 0x00000002
    ES_USER_PRESENT = 0x00000004
    ES_AWAYMODE_REQUIRED = 0x00000040
    ES_CONTINUOUS = 0x80000000


    class LATENCY_TIME(ENUM):
        LT_DONT_CARE = 1
        LT_LOWEST_LATENCY = 2


    LT_DONT_CARE = LATENCY_TIME.LT_DONT_CARE
    LT_LOWEST_LATENCY = LATENCY_TIME.LT_LOWEST_LATENCY
    DIAGNOSTIC_REASON_VERSION = 0
    DIAGNOSTIC_REASON_SIMPLE_STRING = 0x00000001
    DIAGNOSTIC_REASON_DETAILED_STRING = 0x00000002
    DIAGNOSTIC_REASON_NOT_SPECIFIED = 0x80000000
    DIAGNOSTIC_REASON_INVALID_FLAGS = ~0x80000007

    # Defines for power request APIs
    POWER_REQUEST_CONTEXT_VERSION = DIAGNOSTIC_REASON_VERSION
    POWER_REQUEST_CONTEXT_SIMPLE_STRING = (
        DIAGNOSTIC_REASON_SIMPLE_STRING
    )
    POWER_REQUEST_CONTEXT_DETAILED_STRING = (
        DIAGNOSTIC_REASON_DETAILED_STRING
    )


    class _POWER_REQUEST_TYPE(ENUM):
        PowerRequestDisplayRequired = 1
        PowerRequestSystemRequired = 2
        PowerRequestAwayModeRequired = 3
        PowerRequestExecutionRequired = 4


    POWER_REQUEST_TYPE = _POWER_REQUEST_TYPE
    PPOWER_REQUEST_TYPE = POINTER(_POWER_REQUEST_TYPE)

    # end_ntminiport
    if NTDDI_VERSION >= NTDDI_WINXP:
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        # - - - - - - - - - - - - - - - - -
        # Device Power Information
        # Accessable via
        # CM_Get_DevInst_Registry_Property_Ex(CM_DRP_DEVICE_POWER_DATA)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        # - - - - - - - - - - - - - - - - -
        PDCAP_D0_SUPPORTED = 0x00000001
        PDCAP_D1_SUPPORTED = 0x00000002
        PDCAP_D2_SUPPORTED = 0x00000004
        PDCAP_D3_SUPPORTED = 0x00000008
        PDCAP_WAKE_FROM_D0_SUPPORTED = 0x00000010
        PDCAP_WAKE_FROM_D1_SUPPORTED = 0x00000020
        PDCAP_WAKE_FROM_D2_SUPPORTED = 0x00000040
        PDCAP_WAKE_FROM_D3_SUPPORTED = 0x00000080
        PDCAP_WARM_EJECT_SUPPORTED = 0x00000100

        CM_Power_Data_s._fields_ = [
            ('PD_Size', DWORD),
            ('PD_MostRecentPowerState', DEVICE_POWER_STATE),
            ('PD_Capabilities', DWORD),
            ('PD_D1Latency', DWORD),
            ('PD_D2Latency', DWORD),
            ('PD_D3Latency', DWORD),
            ('PD_PowerStateMapping', DEVICE_POWER_STATE * POWER_SYSTEM_MAXIMUM),
            ('PD_DeepestSystemWake', SYSTEM_POWER_STATE),
        ]

    # END IF   (NTDDI_VERSION >= NTDDI_WINXP)

    # begin_wdm
    class POWER_INFORMATION_LEVEL(ENUM):
        SystemPowerPolicyAc = 1
        SystemPowerPolicyDc = 2
        VerifySystemPolicyAc = 3
        VerifySystemPolicyDc = 4
        SystemPowerCapabilities = 5
        SystemBatteryState = 6
        SystemPowerStateHandler = 7
        ProcessorStateHandler = 8
        SystemPowerPolicyCurrent = 9
        AdministratorPowerPolicy = 10
        SystemReserveHiberFile = 11
        ProcessorInformation = 12
        SystemPowerInformation = 13
        ProcessorStateHandler2 = 14
        LastWakeTime = 15
        LastSleepTime = 16
        SystemExecutionState = 17
        SystemPowerStateNotifyHandler = 18
        ProcessorPowerPolicyAc = 19
        ProcessorPowerPolicyDc = 20
        VerifyProcessorPowerPolicyAc = 21
        VerifyProcessorPowerPolicyDc = 22
        ProcessorPowerPolicyCurrent = 23
        SystemPowerStateLogging = 24
        SystemPowerLoggingEntry = 25
        SetPowerSettingValue = 26
        NotifyUserPowerSetting = 27
        PowerInformationLevelUnused0 = 28
        SystemMonitorHiberBootPowerOff = 29
        SystemVideoState = 30
        TraceApplicationPowerMessage = 31
        TraceApplicationPowerMessageEnd = 32
        ProcessorPerfStates = 33
        ProcessorIdleStates = 34
        ProcessorCap = 35
        SystemWakeSource = 36
        SystemHiberFileInformation = 37
        TraceServicePowerMessage = 38
        ProcessorLoad = 39
        PowerShutdownNotification = 40
        MonitorCapabilities = 41
        SessionPowerInit = 42
        SessionDisplayState = 43
        PowerRequestCreate = 44
        PowerRequestAction = 45
        GetPowerRequestList = 46
        ProcessorInformationEx = 47
        NotifyUserModeLegacyPowerEvent = 48
        GroupPark = 49
        ProcessorIdleDomains = 50
        WakeTimerList = 51
        SystemHiberFileSize = 52
        ProcessorIdleStatesHv = 53
        ProcessorPerfStatesHv = 54
        ProcessorPerfCapHv = 55
        ProcessorSetIdle = 56
        LogicalProcessorIdling = 57
        UserPresence = 58
        PowerSettingNotificationName = 59
        GetPowerSettingValue = 60
        IdleResiliency = 61
        SessionRITState = 62
        SessionConnectNotification = 63
        SessionPowerCleanup = 64
        SessionLockState = 65
        SystemHiberbootState = 66
        PlatformInformation = 67
        PdcInvocation = 68
        MonitorInvocation = 69
        FirmwareTableInformationRegistered = 70
        SetShutdownSelectedTime = 71
        SuspendResumeInvocation = 72
        PlmPowerRequestCreate = 73
        ScreenOff = 74
        CsDeviceNotification = 75
        PlatformRole = 76
        LastResumePerformance = 77
        DisplayBurst = 78
        ExitLatencySamplingPercentage = 79
        RegisterSpmPowerSettings = 80
        PlatformIdleStates = 81
        ProcessorIdleVeto = 82
        PlatformIdleVeto = 83
        SystemBatteryStatePrecise = 84
        ThermalEvent = 85
        PowerRequestActionInternal = 86
        BatteryDeviceState = 87
        PowerInformationInternal = 88
        ThermalStandby = 89
        SystemHiberFileType = 90
        PhysicalPowerButtonPress = 91
        QueryPotentialDripsConstraint = 92
        EnergyTrackerCreate = 93
        EnergyTrackerQuery = 94
        UpdateBlackBoxRecorder = 95
        PowerInformationLevelMaximum = 96


    SystemPowerPolicyAc = POWER_INFORMATION_LEVEL.SystemPowerPolicyAc
    SystemPowerPolicyDc = POWER_INFORMATION_LEVEL.SystemPowerPolicyDc
    VerifySystemPolicyAc = POWER_INFORMATION_LEVEL.VerifySystemPolicyAc
    VerifySystemPolicyDc = POWER_INFORMATION_LEVEL.VerifySystemPolicyDc
    SystemPowerCapabilities = POWER_INFORMATION_LEVEL.SystemPowerCapabilities
    SystemBatteryState = POWER_INFORMATION_LEVEL.SystemBatteryState
    SystemPowerStateHandler = POWER_INFORMATION_LEVEL.SystemPowerStateHandler
    ProcessorStateHandler = POWER_INFORMATION_LEVEL.ProcessorStateHandler
    SystemPowerPolicyCurrent = POWER_INFORMATION_LEVEL.SystemPowerPolicyCurrent
    AdministratorPowerPolicy = POWER_INFORMATION_LEVEL.AdministratorPowerPolicy
    SystemReserveHiberFile = POWER_INFORMATION_LEVEL.SystemReserveHiberFile
    ProcessorInformation = POWER_INFORMATION_LEVEL.ProcessorInformation
    SystemPowerInformation = POWER_INFORMATION_LEVEL.SystemPowerInformation
    ProcessorStateHandler2 = POWER_INFORMATION_LEVEL.ProcessorStateHandler2
    LastWakeTime = POWER_INFORMATION_LEVEL.LastWakeTime
    LastSleepTime = POWER_INFORMATION_LEVEL.LastSleepTime
    SystemExecutionState = POWER_INFORMATION_LEVEL.SystemExecutionState
    SystemPowerStateNotifyHandler = POWER_INFORMATION_LEVEL.SystemPowerStateNotifyHandler
    ProcessorPowerPolicyAc = POWER_INFORMATION_LEVEL.ProcessorPowerPolicyAc
    ProcessorPowerPolicyDc = POWER_INFORMATION_LEVEL.ProcessorPowerPolicyDc
    VerifyProcessorPowerPolicyAc = POWER_INFORMATION_LEVEL.VerifyProcessorPowerPolicyAc
    VerifyProcessorPowerPolicyDc = POWER_INFORMATION_LEVEL.VerifyProcessorPowerPolicyDc
    ProcessorPowerPolicyCurrent = POWER_INFORMATION_LEVEL.ProcessorPowerPolicyCurrent
    SystemPowerStateLogging = POWER_INFORMATION_LEVEL.SystemPowerStateLogging
    SystemPowerLoggingEntry = POWER_INFORMATION_LEVEL.SystemPowerLoggingEntry
    SetPowerSettingValue = POWER_INFORMATION_LEVEL.SetPowerSettingValue
    NotifyUserPowerSetting = POWER_INFORMATION_LEVEL.NotifyUserPowerSetting
    PowerInformationLevelUnused0 = POWER_INFORMATION_LEVEL.PowerInformationLevelUnused0
    SystemMonitorHiberBootPowerOff = POWER_INFORMATION_LEVEL.SystemMonitorHiberBootPowerOff
    SystemVideoState = POWER_INFORMATION_LEVEL.SystemVideoState
    TraceApplicationPowerMessage = POWER_INFORMATION_LEVEL.TraceApplicationPowerMessage
    TraceApplicationPowerMessageEnd = POWER_INFORMATION_LEVEL.TraceApplicationPowerMessageEnd
    ProcessorPerfStates = POWER_INFORMATION_LEVEL.ProcessorPerfStates
    ProcessorIdleStates = POWER_INFORMATION_LEVEL.ProcessorIdleStates
    ProcessorCap = POWER_INFORMATION_LEVEL.ProcessorCap
    SystemWakeSource = POWER_INFORMATION_LEVEL.SystemWakeSource
    SystemHiberFileInformation = POWER_INFORMATION_LEVEL.SystemHiberFileInformation
    TraceServicePowerMessage = POWER_INFORMATION_LEVEL.TraceServicePowerMessage
    ProcessorLoad = POWER_INFORMATION_LEVEL.ProcessorLoad
    PowerShutdownNotification = POWER_INFORMATION_LEVEL.PowerShutdownNotification
    MonitorCapabilities = POWER_INFORMATION_LEVEL.MonitorCapabilities
    SessionPowerInit = POWER_INFORMATION_LEVEL.SessionPowerInit
    SessionDisplayState = POWER_INFORMATION_LEVEL.SessionDisplayState
    PowerRequestCreate = POWER_INFORMATION_LEVEL.PowerRequestCreate
    PowerRequestAction = POWER_INFORMATION_LEVEL.PowerRequestAction
    GetPowerRequestList = POWER_INFORMATION_LEVEL.GetPowerRequestList
    ProcessorInformationEx = POWER_INFORMATION_LEVEL.ProcessorInformationEx
    NotifyUserModeLegacyPowerEvent = POWER_INFORMATION_LEVEL.NotifyUserModeLegacyPowerEvent
    GroupPark = POWER_INFORMATION_LEVEL.GroupPark
    ProcessorIdleDomains = POWER_INFORMATION_LEVEL.ProcessorIdleDomains
    WakeTimerList = POWER_INFORMATION_LEVEL.WakeTimerList
    SystemHiberFileSize = POWER_INFORMATION_LEVEL.SystemHiberFileSize
    ProcessorIdleStatesHv = POWER_INFORMATION_LEVEL.ProcessorIdleStatesHv
    ProcessorPerfStatesHv = POWER_INFORMATION_LEVEL.ProcessorPerfStatesHv
    ProcessorPerfCapHv = POWER_INFORMATION_LEVEL.ProcessorPerfCapHv
    ProcessorSetIdle = POWER_INFORMATION_LEVEL.ProcessorSetIdle
    LogicalProcessorIdling = POWER_INFORMATION_LEVEL.LogicalProcessorIdling
    UserPresence = POWER_INFORMATION_LEVEL.UserPresence
    PowerSettingNotificationName = POWER_INFORMATION_LEVEL.PowerSettingNotificationName
    GetPowerSettingValue = POWER_INFORMATION_LEVEL.GetPowerSettingValue
    IdleResiliency = POWER_INFORMATION_LEVEL.IdleResiliency
    SessionRITState = POWER_INFORMATION_LEVEL.SessionRITState
    SessionConnectNotification = POWER_INFORMATION_LEVEL.SessionConnectNotification
    SessionPowerCleanup = POWER_INFORMATION_LEVEL.SessionPowerCleanup
    SessionLockState = POWER_INFORMATION_LEVEL.SessionLockState
    SystemHiberbootState = POWER_INFORMATION_LEVEL.SystemHiberbootState
    PlatformInformation = POWER_INFORMATION_LEVEL.PlatformInformation
    PdcInvocation = POWER_INFORMATION_LEVEL.PdcInvocation
    MonitorInvocation = POWER_INFORMATION_LEVEL.MonitorInvocation
    FirmwareTableInformationRegistered = POWER_INFORMATION_LEVEL.FirmwareTableInformationRegistered
    SetShutdownSelectedTime = POWER_INFORMATION_LEVEL.SetShutdownSelectedTime
    SuspendResumeInvocation = POWER_INFORMATION_LEVEL.SuspendResumeInvocation
    PlmPowerRequestCreate = POWER_INFORMATION_LEVEL.PlmPowerRequestCreate
    ScreenOff = POWER_INFORMATION_LEVEL.ScreenOff
    CsDeviceNotification = POWER_INFORMATION_LEVEL.CsDeviceNotification
    PlatformRole = POWER_INFORMATION_LEVEL.PlatformRole
    LastResumePerformance = POWER_INFORMATION_LEVEL.LastResumePerformance
    DisplayBurst = POWER_INFORMATION_LEVEL.DisplayBurst
    ExitLatencySamplingPercentage = POWER_INFORMATION_LEVEL.ExitLatencySamplingPercentage
    RegisterSpmPowerSettings = POWER_INFORMATION_LEVEL.RegisterSpmPowerSettings
    PlatformIdleStates = POWER_INFORMATION_LEVEL.PlatformIdleStates
    ProcessorIdleVeto = POWER_INFORMATION_LEVEL.ProcessorIdleVeto
    PlatformIdleVeto = POWER_INFORMATION_LEVEL.PlatformIdleVeto
    SystemBatteryStatePrecise = POWER_INFORMATION_LEVEL.SystemBatteryStatePrecise
    ThermalEvent = POWER_INFORMATION_LEVEL.ThermalEvent
    PowerRequestActionInternal = POWER_INFORMATION_LEVEL.PowerRequestActionInternal
    BatteryDeviceState = POWER_INFORMATION_LEVEL.BatteryDeviceState
    PowerInformationInternal = POWER_INFORMATION_LEVEL.PowerInformationInternal
    ThermalStandby = POWER_INFORMATION_LEVEL.ThermalStandby
    SystemHiberFileType = POWER_INFORMATION_LEVEL.SystemHiberFileType
    PhysicalPowerButtonPress = POWER_INFORMATION_LEVEL.PhysicalPowerButtonPress
    QueryPotentialDripsConstraint = POWER_INFORMATION_LEVEL.QueryPotentialDripsConstraint
    EnergyTrackerCreate = POWER_INFORMATION_LEVEL.EnergyTrackerCreate
    EnergyTrackerQuery = POWER_INFORMATION_LEVEL.EnergyTrackerQuery
    UpdateBlackBoxRecorder = POWER_INFORMATION_LEVEL.UpdateBlackBoxRecorder
    PowerInformationLevelMaximum = POWER_INFORMATION_LEVEL.PowerInformationLevelMaximum


    # User Presence Values
    class POWER_USER_PRESENCE_TYPE(ENUM):
        UserNotPresent = 0
        UserPresent = 1
        UserUnknown = 0xFF


    PPOWER_USER_PRESENCE_TYPE = POINTER(POWER_USER_PRESENCE_TYPE)
    UserNotPresent = POWER_USER_PRESENCE_TYPE.UserNotPresent
    UserPresent = POWER_USER_PRESENCE_TYPE.UserPresent
    UserUnknown = POWER_USER_PRESENCE_TYPE.UserUnknown

    _POWER_USER_PRESENCE._fields_ = [
        ('UserPresence', POWER_USER_PRESENCE_TYPE),
    ]

    # Session Connect/Disconnect
    _POWER_SESSION_CONNECT._fields_ = [
        # TRUE - connected, FALSE - disconnected
        ('Connected', BOOLEAN),
        # TRUE - console, FALSE - TS (not used for Connected = FALSE)
        ('Console', BOOLEAN),
    ]

    _POWER_SESSION_TIMEOUTS._fields_ = [
        ('InputTimeout', DWORD),
        ('DisplayTimeout', DWORD),
    ]

    # Session RIT State
    _POWER_SESSION_RIT_STATE._fields_ = [
        # TRUE - RIT input received, FALSE - RIT timeout
        ('Active', BOOLEAN),
        # last input time held for this session
        ('LastInputTime', DWORD),
    ]

    # Winlogon notifications
    _POWER_SESSION_WINLOGON._fields_ = [
        # the Win32k session identifier
        ('SessionId', DWORD),
        # TRUE - for console session, FALSE - for remote session
        ('Console', BOOLEAN),
        # TRUE - lock, FALSE - unlock
        ('Locked', BOOLEAN),
    ]

    # Idle resiliency
    _POWER_IDLE_RESILIENCY._fields_ = [
        ('CoalescingTimeout', DWORD),
        ('IdleResiliencyPeriod', DWORD),
    ]

    # Monitor on/off reasons
    # N.B. Update power - event mapping when adding new events.
    class POWER_MONITOR_REQUEST_REASON(ENUM):
        MonitorRequestReasonUnknown = 1
        MonitorRequestReasonPowerButton = 2
        MonitorRequestReasonRemoteConnection = 3
        MonitorRequestReasonScMonitorpower = 4
        MonitorRequestReasonUserInput = 5
        MonitorRequestReasonAcDcDisplayBurst = 6
        MonitorRequestReasonUserDisplayBurst = 7
        MonitorRequestReasonPoSetSystemState = 8
        MonitorRequestReasonSetThreadExecutionState = 9
        MonitorRequestReasonFullWake = 10
        MonitorRequestReasonSessionUnlock = 11
        MonitorRequestReasonScreenOffRequest = 12
        MonitorRequestReasonIdleTimeout = 13
        MonitorRequestReasonPolicyChange = 14
        MonitorRequestReasonSleepButton = 15
        MonitorRequestReasonLid = 16
        MonitorRequestReasonBatteryCountChange = 17
        MonitorRequestReasonGracePeriod = 18
        MonitorRequestReasonPnP = 19
        MonitorRequestReasonDP = 20
        MonitorRequestReasonSxTransition = 21
        MonitorRequestReasonSystemIdle = 22
        MonitorRequestReasonNearProximity = 23
        MonitorRequestReasonThermalStandby = 24
        MonitorRequestReasonResumePdc = 25
        MonitorRequestReasonResumeS4 = 26
        MonitorRequestReasonTerminal = 27
        MonitorRequestReasonPdcSignal = 28
        MonitorRequestReasonAcDcDisplayBurstSuppressed = 29
        MonitorRequestReasonSystemStateEntered = 30
        MonitorRequestReasonWinrt = 31
        MonitorRequestReasonUserInputKeyboard = 32
        MonitorRequestReasonUserInputMouse = 33
        MonitorRequestReasonUserInputTouch = 34
        MonitorRequestReasonUserInputPen = 35
        MonitorRequestReasonUserInputAccelerometer = 36
        MonitorRequestReasonUserInputHid = 37
        MonitorRequestReasonUserInputPoUserPresent = 38
        MonitorRequestReasonUserInputSessionSwitch = 39
        MonitorRequestReasonUserInputInitialization = 40
        MonitorRequestReasonPdcSignalWindowsMobilePwrNotif = 41
        MonitorRequestReasonPdcSignalWindowsMobileShell = 42
        MonitorRequestReasonPdcSignalHeyCortana = 43
        MonitorRequestReasonPdcSignalHolographicShell = 44
        MonitorRequestReasonPdcSignalFingerprint = 45
        MonitorRequestReasonMax = 46


    MonitorRequestReasonUnknown = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUnknown
    MonitorRequestReasonPowerButton = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonPowerButton
    MonitorRequestReasonRemoteConnection = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonRemoteConnection
    MonitorRequestReasonScMonitorpower = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonScMonitorpower
    MonitorRequestReasonUserInput = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserInput
    MonitorRequestReasonAcDcDisplayBurst = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonAcDcDisplayBurst
    MonitorRequestReasonUserDisplayBurst = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserDisplayBurst
    MonitorRequestReasonPoSetSystemState = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonPoSetSystemState
    MonitorRequestReasonSetThreadExecutionState = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonSetThreadExecutionState
    MonitorRequestReasonFullWake = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonFullWake
    MonitorRequestReasonSessionUnlock = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonSessionUnlock
    MonitorRequestReasonScreenOffRequest = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonScreenOffRequest
    MonitorRequestReasonIdleTimeout = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonIdleTimeout
    MonitorRequestReasonPolicyChange = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonPolicyChange
    MonitorRequestReasonSleepButton = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonSleepButton
    MonitorRequestReasonLid = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonLid
    MonitorRequestReasonBatteryCountChange = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonBatteryCountChange
    MonitorRequestReasonGracePeriod = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonGracePeriod
    MonitorRequestReasonPnP = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonPnP
    MonitorRequestReasonDP = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonDP
    MonitorRequestReasonSxTransition = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonSxTransition
    MonitorRequestReasonSystemIdle = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonSystemIdle
    MonitorRequestReasonNearProximity = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonNearProximity
    MonitorRequestReasonThermalStandby = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonThermalStandby
    MonitorRequestReasonResumePdc = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonResumePdc
    MonitorRequestReasonResumeS4 = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonResumeS4
    MonitorRequestReasonTerminal = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonTerminal
    MonitorRequestReasonPdcSignal = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonPdcSignal
    MonitorRequestReasonAcDcDisplayBurstSuppressed = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonAcDcDisplayBurstSuppressed
    MonitorRequestReasonSystemStateEntered = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonSystemStateEntered
    MonitorRequestReasonWinrt = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonWinrt
    MonitorRequestReasonUserInputKeyboard = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserInputKeyboard
    MonitorRequestReasonUserInputMouse = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserInputMouse
    MonitorRequestReasonUserInputTouch = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserInputTouch
    MonitorRequestReasonUserInputPen = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserInputPen
    MonitorRequestReasonUserInputAccelerometer = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserInputAccelerometer
    MonitorRequestReasonUserInputHid = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserInputHid
    MonitorRequestReasonUserInputPoUserPresent = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserInputPoUserPresent
    MonitorRequestReasonUserInputSessionSwitch = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserInputSessionSwitch
    MonitorRequestReasonUserInputInitialization = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserInputInitialization
    MonitorRequestReasonPdcSignalWindowsMobilePwrNotif = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonPdcSignalWindowsMobilePwrNotif
    MonitorRequestReasonPdcSignalWindowsMobileShell = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonPdcSignalWindowsMobileShell
    MonitorRequestReasonPdcSignalHeyCortana = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonPdcSignalHeyCortana
    MonitorRequestReasonPdcSignalHolographicShell = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonPdcSignalHolographicShell
    MonitorRequestReasonPdcSignalFingerprint = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonPdcSignalFingerprint
    MonitorRequestReasonMax = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonMax


    class _POWER_MONITOR_REQUEST_TYPE(ENUM):
        MonitorRequestTypeOff = 1
        MonitorRequestTypeOnAndPresent = 2
        MonitorRequestTypeToggleOn = 3


    POWER_MONITOR_REQUEST_TYPE = _POWER_MONITOR_REQUEST_TYPE

    # Monitor invocation
    _POWER_MONITOR_INVOCATION._fields_ = [
        ('Console', BOOLEAN),
        ('RequestReason', POWER_MONITOR_REQUEST_REASON),
    ]

    # Last resume performance structure
    _RESUME_PERFORMANCE._fields_ = [
        ('PostTimeMs', DWORD),
        ('TotalResumeTimeMs', ULONGLONG),
        ('ResumeCompleteTimestamp', ULONGLONG),
    ]

    # Power Setting definitions
    class SYSTEM_POWER_CONDITION(ENUM):
        PoAc = 1
        PoDc = 2
        PoHot = 3
        PoConditionMaximum = 4


    PoAc = SYSTEM_POWER_CONDITION.PoAc
    PoDc = SYSTEM_POWER_CONDITION.PoDc
    PoHot = SYSTEM_POWER_CONDITION.PoHot
    PoConditionMaximum = SYSTEM_POWER_CONDITION.PoConditionMaximum

    SET_POWER_SETTING_VALUE._fields_ = [
        # POWER_SETTING_VALUE_VERSION.
        ('Version', DWORD),
        # GUID representing the power setting being applied.
        ('Guid', GUID),
        # AC, DC, thermal, ...
        ('PowerCondition', SYSTEM_POWER_CONDITION),
        # Length (in bytes) of the 'Data' member.
        ('DataLength', DWORD),
        # Data which contains the actual setting value.
        ('Data', BYTE * ANYSIZE_ARRAY),
    ]
    POWER_SETTING_VALUE_VERSION = 0x1

    NOTIFY_USER_POWER_SETTING._fields_ = [
        ('Guid', GUID),
    ]

    # Package definition for an experience button device notification.
    # When
    # someone registers for GUID_EXPERIENCE_BUTTON, this is the
    # definition of
    # the setting data they'll get.
    _APPLICATIONLAUNCH_SETTING_VALUE._fields_ = [
        # specified in 100ns internvals since January 1, 1601.
        ('ActivationTime', LARGE_INTEGER),
        # Reserved for internal use.
        ('Flags', DWORD),
        # which instance of this device was pressed?
        ('ButtonInstanceID', DWORD),
    ]

    # define platform roles
    class _POWER_PLATFORM_ROLE(ENUM):
        PlatformRoleUnspecified = 0
        PlatformRoleDesktop = 1
        PlatformRoleMobile = 2
        PlatformRoleWorkstation = 3
        PlatformRoleEnterpriseServer = 4
        PlatformRoleSOHOServer = 5
        PlatformRoleAppliancePC = 6
        PlatformRolePerformanceServer = 7
        PlatformRoleSlate = 8
        PlatformRoleMaximum = 9


    POWER_PLATFORM_ROLE = _POWER_PLATFORM_ROLE
    PPOWER_PLATFORM_ROLE = POINTER(_POWER_PLATFORM_ROLE)
    POWER_PLATFORM_ROLE_V1 = 0x00000001
    POWER_PLATFORM_ROLE_V1_MAX = _POWER_PLATFORM_ROLE.PlatformRolePerformanceServer + 1
    POWER_PLATFORM_ROLE_V2 = 0x00000002
    POWER_PLATFORM_ROLE_V2_MAX = _POWER_PLATFORM_ROLE.PlatformRoleSlate + 1

    if NTDDI_VERSION >= NTDDI_WIN8:
        POWER_PLATFORM_ROLE_VERSION = POWER_PLATFORM_ROLE_V2
        POWER_PLATFORM_ROLE_VERSION_MAX = POWER_PLATFORM_ROLE_V2_MAX
    else:
        POWER_PLATFORM_ROLE_VERSION = POWER_PLATFORM_ROLE_V1
        POWER_PLATFORM_ROLE_VERSION_MAX = POWER_PLATFORM_ROLE_V1_MAX
    # END IF

    _POWER_PLATFORM_INFORMATION._fields_ = [
        ('AoAc', BOOLEAN),
    ]

    # System power manager capabilities
    _BATCLASS_ = None
    if NTDDI_VERSION >= NTDDI_WINXP or not defined(_BATCLASS_):
        BATTERY_REPORTING_SCALE._fields_ = [
            ('Granularity', DWORD),
            ('Capacity', DWORD),
        ]
    # END IF   (NTDDI_VERSION >= NTDDI_WINXP) or not defined(_BATCLASS_)

    PPM_WMI_LEGACY_PERFSTATE._fields_ = [
        ('Frequency', DWORD),
        ('Flags', DWORD),
        ('PercentFrequency', DWORD),
    ]

    PPM_WMI_IDLE_STATE._fields_ = [
        ('Latency', DWORD),
        ('Power', DWORD),
        ('TimeCheck', DWORD),
        ('PromotePercent', BYTE),
        ('DemotePercent', BYTE),
        ('StateType', BYTE),
        ('Reserved', BYTE),
        ('StateFlags', DWORD),
        ('Context', DWORD),
        ('IdleHandler', DWORD),
        # reserved for future use
        ('Reserved1', DWORD),
    ]

    PPM_WMI_IDLE_STATES._fields_ = [
        ('Type', DWORD),
        ('Count', DWORD),
        # current idle state
        ('TargetState', DWORD),
        # previous idle state
        ('OldState', DWORD),
        ('TargetProcessors', DWORD64),
        ('State', PPM_WMI_IDLE_STATE * ANYSIZE_ARRAY),
    ]

    PPM_WMI_IDLE_STATES_EX._fields_ = [
        ('Type', DWORD),
        ('Count', DWORD),
        # current idle state
        ('TargetState', DWORD),
        # previous idle state
        ('OldState', DWORD),
        ('TargetProcessors', PVOID),
        ('State', PPM_WMI_IDLE_STATE * ANYSIZE_ARRAY),
    ]

    PPM_WMI_PERF_STATE._fields_ = [
        # in Mhz
        ('Frequency', DWORD),
        # in milliwatts
        ('Power', DWORD),
        ('PercentFrequency', BYTE),
        # goto higher state
        ('IncreaseLevel', BYTE),
        # goto lower state
        ('DecreaseLevel', BYTE),
        # performance or throttle
        ('Type', BYTE),
        # in tick counts
        ('IncreaseTime', DWORD),
        # in tick counts
        ('DecreaseTime', DWORD),
        # control value
        ('Control', DWORD64),
        # control value
        ('Status', DWORD64),
        ('HitCount', DWORD),
        # reserved for future use
        ('Reserved1', DWORD),
        ('Reserved2', DWORD64),
        ('Reserved3', DWORD64),
    ]

    PPM_WMI_PERF_STATES._fields_ = [
        ('Count', DWORD),
        ('MaxFrequency', DWORD),
        # current state
        ('CurrentState', DWORD),
        # fastest state considering policy restrictions
        ('MaxPerfState', DWORD),
        # slowest state considering policy restrictions
        ('MinPerfState', DWORD),
        # slowest perf state, fixed, aka the "knee"
        ('LowestPerfState', DWORD),
        ('ThermalConstraint', DWORD),
        ('BusyAdjThreshold', BYTE),
        # domain coordination
        ('PolicyType', BYTE),
        ('Type', BYTE),
        ('Reserved', BYTE),
        ('TimerInterval', DWORD),
        # domain affinity
        ('TargetProcessors', DWORD64),
        ('PStateHandler', DWORD),
        ('PStateContext', DWORD),
        ('TStateHandler', DWORD),
        ('TStateContext', DWORD),
        ('FeedbackHandler', DWORD),
        ('Reserved1', DWORD),
        ('Reserved2', DWORD64),
        ('State', PPM_WMI_PERF_STATE * ANYSIZE_ARRAY),
    ]

    PPM_WMI_PERF_STATES_EX._fields_ = [
        ('Count', DWORD),
        ('MaxFrequency', DWORD),
        # current state
        ('CurrentState', DWORD),
        # fastest state considering policy restrictions
        ('MaxPerfState', DWORD),
        # slowest state considering policy restrictions
        ('MinPerfState', DWORD),
        # slowest perf state, fixed, aka the "knee"
        ('LowestPerfState', DWORD),
        ('ThermalConstraint', DWORD),
        ('BusyAdjThreshold', BYTE),
        # domain coordination
        ('PolicyType', BYTE),
        ('Type', BYTE),
        ('Reserved', BYTE),
        ('TimerInterval', DWORD),
        # domain affinity
        ('TargetProcessors', PVOID),
        ('PStateHandler', DWORD),
        ('PStateContext', DWORD),
        ('TStateHandler', DWORD),
        ('TStateContext', DWORD),
        ('FeedbackHandler', DWORD),
        ('Reserved1', DWORD),
        ('Reserved2', DWORD64),
        ('State', PPM_WMI_PERF_STATE * ANYSIZE_ARRAY),
    ]

    # Legacy processor idle accounting.
    PROC_IDLE_BUCKET_COUNT = 6

    PPM_IDLE_STATE_ACCOUNTING._fields_ = [
        ('IdleTransitions', DWORD),
        ('FailedTransitions', DWORD),
        ('InvalidBucketIndex', DWORD),
        ('TotalTime', DWORD64),
        ('IdleTimeBuckets', DWORD * PROC_IDLE_BUCKET_COUNT),
    ]

    PPM_IDLE_ACCOUNTING._fields_ = [
        ('StateCount', DWORD),
        ('TotalTransitions', DWORD),
        ('ResetCount', DWORD),
        ('StartTime', DWORD64),
        ('State', PPM_IDLE_STATE_ACCOUNTING * ANYSIZE_ARRAY),
    ]

    # Processor idle accounting.
    PROC_IDLE_BUCKET_COUNT_EX = 16

    PPM_IDLE_STATE_BUCKET_EX._fields_ = [
        ('TotalTimeUs', DWORD64),
        ('MinTimeUs', DWORD),
        ('MaxTimeUs', DWORD),
        ('Count', DWORD),
    ]

    PPM_IDLE_STATE_ACCOUNTING_EX._fields_ = [
        ('TotalTime', DWORD64),
        ('IdleTransitions', DWORD),
        ('FailedTransitions', DWORD),
        ('InvalidBucketIndex', DWORD),
        ('MinTimeUs', DWORD),
        ('MaxTimeUs', DWORD),
        ('CancelledTransitions', DWORD),
        ('IdleTimeBuckets',
        PPM_IDLE_STATE_BUCKET_EX * PROC_IDLE_BUCKET_COUNT_EX),
    ]

    PPM_IDLE_ACCOUNTING_EX._fields_ = [
        ('StateCount', DWORD),
        ('TotalTransitions', DWORD),
        ('ResetCount', DWORD),
        ('AbortCount', DWORD),
        ('StartTime', DWORD64),
        ('State', PPM_IDLE_STATE_ACCOUNTING_EX * ANYSIZE_ARRAY),
    ]

    # Definitions of coordination types for _PSD, _TSD, and _CSD BIOS
    # objects from
    # the Acpi 3.0 specification
    ACPI_PPM_SOFTWARE_ALL = 0xFC
    ACPI_PPM_SOFTWARE_ANY = 0xFD
    ACPI_PPM_HARDWARE_ALL = 0xFE

    # Definition of Microsoft PPM coordination types.
    MS_PPM_SOFTWARE_ALL = 0x1

    # Processor firmware rundown feature bit definitions.
    PPM_FIRMWARE_ACPI1C2 = 0x00000001
    PPM_FIRMWARE_ACPI1C3 = 0x00000002
    PPM_FIRMWARE_ACPI1TSTATES = 0x00000004
    PPM_FIRMWARE_CST = 0x00000008
    PPM_FIRMWARE_CSD = 0x00000010
    PPM_FIRMWARE_PCT = 0x00000020
    PPM_FIRMWARE_PSS = 0x00000040
    PPM_FIRMWARE_XPSS = 0x00000080
    PPM_FIRMWARE_PPC = 0x00000100
    PPM_FIRMWARE_PSD = 0x00000200
    PPM_FIRMWARE_PTC = 0x00000400
    PPM_FIRMWARE_TSS = 0x00000800
    PPM_FIRMWARE_TPC = 0x00001000
    PPM_FIRMWARE_TSD = 0x00002000
    PPM_FIRMWARE_PCCH = 0x00004000
    PPM_FIRMWARE_PCCP = 0x00008000
    PPM_FIRMWARE_OSC = 0x00010000
    PPM_FIRMWARE_PDC = 0x00020000
    PPM_FIRMWARE_CPC = 0x00040000
    PPM_FIRMWARE_LPI = 0x00080000

    # Processor performance and idle controls implementations.
    PPM_PERFORMANCE_IMPLEMENTATION_NONE = 0x00000000
    PPM_PERFORMANCE_IMPLEMENTATION_PSTATES = 0x00000001
    PPM_PERFORMANCE_IMPLEMENTATION_PCCV1 = 0x00000002
    PPM_PERFORMANCE_IMPLEMENTATION_CPPC = 0x00000003
    PPM_PERFORMANCE_IMPLEMENTATION_PEP = 0x00000004
    PPM_IDLE_IMPLEMENTATION_NONE = 0x00000000
    PPM_IDLE_IMPLEMENTATION_CSTATES = 0x00000001
    PPM_IDLE_IMPLEMENTATION_PEP = 0x00000002
    PPM_IDLE_IMPLEMENTATION_MICROPEP = 0x00000003
    PPM_IDLE_IMPLEMENTATION_LPISTATES = 0x00000004

    # Processor Power Management WMI interface.
    # {A5B32DDD - 7F39 - 4abc - B892 - 900E43B59EBB}
    PPM_PERFSTATE_CHANGE_GUID = DEFINE_GUID(
        0xA5B32DDD,
        0x7F39,
        0x4ABC,
        0xB8,
        0x92,
        0x90,
        0xE,
        0x43,
        0xB5,
        0x9E,
        0xBB
    )

    # {995e6b7f - d653 - 497a - b978 - 36a30c29bf01}
    PPM_PERFSTATE_DOMAIN_CHANGE_GUID = DEFINE_GUID(
        0x995E6B7F,
        0xD653,
        0x497A,
        0xB9,
        0x78,
        0x36,
        0xA3,
        0xC,
        0x29,
        0xBF,
        0x1
    )

    # {4838fe4f - f71c - 4e51 - 9ecc - 8430a7ac4c6c}
    PPM_IDLESTATE_CHANGE_GUID = DEFINE_GUID(
        0x4838FE4F,
        0xF71C,
        0x4E51,
        0x9E,
        0xCC,
        0x84,
        0x30,
        0xA7,
        0xAC,
        0x4C,
        0x6C
    )

    # {5708cc20 - 7d40 - 4bf4 - b4aa - 2b01338d0126}
    PPM_PERFSTATES_DATA_GUID = DEFINE_GUID(
        0x5708CC20,
        0x7D40,
        0x4BF4,
        0xB4,
        0xAA,
        0x2B,
        0x01,
        0x33,
        0x8D,
        0x01,
        0x26
    )

    # {ba138e10 - e250 - 4ad7 - 8616 - cf1a7ad410e7}
    PPM_IDLESTATES_DATA_GUID = DEFINE_GUID(
        0xBA138E10,
        0xE250,
        0x4AD7,
        0x86,
        0x16,
        0xCF,
        0x1A,
        0x7A,
        0xD4,
        0x10,
        0xE7
    )

    # {e2a26f78 - ae07 - 4ee0 - a30f - ce354f5a94cd}
    PPM_IDLE_ACCOUNTING_GUID = DEFINE_GUID(
        0xE2A26F78,
        0xAE07,
        0x4EE0,
        0xA3,
        0x0F,
        0xCE,
        0x54,
        0xF5,
        0x5A,
        0x94,
        0xCD
    )

    # {d67abd39 - 81f8 - 4a5e - 8152 - 72e31ec912ee}
    PPM_IDLE_ACCOUNTING_EX_GUID = DEFINE_GUID(
        0xD67ABD39,
        0x81F8,
        0x4A5E,
        0x81,
        0x52,
        0x72,
        0xE3,
        0x1E,
        0xC9,
        0x12,
        0xEE
    )

    # {a852c2c8 - 1a4c - 423b - 8c2c - f30d82931a88}
    PPM_THERMALCONSTRAINT_GUID = DEFINE_GUID(
        0xA852C2C8,
        0x1A4C,
        0x423B,
        0x8C,
        0x2C,
        0xF3,
        0x0D,
        0x82,
        0x93,
        0x1A,
        0x88
    )

    # {7fd18652 - 0cfe - 40d2 - b0a1 - 0b066a87759e}
    PPM_PERFMON_PERFSTATE_GUID = DEFINE_GUID(
        0x7FD18652,
        0xCFE,
        0x40D2,
        0xB0,
        0xA1,
        0xB,
        0x6,
        0x6A,
        0x87,
        0x75,
        0x9E
    )

    # {48f377b8 - 6880 - 4c7b - 8bdc - 380176c6654d}
    PPM_THERMAL_POLICY_CHANGE_GUID = DEFINE_GUID(
        0x48F377B8,
        0x6880,
        0x4C7B,
        0x8B,
        0xDC,
        0x38,
        0x1,
        0x76,
        0xC6,
        0x65,
        0x4D
    )

    PPM_PERFSTATE_EVENT._fields_ = [
        ('State', DWORD),
        ('Status', DWORD),
        ('Latency', DWORD),
        ('Speed', DWORD),
        ('Processor', DWORD),
    ]

    PPM_PERFSTATE_DOMAIN_EVENT._fields_ = [
        ('State', DWORD),
        ('Latency', DWORD),
        ('Speed', DWORD),
        ('Processors', DWORD64),
    ]

    PPM_IDLESTATE_EVENT._fields_ = [
        ('NewState', DWORD),
        ('OldState', DWORD),
        ('Processors', DWORD64),
    ]

    PPM_THERMALCHANGE_EVENT._fields_ = [
        ('ThermalConstraint', DWORD),
        ('Processors', DWORD64),
    ]

    PPM_THERMAL_POLICY_EVENT._fields_ = [
        ('Mode', BYTE),
        ('Processors', DWORD64),
    ]

    # Power Policy Management interfaces
    POWER_ACTION_POLICY._fields_ = [
        ('Action', POWER_ACTION),
        ('Flags', DWORD),
        ('EventCode', DWORD),
    ]

    # POWER_ACTION_POLICY - >Flags:
    POWER_ACTION_QUERY_ALLOWED = 0x00000001
    POWER_ACTION_UI_ALLOWED = 0x00000002
    POWER_ACTION_OVERRIDE_APPS = 0x00000004
    POWER_ACTION_HIBERBOOT = 0x00000008
    POWER_ACTION_USER_NOTIFY = 0x00000010  # Indicate User - mode of an impending action.
    POWER_ACTION_DOZE_TO_HIBERNATE = 0x00000020
    POWER_ACTION_ACPI_CRITICAL = 0x01000000
    POWER_ACTION_ACPI_USER_NOTIFY = 0x02000000
    POWER_ACTION_DIRECTED_DRIPS = 0x04000000
    POWER_ACTION_PSEUDO_TRANSITION = 0x08000000
    POWER_ACTION_LIGHTEST_FIRST = 0x10000000
    POWER_ACTION_LOCK_CONSOLE = 0x20000000
    POWER_ACTION_DISABLE_WAKES = 0x40000000
    POWER_ACTION_CRITICAL = 0x80000000

    # POWER_ACTION_POLICY - >EventCode flags
    POWER_LEVEL_USER_NOTIFY_TEXT = 0x00000001
    POWER_LEVEL_USER_NOTIFY_SOUND = 0x00000002
    POWER_LEVEL_USER_NOTIFY_EXEC = 0x00000004
    POWER_USER_NOTIFY_BUTTON = 0x00000008
    POWER_USER_NOTIFY_SHUTDOWN = 0x00000010  # Application and Services are intimated of shutdown.
    POWER_USER_NOTIFY_FORCED_SHUTDOWN = 0x00000020  # Immediate shutdown - Application and Services are not intimated.
    POWER_FORCE_TRIGGER_RESET = 0x80000000

    # Note: for battery alarm EventCodes, the ID of the battery alarm
    # << 16 is ORed
    # into the flags. For example: DISCHARGE_POLICY_LOW << 16
    # The GUID_BATTERY_DISCHARGE_FLAGS_x power settings use a subset
    # of EventCode
    # flags. The POWER_FORCE_TRIGGER_RESET flag doesn't make sense for
    # a battery
    # alarm so it is overloaded for other purposes
    # (gerneral enable/disable).
    BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK = 0x00000007
    BATTERY_DISCHARGE_FLAGS_ENABLE = 0x80000000

    # system battery drain policies
    SYSTEM_POWER_LEVEL._fields_ = [
        ('Enable', BOOLEAN),
        ('Spare', BYTE * 3),
        ('BatteryLevel', DWORD),
        ('PowerPolicy', POWER_ACTION_POLICY),
        ('MinSystemState', SYSTEM_POWER_STATE),
    ]

    # Discharge policy constants
    NUM_DISCHARGE_POLICIES = 4
    DISCHARGE_POLICY_CRITICAL = 0
    DISCHARGE_POLICY_LOW = 1

    # system power policies
    _SYSTEM_POWER_POLICY._fields_ = [
        # 1
        ('Revision', DWORD),
        # events
        ('PowerButton', POWER_ACTION_POLICY),
        ('SleepButton', POWER_ACTION_POLICY),
        ('LidClose', POWER_ACTION_POLICY),
        ('LidOpenWake', SYSTEM_POWER_STATE),
        ('Reserved', DWORD),
        # "system idle" detection
        ('Idle', POWER_ACTION_POLICY),
        ('IdleTimeout', DWORD),
        ('IdleSensitivity', BYTE),
        ('DynamicThrottle', BYTE),
        ('Spare2', BYTE * 2),
        # meaning of power action "sleep"
        ('MinSleep', SYSTEM_POWER_STATE),
        ('MaxSleep', SYSTEM_POWER_STATE),
        ('ReducedLatencySleep', SYSTEM_POWER_STATE),
        ('WinLogonFlags', DWORD),
        ('Spare3', DWORD),
        # parameters for dozing
        ('DozeS4Timeout', DWORD),
        # battery policies
        ('BroadcastCapacityResolution', DWORD),
        ('DischargePolicy', SYSTEM_POWER_LEVEL * NUM_DISCHARGE_POLICIES),
        # video policies
        ('VideoTimeout', DWORD),
        ('VideoDimDisplay', BOOLEAN),
        ('VideoReserved', DWORD * 3),
        # hard disk policies
        ('SpindownTimeout', DWORD),
        # processor policies
        ('OptimizeForPower', BOOLEAN),
        ('FanThrottleTolerance', BYTE),
        ('ForcedThrottle', BYTE),
        ('MinThrottle', BYTE),
        ('OverThrottled', POWER_ACTION_POLICY),
    ]

    # processor power policy state
    # Processor Idle State Policy.
    PROCESSOR_IDLESTATE_POLICY_COUNT = 0x3

    PROCESSOR_IDLESTATE_INFO._fields_ = [
        ('TimeCheck', DWORD),
        ('DemotePercent', BYTE),
        ('PromotePercent', BYTE),
        ('Spare', BYTE * 2),
    ]


    class Flags(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('AllowScaling', WORD, 1),
        ('Disabled', WORD, 1),
        ('Reserved', WORD, 14),
    ]
    Flags.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME

    Flags._fields_ = [
        ('AsWORD', WORD),
        ('DUMMYSTRUCTNAME', Flags.DUMMYSTRUCTNAME),
    ]
    PROCESSOR_IDLESTATE_POLICY.Flags = Flags

    PROCESSOR_IDLESTATE_POLICY._fields_ = [
        ('Revision', WORD),
        ('Flags', PROCESSOR_IDLESTATE_POLICY.Flags),
        ('PolicyCount', DWORD),
        (
        'Policy', PROCESSOR_IDLESTATE_INFO * PROCESSOR_IDLESTATE_POLICY_COUNT),
    ]

    # Legacy Processor Policy. This is only provided to allow legacy
    # applications to compile. New applications must use
    # PROCESSOR_IDLESTATE_POLICY.
    PO_THROTTLE_NONE = 0
    PO_THROTTLE_CONSTANT = 1
    PO_THROTTLE_DEGRADE = 2
    PO_THROTTLE_ADAPTIVE = 3
    PO_THROTTLE_MAXIMUM = 4  # not a policy, just a limit

    _PROCESSOR_POWER_POLICY_INFO._fields_ = [
        # in US
        ('TimeCheck', DWORD),
        # in US
        ('DemoteLimit', DWORD),
        # in US
        ('PromoteLimit', DWORD),
        # Percentage based information
        ('DemotePercent', BYTE),
        ('PromotePercent', BYTE),
        ('Spare', BYTE * 2),
        # Flags
        ('AllowDemotion', DWORD, 1),
        ('AllowPromotion', DWORD, 1),
        ('Reserved', DWORD, 30),
    ]

    # processor power policy
    _PROCESSOR_POWER_POLICY._fields_ = [
        # 1
        ('Revision', DWORD),
        # Dynamic Throttling Policy
        ('DynamicThrottle', BYTE),
        ('Spare', BYTE * 3),
        # Flags
        ('DisableCStates', DWORD, 1),
        ('Reserved', DWORD, 31),
        # revision incremented.
        ('PolicyCount', DWORD),
        ('Policy', PROCESSOR_POWER_POLICY_INFO * 3),
    ]


    # Processor Perf State Policy.
    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class Flags(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('NoDomainAccounting', BYTE, 1),
        ('IncreasePolicy', BYTE, 2),
        ('DecreasePolicy', BYTE, 2),
        ('Reserved', BYTE, 3),
    ]
    Flags.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME

    Flags._fields_ = [
        ('AsBYTE', BYTE),
        ('DUMMYSTRUCTNAME', Flags.DUMMYSTRUCTNAME),
    ]
    DUMMYUNIONNAME.Flags = Flags

    DUMMYUNIONNAME._fields_ = [
        ('Spare', BYTE),
        ('Flags', DUMMYUNIONNAME.Flags),
    ]
    PROCESSOR_PERFSTATE_POLICY.DUMMYUNIONNAME = DUMMYUNIONNAME

    PROCESSOR_PERFSTATE_POLICY._fields_ = [
        ('Revision', DWORD),
        ('MaxThrottle', BYTE),
        ('MinThrottle', BYTE),
        ('BusyAdjThreshold', BYTE),
        ('DUMMYUNIONNAME', PROCESSOR_PERFSTATE_POLICY.DUMMYUNIONNAME),
        ('TimeCheck', DWORD),
        ('IncreaseTime', DWORD),
        ('DecreaseTime', DWORD),
        ('IncreasePercent', DWORD),
        ('DecreasePercent', DWORD),
    ]

    # administrator power policy overrides
    _ADMINISTRATOR_POWER_POLICY._fields_ = [
        # meaning of power action "sleep"
        ('MinSleep', SYSTEM_POWER_STATE),
        ('MaxSleep', SYSTEM_POWER_STATE),
        # video policies
        ('MinVideoTimeout', DWORD),
        ('MaxVideoTimeout', DWORD),
        # disk policies
        ('MinSpindownTimeout', DWORD),
        ('MaxSpindownTimeout', DWORD),
    ]


    class _HIBERFILE_BUCKET_SIZE(ENUM):
        HiberFileBucket1GB = 0
        HiberFileBucket2GB = 1
        HiberFileBucket4GB = 2
        HiberFileBucket8GB = 3
        HiberFileBucket16GB = 4
        HiberFileBucket32GB = 5
        HiberFileBucketUnlimited = 6
        HiberFileBucketMax = 7


    HIBERFILE_BUCKET_SIZE = _HIBERFILE_BUCKET_SIZE
    PHIBERFILE_BUCKET_SIZE = POINTER(_HIBERFILE_BUCKET_SIZE)
    HIBERFILE_TYPE_NONE = 0x00
    HIBERFILE_TYPE_REDUCED = 0x01
    HIBERFILE_TYPE_FULL = 0x02
    HIBERFILE_TYPE_MAX = 0x03

    _HIBERFILE_BUCKET._fields_ = [
        ('MaxPhysicalMemory', DWORD64),
        ('PhysicalMemoryPercent', DWORD * HIBERFILE_TYPE_MAX),
    ]

    _TEMP_SYSTEM_POWER_CAPABILITIES = [
        # Misc supported system features
        ('PowerButtonPresent', BOOLEAN),
        ('SleepButtonPresent', BOOLEAN),
        ('LidPresent', BOOLEAN),
        ('SystemS1', BOOLEAN),
        ('SystemS2', BOOLEAN),
        ('SystemS3', BOOLEAN),
        # hibernate
        ('SystemS4', BOOLEAN),
        # off
        ('SystemS5', BOOLEAN),
        ('HiberFilePresent', BOOLEAN),
        ('FullWake', BOOLEAN),
        ('VideoDimPresent', BOOLEAN),
        ('ApmPresent', BOOLEAN),
        ('UpsPresent', BOOLEAN),
        # Processors
        ('ThermalControl', BOOLEAN),
        ('ProcessorThrottle', BOOLEAN),
        ('ProcessorMinThrottle', BYTE),
    ]
    if NTDDI_VERSION < NTDDI_WINXP:
        _TEMP_SYSTEM_POWER_CAPABILITIES += [
            ('ProcessorThrottleScale', BYTE),
            ('spare2', BYTE * 4),
        ]
    else:
        _TEMP_SYSTEM_POWER_CAPABILITIES += [
            ('ProcessorMaxThrottle', BYTE),
            ('FastSystemS4', BOOLEAN),
            ('Hiberboot', BOOLEAN),
            ('WakeAlarmPresent', BOOLEAN),
            ('AoAc', BOOLEAN),
        ]
    # END IF   (NTDDI_VERSION < NTDDI_WINXP)
    _TEMP_SYSTEM_POWER_CAPABILITIES += [
        # Disk
        ('DiskSpinDown', BOOLEAN),
    ]
    if NTDDI_VERSION < NTDDI_WINTHRESHOLD:
        _TEMP_SYSTEM_POWER_CAPABILITIES += [
            ('spare3', BYTE * 8),
        ]
    else:
        _TEMP_SYSTEM_POWER_CAPABILITIES += [
            # HiberFile
            ('HiberFileType', BYTE),
            ('AoAcConnectivitySupported', BOOLEAN),
            ('spare3', BYTE * 6),
        ]
    # END IF   (NTDDI_VERSION < NTDDI_WINTHRESHOLD)
    _TEMP_SYSTEM_POWER_CAPABILITIES += [
        # System Battery
        ('SystemBatteriesPresent', BOOLEAN),
        ('BatteriesAreShortTerm', BOOLEAN),
        ('BatteryScale', BATTERY_REPORTING_SCALE * 3),
        # Wake
        ('AcOnLineWake', SYSTEM_POWER_STATE),
        ('SoftLidWake', SYSTEM_POWER_STATE),
        ('RtcWake', SYSTEM_POWER_STATE),
        # note this may change on driver load
        ('MinDeviceWakeState', SYSTEM_POWER_STATE),
        ('DefaultLowLatencyWake', SYSTEM_POWER_STATE),
    ]
    SYSTEM_POWER_CAPABILITIES._fields_ = _TEMP_SYSTEM_POWER_CAPABILITIES

    SYSTEM_BATTERY_STATE._fields_ = [
        ('AcOnLine', BOOLEAN),
        ('BatteryPresent', BOOLEAN),
        ('Charging', BOOLEAN),
        ('Discharging', BOOLEAN),
        ('Spare1', BOOLEAN * 3),
        ('Tag', BYTE),
        ('MaxCapacity', DWORD),
        ('RemainingCapacity', DWORD),
        ('Rate', DWORD),
        ('EstimatedTime', DWORD),
        ('DefaultAlert1', DWORD),
        ('DefaultAlert2', DWORD),
    ]

    # Image Format
    if not defined(_MAC):
        # 4 byte packing is the default
        from pyWinAPI.shared.pshpack4_h import *  # NOQA


        IMAGE_DOS_SIGNATURE = 0x5A4D  # MZ
        IMAGE_OS2_SIGNATURE = 0x454E  # NE
        IMAGE_OS2_SIGNATURE_LE = 0x454C  # LE
        IMAGE_VXD_SIGNATURE = 0x454C  # LE
        IMAGE_NT_SIGNATURE = 0x00004550  # PE00

        # 16 bit headers are 2 byte packed
        from pyWinAPI.shared.pshpack2_h import *  # NOQA
    else:
        from pyWinAPI.shared.pshpack1_h import *  # NOQA

        IMAGE_DOS_SIGNATURE = 0x4D5A  # MZ
        IMAGE_OS2_SIGNATURE = 0x4E45  # NE
        IMAGE_OS2_SIGNATURE_LE = 0x4C45  # LE
        IMAGE_NT_SIGNATURE = 0x50450000  # PE00
    # END IF

    _IMAGE_DOS_HEADER._fields_ = [
        # Bytes on last page of file
        ('e_cblp', WORD),
        # Pages in file
        ('e_cp', WORD),
        # Relocations
        ('e_crlc', WORD),
        # Size of header in paragraphs
        ('e_cparhdr', WORD),
        # Minimum extra paragraphs needed
        ('e_minalloc', WORD),
        # Maximum extra paragraphs needed
        ('e_maxalloc', WORD),
        # Initial (relative) SS value
        ('e_ss', WORD),
        # Initial SP value
        ('e_sp', WORD),
        # Checksum
        ('e_csum', WORD),
        # Initial IP value
        ('e_ip', WORD),
        # Initial (relative) CS value
        ('e_cs', WORD),
        # File address of relocation table
        ('e_lfarlc', WORD),
        # Overlay number
        ('e_ovno', WORD),
        # Reserved words
        ('e_res', WORD * 4),
        # OEM identifier (for e_oeminfo)
        ('e_oemid', WORD),
        # OEM information; e_oemid specific
        ('e_oeminfo', WORD),
        # Reserved words
        ('e_res2', WORD * 10),
        # File address of new exe header
        ('e_lfanew', LONG),
    ]

    _IMAGE_OS2_HEADER._fields_ = [
        # Version number
        ('ne_ver', CHAR),
        # Revision number
        ('ne_rev', CHAR),
        # Offset of Entry Table
        ('ne_enttab', WORD),
        # Number of bytes in Entry Table
        ('ne_cbenttab', WORD),
        # Checksum of whole file
        ('ne_crc', LONG),
        # Flag word
        ('ne_flags', WORD),
        # Automatic data segment number
        ('ne_autodata', WORD),
        # Initial heap allocation
        ('ne_heap', WORD),
        # Initial stack allocation
        ('ne_stack', WORD),
        # Initial CS:IP setting
        ('ne_csip', LONG),
        # Initial SS:SP setting
        ('ne_sssp', LONG),
        # Count of file segments
        ('ne_cseg', WORD),
        # Entries in Module Reference Table
        ('ne_cmod', WORD),
        # Size of non - resident name table
        ('ne_cbnrestab', WORD),
        # Offset of Segment Table
        ('ne_segtab', WORD),
        # Offset of Resource Table
        ('ne_rsrctab', WORD),
        # Offset of resident name table
        ('ne_restab', WORD),
        # Offset of Module Reference Table
        ('ne_modtab', WORD),
        # Offset of Imported Names Table
        ('ne_imptab', WORD),
        # Offset of Non - resident Names Table
        ('ne_nrestab', LONG),
        # Count of movable entries
        ('ne_cmovent', WORD),
        # Segment alignment shift count
        ('ne_align', WORD),
        # Count of resource segments
        ('ne_cres', WORD),
        # Target Operating system
        ('ne_exetyp', BYTE),
        # Other .EXE flags
        ('ne_flagsothers', BYTE),
        # offset to return thunks
        ('ne_pretthunks', WORD),
        # offset to segment ref. bytes
        ('ne_psegrefbytes', WORD),
        # Minimum code swap area size
        ('ne_swaparea', WORD),
        # Expected Windows version number
        ('ne_expver', WORD),
    ]

    _IMAGE_VXD_HEADER._fields_ = [
        # The byte ordering for the VXD
        ('e32_border', BYTE),
        # The word ordering for the VXD
        ('e32_worder', BYTE),
        # The EXE format level for now = 0
        ('e32_level', DWORD),
        # The CPU type
        ('e32_cpu', WORD),
        # The OS type
        ('e32_os', WORD),
        # Module version
        ('e32_ver', DWORD),
        # Module flags
        ('e32_mflags', DWORD),
        # Module pages
        ('e32_mpages', DWORD),
        # Object for instruction pointer
        ('e32_startobj', DWORD),
        # Extended instruction pointer
        ('e32_eip', DWORD),
        # Object for stack pointer
        ('e32_stackobj', DWORD),
        # Extended stack pointer
        ('e32_esp', DWORD),
        # VXD page size
        ('e32_pagesize', DWORD),
        # Last page size in VXD
        ('e32_lastpagesize', DWORD),
        # Fixup section size
        ('e32_fixupsize', DWORD),
        # Fixup section checksum
        ('e32_fixupsum', DWORD),
        # Loader section size
        ('e32_ldrsize', DWORD),
        # Loader section checksum
        ('e32_ldrsum', DWORD),
        # Object table offset
        ('e32_objtab', DWORD),
        # Number of objects in module
        ('e32_objcnt', DWORD),
        # Object page map offset
        ('e32_objmap', DWORD),
        # Object iterated data map offset
        ('e32_itermap', DWORD),
        # Offset of Resource Table
        ('e32_rsrctab', DWORD),
        # Number of resource entries
        ('e32_rsrccnt', DWORD),
        # Offset of resident name table
        ('e32_restab', DWORD),
        # Offset of Entry Table
        ('e32_enttab', DWORD),
        # Offset of Module Directive Table
        ('e32_dirtab', DWORD),
        # Number of module directives
        ('e32_dircnt', DWORD),
        # Offset of Fixup Page Table
        ('e32_fpagetab', DWORD),
        # Offset of Fixup Record Table
        ('e32_frectab', DWORD),
        # Offset of Import Module Name Table
        ('e32_impmod', DWORD),
        # Number of entries in Import Module Name Table
        ('e32_impmodcnt', DWORD),
        # Offset of Import Procedure Name Table
        ('e32_impproc', DWORD),
        # Offset of Per - Page Checksum Table
        ('e32_pagesum', DWORD),
        # Offset of Enumerated Data Pages
        ('e32_datapage', DWORD),
        # Number of preload pages
        ('e32_preload', DWORD),
        # Offset of Non - resident Names Table
        ('e32_nrestab', DWORD),
        # Size of Non - resident Name Table
        ('e32_cbnrestab', DWORD),
        # Non - resident Name Table Checksum
        ('e32_nressum', DWORD),
        # Object for automatic data object
        ('e32_autodata', DWORD),
        # Offset of the debugging information
        ('e32_debuginfo', DWORD),
        # The length of the debugging info. in bytes
        ('e32_debuglen', DWORD),
        # Number of instance pages in preload section of VXD file
        ('e32_instpreload', DWORD),
        # Number of instance pages in demand load section of VXD file
        ('e32_instdemand', DWORD),
        # Size of heap - for 16 - bit apps
        ('e32_heapsize', DWORD),
        # Reserved words
        ('e32_res3', BYTE * 12),
        ('e32_winresoff', DWORD),
        ('e32_winreslen', DWORD),
        # Device ID for VxD
        ('e32_devid', WORD),
        # DDK version for VxD
        ('e32_ddkver', WORD),
    ]

    if not defined(_MAC):
        # Back to 4 byte packing
        from pyWinAPI.shared.poppack_h import *  # NOQA
    # END IF

    # File header format.
    _IMAGE_FILE_HEADER._fields_ = [
        ('Machine', WORD),
        ('NumberOfSections', WORD),
        ('TimeDateStamp', DWORD),
        ('PointerToSymbolTable', DWORD),
        ('NumberOfSymbols', DWORD),
        ('SizeOfOptionalHeader', WORD),
        ('Characteristics', WORD),
    ]
    IMAGE_SIZEOF_FILE_HEADER = 20
    IMAGE_FILE_RELOCS_STRIPPED = 0x0001  # Relocation info stripped from file.
    IMAGE_FILE_EXECUTABLE_IMAGE = 0x0002  # File is executable (i.e. no unresolved external references).
    IMAGE_FILE_LINE_NUMS_STRIPPED = 0x0004  # Line nunbers stripped from file.
    IMAGE_FILE_LOCAL_SYMS_STRIPPED = 0x0008  # Local symbols stripped from file.
    IMAGE_FILE_AGGRESIVE_WS_TRIM = 0x0010  # Aggressively trim working set
    IMAGE_FILE_LARGE_ADDRESS_AWARE = 0x0020  # App can handle >2gb addresses
    IMAGE_FILE_BYTES_REVERSED_LO = 0x0080  # Bytes of machine word are reversed.
    IMAGE_FILE_32BIT_MACHINE = 0x0100  # 32 bit word machine.
    IMAGE_FILE_DEBUG_STRIPPED = 0x0200  # Debugging info stripped from file in .DBG file
    IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP = 0x0400  # If Image is on removable media, copy and run from the swap file.
    IMAGE_FILE_NET_RUN_FROM_SWAP = 0x0800  # If Image is on Net, copy and run from the swap file.
    IMAGE_FILE_SYSTEM = 0x1000  # System File.
    IMAGE_FILE_DLL = 0x2000  # File is a DLL.
    IMAGE_FILE_UP_SYSTEM_ONLY = 0x4000  # File should only be run on a UP machine
    IMAGE_FILE_BYTES_REVERSED_HI = 0x8000  # Bytes of machine word are reversed.
    IMAGE_FILE_MACHINE_UNKNOWN = 0

    # Useful for indicating we want to interact with the host and not
    # a WoW guest.
    IMAGE_FILE_MACHINE_TARGET_HOST = 0x0001
    IMAGE_FILE_MACHINE_I386 = 0x014C  # Intel 386.
    IMAGE_FILE_MACHINE_R3000 = 0x0162  # MIPS little - endian, 0x160 big - endian
    IMAGE_FILE_MACHINE_R4000 = 0x0166  # MIPS little - endian
    IMAGE_FILE_MACHINE_R10000 = 0x0168  # MIPS little - endian
    IMAGE_FILE_MACHINE_WCEMIPSV2 = 0x0169  # MIPS little - endian WCE v2
    IMAGE_FILE_MACHINE_ALPHA = 0x0184  # Alpha_AXP
    IMAGE_FILE_MACHINE_SH3 = 0x01A2  # SH3 little - endian
    IMAGE_FILE_MACHINE_SH3DSP = 0x01A3
    IMAGE_FILE_MACHINE_SH3E = 0x01A4  # SH3E little - endian
    IMAGE_FILE_MACHINE_SH4 = 0x01A6  # SH4 little - endian
    IMAGE_FILE_MACHINE_SH5 = 0x01A8  # SH5
    IMAGE_FILE_MACHINE_ARM = 0x01C0  # ARM Little - Endian
    IMAGE_FILE_MACHINE_THUMB = 0x01C2  # ARM Thumb/Thumb - 2 Little - Endian
    IMAGE_FILE_MACHINE_ARMNT = 0x01C4  # ARM Thumb - 2 Little - Endian
    IMAGE_FILE_MACHINE_AM33 = 0x01D3
    IMAGE_FILE_MACHINE_POWERPC = 0x01F0  # IBM PowerPC Little - Endian
    IMAGE_FILE_MACHINE_POWERPCFP = 0x01F1
    IMAGE_FILE_MACHINE_IA64 = 0x0200  # Intel 64
    IMAGE_FILE_MACHINE_MIPS16 = 0x0266  # MIPS
    IMAGE_FILE_MACHINE_ALPHA64 = 0x0284  # ALPHA64
    IMAGE_FILE_MACHINE_MIPSFPU = 0x0366  # MIPS
    IMAGE_FILE_MACHINE_MIPSFPU16 = 0x0466  # MIPS
    IMAGE_FILE_MACHINE_AXP64 = IMAGE_FILE_MACHINE_ALPHA64
    IMAGE_FILE_MACHINE_TRICORE = 0x0520  # Infineon
    IMAGE_FILE_MACHINE_CEF = 0x0CEF
    IMAGE_FILE_MACHINE_EBC = 0x0EBC  # EFI Byte Code
    IMAGE_FILE_MACHINE_AMD64 = 0x8664  # AMD64 (K8)
    IMAGE_FILE_MACHINE_M32R = 0x9041  # M32R little - endian
    IMAGE_FILE_MACHINE_ARM64 = 0xAA64  # ARM64 Little - Endian
    IMAGE_FILE_MACHINE_CEE = 0xC0EE

    # Directory format.
    _IMAGE_DATA_DIRECTORY._fields_ = [
        ('VirtualAddress', DWORD),
        ('Size', DWORD),
    ]
    IMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16

    # Optional header format.
    _IMAGE_OPTIONAL_HEADER._fields_ = [
        # Standard fields.
        ('Magic', WORD),
        ('MajorLinkerVersion', BYTE),
        ('MinorLinkerVersion', BYTE),
        ('SizeOfCode', DWORD),
        ('SizeOfInitializedData', DWORD),
        ('SizeOfUninitializedData', DWORD),
        ('AddressOfEntryPoint', DWORD),
        ('BaseOfCode', DWORD),
        ('BaseOfData', DWORD),
        # NT additional fields.
        ('ImageBase', DWORD),
        ('SectionAlignment', DWORD),
        ('FileAlignment', DWORD),
        ('MajorOperatingSystemVersion', WORD),
        ('MinorOperatingSystemVersion', WORD),
        ('MajorImageVersion', WORD),
        ('MinorImageVersion', WORD),
        ('MajorSubsystemVersion', WORD),
        ('MinorSubsystemVersion', WORD),
        ('Win32VersionValue', DWORD),
        ('SizeOfImage', DWORD),
        ('SizeOfHeaders', DWORD),
        ('CheckSum', DWORD),
        ('Subsystem', WORD),
        ('DllCharacteristics', WORD),
        ('SizeOfStackReserve', DWORD),
        ('SizeOfStackCommit', DWORD),
        ('SizeOfHeapReserve', DWORD),
        ('SizeOfHeapCommit', DWORD),
        ('LoaderFlags', DWORD),
        ('NumberOfRvaAndSizes', DWORD),
        ('DataDirectory', IMAGE_DATA_DIRECTORY * IMAGE_NUMBEROF_DIRECTORY_ENTRIES),
    ]

    _IMAGE_ROM_OPTIONAL_HEADER._fields_ = [
        ('Magic', WORD),
        ('MajorLinkerVersion', BYTE),
        ('MinorLinkerVersion', BYTE),
        ('SizeOfCode', DWORD),
        ('SizeOfInitializedData', DWORD),
        ('SizeOfUninitializedData', DWORD),
        ('AddressOfEntryPoint', DWORD),
        ('BaseOfCode', DWORD),
        ('BaseOfData', DWORD),
        ('BaseOfBss', DWORD),
        ('GprMask', DWORD),
        ('CprMask', DWORD * 4),
        ('GpValue', DWORD),
    ]

    _IMAGE_OPTIONAL_HEADER64._fields_ = [
        ('Magic', WORD),
        ('MajorLinkerVersion', BYTE),
        ('MinorLinkerVersion', BYTE),
        ('SizeOfCode', DWORD),
        ('SizeOfInitializedData', DWORD),
        ('SizeOfUninitializedData', DWORD),
        ('AddressOfEntryPoint', DWORD),
        ('BaseOfCode', DWORD),
        ('ImageBase', ULONGLONG),
        ('SectionAlignment', DWORD),
        ('FileAlignment', DWORD),
        ('MajorOperatingSystemVersion', WORD),
        ('MinorOperatingSystemVersion', WORD),
        ('MajorImageVersion', WORD),
        ('MinorImageVersion', WORD),
        ('MajorSubsystemVersion', WORD),
        ('MinorSubsystemVersion', WORD),
        ('Win32VersionValue', DWORD),
        ('SizeOfImage', DWORD),
        ('SizeOfHeaders', DWORD),
        ('CheckSum', DWORD),
        ('Subsystem', WORD),
        ('DllCharacteristics', WORD),
        ('SizeOfStackReserve', ULONGLONG),
        ('SizeOfStackCommit', ULONGLONG),
        ('SizeOfHeapReserve', ULONGLONG),
        ('SizeOfHeapCommit', ULONGLONG),
        ('LoaderFlags', DWORD),
        ('NumberOfRvaAndSizes', DWORD),
        ('DataDirectory', IMAGE_DATA_DIRECTORY * IMAGE_NUMBEROF_DIRECTORY_ENTRIES),
    ]
    IMAGE_NT_OPTIONAL_HDR32_MAGIC = 0x10B
    IMAGE_NT_OPTIONAL_HDR64_MAGIC = 0x20B
    IMAGE_ROM_OPTIONAL_HDR_MAGIC = 0x107
    if defined(_WIN64):
        IMAGE_NT_OPTIONAL_HDR_MAGIC = IMAGE_NT_OPTIONAL_HDR64_MAGIC
    else:
        IMAGE_NT_OPTIONAL_HDR_MAGIC = IMAGE_NT_OPTIONAL_HDR32_MAGIC
    # END IF
    _IMAGE_NT_HEADERS64._fields_ = [
        ('Signature', DWORD),
        ('FileHeader', IMAGE_FILE_HEADER),
    ]

    _IMAGE_NT_HEADERS._fields_ = [
        ('Signature', DWORD),
        ('FileHeader', IMAGE_FILE_HEADER),
    ]

    _IMAGE_ROM_HEADERS._fields_ = [
        ('FileHeader', IMAGE_FILE_HEADER),
    ]
    if defined(_WIN64):
        IMAGE_NT_HEADERS = IMAGE_NT_HEADERS64
        PIMAGE_NT_HEADERS = PIMAGE_NT_HEADERS64
    else:
        IMAGE_NT_HEADERS = IMAGE_NT_HEADERS32
        PIMAGE_NT_HEADERS = PIMAGE_NT_HEADERS32


    # END IF
    # IMAGE_FIRST_SECTION doesn't need 32/64 versions since the file
    # header is the same either way.
    def IMAGE_FIRST_SECTION(ntheader):
        return (
            PIMAGE_SECTION_HEADER(
                ntheader +
                FIELD_OFFSET(IMAGE_NT_HEADERS, 'OptionalHeader') +
                ntheader.FileHeader.SizeOfOptionalHeader
            )
        )

    # Subsystem Values
    IMAGE_SUBSYSTEM_UNKNOWN = 0  # Unknown subsystem.
    IMAGE_SUBSYSTEM_NATIVE = 1  # Image doesn't require a subsystem.
    IMAGE_SUBSYSTEM_WINDOWS_GUI = 2  # Image runs in the Windows GUI subsystem.
    IMAGE_SUBSYSTEM_WINDOWS_CUI = 3  # Image runs in the Windows character subsystem.
    IMAGE_SUBSYSTEM_OS2_CUI = 5  # image runs in the OS/2 character subsystem.
    IMAGE_SUBSYSTEM_POSIX_CUI = 7  # image runs in the Posix character subsystem.
    IMAGE_SUBSYSTEM_NATIVE_WINDOWS = 8  # image is a native Win9x driver.
    IMAGE_SUBSYSTEM_WINDOWS_CE_GUI = 9  # Image runs in the Windows CE subsystem.
    IMAGE_SUBSYSTEM_EFI_APPLICATION = 10
    IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER = 11
    IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER = 12
    IMAGE_SUBSYSTEM_EFI_ROM = 13
    IMAGE_SUBSYSTEM_XBOX = 14
    IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION = 16
    IMAGE_SUBSYSTEM_XBOX_CODE_CATALOG = 17

    # DllCharacteristics Entries
    # IMAGE_LIBRARY_PROCESS_INIT  0x0001  // Reserved.
    # IMAGE_LIBRARY_PROCESS_TERM  0x0002  // Reserved.
    # IMAGE_LIBRARY_THREAD_INIT   0x0004  // Reserved.
    # IMAGE_LIBRARY_THREAD_TERM   0x0008  // Reserved.
    IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA = 0x0020  # Image can handle a high entropy 64 - bit virtual address space.
    IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE = 0x0040  # DLL can move.
    IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY = 0x0080  # Code Integrity Image
    IMAGE_DLLCHARACTERISTICS_NX_COMPAT = 0x0100  # Image is NX compatible
    IMAGE_DLLCHARACTERISTICS_NO_ISOLATION = 0x0200  # Image understands isolation and doesn't want it
    IMAGE_DLLCHARACTERISTICS_NO_SEH = 0x0400  # Image does not use SEH. No SE handler may reside in this image
    IMAGE_DLLCHARACTERISTICS_NO_BIND = 0x0800  # Do not bind this image.
    IMAGE_DLLCHARACTERISTICS_APPCONTAINER = 0x1000  # Image should execute in an AppContainer
    IMAGE_DLLCHARACTERISTICS_WDM_DRIVER = 0x2000  # Driver uses WDM model
    IMAGE_DLLCHARACTERISTICS_GUARD_CF = 0x4000  # Image supports Control Flow Guard.
    IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE = 0x8000

    # Directory Entries
    IMAGE_DIRECTORY_ENTRY_EXPORT = 0  # Export Directory
    IMAGE_DIRECTORY_ENTRY_IMPORT = 1  # Import Directory
    IMAGE_DIRECTORY_ENTRY_RESOURCE = 2  # Resource Directory
    IMAGE_DIRECTORY_ENTRY_EXCEPTION = 3  # Exception Directory
    IMAGE_DIRECTORY_ENTRY_SECURITY = 4  # Security Directory
    IMAGE_DIRECTORY_ENTRY_BASERELOC = 5  # Base Relocation Table
    IMAGE_DIRECTORY_ENTRY_DEBUG = 6  # Debug Directory

    # IMAGE_DIRECTORY_ENTRY_COPYRIGHT  7 // (X86 usage)
    IMAGE_DIRECTORY_ENTRY_ARCHITECTURE = 7  # Architecture Specific Data
    IMAGE_DIRECTORY_ENTRY_GLOBALPTR = 8  # RVA of GP
    IMAGE_DIRECTORY_ENTRY_TLS = 9  # TLS Directory
    IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG = 10  # Load Configuration Directory
    IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT = 11  # Bound Import Directory in headers
    IMAGE_DIRECTORY_ENTRY_IAT = 12  # Import Address Table
    IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT = 13  # Delay Load Import Descriptors
    IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR = 14  # COM Runtime descriptor

    # Non - COFF Object file header
    ANON_OBJECT_HEADER._fields_ = [
        # Must be IMAGE_FILE_MACHINE_UNKNOWN
        ('Sig1', WORD),
        # Must be 0xffff
        ('Sig2', WORD),
        # >= 1 (implies the CLSID field is present)
        ('Version', WORD),
        ('Machine', WORD),
        ('TimeDateStamp', DWORD),
        # Used to invoke CoCreateInstance
        ('ClassID', CLSID),
        # Size of data that follows the header
        ('SizeOfData', DWORD),
    ]

    ANON_OBJECT_HEADER_V2._fields_ = [
        # Must be IMAGE_FILE_MACHINE_UNKNOWN
        ('Sig1', WORD),
        # Must be 0xffff
        ('Sig2', WORD),
        # >= 2 (implies the Flags field is present - otherwise V1)
        ('Version', WORD),
        ('Machine', WORD),
        ('TimeDateStamp', DWORD),
        # Used to invoke CoCreateInstance
        ('ClassID', CLSID),
        # Size of data that follows the header
        ('SizeOfData', DWORD),
        # 0x1 - > contains metadata
        ('Flags', DWORD),
        # Size of CLR metadata
        ('MetaDataSize', DWORD),
        # Offset of CLR metadata
        ('MetaDataOffset', DWORD),
    ]

    ANON_OBJECT_HEADER_BIGOBJ._fields_ = [
        # Must be IMAGE_FILE_MACHINE_UNKNOWN
        ('Sig1', WORD),
        # Must be 0xffff
        ('Sig2', WORD),
        # >= 2 (implies the Flags field is present)
        ('Version', WORD),
        # Actual machine - IMAGE_FILE_MACHINE_xxx
        ('Machine', WORD),
        ('TimeDateStamp', DWORD),
        # {D1BAA1C7 - BAEE - 4ba9 - AF20 - FAF66AA4DCB8}
        ('ClassID', CLSID),
        # Size of data that follows the header
        ('SizeOfData', DWORD),
        # 0x1 - > contains metadata
        ('Flags', DWORD),
        # Size of CLR metadata
        ('MetaDataSize', DWORD),
        # Offset of CLR metadata
        ('MetaDataOffset', DWORD),
        # extended from WORD
        ('NumberOfSections', DWORD),
        ('PointerToSymbolTable', DWORD),
        ('NumberOfSymbols', DWORD),
    ]

    # Section header format.
    IMAGE_SIZEOF_SHORT_NAME = 8


    class Misc(ctypes.Union):
        pass


    Misc._fields_ = [
        ('PhysicalAddress', DWORD),
        ('VirtualSize', DWORD),
    ]
    _IMAGE_SECTION_HEADER.Misc = Misc

    _IMAGE_SECTION_HEADER._fields_ = [
        ('Name', BYTE * IMAGE_SIZEOF_SHORT_NAME),
        ('Misc', _IMAGE_SECTION_HEADER.Misc),
        ('VirtualAddress', DWORD),
        ('SizeOfRawData', DWORD),
        ('PointerToRawData', DWORD),
        ('PointerToRelocations', DWORD),
        ('PointerToLinenumbers', DWORD),
        ('NumberOfRelocations', WORD),
        ('NumberOfLinenumbers', WORD),
        ('Characteristics', DWORD),
    ]
    IMAGE_SIZEOF_SECTION_HEADER = 40

    # Section characteristics.
    # IMAGE_SCN_TYPE_REG    0x00000000 // Reserved.
    # IMAGE_SCN_TYPE_DSECT    0x00000001 // Reserved.
    # IMAGE_SCN_TYPE_NOLOAD   0x00000002 // Reserved.
    # IMAGE_SCN_TYPE_GROUP    0x00000004 // Reserved.
    IMAGE_SCN_TYPE_NO_PAD = 0x00000008  # Reserved.

    # IMAGE_SCN_TYPE_COPY   0x00000010 // Reserved.
    IMAGE_SCN_CNT_CODE = 0x00000020  # Section contains code.
    IMAGE_SCN_CNT_INITIALIZED_DATA = 0x00000040  # Section contains initialized data.
    IMAGE_SCN_CNT_UNINITIALIZED_DATA = 0x00000080  # Section contains uninitialized data.
    IMAGE_SCN_LNK_OTHER = 0x00000100  # Reserved.
    IMAGE_SCN_LNK_INFO = 0x00000200  # Section contains comments or some other type of information.

    # IMAGE_SCN_TYPE_OVER   0x00000400 // Reserved.
    IMAGE_SCN_LNK_REMOVE = 0x00000800  # Section contents will not become part of image.
    IMAGE_SCN_LNK_COMDAT = 0x00001000  # Section contents comdat.

    # 0x00002000 // Reserved.
    # IMAGE_SCN_MEM_PROTECTED - Obsolete 0x00004000
    # Reset speculative exceptions handling bits in the TLB entries
    # for this section.
    IMAGE_SCN_NO_DEFER_SPEC_EXC = 0x00004000
    IMAGE_SCN_GPREL = 0x00008000  # Section content can be accessed relative to GP
    IMAGE_SCN_MEM_FARDATA = 0x00008000

    # IMAGE_SCN_MEM_SYSHEAP - Obsolete 0x00010000
    IMAGE_SCN_MEM_PURGEABLE = 0x00020000
    IMAGE_SCN_MEM_16BIT = 0x00020000
    IMAGE_SCN_MEM_LOCKED = 0x00040000
    IMAGE_SCN_MEM_PRELOAD = 0x00080000
    IMAGE_SCN_ALIGN_1BYTES = 0x00100000
    IMAGE_SCN_ALIGN_2BYTES = 0x00200000
    IMAGE_SCN_ALIGN_4BYTES = 0x00300000
    IMAGE_SCN_ALIGN_8BYTES = 0x00400000
    IMAGE_SCN_ALIGN_16BYTES = 0x00500000  # Default alignment if no others are specified.
    IMAGE_SCN_ALIGN_32BYTES = 0x00600000
    IMAGE_SCN_ALIGN_64BYTES = 0x00700000
    IMAGE_SCN_ALIGN_128BYTES = 0x00800000
    IMAGE_SCN_ALIGN_256BYTES = 0x00900000
    IMAGE_SCN_ALIGN_512BYTES = 0x00A00000
    IMAGE_SCN_ALIGN_1024BYTES = 0x00B00000
    IMAGE_SCN_ALIGN_2048BYTES = 0x00C00000
    IMAGE_SCN_ALIGN_4096BYTES = 0x00D00000
    IMAGE_SCN_ALIGN_8192BYTES = 0x00E00000

    # Unused      0x00F00000
    IMAGE_SCN_ALIGN_MASK = 0x00F00000
    IMAGE_SCN_LNK_NRELOC_OVFL = 0x01000000  # Section contains extended relocations.
    IMAGE_SCN_MEM_DISCARDABLE = 0x02000000  # Section can be discarded.
    IMAGE_SCN_MEM_NOT_CACHED = 0x04000000  # Section is not cachable.
    IMAGE_SCN_MEM_NOT_PAGED = 0x08000000  # Section is not pageable.
    IMAGE_SCN_MEM_SHARED = 0x10000000  # Section is shareable.
    IMAGE_SCN_MEM_EXECUTE = 0x20000000  # Section is executable.
    IMAGE_SCN_MEM_READ = 0x40000000  # Section is readable.
    IMAGE_SCN_MEM_WRITE = 0x80000000  # Section is writeable.

    # TLS Characteristic Flags
    IMAGE_SCN_SCALE_INDEX = 0x00000001  # Tls index is scaled
    if not defined(_MAC):
        # Symbols, relocs, and linenumbers are 2 byte packed
        from pyWinAPI.shared.pshpack2_h import *  # NOQA
    # END IF

    # Symbol format.
    class N(ctypes.Union):
        pass


    class Name(ctypes.Structure):
        pass


    Name._fields_ = [
        # if 0, use LongName
        ('Short', DWORD),
        # offset into string table
        ('Long', DWORD),
    ]
    N.Name = Name

    N._fields_ = [
        ('ShortName', BYTE * 8),
        ('Name', N.Name),
        # PBYTE [2]
        ('LongName', DWORD * 2),
    ]
    _IMAGE_SYMBOL.N = N

    _IMAGE_SYMBOL._fields_ = [
        ('N', _IMAGE_SYMBOL.N),
        ('Value', DWORD),
        ('SectionNumber', SHORT),
        ('Type', WORD),
        ('StorageClass', BYTE),
        ('NumberOfAuxSymbols', BYTE),
    ]
    IMAGE_SIZEOF_SYMBOL = 18


    class N(ctypes.Union):
        pass


    class Name(ctypes.Structure):
        pass


    Name._fields_ = [
        # if 0, use LongName
        ('Short', DWORD),
        # offset into string table
        ('Long', DWORD),
    ]
    N.Name = Name

    N._fields_ = [
        ('ShortName', BYTE * 8),
        ('Name', N.Name),
        # PBYTE [2]
        ('LongName', DWORD * 2),
    ]
    _IMAGE_SYMBOL_EX.N = N

    _IMAGE_SYMBOL_EX._fields_ = [
        ('N', _IMAGE_SYMBOL_EX.N),
        ('Value', DWORD),
        ('SectionNumber', LONG),
        ('Type', WORD),
        ('StorageClass', BYTE),
        ('NumberOfAuxSymbols', BYTE),
    ]

    # Section values.
    # Symbols have a section number of the section in which they are
    # defined. Otherwise, section numbers have the following meanings:
    IMAGE_SYM_UNDEFINED = 0  # Symbol is undefined or is common.
    IMAGE_SYM_ABSOLUTE = -1  # Symbol is an absolute value.
    IMAGE_SYM_DEBUG = -2  # Symbol is a special debug item.
    IMAGE_SYM_SECTION_MAX = 0xFEFF  # Values 0xFF00 - 0xFFFF are special
    IMAGE_SYM_SECTION_MAX_EX = MAXLONG

    # Type (fundamental) values.
    IMAGE_SYM_TYPE_NULL = 0x0000  # no type.
    IMAGE_SYM_TYPE_VOID = 0x0001
    IMAGE_SYM_TYPE_CHAR = 0x0002  # type character.
    IMAGE_SYM_TYPE_SHORT = 0x0003  # type SHORT integer.
    IMAGE_SYM_TYPE_INT = 0x0004
    IMAGE_SYM_TYPE_LONG = 0x0005
    IMAGE_SYM_TYPE_FLOAT = 0x0006
    IMAGE_SYM_TYPE_DOUBLE = 0x0007
    IMAGE_SYM_TYPE_STRUCT = 0x0008
    IMAGE_SYM_TYPE_UNION = 0x0009
    IMAGE_SYM_TYPE_ENUM = 0x000A  # enumeration.
    IMAGE_SYM_TYPE_MOE = 0x000B  # member of enumeration.
    IMAGE_SYM_TYPE_BYTE = 0x000C
    IMAGE_SYM_TYPE_WORD = 0x000D
    IMAGE_SYM_TYPE_UINT = 0x000E
    IMAGE_SYM_TYPE_DWORD = 0x000F
    IMAGE_SYM_TYPE_PCODE = 0x8000

    # Type (derived) values.
    IMAGE_SYM_DTYPE_NULL = 0  # no derived type.
    IMAGE_SYM_DTYPE_POINTER = 1  # pointer.
    IMAGE_SYM_DTYPE_FUNCTION = 2  # function.
    IMAGE_SYM_DTYPE_ARRAY = 3  # array.

    # Storage classes.
    IMAGE_SYM_CLASS_END_OF_FUNCTION = -1
    IMAGE_SYM_CLASS_NULL = 0x0000
    IMAGE_SYM_CLASS_AUTOMATIC = 0x0001
    IMAGE_SYM_CLASS_EXTERNAL = 0x0002
    IMAGE_SYM_CLASS_STATIC = 0x0003
    IMAGE_SYM_CLASS_REGISTER = 0x0004
    IMAGE_SYM_CLASS_EXTERNAL_DEF = 0x0005
    IMAGE_SYM_CLASS_LABEL = 0x0006
    IMAGE_SYM_CLASS_UNDEFINED_LABEL = 0x0007
    IMAGE_SYM_CLASS_MEMBER_OF_STRUCT = 0x0008
    IMAGE_SYM_CLASS_ARGUMENT = 0x0009
    IMAGE_SYM_CLASS_STRUCT_TAG = 0x000A
    IMAGE_SYM_CLASS_MEMBER_OF_UNION = 0x000B
    IMAGE_SYM_CLASS_UNION_TAG = 0x000C
    IMAGE_SYM_CLASS_TYPE_DEFINITION = 0x000D
    IMAGE_SYM_CLASS_UNDEFINED_STATIC = 0x000E
    IMAGE_SYM_CLASS_ENUM_TAG = 0x000F
    IMAGE_SYM_CLASS_MEMBER_OF_ENUM = 0x0010
    IMAGE_SYM_CLASS_REGISTER_PARAM = 0x0011
    IMAGE_SYM_CLASS_BIT_FIELD = 0x0012
    IMAGE_SYM_CLASS_FAR_EXTERNAL = 0x0044
    IMAGE_SYM_CLASS_BLOCK = 0x0064
    IMAGE_SYM_CLASS_FUNCTION = 0x0065
    IMAGE_SYM_CLASS_END_OF_STRUCT = 0x0066
    IMAGE_SYM_CLASS_FILE = 0x0067

    # new
    IMAGE_SYM_CLASS_SECTION = 0x0068
    IMAGE_SYM_CLASS_WEAK_EXTERNAL = 0x0069
    IMAGE_SYM_CLASS_CLR_TOKEN = 0x006B

    # type packing constants
    N_BTMASK = 0x000F
    N_TMASK = 0x0030
    N_TMASK1 = 0x00C0
    N_TMASK2 = 0x00F0
    N_BTSHFT = 4
    N_TSHIFT = 2

    # MACROS
    # Basic Type of x
    def BTYPE(x):
        return x & N_BTMASK

    # Is x a pointer?
    ISPTR = None
    if not defined(ISPTR):
        def ISPTR(x):
            return (x & N_TMASK) == (IMAGE_SYM_DTYPE_POINTER << N_BTSHFT)
    # END IF

    # Is x a function?
    ISFCN = None
    if not defined(ISFCN):
        def ISFCN(x):
            return (x & N_TMASK) == (IMAGE_SYM_DTYPE_FUNCTION << N_BTSHFT)
    # END IF

    # Is x an array?
    ISARY = None
    if not defined(ISARY):
        def ISARY(x):
            return (x & N_TMASK) == (IMAGE_SYM_DTYPE_ARRAY << N_BTSHFT)
    # END IF

    # Is x a structure, union, or enumeration TAG?
    ISTAG = None
    if not defined(ISTAG):
        def ISTAG(x):
            return x in (
                IMAGE_SYM_CLASS_STRUCT_TAG,
                IMAGE_SYM_CLASS_UNION_TAG,
                IMAGE_SYM_CLASS_ENUM_TAG
            )
    # END IF
    INCREF = None
    if not defined(INCREF):
        def INCREF(x):
            return (
                ((x & ~N_BTMASK) << N_TSHIFT) |
                (IMAGE_SYM_DTYPE_POINTER << N_BTSHFT) |
                (x & N_BTMASK)
            )
    # END IF
    DECREF = None
    if not defined(DECREF):
        def DECREF(x):
            return ((x >> N_TSHIFT) & ~N_BTMASK) | (x & N_BTMASK)
    # END IF

    from pyWinAPI.shared.pshpack2_h import *  # NOQA

    IMAGE_AUX_SYMBOL_TOKEN_DEF._fields_ = [
        # IMAGE_AUX_SYMBOL_TYPE
        ('bAuxType', BYTE),
        # Must be 0
        ('bReserved', BYTE),
        ('SymbolTableIndex', DWORD),
        # Must be 0
        ('rgbReserved', BYTE * 12),
    ]

    from pyWinAPI.shared.poppack_h import *  # NOQA


    # Auxiliary entry format.
    class Sym(ctypes.Structure):
        pass


    class Misc(ctypes.Union):
        pass


    class LnSz(ctypes.Structure):
        pass


    LnSz._fields_ = [
        # declaration line number
        ('Linenumber', WORD),
        # size of struct, union, or enum
        ('Size', WORD),
    ]
    Misc.LnSz = LnSz

    Misc._fields_ = [
        ('LnSz', Misc.LnSz),
        ('TotalSize', DWORD),
    ]
    Sym.Misc = Misc


    class FcnAry(ctypes.Union):
        pass


    class Function(ctypes.Structure):
        pass


    Function._fields_ = [
        # if ISFCN, tag, or .bb DWORD PointerToLinenumber;
        ('PointerToNextFunction', DWORD),
    ]
    FcnAry.Function = Function


    class Array(ctypes.Structure):
        pass


    FcnAry.Array = Array

    FcnAry._fields_ = [
        # if ISFCN, tag, or .bb
        ('Function', FcnAry.Function),
        # if ISARY, up to 4 dimen.
        ('Array', FcnAry.Array),
    ]
    Sym.FcnAry = FcnAry

    Sym._fields_ = [
        # struct, union, or enum tag index
        ('TagIndex', DWORD),
        ('Misc', Sym.Misc),
        ('FcnAry', Sym.FcnAry),
        # tv index
        ('TvIndex', WORD),
    ]
    _IMAGE_AUX_SYMBOL.Sym = Sym


    class File(ctypes.Structure):
        pass


    File._fields_ = [
        ('Name', BYTE * IMAGE_SIZEOF_SYMBOL),
    ]
    _IMAGE_AUX_SYMBOL.File = File


    class Section(ctypes.Structure):
        pass


    Section._fields_ = [
        # section length
        ('Length', DWORD),
        # number of relocation entries
        ('NumberOfRelocations', WORD),
        # number of line numbers
        ('NumberOfLinenumbers', WORD),
        # checksum for communal
        ('CheckSum', DWORD),
        # section number to associate with
        ('Number', SHORT),
        # communal selection type
        ('Selection', BYTE),
        ('bReserved', BYTE),
        # high bits of the section number
        ('HighNumber', SHORT),
    ]
    _IMAGE_AUX_SYMBOL.Section = Section


    class CRC(ctypes.Structure):
        pass


    CRC._fields_ = [
        ('crc', DWORD),
        ('rgbReserved', BYTE * 14),
    ]
    _IMAGE_AUX_SYMBOL.CRC = CRC

    _IMAGE_AUX_SYMBOL._fields_ = [
        ('Sym', _IMAGE_AUX_SYMBOL.Sym),
        ('File', _IMAGE_AUX_SYMBOL.File),
        ('Section', _IMAGE_AUX_SYMBOL.Section),
        ('TokenDef', IMAGE_AUX_SYMBOL_TOKEN_DEF),
        ('CRC', _IMAGE_AUX_SYMBOL.CRC),
    ]


    class Sym(ctypes.Structure):
        pass


    Sym._fields_ = [
        # the weak extern default symbol index
        ('WeakDefaultSymIndex', DWORD),
        ('WeakSearchType', DWORD),
        ('rgbReserved', BYTE * 12),
    ]
    _IMAGE_AUX_SYMBOL_EX.Sym = Sym


    class File(ctypes.Structure):
        pass


    File._fields_ = [
        ('Name', BYTE * ctypes.sizeof(IMAGE_SYMBOL_EX)),
    ]

    _IMAGE_AUX_SYMBOL_EX.File = File


    class Section(ctypes.Structure):
        pass


    Section._fields_ = [
        # section length
        ('Length', DWORD),
        # number of relocation entries
        ('NumberOfRelocations', WORD),
        # number of line numbers
        ('NumberOfLinenumbers', WORD),
        # checksum for communal
        ('CheckSum', DWORD),
        # section number to associate with
        ('Number', SHORT),
        # communal selection type
        ('Selection', BYTE),
        ('bReserved', BYTE),
        # high bits of the section number
        ('HighNumber', SHORT),
        ('rgbReserved', BYTE * 2),
    ]
    _IMAGE_AUX_SYMBOL_EX.Section = Section


    class CRC(ctypes.Structure):
        pass


    CRC._fields_ = [
        ('crc', DWORD),
        ('rgbReserved', BYTE * 16),
    ]
    _IMAGE_AUX_SYMBOL_EX.CRC = CRC

    _IMAGE_AUX_SYMBOL_EX._fields_ = [
        ('Sym', _IMAGE_AUX_SYMBOL_EX.Sym),
        ('File', _IMAGE_AUX_SYMBOL_EX.File),
        ('Section', _IMAGE_AUX_SYMBOL_EX.Section),
        ('TokenDef', IMAGE_AUX_SYMBOL_TOKEN_DEF),
        ('rgbReserved', BYTE * 2),
        ('DUMMYSTRUCTNAME', _IMAGE_AUX_SYMBOL_EX.DUMMYSTRUCTNAME),
        ('CRC', _IMAGE_AUX_SYMBOL_EX.CRC),

    ]


    class IMAGE_AUX_SYMBOL_TYPE(ENUM):
        IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1


    # Communal selection types.
    IMAGE_COMDAT_SELECT_NODUPLICATES = 1
    IMAGE_COMDAT_SELECT_ANY = 2
    IMAGE_COMDAT_SELECT_SAME_SIZE = 3
    IMAGE_COMDAT_SELECT_EXACT_MATCH = 4
    IMAGE_COMDAT_SELECT_ASSOCIATIVE = 5
    IMAGE_COMDAT_SELECT_LARGEST = 6
    IMAGE_COMDAT_SELECT_NEWEST = 7
    IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY = 1
    IMAGE_WEAK_EXTERN_SEARCH_LIBRARY = 2
    IMAGE_WEAK_EXTERN_SEARCH_ALIAS = 3
    IMAGE_WEAK_EXTERN_ANTI_DEPENDENCY = 4


    # Relocation format.
    class DUMMYUNIONNAME(ctypes.Union):
        pass


    DUMMYUNIONNAME._fields_ = [
        ('VirtualAddress', DWORD),
        # Set to the real count when IMAGE_SCN_LNK_NRELOC_OVFL is set
        ('RelocCount', DWORD),
    ]
    _IMAGE_RELOCATION.DUMMYUNIONNAME = DUMMYUNIONNAME

    _IMAGE_RELOCATION._fields_ = [
        ('DUMMYUNIONNAME', _IMAGE_RELOCATION.DUMMYUNIONNAME),
        ('SymbolTableIndex', DWORD),
        ('Type', WORD),
    ]

    # I386 relocation types.
    IMAGE_REL_I386_ABSOLUTE = 0x0000  # Reference is absolute, no relocation is necessary
    IMAGE_REL_I386_DIR16 = 0x0001  # Direct 16 - bit reference to the symbols virtual address
    IMAGE_REL_I386_REL16 = 0x0002  # PC - relative 16 - bit reference to the symbols virtual address
    IMAGE_REL_I386_DIR32 = 0x0006  # Direct 32 - bit reference to the symbols virtual address

    # Direct 32 - bit reference to the symbols virtual address, base
    # not included
    IMAGE_REL_I386_DIR32NB = 0x0007

    # Direct 16 - bit reference to the segment - selector bits of a 32
    # - bit virtual address
    IMAGE_REL_I386_SEG12 = 0x0009
    IMAGE_REL_I386_SECTION = 0x000A
    IMAGE_REL_I386_SECREL = 0x000B
    IMAGE_REL_I386_TOKEN = 0x000C  # clr token
    IMAGE_REL_I386_SECREL7 = 0x000D  # 7 bit offset from base of section containing target
    IMAGE_REL_I386_REL32 = 0x0014  # PC - relative 32 - bit reference to the symbols virtual address

    # MIPS relocation types.
    IMAGE_REL_MIPS_ABSOLUTE = 0x0000  # Reference is absolute, no relocation is necessary
    IMAGE_REL_MIPS_REFHALF = 0x0001
    IMAGE_REL_MIPS_REFWORD = 0x0002
    IMAGE_REL_MIPS_JMPADDR = 0x0003
    IMAGE_REL_MIPS_REFHI = 0x0004
    IMAGE_REL_MIPS_REFLO = 0x0005
    IMAGE_REL_MIPS_GPREL = 0x0006
    IMAGE_REL_MIPS_LITERAL = 0x0007
    IMAGE_REL_MIPS_SECTION = 0x000A
    IMAGE_REL_MIPS_SECREL = 0x000B
    IMAGE_REL_MIPS_SECRELLO = 0x000C  # Low 16 - bit section relative referemce (used for >32k TLS)
    IMAGE_REL_MIPS_SECRELHI = 0x000D  # High 16 - bit section relative reference (used for >32k TLS)
    IMAGE_REL_MIPS_TOKEN = 0x000E  # clr token
    IMAGE_REL_MIPS_JMPADDR16 = 0x0010
    IMAGE_REL_MIPS_REFWORDNB = 0x0022
    IMAGE_REL_MIPS_PAIR = 0x0025

    # Alpha Relocation types.
    IMAGE_REL_ALPHA_ABSOLUTE = 0x0000
    IMAGE_REL_ALPHA_REFLONG = 0x0001
    IMAGE_REL_ALPHA_REFQUAD = 0x0002
    IMAGE_REL_ALPHA_GPREL32 = 0x0003
    IMAGE_REL_ALPHA_LITERAL = 0x0004
    IMAGE_REL_ALPHA_LITUSE = 0x0005
    IMAGE_REL_ALPHA_GPDISP = 0x0006
    IMAGE_REL_ALPHA_BRADDR = 0x0007
    IMAGE_REL_ALPHA_HINT = 0x0008
    IMAGE_REL_ALPHA_INLINE_REFLONG = 0x0009
    IMAGE_REL_ALPHA_REFHI = 0x000A
    IMAGE_REL_ALPHA_REFLO = 0x000B
    IMAGE_REL_ALPHA_PAIR = 0x000C
    IMAGE_REL_ALPHA_MATCH = 0x000D
    IMAGE_REL_ALPHA_SECTION = 0x000E
    IMAGE_REL_ALPHA_SECREL = 0x000F
    IMAGE_REL_ALPHA_REFLONGNB = 0x0010
    IMAGE_REL_ALPHA_SECRELLO = 0x0011  # Low 16 - bit section relative reference
    IMAGE_REL_ALPHA_SECRELHI = 0x0012  # High 16 - bit section relative reference
    IMAGE_REL_ALPHA_REFQ3 = 0x0013  # High 16 bits of 48 bit reference
    IMAGE_REL_ALPHA_REFQ2 = 0x0014  # Middle 16 bits of 48 bit reference
    IMAGE_REL_ALPHA_REFQ1 = 0x0015  # Low 16 bits of 48 bit reference
    IMAGE_REL_ALPHA_GPRELLO = 0x0016  # Low 16 - bit GP relative reference
    IMAGE_REL_ALPHA_GPRELHI = 0x0017  # High 16 - bit GP relative reference

    # IBM PowerPC relocation types.
    IMAGE_REL_PPC_ABSOLUTE = 0x0000  # NOP
    IMAGE_REL_PPC_ADDR64 = 0x0001  # 64 - bit address
    IMAGE_REL_PPC_ADDR32 = 0x0002  # 32 - bit address
    IMAGE_REL_PPC_ADDR24 = 0x0003  # 26 - bit address, shifted left 2 (branch absolute)
    IMAGE_REL_PPC_ADDR16 = 0x0004  # 16 - bit address
    IMAGE_REL_PPC_ADDR14 = 0x0005  # 16 - bit address, shifted left 2 (load doubleword)
    IMAGE_REL_PPC_REL24 = 0x0006  # 26 - bit PC - relative offset, shifted left 2 (branch relative)
    IMAGE_REL_PPC_REL14 = 0x0007  # 16 - bit PC - relative offset, shifted left 2 (br cond relative)
    IMAGE_REL_PPC_TOCREL16 = 0x0008  # 16 - bit offset from TOC base
    IMAGE_REL_PPC_TOCREL14 = 0x0009  # 16 - bit offset from TOC base, shifted left 2 (load doubleword)
    IMAGE_REL_PPC_ADDR32NB = 0x000A  # 32 - bit addr w/o image base
    IMAGE_REL_PPC_SECREL = 0x000B  # va of containing section (as in an image sectionhdr)
    IMAGE_REL_PPC_SECTION = 0x000C  # sectionheader number
    IMAGE_REL_PPC_IFGLUE = 0x000D  # substitute TOC restore instruction iff symbol is glue code
    IMAGE_REL_PPC_IMGLUE = 0x000E  # symbol is glue code; virtual address is TOC restore instruction
    IMAGE_REL_PPC_SECREL16 = 0x000F  # va of containing section (limited to 16 bits)
    IMAGE_REL_PPC_REFHI = 0x0010
    IMAGE_REL_PPC_REFLO = 0x0011
    IMAGE_REL_PPC_PAIR = 0x0012
    IMAGE_REL_PPC_SECRELLO = 0x0013  # Low 16 - bit section relative reference (used for >32k TLS)
    IMAGE_REL_PPC_SECRELHI = 0x0014  # High 16 - bit section relative reference (used for >32k TLS)
    IMAGE_REL_PPC_GPREL = 0x0015
    IMAGE_REL_PPC_TOKEN = 0x0016  # clr token
    IMAGE_REL_PPC_TYPEMASK = 0x00FF  # mask to isolate above values in IMAGE_RELOCATION.Type

    # Flag bits in IMAGE_RELOCATION.TYPE
    IMAGE_REL_PPC_NEG = 0x0100  # subtract reloc value rather than adding it
    IMAGE_REL_PPC_BRTAKEN = 0x0200  # fix branch prediction bit to predict branch taken
    IMAGE_REL_PPC_BRNTAKEN = 0x0400  # fix branch prediction bit to predict branch not taken
    IMAGE_REL_PPC_TOCDEFN = 0x0800  # toc slot defined in file (or, data in toc)

    # Hitachi SH3 relocation types.
    IMAGE_REL_SH3_ABSOLUTE = 0x0000  # No relocation
    IMAGE_REL_SH3_DIRECT16 = 0x0001  # 16 bit direct
    IMAGE_REL_SH3_DIRECT32 = 0x0002  # 32 bit direct
    IMAGE_REL_SH3_DIRECT8 = 0x0003  # 8 bit direct, - 128..255
    IMAGE_REL_SH3_DIRECT8_WORD = 0x0004  # 8 bit direct .W (0 ext.)
    IMAGE_REL_SH3_DIRECT8_LONG = 0x0005  # 8 bit direct .L (0 ext.)
    IMAGE_REL_SH3_DIRECT4 = 0x0006  # 4 bit direct (0 ext.)
    IMAGE_REL_SH3_DIRECT4_WORD = 0x0007  # 4 bit direct .W (0 ext.)
    IMAGE_REL_SH3_DIRECT4_LONG = 0x0008  # 4 bit direct .L (0 ext.)
    IMAGE_REL_SH3_PCREL8_WORD = 0x0009  # 8 bit PC relative .W
    IMAGE_REL_SH3_PCREL8_LONG = 0x000A  # 8 bit PC relative .L
    IMAGE_REL_SH3_PCREL12_WORD = 0x000B  # 12 LSB PC relative .W
    IMAGE_REL_SH3_STARTOF_SECTION = 0x000C  # Start of EXE section
    IMAGE_REL_SH3_SIZEOF_SECTION = 0x000D  # Size of EXE section
    IMAGE_REL_SH3_SECTION = 0x000E  # Section table index
    IMAGE_REL_SH3_SECREL = 0x000F  # Offset within section
    IMAGE_REL_SH3_DIRECT32_NB = 0x0010  # 32 bit direct not based
    IMAGE_REL_SH3_GPREL4_LONG = 0x0011  # GP - relative addressing
    IMAGE_REL_SH3_TOKEN = 0x0012  # clr token
    IMAGE_REL_SHM_PCRELPT = 0x0013  # Offset from current

    # instruction in longwords
    # if not NOMODE, insert the
    # inverse of the low bit at
    # bit 32 to select PTA/PTB
    IMAGE_REL_SHM_REFLO = 0x0014  # Low bits of 32 - bit address
    IMAGE_REL_SHM_REFHALF = 0x0015  # High bits of 32 - bit address
    IMAGE_REL_SHM_RELLO = 0x0016  # Low bits of relative reference
    IMAGE_REL_SHM_RELHALF = 0x0017  # High bits of relative reference
    IMAGE_REL_SHM_PAIR = 0x0018  # offset operand for relocation
    IMAGE_REL_SH_NOMODE = 0x8000  # relocation ignores section mode
    IMAGE_REL_ARM_ABSOLUTE = 0x0000  # No relocation required
    IMAGE_REL_ARM_ADDR32 = 0x0001  # 32 bit address
    IMAGE_REL_ARM_ADDR32NB = 0x0002  # 32 bit address w/o image base
    IMAGE_REL_ARM_BRANCH24 = 0x0003  # 24 bit offset << 2 & sign ext.
    IMAGE_REL_ARM_BRANCH11 = 0x0004  # Thumb: 2 11 bit offsets
    IMAGE_REL_ARM_TOKEN = 0x0005  # clr token
    IMAGE_REL_ARM_GPREL12 = 0x0006  # GP - relative addressing (ARM)
    IMAGE_REL_ARM_GPREL7 = 0x0007  # GP - relative addressing (Thumb)
    IMAGE_REL_ARM_BLX24 = 0x0008
    IMAGE_REL_ARM_BLX11 = 0x0009
    IMAGE_REL_ARM_SECTION = 0x000E  # Section table index
    IMAGE_REL_ARM_SECREL = 0x000F  # Offset within section
    IMAGE_REL_ARM_MOV32A = 0x0010  # ARM: MOVW/MOVT
    IMAGE_REL_ARM_MOV32 = 0x0010  # ARM: MOVW/MOVT (deprecated)
    IMAGE_REL_ARM_MOV32T = 0x0011  # Thumb: MOVW/MOVT
    IMAGE_REL_THUMB_MOV32 = 0x0011  # Thumb: MOVW/MOVT (deprecated)
    IMAGE_REL_ARM_BRANCH20T = 0x0012  # Thumb: 32 - bit conditional B
    IMAGE_REL_THUMB_BRANCH20 = 0x0012  # Thumb: 32 - bit conditional B (deprecated)
    IMAGE_REL_ARM_BRANCH24T = 0x0014  # Thumb: 32 - bit B or BL
    IMAGE_REL_THUMB_BRANCH24 = 0x0014  # Thumb: 32 - bit B or BL (deprecated)
    IMAGE_REL_ARM_BLX23T = 0x0015  # Thumb: BLX immediate
    IMAGE_REL_THUMB_BLX23 = 0x0015  # Thumb: BLX immediate (deprecated)
    IMAGE_REL_AM_ABSOLUTE = 0x0000
    IMAGE_REL_AM_ADDR32 = 0x0001
    IMAGE_REL_AM_ADDR32NB = 0x0002
    IMAGE_REL_AM_CALL32 = 0x0003
    IMAGE_REL_AM_FUNCINFO = 0x0004
    IMAGE_REL_AM_REL32_1 = 0x0005
    IMAGE_REL_AM_REL32_2 = 0x0006
    IMAGE_REL_AM_SECREL = 0x0007
    IMAGE_REL_AM_SECTION = 0x0008
    IMAGE_REL_AM_TOKEN = 0x0009

    # ARM64 relocations types.
    IMAGE_REL_ARM64_ABSOLUTE = 0x0000  # No relocation required
    IMAGE_REL_ARM64_ADDR32 = 0x0001  # 32 bit address. Reviewnot do we need it?
    IMAGE_REL_ARM64_ADDR32NB = 0x0002  # 32 bit address w/o image base (RVA: for Data/PData/XData)
    IMAGE_REL_ARM64_BRANCH26 = 0x0003  # 26 bit offset << 2 & sign ext. for B & BL
    IMAGE_REL_ARM64_PAGEBASE_REL21 = 0x0004  # ADRP
    IMAGE_REL_ARM64_REL21 = 0x0005  # ADR
    IMAGE_REL_ARM64_PAGEOFFSET_12A = 0x0006  # ADD/ADDS (immediate) with zero shift, for page offset
    IMAGE_REL_ARM64_PAGEOFFSET_12L = 0x0007  # LDR (indexed, UINT immediate), for page offset
    IMAGE_REL_ARM64_SECREL = 0x0008  # Offset within section

    # ADD/ADDS (immediate) with zero shift, for bit 0:11 of section
    # offset
    IMAGE_REL_ARM64_SECREL_LOW12A = 0x0009

    # ADD/ADDS (immediate) with zero shift, for bit 12:23 of section
    # offset
    IMAGE_REL_ARM64_SECREL_HIGH12A = 0x000A
    IMAGE_REL_ARM64_SECREL_LOW12L = 0x000B  # LDR (indexed, UINT immediate), for bit 0:11 of section offset
    IMAGE_REL_ARM64_TOKEN = 0x000C
    IMAGE_REL_ARM64_SECTION = 0x000D  # Section table index
    IMAGE_REL_ARM64_ADDR64 = 0x000E  # 64 bit address
    IMAGE_REL_ARM64_BRANCH19 = 0x000F  # 19 bit offset << 2 & sign ext. for conditional B

    # x64 relocations
    IMAGE_REL_AMD64_ABSOLUTE = 0x0000  # Reference is absolute, no relocation is necessary
    IMAGE_REL_AMD64_ADDR64 = 0x0001  # 64 - bit address (VA).
    IMAGE_REL_AMD64_ADDR32 = 0x0002  # 32 - bit address (VA).
    IMAGE_REL_AMD64_ADDR32NB = 0x0003  # 32 - bit address w/o image base (RVA).
    IMAGE_REL_AMD64_REL32 = 0x0004  # 32 - bit relative address from byte following reloc
    IMAGE_REL_AMD64_REL32_1 = 0x0005  # 32 - bit relative address from byte distance 1 from reloc
    IMAGE_REL_AMD64_REL32_2 = 0x0006  # 32 - bit relative address from byte distance 2 from reloc
    IMAGE_REL_AMD64_REL32_3 = 0x0007  # 32 - bit relative address from byte distance 3 from reloc
    IMAGE_REL_AMD64_REL32_4 = 0x0008  # 32 - bit relative address from byte distance 4 from reloc
    IMAGE_REL_AMD64_REL32_5 = 0x0009  # 32 - bit relative address from byte distance 5 from reloc
    IMAGE_REL_AMD64_SECTION = 0x000A  # Section index
    IMAGE_REL_AMD64_SECREL = 0x000B  # 32 bit offset from base of section containing target
    IMAGE_REL_AMD64_SECREL7 = 0x000C  # 7 bit UINT offset from base of section containing target
    IMAGE_REL_AMD64_TOKEN = 0x000D  # 32 bit metadata token
    IMAGE_REL_AMD64_SREL32 = 0x000E  # 32 bit INT span - dependent value emitted into object
    IMAGE_REL_AMD64_PAIR = 0x000F
    IMAGE_REL_AMD64_SSPAN32 = 0x0010  # 32 bit INT span - dependent value applied at link time

    # IA64 relocation types.
    IMAGE_REL_IA64_ABSOLUTE = 0x0000
    IMAGE_REL_IA64_IMM14 = 0x0001
    IMAGE_REL_IA64_IMM22 = 0x0002
    IMAGE_REL_IA64_IMM64 = 0x0003
    IMAGE_REL_IA64_DIR32 = 0x0004
    IMAGE_REL_IA64_DIR64 = 0x0005
    IMAGE_REL_IA64_PCREL21B = 0x0006
    IMAGE_REL_IA64_PCREL21M = 0x0007
    IMAGE_REL_IA64_PCREL21F = 0x0008
    IMAGE_REL_IA64_GPREL22 = 0x0009
    IMAGE_REL_IA64_LTOFF22 = 0x000A
    IMAGE_REL_IA64_SECTION = 0x000B
    IMAGE_REL_IA64_SECREL22 = 0x000C
    IMAGE_REL_IA64_SECREL64I = 0x000D
    IMAGE_REL_IA64_SECREL32 = 0x000E

    IMAGE_REL_IA64_DIR32NB = 0x0010
    IMAGE_REL_IA64_SREL14 = 0x0011
    IMAGE_REL_IA64_SREL22 = 0x0012
    IMAGE_REL_IA64_SREL32 = 0x0013
    IMAGE_REL_IA64_UREL32 = 0x0014
    IMAGE_REL_IA64_PCREL60B = 0x0016  # If possible, convert to MBB bundle with NOP.B in slot 1
    IMAGE_REL_IA64_PCREL60F = 0x0017  # If possible, convert to MFB bundle with NOP.F in slot 1
    IMAGE_REL_IA64_PCREL60I = 0x0018  # If possible, convert to MIB bundle with NOP.I in slot 1
    IMAGE_REL_IA64_PCREL60M = 0x0019  # If possible, convert to MMB bundle with NOP.M in slot 1
    IMAGE_REL_IA64_IMMGPREL64 = 0x001A
    IMAGE_REL_IA64_TOKEN = 0x001B  # clr token
    IMAGE_REL_IA64_GPREL32 = 0x001C
    IMAGE_REL_IA64_ADDEND = 0x001F

    # CEF relocation types.
    IMAGE_REL_CEF_ABSOLUTE = 0x0000  # Reference is absolute, no relocation is necessary
    IMAGE_REL_CEF_ADDR32 = 0x0001  # 32 - bit address (VA).
    IMAGE_REL_CEF_ADDR64 = 0x0002  # 64 - bit address (VA).
    IMAGE_REL_CEF_ADDR32NB = 0x0003  # 32 - bit address w/o image base (RVA).
    IMAGE_REL_CEF_SECTION = 0x0004  # Section index
    IMAGE_REL_CEF_SECREL = 0x0005  # 32 bit offset from base of section containing target
    IMAGE_REL_CEF_TOKEN = 0x0006  # 32 bit metadata token

    # clr relocation types.
    IMAGE_REL_CEE_ABSOLUTE = 0x0000  # Reference is absolute, no relocation is necessary
    IMAGE_REL_CEE_ADDR32 = 0x0001  # 32 - bit address (VA).
    IMAGE_REL_CEE_ADDR64 = 0x0002  # 64 - bit address (VA).
    IMAGE_REL_CEE_ADDR32NB = 0x0003  # 32 - bit address w/o image base (RVA).
    IMAGE_REL_CEE_SECTION = 0x0004  # Section index
    IMAGE_REL_CEE_SECREL = 0x0005  # 32 bit offset from base of section containing target
    IMAGE_REL_CEE_TOKEN = 0x0006  # 32 bit metadata token
    IMAGE_REL_M32R_ABSOLUTE = 0x0000  # No relocation required
    IMAGE_REL_M32R_ADDR32 = 0x0001  # 32 bit address
    IMAGE_REL_M32R_ADDR32NB = 0x0002  # 32 bit address w/o image base
    IMAGE_REL_M32R_ADDR24 = 0x0003  # 24 bit address
    IMAGE_REL_M32R_GPREL16 = 0x0004  # GP relative addressing
    IMAGE_REL_M32R_PCREL24 = 0x0005  # 24 bit offset << 2 & sign ext.
    IMAGE_REL_M32R_PCREL16 = 0x0006  # 16 bit offset << 2 & sign ext.
    IMAGE_REL_M32R_PCREL8 = 0x0007  # 8 bit offset << 2 & sign ext.
    IMAGE_REL_M32R_REFHALF = 0x0008  # 16 MSBs
    IMAGE_REL_M32R_REFHI = 0x0009  # 16 MSBs; adj for LSB sign ext.
    IMAGE_REL_M32R_REFLO = 0x000A  # 16 LSBs
    IMAGE_REL_M32R_PAIR = 0x000B  # Link HI and LO
    IMAGE_REL_M32R_SECTION = 0x000C  # Section table index
    IMAGE_REL_M32R_SECREL32 = 0x000D  # 32 bit section relative reference
    IMAGE_REL_M32R_TOKEN = 0x000E  # clr token
    IMAGE_REL_EBC_ABSOLUTE = 0x0000  # No relocation required
    IMAGE_REL_EBC_ADDR32NB = 0x0001  # 32 bit address w/o image base
    IMAGE_REL_EBC_REL32 = 0x0002  # 32 - bit relative address from byte following reloc
    IMAGE_REL_EBC_SECTION = 0x0003  # Section table index
    IMAGE_REL_EBC_SECREL = 0x0004  # Offset within section


    def EXT_IMM64(Value, Address, Size, InstPos, ValPos):
        Value |= (((Address >> InstPos) & ((1 << Size) - 1)) << ValPos)  # Intel - IA64 - Filler Intel - IA64 - Filler
        return Value


    def INS_IMM64(Value, Address, Size, InstPos, ValPos):
        Address = (
            (Address & ~(((1 << Size) - 1) << InstPos)) |
            (((Value >> ValPos) & ((1 << Size) - 1)) << InstPos)
        ) # Intel-IA64-Filler
        return Address


    EMARCH_ENC_I17_IMM7B_INST_WORD_X = 3  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM7B_SIZE_X = 7  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X = 4  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM7B_VAL_POS_X = 0  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM9D_INST_WORD_X = 3  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM9D_SIZE_X = 9  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X = 18  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM9D_VAL_POS_X = 7  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM5C_INST_WORD_X = 3  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM5C_SIZE_X = 5  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X = 13  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM5C_VAL_POS_X = 16  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IC_INST_WORD_X = 3  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IC_SIZE_X = 1  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IC_INST_WORD_POS_X = 12  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IC_VAL_POS_X = 21  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM41a_INST_WORD_X = 1  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM41a_SIZE_X = 10  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X = 14  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM41a_VAL_POS_X = 22  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM41b_INST_WORD_X = 1  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM41b_SIZE_X = 8  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X = 24  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM41b_VAL_POS_X = 32  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM41c_INST_WORD_X = 2  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM41c_SIZE_X = 23  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X = 0  # Intel - IA64 - Filler
    EMARCH_ENC_I17_IMM41c_VAL_POS_X = 40  # Intel - IA64 - Filler
    EMARCH_ENC_I17_SIGN_INST_WORD_X = 3  # Intel - IA64 - Filler
    EMARCH_ENC_I17_SIGN_SIZE_X = 1  # Intel - IA64 - Filler
    EMARCH_ENC_I17_SIGN_INST_WORD_POS_X = 27  # Intel - IA64 - Filler
    EMARCH_ENC_I17_SIGN_VAL_POS_X = 63  # Intel - IA64 - Filler
    X3_OPCODE_INST_WORD_X = 3  # Intel - IA64 - Filler
    X3_OPCODE_SIZE_X = 4  # Intel - IA64 - Filler
    X3_OPCODE_INST_WORD_POS_X = 28  # Intel - IA64 - Filler
    X3_OPCODE_SIGN_VAL_POS_X = 0  # Intel - IA64 - Filler
    X3_I_INST_WORD_X = 3  # Intel - IA64 - Filler
    X3_I_SIZE_X = 1  # Intel - IA64 - Filler
    X3_I_INST_WORD_POS_X = 27  # Intel - IA64 - Filler
    X3_I_SIGN_VAL_POS_X = 59  # Intel - IA64 - Filler
    X3_D_WH_INST_WORD_X = 3  # Intel - IA64 - Filler
    X3_D_WH_SIZE_X = 3  # Intel - IA64 - Filler
    X3_D_WH_INST_WORD_POS_X = 24  # Intel - IA64 - Filler
    X3_D_WH_SIGN_VAL_POS_X = 0  # Intel - IA64 - Filler
    X3_IMM20_INST_WORD_X = 3  # Intel - IA64 - Filler
    X3_IMM20_SIZE_X = 20  # Intel - IA64 - Filler
    X3_IMM20_INST_WORD_POS_X = 4  # Intel - IA64 - Filler
    X3_IMM20_SIGN_VAL_POS_X = 0  # Intel - IA64 - Filler
    X3_IMM39_1_INST_WORD_X = 2  # Intel - IA64 - Filler
    X3_IMM39_1_SIZE_X = 23  # Intel - IA64 - Filler
    X3_IMM39_1_INST_WORD_POS_X = 0  # Intel - IA64 - Filler
    X3_IMM39_1_SIGN_VAL_POS_X = 36  # Intel - IA64 - Filler
    X3_IMM39_2_INST_WORD_X = 1  # Intel - IA64 - Filler
    X3_IMM39_2_SIZE_X = 16  # Intel - IA64 - Filler
    X3_IMM39_2_INST_WORD_POS_X = 16  # Intel - IA64 - Filler
    X3_IMM39_2_SIGN_VAL_POS_X = 20  # Intel - IA64 - Filler
    X3_P_INST_WORD_X = 3  # Intel - IA64 - Filler
    X3_P_SIZE_X = 4  # Intel - IA64 - Filler
    X3_P_INST_WORD_POS_X = 0  # Intel - IA64 - Filler
    X3_P_SIGN_VAL_POS_X = 0  # Intel - IA64 - Filler
    X3_TMPLT_INST_WORD_X = 0  # Intel - IA64 - Filler
    X3_TMPLT_SIZE_X = 4  # Intel - IA64 - Filler
    X3_TMPLT_INST_WORD_POS_X = 0  # Intel - IA64 - Filler
    X3_TMPLT_SIGN_VAL_POS_X = 0  # Intel - IA64 - Filler
    X3_BTYPE_QP_INST_WORD_X = 2  # Intel - IA64 - Filler
    X3_BTYPE_QP_SIZE_X = 9  # Intel - IA64 - Filler
    X3_BTYPE_QP_INST_WORD_POS_X = 23  # Intel - IA64 - Filler
    X3_BTYPE_QP_INST_VAL_POS_X = 0  # Intel - IA64 - Filler
    X3_EMPTY_INST_WORD_X = 1  # Intel - IA64 - Filler
    X3_EMPTY_SIZE_X = 2  # Intel - IA64 - Filler
    X3_EMPTY_INST_WORD_POS_X = 14  # Intel - IA64 - Filler
    X3_EMPTY_INST_VAL_POS_X = 0  # Intel - IA64 - Filler


    # Line number format.
    class Type(ctypes.Union):
        pass


    Type._fields_ = [
        # Symbol table index of function name if Linenumber is 0.
        ('SymbolTableIndex', DWORD),
        # Virtual address of line number.
        ('VirtualAddress', DWORD),
    ]
    _IMAGE_LINENUMBER.Type = Type

    _IMAGE_LINENUMBER._fields_ = [
        ('Type', _IMAGE_LINENUMBER.Type),
        # Line number.
        ('Linenumber', WORD),
    ]

    PIMAGE_LINENUMBER = POINTER(IMAGE_LINENUMBER)

    if not defined(_MAC):
        # Back to 4 byte packing
        from pyWinAPI.shared.poppack_h import *  # NOQA
    # END IF

    # Based relocation format.
    _IMAGE_BASE_RELOCATION._fields_ = [
        ('VirtualAddress', DWORD),
        ('SizeOfBlock', DWORD),
    ]

    PIMAGE_BASE_RELOCATION = POINTER(IMAGE_BASE_RELOCATION)

    # Based relocation types.
    IMAGE_REL_BASED_ABSOLUTE = 0
    IMAGE_REL_BASED_HIGH = 1
    IMAGE_REL_BASED_LOW = 2
    IMAGE_REL_BASED_HIGHLOW = 3
    IMAGE_REL_BASED_HIGHADJ = 4
    IMAGE_REL_BASED_MACHINE_SPECIFIC_5 = 5
    IMAGE_REL_BASED_RESERVED = 6
    IMAGE_REL_BASED_MACHINE_SPECIFIC_7 = 7
    IMAGE_REL_BASED_MACHINE_SPECIFIC_8 = 8
    IMAGE_REL_BASED_MACHINE_SPECIFIC_9 = 9
    IMAGE_REL_BASED_DIR64 = 10

    # Platform - specific based relocation types.
    IMAGE_REL_BASED_IA64_IMM64 = 9
    IMAGE_REL_BASED_MIPS_JMPADDR = 5
    IMAGE_REL_BASED_MIPS_JMPADDR16 = 9
    IMAGE_REL_BASED_ARM_MOV32 = 5
    IMAGE_REL_BASED_THUMB_MOV32 = 7

    # Archive format.
    IMAGE_ARCHIVE_START_SIZE = 8
    IMAGE_ARCHIVE_START = "not <arch>\n"
    IMAGE_ARCHIVE_END = "`\n"
    IMAGE_ARCHIVE_PAD = "\n"
    IMAGE_ARCHIVE_LINKER_MEMBER = "/               "
    IMAGE_ARCHIVE_LONGNAMES_MEMBER = "//              "
    IMAGE_ARCHIVE_HYBRIDMAP_MEMBER = "/<HYBRIDMAP>/   "

    _IMAGE_ARCHIVE_MEMBER_HEADER._fields_ = [
        # File member name - `/' terminated.
        ('Name', BYTE * 16),
        # File member date - decimal.
        ('Date', BYTE * 12),
        # File member user id - decimal.
        ('UserID', BYTE * 6),
        # File member group id - decimal.
        ('GroupID', BYTE * 6),
        # File member mode - octal.
        ('Mode', BYTE * 8),
        # File member size - decimal.
        ('Size', BYTE * 10),
        # String to end header.
        ('EndHeader', BYTE * 2),
    ]
    IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR = 60

    # DLL support.
    # Export Format
    _IMAGE_EXPORT_DIRECTORY._fields_ = [
        ('Characteristics', DWORD),
        ('TimeDateStamp', DWORD),
        ('MajorVersion', WORD),
        ('MinorVersion', WORD),
        ('Name', DWORD),
        ('Base', DWORD),
        ('NumberOfFunctions', DWORD),
        ('NumberOfNames', DWORD),
        # RVA from base of image
        ('AddressOfFunctions', DWORD),
        # RVA from base of image
        ('AddressOfNames', DWORD),
        # RVA from base of image
        ('AddressOfNameOrdinals', DWORD),
    ]

    # Import Format
    _IMAGE_IMPORT_BY_NAME._fields_ = [
        ('Hint', WORD),
        ('Name', CHAR * 1),
    ]

    # Use align 8 for the 64 - bit IAT.
    from pyWinAPI.shared.pshpack8_h import *  # NOQA


    class u1(ctypes.Union):
        pass


    u1._fields_ = [
        # PBYTE
        ('ForwarderString', ULONGLONG),
        # PDWORD
        ('Function', ULONGLONG),
        ('Ordinal', ULONGLONG),
        # PIMAGE_IMPORT_BY_NAME
        ('AddressOfData', ULONGLONG),
    ]
    _IMAGE_THUNK_DATA64.u1 = u1

    _IMAGE_THUNK_DATA64._fields_ = [
        ('u1', _IMAGE_THUNK_DATA64.u1),
    ]

    # Back to 4 byte packing
    from pyWinAPI.shared.poppack_h import *  # NOQA


    class u1(ctypes.Union):
        pass


    u1._fields_ = [
        # PBYTE
        ('ForwarderString', DWORD),
        # PDWORD
        ('Function', DWORD),
        ('Ordinal', DWORD),
        # PIMAGE_IMPORT_BY_NAME
        ('AddressOfData', DWORD),
    ]
    _IMAGE_THUNK_DATA32.u1 = u1

    _IMAGE_THUNK_DATA32._fields_ = [
        ('u1', _IMAGE_THUNK_DATA32.u1),
    ]
    IMAGE_ORDINAL_FLAG64 = 0x8000000000000000
    IMAGE_ORDINAL_FLAG32 = 0x80000000

    PIMAGE_THUNK_DATA32 = POINTER(IMAGE_THUNK_DATA32)


    def IMAGE_ORDINAL64(Ordinal):
        return Ordinal & 0xFFFF


    def IMAGE_ORDINAL32(Ordinal):
        return Ordinal & 0xFFFF


    def IMAGE_SNAP_BY_ORDINAL64(Ordinal):
        return (Ordinal & IMAGE_ORDINAL_FLAG64) != 0


    def IMAGE_SNAP_BY_ORDINAL32(Ordinal):
        return (Ordinal & IMAGE_ORDINAL_FLAG32) != 0


    # Thread Local Storage
    # typedef VOID
    # (NTAPI *PIMAGE_TLS_CALLBACK) (
    # PVOID DllHandle,
    # DWORD Reason,
    # PVOID Reserved
    # );
    PIMAGE_TLS_CALLBACK = NTAPI(
        VOID,
        PVOID,
        DWORD,
        PVOID
    )


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('Reserved0', DWORD, 20),
        ('Alignment', DWORD, 4),
        ('Reserved1', DWORD, 8),
    ]
    DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME

    DUMMYUNIONNAME._fields_ = [
        ('Characteristics', DWORD),
        ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
    ]
    _IMAGE_TLS_DIRECTORY64.DUMMYUNIONNAME = DUMMYUNIONNAME

    _IMAGE_TLS_DIRECTORY64._fields_ = [
        ('StartAddressOfRawData', ULONGLONG),
        ('EndAddressOfRawData', ULONGLONG),
        # PDWORD
        ('AddressOfIndex', ULONGLONG),
        # PIMAGE_TLS_CALLBACK *;
        ('AddressOfCallBacks', ULONGLONG),
        ('SizeOfZeroFill', DWORD),
        ('DUMMYUNIONNAME', _IMAGE_TLS_DIRECTORY64.DUMMYUNIONNAME),
    ]

    PIMAGE_TLS_DIRECTORY64 = POINTER(IMAGE_TLS_DIRECTORY64)


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('Reserved0', DWORD, 20),
        ('Alignment', DWORD, 4),
        ('Reserved1', DWORD, 8),
    ]
    DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME

    DUMMYUNIONNAME._fields_ = [
        ('Characteristics', DWORD),
        ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
    ]
    _IMAGE_TLS_DIRECTORY32.DUMMYUNIONNAME = DUMMYUNIONNAME

    _IMAGE_TLS_DIRECTORY32._fields_ = [
        ('StartAddressOfRawData', DWORD),
        ('EndAddressOfRawData', DWORD),
        # PDWORD
        ('AddressOfIndex', DWORD),
        # PIMAGE_TLS_CALLBACK *
        ('AddressOfCallBacks', DWORD),
        ('SizeOfZeroFill', DWORD),
        ('DUMMYUNIONNAME', _IMAGE_TLS_DIRECTORY32.DUMMYUNIONNAME),
    ]

    PIMAGE_TLS_DIRECTORY32 = POINTER(IMAGE_TLS_DIRECTORY32)

    if defined(_WIN64):
        IMAGE_ORDINAL_FLAG = IMAGE_ORDINAL_FLAG64


        def IMAGE_ORDINAL(Ordinal):
            return IMAGE_ORDINAL64(Ordinal)


        IMAGE_THUNK_DATA = IMAGE_THUNK_DATA64
        PIMAGE_THUNK_DATA = PIMAGE_THUNK_DATA64


        def IMAGE_SNAP_BY_ORDINAL(Ordinal):
            return IMAGE_SNAP_BY_ORDINAL64(Ordinal)


        IMAGE_TLS_DIRECTORY = IMAGE_TLS_DIRECTORY64
        PIMAGE_TLS_DIRECTORY = PIMAGE_TLS_DIRECTORY64
    else:
        IMAGE_ORDINAL_FLAG = IMAGE_ORDINAL_FLAG32


        def IMAGE_ORDINAL(Ordinal):
            return IMAGE_ORDINAL32(Ordinal)


        IMAGE_THUNK_DATA = IMAGE_THUNK_DATA32
        PIMAGE_THUNK_DATA = PIMAGE_THUNK_DATA32


        def IMAGE_SNAP_BY_ORDINAL(Ordinal):
            return IMAGE_SNAP_BY_ORDINAL32(Ordinal)


        IMAGE_TLS_DIRECTORY = IMAGE_TLS_DIRECTORY32
        PIMAGE_TLS_DIRECTORY = PIMAGE_TLS_DIRECTORY32


    # END IF
    class DUMMYUNIONNAME(ctypes.Union):
        pass


    DUMMYUNIONNAME._fields_ = [
        # 0 for terminating null import descriptor
        ('Characteristics', DWORD),
        # RVA to original unbound IAT (PIMAGE_THUNK_DATA)
        ('OriginalFirstThunk', DWORD),
    ]
    _IMAGE_IMPORT_DESCRIPTOR.DUMMYUNIONNAME = DUMMYUNIONNAME

    _IMAGE_IMPORT_DESCRIPTOR._fields_ = [
        ('DUMMYUNIONNAME', _IMAGE_IMPORT_DESCRIPTOR.DUMMYUNIONNAME),
        # 0 if not bound,
        ('TimeDateStamp', DWORD),
        # - 1 if no forwarders
        ('ForwarderChain', DWORD),
        ('Name', DWORD),
        # RVA to IAT (if bound this IAT has actual addresses)
        ('FirstThunk', DWORD),
    ]

    PIMAGE_IMPORT_DESCRIPTOR = POINTER(IMAGE_IMPORT_DESCRIPTOR)

    # New format import descriptors pointed to by DataDirectory[
    # IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ]
    _IMAGE_BOUND_IMPORT_DESCRIPTOR._fields_ = [
        ('TimeDateStamp', DWORD),
        ('OffsetModuleName', WORD),
        ('NumberOfModuleForwarderRefs', WORD),
    ]

    _IMAGE_BOUND_FORWARDER_REF._fields_ = [
        ('TimeDateStamp', DWORD),
        ('OffsetModuleName', WORD),
        ('Reserved', WORD),
    ]


    class Attributes(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        # Delay load version 2
        ('RvaBased', DWORD, 1),
        ('ReservedAttributes', DWORD, 31),
    ]
    Attributes.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME

    Attributes._fields_ = [
        ('AllAttributes', DWORD),
        ('DUMMYSTRUCTNAME', Attributes.DUMMYSTRUCTNAME),
    ]
    _IMAGE_DELAYLOAD_DESCRIPTOR.Attributes = Attributes

    _IMAGE_DELAYLOAD_DESCRIPTOR._fields_ = [
        ('Attributes', _IMAGE_DELAYLOAD_DESCRIPTOR.Attributes),
        # RVA to the name of the target library
        # (NULL - terminate ASCII string)
        ('DllNameRVA', DWORD),
        # RVA to the HMODULE caching location (PHMODULE)
        ('ModuleHandleRVA', DWORD),
        # RVA to the start of the IAT (PIMAGE_THUNK_DATA)
        ('ImportAddressTableRVA', DWORD),
        # RVA to the start of the name table
        # (PIMAGE_THUNK_DATA::AddressOfData)
        ('ImportNameTableRVA', DWORD),
        # RVA to an optional bound IAT
        ('BoundImportAddressTableRVA', DWORD),
        # RVA to an optional unload info table
        ('UnloadInformationTableRVA', DWORD),
        # 0 if not bound,
        ('TimeDateStamp', DWORD),
    ]

    PIMAGE_DELAYLOAD_DESCRIPTOR = POINTER(IMAGE_DELAYLOAD_DESCRIPTOR)

    # Resource Format.
    # Resource directory consists of two counts, following by a
    # variable length
    # array of directory entries. The first count is the number of
    # entries at
    # beginning of the array that have actual names associated with
    # each entry.
    # The entries are in ascending order, case insensitive strings.
    # The second
    # count is the number of entries that immediately follow the named
    # entries.
    # This second count identifies the number of entries that have 16
    # - bit integer
    # Ids as their name. These entries are also sorted in ascending
    # order.
    # This structure allows fast lookup by either name or number, but
    # for any
    # given resource entry only one form of lookup is supported, not
    # both.
    # This is consistant with the syntax of the .RC file and the .RES
    # file.
    _IMAGE_RESOURCE_DIRECTORY._fields_ = [
        ('Characteristics', DWORD),
        ('TimeDateStamp', DWORD),
        ('MajorVersion', WORD),
        ('MinorVersion', WORD),
        ('NumberOfNamedEntries', WORD),
        ('NumberOfIdEntries', WORD),
    ]
    IMAGE_RESOURCE_NAME_IS_STRING = 0x80000000
    IMAGE_RESOURCE_DATA_IS_DIRECTORY = 0x80000000


    # Each directory contains the 32 - bit Name of the entry and an
    # offset,
    # relative to the beginning of the resource directory of the data
    # associated
    # with this directory entry. If the name of the entry is an actual
    # text
    # string instead of an integer Id, then the high order bit of the
    # name field
    # is set to one and the low order 31 - bits are an offset,
    # relative to the
    # beginning of the resource directory of the string, which is of
    # type
    # IMAGE_RESOURCE_DIRECTORY_STRING. Otherwise the high bit is clear
    # and the
    # low - order 16 - bits are the integer Id that identify this
    # resource directory
    # entry. If the directory entry is yet another resource directory
    # (i.e. a
    # subdirectory), then the high order bit of the offset field will be
    #
    # set to indicate this. Otherwise the high bit is clear and the
    # offset
    # field points to a resource data entry.
    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('NameOffset', DWORD, 31),
        ('NameIsString', DWORD, 1),
    ]
    DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME

    DUMMYUNIONNAME._fields_ = [
        ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
        ('Name', DWORD),
        ('Id', WORD),
    ]
    _IMAGE_RESOURCE_DIRECTORY_ENTRY.DUMMYUNIONNAME = DUMMYUNIONNAME


    class DUMMYUNIONNAME2(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME2(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME2._fields_ = [
        ('OffsetToDirectory', DWORD, 31),
        ('DataIsDirectory', DWORD, 1),
    ]
    DUMMYUNIONNAME2.DUMMYSTRUCTNAME2 = DUMMYSTRUCTNAME2

    DUMMYUNIONNAME2._fields_ = [
        ('OffsetToData', DWORD),
        ('DUMMYSTRUCTNAME2', DUMMYUNIONNAME2.DUMMYSTRUCTNAME2),
    ]
    _IMAGE_RESOURCE_DIRECTORY_ENTRY.DUMMYUNIONNAME2 = DUMMYUNIONNAME2

    _IMAGE_RESOURCE_DIRECTORY_ENTRY._fields_ = [
        ('DUMMYUNIONNAME', _IMAGE_RESOURCE_DIRECTORY_ENTRY.DUMMYUNIONNAME),
        ('DUMMYUNIONNAME2', _IMAGE_RESOURCE_DIRECTORY_ENTRY.DUMMYUNIONNAME2),
    ]

    # For resource directory entries that have actual string names,
    # the Name
    # field of the directory entry points to an object of the
    # following type.
    # All of these string objects are stored together after the last
    # resource
    # directory entry and before the first resource data object. This
    # minimizes
    # the impact of these variable length objects on the alignment of
    # the fixed
    # size directory entry objects.
    _IMAGE_RESOURCE_DIRECTORY_STRING._fields_ = [
        ('Length', WORD),
        ('NameString', CHAR * 1),
    ]

    _IMAGE_RESOURCE_DIR_STRING_U._fields_ = [
        ('Length', WORD),
        ('NameString', WCHAR * 1),
    ]

    # Each resource data entry describes a leaf node in the resource
    # directory
    # tree. It contains an offset, relative to the beginning of the
    # resource
    # directory of the data for the resource, a size field that gives
    # the number
    # of bytes of data at that offset, a CodePage that should be used
    # when
    # decoding code point values within the resource data. Typically
    # for new
    # applications the code page would be the unicode code page.
    _IMAGE_RESOURCE_DATA_ENTRY._fields_ = [
        ('OffsetToData', DWORD),
        ('Size', DWORD),
        ('CodePage', DWORD),
        ('Reserved', DWORD),
    ]

    # begin_ntoshvp
    # Code Integrity in loadconfig (CI)
    _IMAGE_LOAD_CONFIG_CODE_INTEGRITY._fields_ = [
        # Flags to indicate if CI information is available, etc.
        ('Flags', WORD),
        # 0xFFFF means not available
        ('Catalog', WORD),
        ('CatalogOffset', DWORD),
        # Additional bitmask to be defined later
        ('Reserved', DWORD),
    ]

    # Dynamic value relocation table in loadconfig
    _IMAGE_DYNAMIC_RELOCATION_TABLE._fields_ = [
        ('Version', DWORD),
        ('Size', DWORD),
    ]

    # Dynamic value relocation entries following
    # IMAGE_DYNAMIC_RELOCATION_TABLE
    from pyWinAPI.shared.pshpack1_h import *  # NOQA


    _IMAGE_DYNAMIC_RELOCATION32._fields_ = [
        ('Symbol', DWORD),
        ('BaseRelocSize', DWORD),
    ]

    _IMAGE_DYNAMIC_RELOCATION64._fields_ = [
        ('Symbol', ULONGLONG),
        ('BaseRelocSize', DWORD),
    ]

    _IMAGE_DYNAMIC_RELOCATION32_V2._fields_ = [
        ('HeaderSize', DWORD),
        ('FixupInfoSize', DWORD),
        ('Symbol', DWORD),
        ('SymbolGroup', DWORD),
        ('Flags', DWORD),
    ]

    _IMAGE_DYNAMIC_RELOCATION64_V2._fields_ = [
        ('HeaderSize', DWORD),
        ('FixupInfoSize', DWORD),
        ('Symbol', ULONGLONG),
        ('SymbolGroup', DWORD),
        ('Flags', DWORD),
    ]

    # Back to 4 byte packing
    from pyWinAPI.shared.poppack_h import *  # NOQA


    if defined(_WIN64):
        IMAGE_DYNAMIC_RELOCATION = IMAGE_DYNAMIC_RELOCATION64
        PIMAGE_DYNAMIC_RELOCATION = PIMAGE_DYNAMIC_RELOCATION64
        IMAGE_DYNAMIC_RELOCATION_V2 = IMAGE_DYNAMIC_RELOCATION64_V2
        PIMAGE_DYNAMIC_RELOCATION_V2 = PIMAGE_DYNAMIC_RELOCATION64_V2
    else:
        IMAGE_DYNAMIC_RELOCATION = IMAGE_DYNAMIC_RELOCATION32
        PIMAGE_DYNAMIC_RELOCATION = PIMAGE_DYNAMIC_RELOCATION32
        IMAGE_DYNAMIC_RELOCATION_V2 = IMAGE_DYNAMIC_RELOCATION32_V2
        PIMAGE_DYNAMIC_RELOCATION_V2 = PIMAGE_DYNAMIC_RELOCATION32_V2
    # END IF

    # Defined symbolic dynamic relocation entries.
    IMAGE_DYNAMIC_RELOCATION_GUARD_RF_PROLOGUE = 0x00000001
    IMAGE_DYNAMIC_RELOCATION_GUARD_RF_EPILOGUE = 0x00000002
    from pyWinAPI.shared.pshpack1_h import *  # NOQA


    _IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER._fields_ = [
        ('PrologueByteCount', BYTE),
    ]

    PIMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER = POINTER(IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER)

    _IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER._fields_ = [
        ('EpilogueCount', DWORD),
        ('EpilogueByteCount', BYTE),
        ('BranchDescriptorElementSize', BYTE),
        ('BranchDescriptorCount', WORD),
    ]

    PIMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER = POINTER(IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER)


    # Back to 4 byte packing
    from pyWinAPI.shared.poppack_h import *  # NOQA


    # Load Configuration Directory Entry
    _IMAGE_LOAD_CONFIG_DIRECTORY32._fields_ = [
        ('Size', DWORD),
        ('TimeDateStamp', DWORD),
        ('MajorVersion', WORD),
        ('MinorVersion', WORD),
        ('GlobalFlagsClear', DWORD),
        ('GlobalFlagsSet', DWORD),
        ('CriticalSectionDefaultTimeout', DWORD),
        ('DeCommitFreeBlockThreshold', DWORD),
        ('DeCommitTotalFreeThreshold', DWORD),
        # VA
        ('LockPrefixTable', DWORD),
        ('MaximumAllocationSize', DWORD),
        ('VirtualMemoryThreshold', DWORD),
        ('ProcessHeapFlags', DWORD),
        ('ProcessAffinityMask', DWORD),
        ('CSDVersion', WORD),
        ('DependentLoadFlags', WORD),
        # VA
        ('EditList', DWORD),
        # VA
        ('SecurityCookie', DWORD),
        # VA
        ('SEHandlerTable', DWORD),
        ('SEHandlerCount', DWORD),
        # VA
        ('GuardCFCheckFunctionPointer', DWORD),
        # VA
        ('GuardCFDispatchFunctionPointer', DWORD),
        # VA
        ('GuardCFFunctionTable', DWORD),
        ('GuardCFFunctionCount', DWORD),
        ('GuardFlags', DWORD),
        ('CodeIntegrity', IMAGE_LOAD_CONFIG_CODE_INTEGRITY),
        # VA
        ('GuardAddressTakenIatEntryTable', DWORD),
        ('GuardAddressTakenIatEntryCount', DWORD),
        # VA
        ('GuardLongJumpTargetTable', DWORD),
        ('GuardLongJumpTargetCount', DWORD),
        # VA
        ('DynamicValueRelocTable', DWORD),
        ('CHPEMetadataPointer', DWORD),
        # VA
        ('GuardRFFailureRoutine', DWORD),
        # VA
        ('GuardRFFailureRoutineFunctionPointer', DWORD),
        ('DynamicValueRelocTableOffset', DWORD),
        ('DynamicValueRelocTableSection', WORD),
        ('Reserved2', WORD),
        # VA
        ('GuardRFVerifyStackPointerFunctionPointer', DWORD),
        ('HotPatchTableOffset', DWORD),
        ('Reserved3', DWORD),
        # VA
        ('EnclaveConfigurationPointer', DWORD),
    ]

    _IMAGE_LOAD_CONFIG_DIRECTORY64._fields_ = [
        ('Size', DWORD),
        ('TimeDateStamp', DWORD),
        ('MajorVersion', WORD),
        ('MinorVersion', WORD),
        ('GlobalFlagsClear', DWORD),
        ('GlobalFlagsSet', DWORD),
        ('CriticalSectionDefaultTimeout', DWORD),
        ('DeCommitFreeBlockThreshold', ULONGLONG),
        ('DeCommitTotalFreeThreshold', ULONGLONG),
        # VA
        ('LockPrefixTable', ULONGLONG),
        ('MaximumAllocationSize', ULONGLONG),
        ('VirtualMemoryThreshold', ULONGLONG),
        ('ProcessAffinityMask', ULONGLONG),
        ('ProcessHeapFlags', DWORD),
        ('CSDVersion', WORD),
        ('DependentLoadFlags', WORD),
        # VA
        ('EditList', ULONGLONG),
        # VA
        ('SecurityCookie', ULONGLONG),
        # VA
        ('SEHandlerTable', ULONGLONG),
        ('SEHandlerCount', ULONGLONG),
        # VA
        ('GuardCFCheckFunctionPointer', ULONGLONG),
        # VA
        ('GuardCFDispatchFunctionPointer', ULONGLONG),
        # VA
        ('GuardCFFunctionTable', ULONGLONG),
        ('GuardCFFunctionCount', ULONGLONG),
        ('GuardFlags', DWORD),
        ('CodeIntegrity', IMAGE_LOAD_CONFIG_CODE_INTEGRITY),
        # VA
        ('GuardAddressTakenIatEntryTable', ULONGLONG),
        ('GuardAddressTakenIatEntryCount', ULONGLONG),
        # VA
        ('GuardLongJumpTargetTable', ULONGLONG),
        ('GuardLongJumpTargetCount', ULONGLONG),
        # VA
        ('DynamicValueRelocTable', ULONGLONG),
        # VA
        ('CHPEMetadataPointer', ULONGLONG),
        # VA
        ('GuardRFFailureRoutine', ULONGLONG),
        # VA
        ('GuardRFFailureRoutineFunctionPointer', ULONGLONG),
        ('DynamicValueRelocTableOffset', DWORD),
        ('DynamicValueRelocTableSection', WORD),
        ('Reserved2', WORD),
        # VA
        ('GuardRFVerifyStackPointerFunctionPointer', ULONGLONG),
        ('HotPatchTableOffset', DWORD),
        ('Reserved3', DWORD),
        # VA
        ('EnclaveConfigurationPointer', ULONGLONG),
    ]

    # end_ntoshvp
    # begin_ntoshvp
    if defined(_WIN64):
        IMAGE_LOAD_CONFIG_DIRECTORY = IMAGE_LOAD_CONFIG_DIRECTORY64
        PIMAGE_LOAD_CONFIG_DIRECTORY = PIMAGE_LOAD_CONFIG_DIRECTORY64

    else:
        IMAGE_LOAD_CONFIG_DIRECTORY = IMAGE_LOAD_CONFIG_DIRECTORY32
        PIMAGE_LOAD_CONFIG_DIRECTORY = PIMAGE_LOAD_CONFIG_DIRECTORY32
    # END IF

    # end_ntoshvp
    _IMAGE_HOT_PATCH_INFO._fields_ = [
        ('Version', DWORD),
        ('Size', DWORD),
        ('SequenceNumber', DWORD),
        ('BaseImageList', DWORD),
        ('BaseImageCount', DWORD),
        # V2 and later
        ('BufferOffset', DWORD),
    ]

    _IMAGE_HOT_PATCH_BASE._fields_ = [
        ('SequenceNumber', DWORD),
        ('Flags', DWORD),
        ('OriginalTimeDateStamp', DWORD),
        ('OriginalCheckSum', DWORD),
        ('CodeIntegrityInfo', DWORD),
        ('CodeIntegritySize', DWORD),
        ('PatchTable', DWORD),
        # V2 and later
        ('BufferOffset', DWORD),
    ]

    _IMAGE_HOT_PATCH_HASHES._fields_ = [
        ('SHA256', BYTE * 32),
        ('SHA1', BYTE * 20),
    ]
    IMAGE_HOT_PATCH_BASE_OBLIGATORY = 0x00000001
    IMAGE_HOT_PATCH_CHUNK_INVERSE = 0x80000000
    IMAGE_HOT_PATCH_CHUNK_OBLIGATORY = 0x40000000
    IMAGE_HOT_PATCH_CHUNK_RESERVED = 0x3FF03000
    IMAGE_HOT_PATCH_CHUNK_TYPE = 0x000FC000
    IMAGE_HOT_PATCH_CHUNK_SOURCE_RVA = 0x00008000
    IMAGE_HOT_PATCH_CHUNK_TARGET_RVA = 0x00004000
    IMAGE_HOT_PATCH_CHUNK_SIZE = 0x00000FFF
    IMAGE_HOT_PATCH_NONE = 0x00000000
    IMAGE_HOT_PATCH_FUNCTION = 0x0001C000
    IMAGE_HOT_PATCH_ABSOLUTE = 0x0002C000
    IMAGE_HOT_PATCH_REL32 = 0x0003C000
    IMAGE_HOT_PATCH_CALL_TARGET = 0x00044000
    IMAGE_HOT_PATCH_INDIRECT = 0x0005C000
    IMAGE_HOT_PATCH_NO_CALL_TARGET = 0x00064000
    IMAGE_HOT_PATCH_DYNAMIC_VALUE = 0x00078000

    # Module performs control flow integrity checks using system -
    # supplied support
    IMAGE_GUARD_CF_INSTRUMENTED = 0x00000100
    IMAGE_GUARD_CFW_INSTRUMENTED = 0x00000200  # Module performs control flow and write integrity checks
    IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT = 0x00000400  # Module contains valid control flow target metadata
    IMAGE_GUARD_SECURITY_COOKIE_UNUSED = 0x00000800  # Module does not make use of the /GS security cookie
    IMAGE_GUARD_PROTECT_DELAYLOAD_IAT = 0x00001000  # Module supports read only delay load IAT

    # Delayload import table in its own .didat section
    # (with nothing else in it) that can be freely reprotected
    IMAGE_GUARD_DELAYLOAD_IAT_IN_ITS_OWN_SECTION = 0x00002000

    # taken IAT table is also present in the load config.
    IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION = 0x00008000  # Module enables suppression of exports
    IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT = 0x00010000  # Module contains longjmp target information
    IMAGE_GUARD_RF_INSTRUMENTED = 0x00020000  # Module contains return flow instrumentation and metadata
    IMAGE_GUARD_RF_ENABLE = 0x00040000  # Module requests that the OS enable return flow protection

    # Module requests that the OS enable return flow protection in
    # strict mode
    IMAGE_GUARD_RF_STRICT = 0x00080000

    # Stride of Guard CF function table encoded in these bits
    # (additional count of bytes per element)
    IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK = 0xF0000000
    IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT = 28  # Shift to right - justify Guard CF function table stride

    # GFIDS table entry flags.
    IMAGE_GUARD_FLAG_FID_SUPPRESSED = 0x01  # The containing GFID entry is suppressed
    IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED = 0x02  # The containing GFID entry is export suppressed

    # WIN CE Exception table format
    # Function table entry format. Function table is pointed to by the
    # IMAGE_DIRECTORY_ENTRY_EXCEPTION directory entry.
    _IMAGE_CE_RUNTIME_FUNCTION_ENTRY._fields_ = [
        ('FuncStart', DWORD),
        ('PrologLen', DWORD, 8),
        ('FuncLen', DWORD, 22),
        ('ThirtyTwoBit', DWORD, 1),
        ('ExceptionFlag', DWORD, 1),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('Flag', DWORD, 2),
        ('FunctionLength', DWORD, 11),
        ('Ret', DWORD, 2),
        ('H', DWORD, 1),
        ('Reg', DWORD, 3),
        ('R', DWORD, 1),
        ('L', DWORD, 1),
        ('C', DWORD, 1),
        ('StackAdjust', DWORD, 10),
    ]
    DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME

    DUMMYUNIONNAME._fields_ = [
        ('UnwindData', DWORD),
        ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
    ]
    _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY.DUMMYUNIONNAME = DUMMYUNIONNAME

    _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY._fields_ = [
        ('BeginAddress', DWORD),
        ('DUMMYUNIONNAME', _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY.DUMMYUNIONNAME),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    class DUMMYSTRUCTNAME(ctypes.Structure):
        pass


    DUMMYSTRUCTNAME._fields_ = [
        ('Flag', DWORD, 2),
        ('FunctionLength', DWORD, 11),
        ('RegF', DWORD, 3),
        ('RegI', DWORD, 4),
        ('H', DWORD, 1),
        ('CR', DWORD, 2),
        ('FrameSize', DWORD, 9),
    ]
    DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME

    DUMMYUNIONNAME._fields_ = [
        ('UnwindData', DWORD),
        ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
    ]
    _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY.DUMMYUNIONNAME = DUMMYUNIONNAME

    _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY._fields_ = [
        ('BeginAddress', DWORD),
        ('DUMMYUNIONNAME', _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY.DUMMYUNIONNAME),
    ]

    _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY._fields_ = [
        ('BeginAddress', ULONGLONG),
        ('EndAddress', ULONGLONG),
        ('ExceptionHandler', ULONGLONG),
        ('HandlerData', ULONGLONG),
        ('PrologEndAddress', ULONGLONG),
    ]

    _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY._fields_ = [
        ('BeginAddress', DWORD),
        ('EndAddress', DWORD),
        ('ExceptionHandler', DWORD),
        ('HandlerData', DWORD),
        ('PrologEndAddress', DWORD),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    DUMMYUNIONNAME._fields_ = [
        ('UnwindInfoAddress', DWORD),
        ('UnwindData', DWORD),
    ]
    _IMAGE_RUNTIME_FUNCTION_ENTRY.DUMMYUNIONNAME = DUMMYUNIONNAME

    _IMAGE_RUNTIME_FUNCTION_ENTRY._fields_ = [
        ('BeginAddress', DWORD),
        ('EndAddress', DWORD),
        ('DUMMYUNIONNAME', _IMAGE_RUNTIME_FUNCTION_ENTRY.DUMMYUNIONNAME),
    ]

    _IMAGE_RUNTIME_FUNCTION_ENTRY = IMAGE_IA64_RUNTIME_FUNCTION_ENTRY
    _PIMAGE_RUNTIME_FUNCTION_ENTRY = PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY

    if defined(_AXP64_):
        IMAGE_AXP64_RUNTIME_FUNCTION_ENTRY = IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
        PIMAGE_AXP64_RUNTIME_FUNCTION_ENTRY = PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
        IMAGE_RUNTIME_FUNCTION_ENTRY = IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
        PIMAGE_RUNTIME_FUNCTION_ENTRY = PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
    elif defined(_ALPHA_):
        IMAGE_RUNTIME_FUNCTION_ENTRY = IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY
        PIMAGE_RUNTIME_FUNCTION_ENTRY = PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY
    elif defined(_ARM64_):
        IMAGE_RUNTIME_FUNCTION_ENTRY = IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY
        PIMAGE_RUNTIME_FUNCTION_ENTRY = PIMAGE_ARM64_RUNTIME_FUNCTION_ENTRY
    elif defined(_ARM_):
        IMAGE_RUNTIME_FUNCTION_ENTRY = IMAGE_ARM_RUNTIME_FUNCTION_ENTRY
        PIMAGE_RUNTIME_FUNCTION_ENTRY = PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY
    else:
        IMAGE_RUNTIME_FUNCTION_ENTRY = _IMAGE_RUNTIME_FUNCTION_ENTRY
        PIMAGE_RUNTIME_FUNCTION_ENTRY = _PIMAGE_RUNTIME_FUNCTION_ENTRY
    # END IF

    # Sofware enclave information
    IMAGE_ENCLAVE_LONG_ID_LENGTH = 32
    IMAGE_ENCLAVE_SHORT_ID_LENGTH = 16

    _IMAGE_ENCLAVE_CONFIG32._fields_ = [
        ('Size', DWORD),
        ('MinimumRequiredConfigSize', DWORD),
        ('PolicyFlags', DWORD),
        ('NumberOfImports', DWORD),
        ('ImportList', DWORD),
        ('ImportEntrySize', DWORD),
        ('FamilyID', BYTE * IMAGE_ENCLAVE_SHORT_ID_LENGTH),
        ('ImageID', BYTE * IMAGE_ENCLAVE_SHORT_ID_LENGTH),
        ('ImageVersion', DWORD),
        ('SecurityVersion', DWORD),
        ('EnclaveSize', DWORD),
        ('NumberOfThreads', DWORD),
        ('EnclaveFlags', DWORD),
    ]

    _IMAGE_ENCLAVE_CONFIG64._fields_ = [
        ('Size', DWORD),
        ('MinimumRequiredConfigSize', DWORD),
        ('PolicyFlags', DWORD),
        ('NumberOfImports', DWORD),
        ('ImportList', DWORD),
        ('ImportEntrySize', DWORD),
        ('FamilyID', BYTE * IMAGE_ENCLAVE_SHORT_ID_LENGTH),
        ('ImageID', BYTE * IMAGE_ENCLAVE_SHORT_ID_LENGTH),
        ('ImageVersion', DWORD),
        ('SecurityVersion', DWORD),
        ('EnclaveSize', ULONGLONG),
        ('NumberOfThreads', DWORD),
        ('EnclaveFlags', DWORD),
    ]
    if defined(_WIN64):
        IMAGE_ENCLAVE_CONFIG = IMAGE_ENCLAVE_CONFIG64
        PIMAGE_ENCLAVE_CONFIG = PIMAGE_ENCLAVE_CONFIG64
    else:
        IMAGE_ENCLAVE_CONFIG = IMAGE_ENCLAVE_CONFIG32
        PIMAGE_ENCLAVE_CONFIG = PIMAGE_ENCLAVE_CONFIG32
    # END IF

    IMAGE_ENCLAVE_MINIMUM_CONFIG_SIZE = (
        FIELD_OFFSET(IMAGE_ENCLAVE_CONFIG, 'EnclaveFlags')
    )
    IMAGE_ENCLAVE_POLICY_DEBUGGABLE = 0x00000001
    IMAGE_ENCLAVE_FLAG_PRIMARY_IMAGE = 0x00000001

    _IMAGE_ENCLAVE_IMPORT._fields_ = [
        ('MatchType', DWORD),
        ('MinimumSecurityVersion', DWORD),
        ('UniqueOrAuthorID', BYTE * IMAGE_ENCLAVE_LONG_ID_LENGTH),
        ('FamilyID', BYTE * IMAGE_ENCLAVE_SHORT_ID_LENGTH),
        ('ImageID', BYTE * IMAGE_ENCLAVE_SHORT_ID_LENGTH),
        ('ImportName', DWORD),
        ('Reserved', DWORD),
    ]
    IMAGE_ENCLAVE_IMPORT_MATCH_NONE = 0x00000000
    IMAGE_ENCLAVE_IMPORT_MATCH_UNIQUE_ID = 0x00000001
    IMAGE_ENCLAVE_IMPORT_MATCH_AUTHOR_ID = 0x00000002
    IMAGE_ENCLAVE_IMPORT_MATCH_FAMILY_ID = 0x00000003
    IMAGE_ENCLAVE_IMPORT_MATCH_IMAGE_ID = 0x00000004

    # Debug Format
    _IMAGE_DEBUG_DIRECTORY._fields_ = [
        ('Characteristics', DWORD),
        ('TimeDateStamp', DWORD),
        ('MajorVersion', WORD),
        ('MinorVersion', WORD),
        ('Type', DWORD),
        ('SizeOfData', DWORD),
        ('AddressOfRawData', DWORD),
        ('PointerToRawData', DWORD),
    ]
    IMAGE_DEBUG_TYPE_UNKNOWN = 0
    IMAGE_DEBUG_TYPE_COFF = 1
    IMAGE_DEBUG_TYPE_CODEVIEW = 2
    IMAGE_DEBUG_TYPE_FPO = 3
    IMAGE_DEBUG_TYPE_MISC = 4
    IMAGE_DEBUG_TYPE_EXCEPTION = 5
    IMAGE_DEBUG_TYPE_FIXUP = 6
    IMAGE_DEBUG_TYPE_OMAP_TO_SRC = 7
    IMAGE_DEBUG_TYPE_OMAP_FROM_SRC = 8
    IMAGE_DEBUG_TYPE_BORLAND = 9
    IMAGE_DEBUG_TYPE_RESERVED10 = 10
    IMAGE_DEBUG_TYPE_CLSID = 11
    IMAGE_DEBUG_TYPE_VC_FEATURE = 12
    IMAGE_DEBUG_TYPE_POGO = 13
    IMAGE_DEBUG_TYPE_ILTCG = 14
    IMAGE_DEBUG_TYPE_MPX = 15
    IMAGE_DEBUG_TYPE_REPRO = 16

    _IMAGE_COFF_SYMBOLS_HEADER._fields_ = [
        ('NumberOfSymbols', DWORD),
        ('LvaToFirstSymbol', DWORD),
        ('NumberOfLinenumbers', DWORD),
        ('LvaToFirstLinenumber', DWORD),
        ('RvaToFirstByteOfCode', DWORD),
        ('RvaToLastByteOfCode', DWORD),
        ('RvaToFirstByteOfData', DWORD),
        ('RvaToLastByteOfData', DWORD),
    ]
    FRAME_FPO = 0
    FRAME_TRAP = 1
    FRAME_TSS = 2
    FRAME_NONFPO = 3

    _FPO_DATA._fields_ = [
        # offset 1st byte of function code
        ('ulOffStart', DWORD),
        # bytes in function
        ('cbProcSize', DWORD),
        # bytes in locals/4
        ('cdwLocals', DWORD),
        # bytes in params/4
        ('cdwParams', WORD),
        # bytes in prolog
        ('cbProlog', WORD, 8),
        # regs saved
        ('cbRegs', WORD, 3),
        # TRUE if SEH in func
        ('fHasSEH', WORD, 1),
        # TRUE if EBP has been allocated
        ('fUseBP', WORD, 1),
        # reserved for future use
        ('reserved', WORD, 1),
        # frame type
        ('cbFrame', WORD, 2),
    ]
    SIZEOF_RFPO_DATA = 16
    IMAGE_DEBUG_MISC_EXENAME = 1

    _IMAGE_DEBUG_MISC._fields_ = [
        # type of misc data, see defines
        ('DataType', DWORD),
        # total length of record, rounded to four
        ('Length', DWORD),
        # TRUE if data is unicode string
        ('Unicode', BOOLEAN),
        ('Reserved', BYTE * 3),
        # Actual data
        ('Data', BYTE * 1),
    ]

    # Function table extracted from MIPS/ALPHA/IA64 images. Does not
    # contain
    # information needed only for runtime support. Just those fields
    # for
    # each entry needed by a debugger.
    _IMAGE_FUNCTION_ENTRY._fields_ = [
        ('StartingAddress', DWORD),
        ('EndingAddress', DWORD),
        ('EndOfPrologue', DWORD),
    ]


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    DUMMYUNIONNAME._fields_ = [
        ('EndOfPrologue', ULONGLONG),
        ('UnwindInfoAddress', ULONGLONG),
    ]
    _IMAGE_FUNCTION_ENTRY64.DUMMYUNIONNAME = DUMMYUNIONNAME

    _IMAGE_FUNCTION_ENTRY64._fields_ = [
        ('StartingAddress', ULONGLONG),
        ('EndingAddress', ULONGLONG),
        ('DUMMYUNIONNAME', _IMAGE_FUNCTION_ENTRY64.DUMMYUNIONNAME),
    ]

    # Debugging information can be stripped from an image file and
    # placed
    # in a separate .DBG file, whose file name part is the same as the
    # image file name part (e.g. symbols for CMD.EXE could be stripped
    # and placed in
    # CMD.DBG). This is indicated by the IMAGE_FILE_DEBUG_STRIPPED
    # flag in the Characteristics field of the file header. The
    # beginning of
    # the .DBG file contains the following structure which captures
    # certain
    # information from the image file. This allows a debug to proceed
    # even if
    # the original image file is not accessable. This header is
    # followed by
    # zero of more IMAGE_SECTION_HEADER structures, followed by zero
    # or more
    # IMAGE_DEBUG_DIRECTORY structures. The latter structures and
    # those in
    # the image file contain file offsets relative to the beginning of
    # the
    # .DBG file.
    # If symbols have been stripped from an image, the
    # IMAGE_DEBUG_MISC structure
    # is left in the image file, but not mapped. This allows a
    # debugger to
    # compute the name of the .DBG file, from the name of the image in
    # the
    # IMAGE_DEBUG_MISC structure.
    _IMAGE_SEPARATE_DEBUG_HEADER._fields_ = [
        ('Signature', WORD),
        ('Flags', WORD),
        ('Machine', WORD),
        ('Characteristics', WORD),
        ('TimeDateStamp', DWORD),
        ('CheckSum', DWORD),
        ('ImageBase', DWORD),
        ('SizeOfImage', DWORD),
        ('NumberOfSections', DWORD),
        ('ExportedNamesSize', DWORD),
        ('DebugDirectorySize', DWORD),
        ('SectionAlignment', DWORD),
        ('Reserved', DWORD * 2),
    ]

    # begin_ntoshvp
    _NON_PAGED_DEBUG_INFO._fields_ = [
        ('Signature', WORD),
        ('Flags', WORD),
        ('Size', DWORD),
        ('Machine', WORD),
        ('Characteristics', WORD),
        ('TimeDateStamp', DWORD),
        ('CheckSum', DWORD),
        ('SizeOfImage', DWORD),
        ('ImageBase', ULONGLONG),
    ]

    # end_ntoshvp
    if not defined(_MAC):
        IMAGE_SEPARATE_DEBUG_SIGNATURE = 0x4944
        NON_PAGED_DEBUG_SIGNATURE = 0x494E
    else:
        IMAGE_SEPARATE_DEBUG_SIGNATURE = 0x4449  # DI
        NON_PAGED_DEBUG_SIGNATURE = 0x4E49  # NI
    # END IF

    IMAGE_SEPARATE_DEBUG_FLAGS_MASK = 0x8000
    IMAGE_SEPARATE_DEBUG_MISMATCH = 0x8000  # when DBG was updated, the

    # old checksum didn't match.
    # The .arch section is made up of headers, each describing an
    # amask position/value
    # pointing to an array of IMAGE_ARCHITECTURE_ENTRY's. Each "array"
    # (both the header
    # and entry arrays) are terminiated by a quadword of 0xffffffffL.
    # NOTE: There may be quadwords of 0 sprinkled around and must be
    # skipped.
    _ImageArchitectureHeader._fields_ = [
        # 1 - > code section depends on mask bit
        ('AmaskValue', UINT, 1),
        # MBZ
        ('', INT, 7),
        # Amask bit in question for this fixup
        ('AmaskShift', UINT, 8),
        # MBZ
        ('', INT, 16),
        # RVA into .arch section to array of ARCHITECTURE_ENTRY's
        ('FirstEntryRVA', DWORD),
    ]

    _ImageArchitectureEntry._fields_ = [
        # RVA of instruction to fixup
        ('FixupInstRVA', DWORD),
        # fixup instruction (see alphaops.h)
        ('NewInst', DWORD),
    ]

    # Back to the initial value
    from pyWinAPI.shared.poppack_h import *  # NOQA


    # The following structure defines the new import object. Note the
    # values of the first two fields,
    # which must be set as stated in order to differentiate old and
    # new import members.
    # Following this structure, the linker emits two null - terminated
    # strings used to recreate the
    # import at the time of use. The first string is the import's
    # name, the second is the dll's name.
    IMPORT_OBJECT_HDR_SIG2 = 0xFFFF


    class DUMMYUNIONNAME(ctypes.Union):
        pass


    DUMMYUNIONNAME._fields_ = [
        # if grf & IMPORT_OBJECT_ORDINAL
        ('Ordinal', WORD),
        ('Hint', WORD),
    ]
    IMPORT_OBJECT_HEADER.DUMMYUNIONNAME = DUMMYUNIONNAME

    IMPORT_OBJECT_HEADER._fields_ = [
        # Must be IMAGE_FILE_MACHINE_UNKNOWN
        ('Sig1', WORD),
        # Must be IMPORT_OBJECT_HDR_SIG2.
        ('Sig2', WORD),
        ('Version', WORD),
        ('Machine', WORD),
        # Time/date stamp
        ('TimeDateStamp', DWORD),
        # particularly useful for incremental links
        ('SizeOfData', DWORD),
        ('DUMMYUNIONNAME', IMPORT_OBJECT_HEADER.DUMMYUNIONNAME),
        # IMPORT_TYPE
        ('Type', WORD, 2),
        # IMPORT_NAME_TYPE
        ('NameType', WORD, 3),
        # Reserved. Must be zero.
        ('Reserved', WORD, 11),
    ]


    class IMPORT_OBJECT_TYPE(ENUM):
        IMPORT_OBJECT_CODE = 0
        IMPORT_OBJECT_DATA = 1
        IMPORT_OBJECT_CONST = 2


    class IMPORT_OBJECT_NAME_TYPE(ENUM):
        IMPORT_OBJECT_ORDINAL = 0
        IMPORT_OBJECT_NAME = 1

        # Import name == public symbol name skipping leading ?, @, or
        # optionally _.
        IMPORT_OBJECT_NAME_NO_PREFIX = 2

        # Import name == public symbol name skipping leading ?, @, or
        # optionally _
        IMPORT_OBJECT_NAME_UNDECORATE = 3

        # Import name == a name is explicitly provided after the DLL
        # name.
        IMPORT_OBJECT_NAME_EXPORTAS = 4


    __IMAGE_COR20_HEADER_DEFINED__ = None
    if not defined(__IMAGE_COR20_HEADER_DEFINED__):
        __IMAGE_COR20_HEADER_DEFINED__ = 1

        class ReplacesCorHdrNumericDefines(ENUM):
            COMIMAGE_FLAGS_ILONLY = 0x00000001
            COMIMAGE_FLAGS_32BITREQUIRED = 0x00000002
            COMIMAGE_FLAGS_IL_LIBRARY = 0x00000004
            COMIMAGE_FLAGS_STRONGNAMESIGNED = 0x00000008
            COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 0x00000010
            COMIMAGE_FLAGS_TRACKDEBUGDATA = 0x00010000
            COMIMAGE_FLAGS_32BITPREFERRED = 0x00020000
            COR_VERSION_MAJOR_V2 = 2
            COR_VERSION_MAJOR = COR_VERSION_MAJOR_V2
            COR_VERSION_MINOR = 5
            COR_DELETED_NAME_LENGTH = 8
            COR_VTABLEGAP_NAME_LENGTH = 8
            NATIVE_TYPE_MAX_CB = 1
            COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 0xFF
            IMAGE_COR_MIH_METHODRVA = 0x01
            IMAGE_COR_MIH_EHRVA = 0x02
            IMAGE_COR_MIH_BASICBLOCK = 0x08
            COR_VTABLE_32BIT = 0x01
            COR_VTABLE_64BIT = 0x02
            COR_VTABLE_FROM_UNMANAGED = 0x04
            # If set, transition from unmanaged with keeping the
            # current appdomain.
            COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = 0x08
            COR_VTABLE_CALL_MOST_DERIVED = 0x10
            IMAGE_COR_EATJ_THUNK_SIZE = 32
            MAX_CLASS_NAME = 1024
            MAX_PACKAGE_NAME = 1024

            # CLR 2.0 header structure.
        class DUMMYUNIONNAME(ctypes.Union):
            pass

        DUMMYUNIONNAME._fields_ = [
            ('EntryPointToken', DWORD),
            ('EntryPointRVA', DWORD),
        ]
        IMAGE_COR20_HEADER.DUMMYUNIONNAME = DUMMYUNIONNAME


        IMAGE_COR20_HEADER._fields_ = [
            # Header versioning
            ('cb', DWORD),
            ('MajorRuntimeVersion', WORD),
            ('MinorRuntimeVersion', WORD),
            # Symbol table and startup information
            ('MetaData', IMAGE_DATA_DIRECTORY),
            ('Flags', DWORD),
            # If COMIMAGE_FLAGS_NATIVE_ENTYPOINT is set,
            # EntryPointRVA represents an RVA to a native entrypoint.
            ('DUMMYUNIONNAME', IMAGE_COR20_HEADER.DUMMYUNIONNAME),
            # Binding information
            ('Resources', IMAGE_DATA_DIRECTORY),
            ('StrongNameSignature', IMAGE_DATA_DIRECTORY),
            # Regular fixup and binding information
            ('CodeManagerTable', IMAGE_DATA_DIRECTORY),
            ('VTableFixups', IMAGE_DATA_DIRECTORY),
            ('ExportAddressTableJumps', IMAGE_DATA_DIRECTORY),
            # Precompiled image info (internal use only - set to zero)
            ('ManagedNativeHeader', IMAGE_DATA_DIRECTORY),
        ]
    # END IF   __IMAGE_COR20_HEADER_DEFINED__

    # End Image Format
    from pyWinAPI.shared.apiset_h import * # NOQA

    # prototypes
    # begin_ntifs
    blah = 1
    if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM):
        if NTDDI_VERSION > NTDDI_WINXP:
            ntoskrnl = ctypes.windll.NTOSKRNL
            # NTSYSAPI
            # _Success_(return != 0)
            # WORD
            # NTAPI
            # RtlCaptureStackBackTrace(
            # _In_ DWORD FramesToSkip,
            # _In_ DWORD FramesToCapture,
            # _Out_writes_to_(FramesToCapture,return) PVOID* BackTrace,
            # _Out_opt_ PDWORD BackTraceHash
            # );
            RtlCaptureStackBackTrace = (
                ntoskrnl.RtlCaptureStackBackTrace
            )
            RtlCaptureStackBackTrace.restype = WORD

        # END IF
    # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM)

    if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM):
        if NTDDI_VERSION > NTDDI_WIN2K:
            ntoskrnl = ctypes.windll.NTOSKRNL
            # NTSYSAPI
            # VOID
            # NTAPI
            # RtlCaptureContext(
            # _Out_ PCONTEXT ContextRecord
            # );
            RtlCaptureContext = ntoskrnl.RtlCaptureContext
            RtlCaptureContext.restype = VOID

        # END IF
    # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
    # end_ntifs


    if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM):
        ntoskrnl = ctypes.windll.NTOSKRNL
        # NTSYSAPI
        # VOID
        # NTAPI
        # RtlUnwind(
        # _In_opt_ PVOID TargetFrame,
        # _In_opt_ PVOID TargetIp,
        # _In_opt_ PEXCEPTION_RECORD ExceptionRecord,
        # _In_ PVOID ReturnValue
        # );
        RtlUnwind = ntoskrnl.RtlUnwind
        RtlUnwind.restype = VOID

    # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM)


    if defined(_AMD64_):
        ntdll = ctypes.windll.NTDLL
        if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM):
            # NTSYSAPI
            # BOOLEAN
            # __cdecl
            # RtlAddFunctionTable(
            # _In_reads_(EntryCount) PRUNTIME_FUNCTION FunctionTable,
            # _In_ DWORD EntryCount,
            # _In_ DWORD64 BaseAddress
            # );
            RtlAddFunctionTable = ntdll.RtlAddFunctionTable
            RtlAddFunctionTable.restype = BOOLEAN

            # NTSYSAPI
            # BOOLEAN
            # __cdecl
            # RtlDeleteFunctionTable(
            # _In_ PRUNTIME_FUNCTION FunctionTable
            # );
            RtlDeleteFunctionTable = ntdll.RtlDeleteFunctionTable
            RtlDeleteFunctionTable.restype = BOOLEAN

            # NTSYSAPI
            # BOOLEAN
            # __cdecl
            # RtlInstallFunctionTableCallback(
            # _In_ DWORD64 TableIdentifier,
            # _In_ DWORD64 BaseAddress,
            # _In_ DWORD Length,
            # _In_ PGET_RUNTIME_FUNCTION_CALLBACK Callback,
            # _In_opt_ PVOID Context,
            # _In_opt_ PCWSTR OutOfProcessCallbackDll
            # );
            RtlInstallFunctionTableCallback = (
                ntdll.RtlInstallFunctionTableCallback
            )
            RtlInstallFunctionTableCallback.restype = BOOLEAN

            if NTDDI_VERSION >= NTDDI_WIN8:
                # NTSYSAPI
                # DWORD
                # NTAPI
                # RtlAddGrowableFunctionTable(
                # _Out_ PVOID* DynamicTable,
                # _In_reads_(MaximumEntryCount) PRUNTIME_FUNCTION FunctionTable,
                # _In_ DWORD EntryCount,
                # _In_ DWORD MaximumEntryCount,
                # _In_ ULONG_PTR RangeBase,
                # _In_ ULONG_PTR RangeEnd
                # );
                RtlAddGrowableFunctionTable = (
                    ntdll.RtlAddGrowableFunctionTable
                )
                RtlAddGrowableFunctionTable.restype = DWORD

                # NTSYSAPI
                # VOID
                # NTAPI
                # RtlGrowFunctionTable(
                # _Inout_ PVOID DynamicTable,
                # _In_ DWORD NewEntryCount
                # );
                RtlGrowFunctionTable = ntdll.RtlGrowFunctionTable
                RtlGrowFunctionTable.restype = VOID

                # NTSYSAPI
                # VOID
                # NTAPI
                # RtlDeleteGrowableFunctionTable(
                # _In_ PVOID DynamicTable
                # );
                RtlDeleteGrowableFunctionTable = (
                    ntdll.RtlDeleteGrowableFunctionTable
                )
                RtlDeleteGrowableFunctionTable.restype = VOID

            # END IF   (NTDDI_VERSION >= NTDDI_WIN8)
        # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)

        if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM):
            # NTSYSAPI
            # PRUNTIME_FUNCTION
            # NTAPI
            # RtlLookupFunctionEntry(
            # _In_ DWORD64 ControlPc,
            # _Out_ PDWORD64 ImageBase,
            # _Inout_opt_ PUNWIND_HISTORY_TABLE HistoryTable
            # );
            RtlLookupFunctionEntry = ntdll.RtlLookupFunctionEntry
            RtlLookupFunctionEntry.restype = PRUNTIME_FUNCTION
        # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM)

        if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM):
            # NTSYSAPI
            # VOID
            # __cdecl
            # RtlRestoreContext(
            # _In_ PCONTEXT ContextRecord,
            # _In_opt_ struct _EXCEPTION_RECORD* ExceptionRecord
            # );
            RtlRestoreContext = ntdll.RtlRestoreContext
            RtlRestoreContext.restype = VOID

        # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)

        if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM):
            # NTSYSAPI
            # VOID
            # NTAPI
            # RtlUnwindEx(
            # _In_opt_ PVOID TargetFrame,
            # _In_opt_ PVOID TargetIp,
            # _In_opt_ PEXCEPTION_RECORD ExceptionRecord,
            # _In_ PVOID ReturnValue,
            # _In_ PCONTEXT ContextRecord,
            # _In_opt_ PUNWIND_HISTORY_TABLE HistoryTable
            # );
            RtlUnwindEx = ntdll.RtlUnwindEx
            RtlUnwindEx.restype = VOID

        # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM)

        if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM):
            # NTSYSAPI
            # PEXCEPTION_ROUTINE
            # NTAPI
            # RtlVirtualUnwind(
            # _In_ DWORD HandlerType,
            # _In_ DWORD64 ImageBase,
            # _In_ DWORD64 ControlPc,
            # _In_ PRUNTIME_FUNCTION FunctionEntry,
            # _Inout_ PCONTEXT ContextRecord,
            # _Out_ PVOID* HandlerData,
            # _Out_ PDWORD64 EstablisherFrame,
            # _Inout_opt_ PKNONVOLATILE_CONTEXT_POINTERS ContextPointers
            # );
            RtlVirtualUnwind = ntdll.RtlVirtualUnwind
            RtlVirtualUnwind.restype = PEXCEPTION_ROUTINE

        # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
    # END IF   _AMD64_

    if defined(_ARM_):
        ntdll = ctypes.windll.NTDLL
        if WINAPI_FAMILY_PARTITION(
            WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM):
            # NTSYSAPI
            # BOOLEAN
            # __cdecl
            # RtlAddFunctionTable(
            # _In_reads_(EntryCount) PRUNTIME_FUNCTION FunctionTable,
            # _In_ DWORD EntryCount,
            # _In_ DWORD BaseAddress
            # );
            RtlAddFunctionTable = ntdll.RtlAddFunctionTable
            RtlAddFunctionTable.restype = BOOLEAN

            # NTSYSAPI
            # BOOLEAN
            # __cdecl
            # RtlDeleteFunctionTable(
            # _In_ PRUNTIME_FUNCTION FunctionTable
            # );
            RtlDeleteFunctionTable = ntdll.RtlDeleteFunctionTable
            RtlDeleteFunctionTable.restype = BOOLEAN

            # NTSYSAPI
            # BOOLEAN
            # __cdecl
            # RtlInstallFunctionTableCallback(
            # _In_ DWORD TableIdentifier,
            # _In_ DWORD BaseAddress,
            # _In_ DWORD Length,
            # _In_ PGET_RUNTIME_FUNCTION_CALLBACK Callback,
            # _In_opt_ PVOID Context,
            # _In_opt_ PCWSTR OutOfProcessCallbackDll
            # );
            RtlInstallFunctionTableCallback = (
                ntdll.RtlInstallFunctionTableCallback
            )
            RtlInstallFunctionTableCallback.restype = BOOLEAN

            if NTDDI_VERSION >= NTDDI_WIN8:
                # NTSYSAPI
                # DWORD
                # NTAPI
                # RtlAddGrowableFunctionTable(
                # _Out_ PVOID* DynamicTable,
                # _In_reads_(MaximumEntryCount) PRUNTIME_FUNCTION FunctionTable,
                # _In_ DWORD EntryCount,
                # _In_ DWORD MaximumEntryCount,
                # _In_ ULONG_PTR RangeBase,
                # _In_ ULONG_PTR RangeEnd
                # );
                RtlAddGrowableFunctionTable = (
                    ntdll.RtlAddGrowableFunctionTable
                )
                RtlAddGrowableFunctionTable.restype = DWORD

                # NTSYSAPI
                # VOID
                # NTAPI
                # RtlGrowFunctionTable(
                # _Inout_ PVOID DynamicTable,
                # _In_ DWORD NewEntryCount
                # );
                RtlGrowFunctionTable = ntdll.RtlGrowFunctionTable
                RtlGrowFunctionTable.restype = VOID

                # NTSYSAPI
                # VOID
                # NTAPI
                # RtlDeleteGrowableFunctionTable(
                # _In_ PVOID DynamicTable
                # );
                RtlDeleteGrowableFunctionTable = (
                    ntdll.RtlDeleteGrowableFunctionTable
                )
                RtlDeleteGrowableFunctionTable.restype = VOID

            # END IF   (NTDDI_VERSION >= NTDDI_WIN8)
        # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)

        if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM):
            # NTSYSAPI
            # PRUNTIME_FUNCTION
            # NTAPI
            # RtlLookupFunctionEntry(
            # _In_ ULONG_PTR ControlPc,
            # _Out_ PDWORD ImageBase,
            # _Inout_opt_ PUNWIND_HISTORY_TABLE HistoryTable
            # );
            RtlLookupFunctionEntry = ntdll.RtlLookupFunctionEntry
            RtlLookupFunctionEntry.restype = PRUNTIME_FUNCTION

        # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM)

        if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM):
            # NTSYSAPI
            # VOID
            # __cdecl
            # RtlRestoreContext(
            # _In_ PCONTEXT ContextRecord,
            # _In_opt_ struct _EXCEPTION_RECORD* ExceptionRecord
            # );
            RtlRestoreContext = ntdll.RtlRestoreContext
            RtlRestoreContext.restype = VOID

        # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)

        if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM):
            # NTSYSAPI
            # VOID
            # NTAPI
            # RtlUnwindEx(
            # _In_opt_ PVOID TargetFrame,
            # _In_opt_ PVOID TargetIp,
            # _In_opt_ PEXCEPTION_RECORD ExceptionRecord,
            # _In_ PVOID ReturnValue,
            # _In_ PCONTEXT ContextRecord,
            # _In_opt_ PUNWIND_HISTORY_TABLE HistoryTable
            # );
            RtlUnwindEx = ntdll.RtlUnwindEx
            RtlUnwindEx.restype = VOID

        # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM)

        if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM):
            # NTSYSAPI
            # PEXCEPTION_ROUTINE
            # NTAPI
            # RtlVirtualUnwind(
            # _In_ DWORD HandlerType,
            # _In_ DWORD ImageBase,
            # _In_ DWORD ControlPc,
            # _In_ PRUNTIME_FUNCTION FunctionEntry,
            # _Inout_ PCONTEXT ContextRecord,
            # _Out_ PVOID* HandlerData,
            # _Out_ PDWORD EstablisherFrame,
            # _Inout_opt_ PKNONVOLATILE_CONTEXT_POINTERS ContextPointers
            # );
            RtlVirtualUnwind = ntdll.RtlVirtualUnwind
            RtlVirtualUnwind.restype = PEXCEPTION_ROUTINE

        # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
    # END IF   _ARM_

    if defined(_ARM64_):
        if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM):
            # NTSYSAPI
            # BOOLEAN
            # __cdecl
            # RtlAddFunctionTable(
            # _In_reads_(EntryCount) PRUNTIME_FUNCTION FunctionTable,
            # _In_ DWORD EntryCount,
            # _In_ ULONG_PTR BaseAddress
            # );
            RtlAddFunctionTable = ntdll.RtlAddFunctionTable
            RtlAddFunctionTable.restype = BOOLEAN

            # NTSYSAPI
            # BOOLEAN
            # __cdecl
            # RtlDeleteFunctionTable(
            # _In_ PRUNTIME_FUNCTION FunctionTable
            # );
            RtlDeleteFunctionTable = ntdll.RtlDeleteFunctionTable
            RtlDeleteFunctionTable.restype = BOOLEAN

            # NTSYSAPI
            # BOOLEAN
            # __cdecl
            # RtlInstallFunctionTableCallback(
            # _In_ ULONG_PTR TableIdentifier,
            # _In_ ULONG_PTR BaseAddress,
            # _In_ DWORD Length,
            # _In_ PGET_RUNTIME_FUNCTION_CALLBACK Callback,
            # _In_opt_ PVOID Context,
            # _In_opt_ PCWSTR OutOfProcessCallbackDll
            # );
            RtlInstallFunctionTableCallback = (
                ntdll.RtlInstallFunctionTableCallback
            )
            RtlInstallFunctionTableCallback.restype = BOOLEAN

            ntdll = ctypes.windll.NTDLL

            if NTDDI_VERSION >= NTDDI_WIN8:
                # NTSYSAPI
                # DWORD
                # NTAPI
                # RtlAddGrowableFunctionTable(
                # _Out_ PVOID* DynamicTable,
                # _In_reads_(MaximumEntryCount) PRUNTIME_FUNCTION FunctionTable,
                # _In_ DWORD EntryCount,
                # _In_ DWORD MaximumEntryCount,
                # _In_ ULONG_PTR RangeBase,
                # _In_ ULONG_PTR RangeEnd
                # );
                RtlAddGrowableFunctionTable = (
                    ntdll.RtlAddGrowableFunctionTable
                )
                RtlAddGrowableFunctionTable.restype = DWORD

                # NTSYSAPI
                # VOID
                # NTAPI
                # RtlGrowFunctionTable(
                # _Inout_ PVOID DynamicTable,
                # _In_ DWORD NewEntryCount
                # );
                RtlGrowFunctionTable = ntdll.RtlGrowFunctionTable
                RtlGrowFunctionTable.restype = VOID

                # NTSYSAPI
                # VOID
                # NTAPI
                # RtlDeleteGrowableFunctionTable(
                # _In_ PVOID DynamicTable
                # );
                RtlDeleteGrowableFunctionTable = (
                    ntdll.RtlDeleteGrowableFunctionTable
                )
                RtlDeleteGrowableFunctionTable.restype = VOID

            # END IF   (NTDDI_VERSION >= NTDDI_WIN8)
        # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)

        if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM):
            # NTSYSAPI
            # PRUNTIME_FUNCTION
            # NTAPI
            # RtlLookupFunctionEntry(
            # _In_ ULONG_PTR ControlPc,
            # _Out_ PULONG_PTR ImageBase,
            # _Inout_opt_ PUNWIND_HISTORY_TABLE HistoryTable
            # );
            RtlLookupFunctionEntry = ntdll.RtlLookupFunctionEntry
            RtlLookupFunctionEntry.restype = PRUNTIME_FUNCTION

        # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM)

        if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM):
            # NTSYSAPI
            # VOID
            # __cdecl
            # RtlRestoreContext(
            # _In_ PCONTEXT ContextRecord,
            # _In_opt_ struct _EXCEPTION_RECORD* ExceptionRecord
            # );
            RtlRestoreContext = ntdll.RtlRestoreContext
            RtlRestoreContext.restype = VOID

        # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)

        if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM):
            # NTSYSAPI
            # VOID
            # NTAPI
            # RtlUnwindEx(
            # _In_opt_ PVOID TargetFrame,
            # _In_opt_ PVOID TargetIp,
            # _In_opt_ PEXCEPTION_RECORD ExceptionRecord,
            # _In_ PVOID ReturnValue,
            # _In_ PCONTEXT ContextRecord,
            # _In_opt_ PUNWIND_HISTORY_TABLE HistoryTable
            # );
            RtlUnwindEx = ntdll.RtlUnwindEx
            RtlUnwindEx.restype = VOID

        ntdll = ctypes.windll.NTDLL

        if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM):
            # NTSYSAPI
            # PEXCEPTION_ROUTINE
            # NTAPI
            # RtlVirtualUnwind(
            # _In_ DWORD HandlerType,
            # _In_ ULONG_PTR ImageBase,
            # _In_ ULONG_PTR ControlPc,
            # _In_ PRUNTIME_FUNCTION FunctionEntry,
            # _Inout_ PCONTEXT ContextRecord,
            # _Out_ PVOID* HandlerData,
            # _Out_ PULONG_PTR EstablisherFrame,
            # _Inout_opt_ PKNONVOLATILE_CONTEXT_POINTERS ContextPointers
            # );
            RtlVirtualUnwind = ntdll.RtlVirtualUnwind
            RtlVirtualUnwind.restype = PEXCEPTION_ROUTINE

        # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
    # END IF   _ARM64_

    if defined(_CHPE_X86_ARM64_):
        ntdll = ctypes.windll.NTDLL

        if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM):
            # NTSYSAPI
            # VOID
            # NTAPI
            # RtlUnwindEx(
            # _In_opt_ PVOID TargetFrame,
            # _In_opt_ PVOID TargetIp,
            # _In_opt_ PEXCEPTION_RECORD ExceptionRecord,
            # _In_ PVOID ReturnValue,
            # _In_ PCONTEXT ContextRecord,
            # _In_opt_ PVOID HistoryTable
            # );
            RtlUnwindEx = ntdll.RtlUnwindEx
            RtlUnwindEx.restype = VOID

        # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM)
        if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM):
            pass
        # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM)

    # END IF



    if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM):
        # NTSYSAPI
        # PVOID
        # NTAPI
        # RtlPcToFileHeader(
        # _In_ PVOID PcValue,
        # _Out_ PVOID* BaseOfImage
        # );
        RtlPcToFileHeader = ntdll.RtlPcToFileHeader
        RtlPcToFileHeader.restype = PVOID

    # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP | WINAPI_PARTITION_SYSTEM)

    if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM):
        if NTDDI_VERSION >= NTDDI_WIN2K:
            # _Check_return_
            # NTSYSAPI
            # SIZE_T
            # NTAPI
            # RtlCompareMemory(
            # _In_ VOID* Source1,
            # _In_ VOID* Source2,
            # _In_ SIZE_T Length
            # );
            RtlCompareMemory = ntdll.RtlCompareMemory
            RtlCompareMemory.restype = SIZE_T

        # END IF
    # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
    # for move macros
    if defined(_MAC):
        _INC_STRING = None
        if not defined(_INC_STRING):
            from pyWinAPI.km.crt.string_h import *  # NOQA
        # END IF  _INC_STRING
    else:
        from pyWinAPI.km.crt.string_h import *  # NOQA
    # END IF   _MAC

    _SLIST_HEADER_ = None
    if not defined(_SLIST_HEADER_):
        _SLIST_HEADER_ = 1

        if defined(_WIN64):
            # The type SINGLE_LIST_ENTRY is not suitable for use with
            # SLISTs. For
            # WIN64, an entry on an SLIST is required to be 16 - byte
            # aligned, while a
            # SINGLE_LIST_ENTRY structure has only 8 byte alignment.
            # Therefore, all SLIST code should use the SLIST_ENTRY
            # type instead of the
            # SINGLE_LIST_ENTRY type.
            _SLIST_ENTRY._fields_ = [
                ('Next', POINTER(_SLIST_ENTRY)),
            ]
        else:
            SLIST_ENTRY = _SINGLE_LIST_ENTRY
            PSLIST_ENTRY = POINTER(_SINGLE_LIST_ENTRY)

        # END IF   _WIN64
        if defined(_AMD64_):
            class DUMMYSTRUCTNAME(ctypes.Structure):
                pass


            DUMMYSTRUCTNAME._fields_ = [
                # original typedef struct ULONGLONG Alignment;
                ('Region', ULONGLONG),
            ]
            _SLIST_HEADER.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


            class HeaderX64(ctypes.Structure):
                pass


            HeaderX64._fields_ = [
                # x64 16 - byte header ULONGLONG Depth:16;
                ('Sequence', ULONGLONG, 48),
                ('Reserved', ULONGLONG, 4),
                # last 4 bits are always 0's
                ('NextEntry', ULONGLONG, 60),
            ]
            _SLIST_HEADER.HeaderX64 = HeaderX64

            _SLIST_HEADER._fields_ = [
                # original struct
                ('DUMMYSTRUCTNAME', _SLIST_HEADER.DUMMYSTRUCTNAME),
                # x64 16 - byte header
                ('HeaderX64', _SLIST_HEADER.HeaderX64),
            ]
        elif defined(_ARM64_):

            class DUMMYSTRUCTNAME(ctypes.Structure):
                pass


            DUMMYSTRUCTNAME._fields_ = [
                # original typedef struct ULONGLONG Alignment;
                ('Region', ULONGLONG),
            ]
            _SLIST_HEADER.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


            class HeaderArm64(ctypes.Structure):
                pass


            HeaderArm64._fields_ = [
                # ARM64 16 - byte header ULONGLONG Depth:16;
                ('Sequence', ULONGLONG, 48),
                ('Reserved', ULONGLONG, 4),
                # last 4 bits are always 0's
                ('NextEntry', ULONGLONG, 60),
            ]
            _SLIST_HEADER.HeaderArm64 = HeaderArm64

            _SLIST_HEADER._fields_ = [
                # original struct
                ('DUMMYSTRUCTNAME', _SLIST_HEADER.DUMMYSTRUCTNAME),
                # ARM64 16 - byte header
                ('HeaderArm64', _SLIST_HEADER.HeaderArm64),
            ]

            # ARM64_WORKITEM: should this be merged with AMD64 above?
        elif defined(_X86_):

            class DUMMYSTRUCTNAME(ctypes.Structure):
                pass


            DUMMYSTRUCTNAME._fields_ = [
                ('Next', SLIST_ENTRY),
                ('Depth', WORD),
                ('CpuId', WORD),
            ]
            _SLIST_HEADER.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME

            _SLIST_HEADER._fields_ = [
                ('Alignment', ULONGLONG),
                ('DUMMYSTRUCTNAME', _SLIST_HEADER.DUMMYSTRUCTNAME),
            ]


        elif defined(_ARM_):

            class DUMMYSTRUCTNAME(ctypes.Structure):
                pass


            DUMMYSTRUCTNAME._fields_ = [
                ('Next', SLIST_ENTRY),
                ('Depth', WORD),
                ('Reserved', WORD),
            ]
            _SLIST_HEADER.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME

            _SLIST_HEADER._fields_ = [
                ('Alignment', ULONGLONG),
                ('DUMMYSTRUCTNAME', _SLIST_HEADER.DUMMYSTRUCTNAME),
            ]

        # END IF
    # END IF   _SLIST_HEADER_

    if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM):
        ntdll = ctypes.windll.NTDLL
        # NTSYSAPI
        # VOID
        # NTAPI
        # RtlInitializeSListHead(
        # _Out_ PSLIST_HEADER ListHead
        # );
        RtlInitializeSListHead = ntdll.RtlInitializeSListHead
        RtlInitializeSListHead.restype = VOID

        # _Must_inspect_result_
        # NTSYSAPI
        # PSLIST_ENTRY
        # NTAPI
        # RtlFirstEntrySList(
        # _In_ SLIST_HEADER *ListHead
        # );
        RtlFirstEntrySList = ntdll.RtlFirstEntrySList
        RtlFirstEntrySList.restype = PSLIST_ENTRY

        # NTSYSAPI
        # PSLIST_ENTRY
        # NTAPI
        # RtlInterlockedPopEntrySList(
        # _Inout_ PSLIST_HEADER ListHead
        # );
        RtlInterlockedPopEntrySList = ntdll.RtlInterlockedPopEntrySList
        RtlInterlockedPopEntrySList.restype = PSLIST_ENTRY

        # NTSYSAPI
        # PSLIST_ENTRY
        # NTAPI
        # RtlInterlockedPushEntrySList(
        # _Inout_ PSLIST_HEADER ListHead,
        # _Inout_ __drv_aliasesMem PSLIST_ENTRY ListEntry
        # );
        RtlInterlockedPushEntrySList = (
            ntdll.RtlInterlockedPushEntrySList
        )
        RtlInterlockedPushEntrySList.restype = PSLIST_ENTRY

        # NTSYSAPI
        # PSLIST_ENTRY
        # NTAPI
        # RtlInterlockedFlushSList(
        # _Inout_ PSLIST_HEADER ListHead
        # );
        RtlInterlockedFlushSList = ntdll.RtlInterlockedFlushSList
        RtlInterlockedFlushSList.restype = PSLIST_ENTRY

        # NTSYSAPI
        # WORD
        # NTAPI
        # RtlQueryDepthSList(
        # _In_ PSLIST_HEADER ListHead
        # );
        RtlQueryDepthSList = ntdll.RtlQueryDepthSList
        RtlQueryDepthSList.restype = WORD

    # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)

    _RTL_RUN_ONCE_DEF = None
    if not defined(_RTL_RUN_ONCE_DEF):
        _RTL_RUN_ONCE_DEF = 1
        # Run once
        RTL_RUN_ONCE_INIT = [0]  # Static initializer

        # Run once flags
        RTL_RUN_ONCE_CHECK_ONLY = 0x00000001
        RTL_RUN_ONCE_ASYNC = 0x00000002
        RTL_RUN_ONCE_INIT_FAILED = 0x00000004

        # The context stored in the run once structure must leave the
        # following number
        # of low order bits unused.
        RTL_RUN_ONCE_CTX_RESERVED_BITS = 2

        _RTL_RUN_ONCE._fields_ = [
            ('Ptr', PVOID),
        ]
    # END IF   _RTL_RUN_ONCE_DEF

    _RTL_BARRIER._fields_ = [
        ('Reserved1', DWORD),
        ('Reserved2', DWORD),
        ('Reserved3', ULONG_PTR * 2),
        ('Reserved4', DWORD),
        ('Reserved5', DWORD),
    ]

    # begin_ntoshvp
    # Include the more obscure SAL annotations (like __drv_aliasesMem)
    # instead of assuming the crtdefs.h will include them.
    from pyWinAPI.shared.specstrings_h import *  # NOQA


    # Fast fail failure codes.
    # N.B. Failure code zero should not be used, but is required to be
    # reserved
    # for compatibility with previous handling of the
    # STATUS_STACK_BUFFER_OVERRUN exception status code.
    # When updating failure codes here, please also update references
    # in
    # the debugger codebase
    # (currently onecore\sdktools\debuggers\ntsd64\util.cpp)
    FAST_FAIL_LEGACY_GS_VIOLATION = 0
    FAST_FAIL_VTGUARD_CHECK_FAILURE = 1
    FAST_FAIL_STACK_COOKIE_CHECK_FAILURE = 2
    FAST_FAIL_CORRUPT_LIST_ENTRY = 3
    FAST_FAIL_INCORRECT_STACK = 4
    FAST_FAIL_INVALID_ARG = 5
    FAST_FAIL_GS_COOKIE_INIT = 6
    FAST_FAIL_FATAL_APP_EXIT = 7
    FAST_FAIL_RANGE_CHECK_FAILURE = 8
    FAST_FAIL_UNSAFE_REGISTRY_ACCESS = 9
    FAST_FAIL_GUARD_ICALL_CHECK_FAILURE = 10
    FAST_FAIL_GUARD_WRITE_CHECK_FAILURE = 11
    FAST_FAIL_INVALID_FIBER_SWITCH = 12
    FAST_FAIL_INVALID_SET_OF_CONTEXT = 13
    FAST_FAIL_INVALID_REFERENCE_COUNT = 14
    FAST_FAIL_INVALID_JUMP_BUFFER = 18
    FAST_FAIL_MRDATA_MODIFIED = 19
    FAST_FAIL_CERTIFICATION_FAILURE = 20
    FAST_FAIL_INVALID_EXCEPTION_CHAIN = 21
    FAST_FAIL_CRYPTO_LIBRARY = 22
    FAST_FAIL_INVALID_CALL_IN_DLL_CALLOUT = 23
    FAST_FAIL_INVALID_IMAGE_BASE = 24
    FAST_FAIL_DLOAD_PROTECTION_FAILURE = 25
    FAST_FAIL_UNSAFE_EXTENSION_CALL = 26
    FAST_FAIL_DEPRECATED_SERVICE_INVOKED = 27
    FAST_FAIL_INVALID_BUFFER_ACCESS = 28
    FAST_FAIL_INVALID_BALANCED_TREE = 29
    FAST_FAIL_INVALID_NEXT_THREAD = 30
    FAST_FAIL_GUARD_ICALL_CHECK_SUPPRESSED = 31  # Telemetry, nonfatal
    FAST_FAIL_APCS_DISABLED = 32
    FAST_FAIL_INVALID_IDLE_STATE = 33
    FAST_FAIL_MRDATA_PROTECTION_FAILURE = 34
    FAST_FAIL_UNEXPECTED_HEAP_EXCEPTION = 35
    FAST_FAIL_INVALID_LOCK_STATE = 36
    FAST_FAIL_GUARD_JUMPTABLE = 37  # Known to compiler, must retain value 37
    FAST_FAIL_INVALID_LONGJUMP_TARGET = 38
    FAST_FAIL_INVALID_DISPATCH_CONTEXT = 39
    FAST_FAIL_INVALID_THREAD = 40
    FAST_FAIL_INVALID_SYSCALL_NUMBER = 41  # Telemetry, nonfatal
    FAST_FAIL_INVALID_FILE_OPERATION = 42  # Telemetry, nonfatal
    FAST_FAIL_LPAC_ACCESS_DENIED = 43  # Telemetry, nonfatal
    FAST_FAIL_GUARD_SS_FAILURE = 44
    FAST_FAIL_LOADER_CONTINUITY_FAILURE = 45  # Telemetry, nonfatal
    FAST_FAIL_GUARD_EXPORT_SUPPRESSION_FAILURE = 46
    FAST_FAIL_INVALID_CONTROL_STACK = 47
    FAST_FAIL_SET_CONTEXT_DENIED = 48
    FAST_FAIL_INVALID_IAT = 49
    FAST_FAIL_HEAP_METADATA_CORRUPTION = 50
    FAST_FAIL_PAYLOAD_RESTRICTION_VIOLATION = 51
    FAST_FAIL_LOW_LABEL_ACCESS_DENIED = 52  # Telemetry, nonfatal
    FAST_FAIL_ENCLAVE_CALL_FAILURE = 53
    FAST_FAIL_UNHANDLED_LSS_EXCEPTON = 54
    FAST_FAIL_ADMINLESS_ACCESS_DENIED = 55  # Telemetry, nonfatal
    FAST_FAIL_UNEXPECTED_CALL = 56
    FAST_FAIL_INVALID_FAST_FAIL_CODE = 0xFFFFFFFF
    if _MSC_VER >= 1610:
        pass
    # END IF
    HEAP_NO_SERIALIZE = 0x00000001
    HEAP_GROWABLE = 0x00000002
    HEAP_GENERATE_EXCEPTIONS = 0x00000004
    HEAP_ZERO_MEMORY = 0x00000008
    HEAP_REALLOC_IN_PLACE_ONLY = 0x00000010
    HEAP_TAIL_CHECKING_ENABLED = 0x00000020
    HEAP_FREE_CHECKING_ENABLED = 0x00000040
    HEAP_DISABLE_COALESCE_ON_FREE = 0x00000080
    HEAP_CREATE_ALIGN_16 = 0x00010000
    HEAP_CREATE_ENABLE_TRACING = 0x00020000
    HEAP_CREATE_ENABLE_EXECUTE = 0x00040000
    HEAP_MAXIMUM_TAG = 0x0FFF
    HEAP_PSEUDO_TAG_FLAG = 0x8000
    HEAP_TAG_SHIFT = 18
    HEAP_CREATE_SEGMENT_HEAP = 0x00000100
    HEAP_CREATE_HARDENED = 0x00000200

    if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP):
        if not defined(MIDL_PASS):
            pass
        # END IF
    # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

    IS_TEXT_UNICODE_ASCII16 = 0x0001
    IS_TEXT_UNICODE_REVERSE_ASCII16 = 0x0010
    IS_TEXT_UNICODE_STATISTICS = 0x0002
    IS_TEXT_UNICODE_REVERSE_STATISTICS = 0x0020
    IS_TEXT_UNICODE_CONTROLS = 0x0004
    IS_TEXT_UNICODE_REVERSE_CONTROLS = 0x0040
    IS_TEXT_UNICODE_SIGNATURE = 0x0008
    IS_TEXT_UNICODE_REVERSE_SIGNATURE = 0x0080
    IS_TEXT_UNICODE_ILLEGAL_CHARS = 0x0100
    IS_TEXT_UNICODE_ODD_LENGTH = 0x0200
    IS_TEXT_UNICODE_DBCS_LEADBYTE = 0x0400
    IS_TEXT_UNICODE_NULL_BYTES = 0x1000
    IS_TEXT_UNICODE_UNICODE_MASK = 0x000F
    IS_TEXT_UNICODE_REVERSE_MASK = 0x00F0
    IS_TEXT_UNICODE_NOT_UNICODE_MASK = 0x0F00
    IS_TEXT_UNICODE_NOT_ASCII_MASK = 0xF000
    COMPRESSION_FORMAT_NONE = 0x0000
    COMPRESSION_FORMAT_DEFAULT = 0x0001
    COMPRESSION_FORMAT_LZNT1 = 0x0002
    COMPRESSION_FORMAT_XPRESS = 0x0003
    COMPRESSION_FORMAT_XPRESS_HUFF = 0x0004
    COMPRESSION_ENGINE_STANDARD = 0x0000
    COMPRESSION_ENGINE_MAXIMUM = 0x0100

    COMPRESSION_ENGINE_HIBER = 0x0200

    _DBG_MEMCPY_INLINE_ = None
    _MEMCPY_INLINE_ = None
    _CRTBLD = None
    if (
        defined(_DBG_MEMCPY_INLINE_) and
        not defined(MIDL_PASS) and
        not defined(_MEMCPY_INLINE_) and
        not defined(_CRTBLD)
    ):
        _MEMCPY_INLINE_ = 1
        # Make sure the source and destination do not overlap such
        # that the
        # move destroys the destination.
        ntdll = ctypes.windll.NTDLL

    # END IF
    def RtlEqualMemory(Destination, Source, Length):
        return not memcmp(Destination, Source, Length)


    def RtlMoveMemory(Destination, Source, Length):
        return ctypes.memmove(Destination, Source, Length)


    def RtlCopyMemory(Destination, Source, Length):
        return memcpy(Destination, Source, Length)


    def RtlFillMemory(Destination, Length, Fill):
        return ctypes.memset(Destination, Fill, Length)


    def RtlZeroMemory(Destination, Length):
        return ctypes.memset(Destination, 0, Length)


    if not defined(MIDL_PASS):
        if defined(_M_AMD64):
            if not defined(_M_CEE) and (defined(_M_ARM) or defined(_M_ARM64)):
                pass
            else:
                pass
            # END IF
        else:
            pass
        # END IF   _M_AMD64
    # END IF

    # begin_wdm
    SEF_DACL_AUTO_INHERIT = 0x01
    SEF_SACL_AUTO_INHERIT = 0x02
    SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT = 0x04
    SEF_AVOID_PRIVILEGE_CHECK = 0x08
    SEF_AVOID_OWNER_CHECK = 0x10
    SEF_DEFAULT_OWNER_FROM_PARENT = 0x20
    SEF_DEFAULT_GROUP_FROM_PARENT = 0x40
    SEF_MACL_NO_WRITE_UP = 0x100
    SEF_MACL_NO_READ_UP = 0x200
    SEF_MACL_NO_EXECUTE_UP = 0x400
    SEF_AI_USE_EXTRA_PARAMS = 0x800
    SEF_AVOID_OWNER_RESTRICTION = 0x1000
    SEF_FORCE_USER_MODE = 0x2000
    SEF_MACL_VALID_FLAGS = (
        SEF_MACL_NO_WRITE_UP |
        SEF_MACL_NO_READ_UP |
        SEF_MACL_NO_EXECUTE_UP
    )

    # end_wdm
    _MESSAGE_RESOURCE_ENTRY._fields_ = [
        ('Length', WORD),
        ('Flags', WORD),
        ('Text', BYTE * 1),
    ]
    MESSAGE_RESOURCE_UNICODE = 0x0001

    _MESSAGE_RESOURCE_BLOCK._fields_ = [
        ('LowId', DWORD),
        ('HighId', DWORD),
        ('OffsetToEntries', DWORD),
    ]

    _MESSAGE_RESOURCE_DATA._fields_ = [
        ('NumberOfBlocks', DWORD),
        ('Blocks', MESSAGE_RESOURCE_BLOCK * 1),
    ]

    _OSVERSIONINFOA._fields_ = [
        ('dwOSVersionInfoSize', DWORD),
        ('dwMajorVersion', DWORD),
        ('dwMinorVersion', DWORD),
        ('dwBuildNumber', DWORD),
        ('dwPlatformId', DWORD),
        # Maintenance string for PSS usage
        ('szCSDVersion', CHAR * 128),
    ]

    _OSVERSIONINFOW._fields_ = [
        ('dwOSVersionInfoSize', DWORD),
        ('dwMajorVersion', DWORD),
        ('dwMinorVersion', DWORD),
        ('dwBuildNumber', DWORD),
        ('dwPlatformId', DWORD),
        # Maintenance string for PSS usage
        ('szCSDVersion', WCHAR * 128),
    ]
    if defined(UNICODE):
        OSVERSIONINFO = OSVERSIONINFOW
        POSVERSIONINFO = POSVERSIONINFOW
        LPOSVERSIONINFO = LPOSVERSIONINFOW
    else:
        OSVERSIONINFO = OSVERSIONINFOA
        POSVERSIONINFO = POSVERSIONINFOA
        LPOSVERSIONINFO = LPOSVERSIONINFOA
    # END IF   UNICODE

    _OSVERSIONINFOEXA._fields_ = [
        ('dwOSVersionInfoSize', DWORD),
        ('dwMajorVersion', DWORD),
        ('dwMinorVersion', DWORD),
        ('dwBuildNumber', DWORD),
        ('dwPlatformId', DWORD),
        # Maintenance string for PSS usage
        ('szCSDVersion', CHAR * 128),
        ('wServicePackMajor', WORD),
        ('wServicePackMinor', WORD),
        ('wSuiteMask', WORD),
        ('wProductType', BYTE),
        ('wReserved', BYTE),
    ]

    _OSVERSIONINFOEXW._fields_ = [
        ('dwOSVersionInfoSize', DWORD),
        ('dwMajorVersion', DWORD),
        ('dwMinorVersion', DWORD),
        ('dwBuildNumber', DWORD),
        ('dwPlatformId', DWORD),
        # Maintenance string for PSS usage
        ('szCSDVersion', WCHAR * 128),
        ('wServicePackMajor', WORD),
        ('wServicePackMinor', WORD),
        ('wSuiteMask', WORD),
        ('wProductType', BYTE),
        ('wReserved', BYTE),
    ]
    if defined(UNICODE):
        OSVERSIONINFOEX = OSVERSIONINFOEXW
        POSVERSIONINFOEX = POSVERSIONINFOEXW
        LPOSVERSIONINFOEX = LPOSVERSIONINFOEXW
    else:
        OSVERSIONINFOEX = OSVERSIONINFOEXA
        POSVERSIONINFOEX = POSVERSIONINFOEXA
        LPOSVERSIONINFOEX = LPOSVERSIONINFOEXA
    # END IF   UNICODE

    # begin_wudfpwdm
    # RtlVerifyVersionInfo() conditions
    VER_EQUAL = 1
    VER_GREATER = 2
    VER_GREATER_EQUAL = 3
    VER_LESS = 4
    VER_LESS_EQUAL = 5
    VER_AND = 6
    VER_OR = 7
    VER_CONDITION_MASK = 7
    VER_NUM_BITS_PER_CONDITION_MASK = 3

    # RtlVerifyVersionInfo() type mask bits
    VER_MINORVERSION = 0x0000001
    VER_MAJORVERSION = 0x0000002
    VER_BUILDNUMBER = 0x0000004
    VER_PLATFORMID = 0x0000008
    VER_SERVICEPACKMINOR = 0x0000010
    VER_SERVICEPACKMAJOR = 0x0000020
    VER_SUITENAME = 0x0000040
    VER_PRODUCT_TYPE = 0x0000080

    # RtlVerifyVersionInfo() os product type values
    VER_NT_WORKSTATION = 0x0000001
    VER_NT_DOMAIN_CONTROLLER = 0x0000002
    VER_NT_SERVER = 0x0000003

    # dwPlatformId defines:
    VER_PLATFORM_WIN32s = 0
    VER_PLATFORM_WIN32_WINDOWS = 1
    VER_PLATFORM_WIN32_NT = 2

    if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM):
        # VerifyVersionInfo() macro to set the condition mask
        # For documentation sakes here's the old version of the macro
        # that got
        # changed to call an API
        # define VER_SET_CONDITION(_m_,_t_,_c_)
        # _m_=(_m_ | (_c_ << (1 << _t_)))
        def VER_SET_CONDITION(_m_, _t_, _c_):
            _m_ = VerSetConditionMask(_m_, _t_, _c_)
            return _m_

        _WINBASE_ = None
        if not defined(_WINBASE_) and not defined(MIDL_PASS):
            if NTDDI_VERSION >= NTDDI_WIN2K:
                ntdll = ctypes.windll.NTDLL
                # NTSYSAPI
                # ULONGLONG
                # NTAPI
                # VerSetConditionMask(
                # _In_ ULONGLONG ConditionMask,
                # _In_ DWORD TypeMask,
                # _In_ BYTE  Condition
                # );
                VerSetConditionMask = ntdll.VerSetConditionMask
                VerSetConditionMask.restype = ULONGLONG

            # END IF
        # END IF   not defined(_WINBASE_) and not defined(MIDL_PASS)
    # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)


    if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM):
        # begin_ntddk
        ntdll = ctypes.windll.NTDLL

        if NTDDI_VERSION >= NTDDI_VISTA:
            # NTSYSAPI
            # BOOLEAN
            # NTAPI
            # RtlGetProductInfo(
            # _In_  DWORD  OSMajorVersion,
            # _In_  DWORD  OSMinorVersion,
            # _In_  DWORD  SpMajorVersion,
            # _In_  DWORD  SpMinorVersion,
            # _Out_ PDWORD ReturnedProductType
            # );
            RtlGetProductInfo = ntdll.RtlGetProductInfo
            RtlGetProductInfo.restype = BOOLEAN

        # END IF
    # end_ntddk
    # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)

    RTL_UMS_VERSION = 0x0100


    class _RTL_UMS_THREAD_INFO_CLASS(ENUM):
        UmsThreadInvalidInfoClass = 0
        UmsThreadUserContext = 1
        UmsThreadPriority = 2
        UmsThreadAffinity = 3
        UmsThreadTeb = 4
        UmsThreadIsSuspended = 5
        UmsThreadIsTerminated = 6
        UmsThreadMaxInfoClass = 7


    RTL_UMS_THREAD_INFO_CLASS = _RTL_UMS_THREAD_INFO_CLASS
    PRTL_UMS_THREAD_INFO_CLASS = POINTER(_RTL_UMS_THREAD_INFO_CLASS)


    class _RTL_UMS_SCHEDULER_REASON(ENUM):
        UmsSchedulerStartup = 0
        UmsSchedulerThreadBlocked = 1
        UmsSchedulerThreadYield = 2


    RTL_UMS_SCHEDULER_REASON = _RTL_UMS_SCHEDULER_REASON
    PRTL_UMS_SCHEDULER_REASON = POINTER(_RTL_UMS_SCHEDULER_REASON)

    # _Function_class_(RTL_UMS_SCHEDULER_ENTRY_POINT)
    # VOID
    # NTAPI
    # RTL_UMS_SCHEDULER_ENTRY_POINT(
    # _In_ RTL_UMS_SCHEDULER_REASON Reason,
    # _In_ ULONG_PTR ActivationPayload,
    # _In_ PVOID SchedulerParam
    # );
    RTL_UMS_SCHEDULER_ENTRY_POINT = NTAPI(
        VOID,
        RTL_UMS_SCHEDULER_REASON,
        ULONG_PTR,
        PVOID
    )
    PRTL_UMS_SCHEDULER_ENTRY_POINT = POINTER(RTL_UMS_SCHEDULER_ENTRY_POINT)

    IS_VALIDATION_ENABLED = None
    if not defined(IS_VALIDATION_ENABLED):
        if NTDDI_VERSION >= NTDDI_WIN8:
            # Validation runlevel helper macro: checks if a particular
            # level L enables the
            # validation class C.
            # Returns a non - zero scalar if class C is enabled, and
            # zero otherwise.
            def IS_VALIDATION_ENABLED(C, L):
                return L & C


            # Validation classes are broken into:
            # 8 predefined validation classes, spanning bits 0 to 7 of
            # the level value
            # 24 custom - defined validation classes, spanning bits 8
            # to 31
            VRL_PREDEFINED_CLASS_BEGIN = 1 << 0
            VRL_CUSTOM_CLASS_BEGIN = 1 << 8

            # The following are predefined validation classes.
            VRL_CLASS_CONSISTENCY = VRL_PREDEFINED_CLASS_BEGIN << 0

            # Do not ignore kernel breaks when kernel debugging is
            # disabled (debug builds only)
            VRL_ENABLE_KERNEL_BREAKS = 1 << 31
        # END IF   (NTDDI_VERSION >= NTDDI_WIN8)
    # END IF   not defined(IS_VALIDATION_ENABLED)

    if NTDDI_VERSION >= NTDDI_WIN8:
        # RtlCheckTokenMembership flags.
        CTMF_INCLUDE_APPCONTAINER = 0x00000001
        CTMF_INCLUDE_LPAC = 0x00000002
        CTMF_VALID_FLAGS = (
            CTMF_INCLUDE_APPCONTAINER |
            CTMF_INCLUDE_LPAC
        )
    # END IF   (NTDDI_VERSION >= NTDDI_WIN8)

    if NTDDI_VERSION >= NTDDI_WIN8:
        # end_ntosp
        if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM):
            # begin_ntosp
            # Crc32 and Crc64 routines that use standardized algorithms
            # end_ntosp
            pass
        # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
        # begin_ntosp
    # END IF   (NTDDI_VERSION >= NTDDI_WIN8)

    if NTDDI_VERSION >= NTDDI_WINTHRESHOLD:
        # API to detect what type of OS Deployment this is. Current
        # valid values
        # are listed below
        # Valid OsDeployment values that can be returned
        class _OS_DEPLOYEMENT_STATE_VALUES(ENUM):
            OS_DEPLOYMENT_STANDARD = 1
            OS_DEPLOYMENT_COMPACT = 2


        OS_DEPLOYEMENT_STATE_VALUES = _OS_DEPLOYEMENT_STATE_VALUES
        # No flags currently defined, passed 0
    # END IF   NTDDI_VERSION >= NTDDI_WINTHRESHOLD

    # Flush routines for DAX mapped files
    if NTDDI_VERSION >= NTDDI_WIN10_RS2 and defined(_AMD64_):
        _NV_MEMORY_RANGE._fields_ = [
            ('BaseAddress', POINTER(VOID)),
            ('Length', SIZE_T),
        ]

        # Flags for RtlFlushNonVolatileMemory and
        # RtlFlushNonVolatileMemoryRanges
        FLUSH_NV_MEMORY_IN_FLAG_NO_DRAIN = 0x00000001

        # Default token is used to call the flush and drain routines
        # without the
        # RtlGetNonVolatileToken call, for callers who know the
        # details about the
        # region they are flushing.
        FLUSH_NV_MEMORY_DEFAULT_TOKEN = -1
    # END IF   (NTDDI_VERSION >= NTDDI_RS2) and defined(_AMD64_)

    # Correlation Vector Routines.

    if NTDDI_VERSION >= NTDDI_WIN10_RS2:
        RTL_CORRELATION_VECTOR_STRING_LENGTH = 129
        RTL_CORRELATION_VECTOR_VERSION_1 = 1
        RTL_CORRELATION_VECTOR_VERSION_2 = 2
        RTL_CORRELATION_VECTOR_VERSION_CURRENT = (
            RTL_CORRELATION_VECTOR_VERSION_2
        )
        RTL_CORRELATION_VECTOR_V1_PREFIX_LENGTH = 16
        RTL_CORRELATION_VECTOR_V1_LENGTH = 64
        RTL_CORRELATION_VECTOR_V2_PREFIX_LENGTH = 22
        RTL_CORRELATION_VECTOR_V2_LENGTH = 128

        CORRELATION_VECTOR._fields_ = [
            ('Version', CHAR),
            ('Vector', CHAR * RTL_CORRELATION_VECTOR_STRING_LENGTH),
        ]


        def TraceLoggingCORRELATION_VECTOR(cv):
            return TraceLoggingString(cv.Vector, "__TlgCV__")


        ntoskrnl = ctypes.windll.NTOSKRNL

        # NTSYSAPI
        # DWORD
        # NTAPI
        # RtlInitializeCorrelationVector(
        # _Out_ PCORRELATION_VECTOR CorrelationVector,
        # _In_  INT Version,
        # _In_opt_  GUID * Guid
        # );
        RtlInitializeCorrelationVector = (
            ntoskrnl.RtlInitializeCorrelationVector
        )
        RtlInitializeCorrelationVector.restype = DWORD

        # NTSYSAPI
        # DWORD
        # NTAPI
        # RtlIncrementCorrelationVector(
        # _Inout_ PCORRELATION_VECTOR CorrelationVector
        # );
        RtlIncrementCorrelationVector = (
            ntoskrnl.RtlIncrementCorrelationVector
        )
        RtlIncrementCorrelationVector.restype = DWORD

        # NTSYSAPI
        # DWORD
        # NTAPI
        # RtlExtendCorrelationVector(
        # _Inout_ PCORRELATION_VECTOR CorrelationVector
        # );
        RtlExtendCorrelationVector = (
            ntoskrnl.RtlExtendCorrelationVector
        )
        RtlExtendCorrelationVector.restype = DWORD

        # NTSYSAPI
        # DWORD
        # NTAPI
        # RtlValidateCorrelationVector(
        # _In_ PCORRELATION_VECTOR Vector
        # );
        RtlValidateCorrelationVector = (
            ntoskrnl.RtlValidateCorrelationVector
        )
        RtlValidateCorrelationVector.restype = DWORD

    # END IF   NTDDI_VERSION >= NTDDI_RS2

    if NTDDI_VERSION >= NTDDI_WIN10_RS4:
        _CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG._fields_ = [
            # Size of the structure in bytes
            ('Size', DWORD),
            # Guid used to identify background task to trigger
            ('TriggerId', PCWSTR),
        ]

        if not defined(MIDL_PASS):
            ntdll = ctypes.windll.NTDLL
            # FORCEINLINE
            # VOID
            # CUSTOM_SYSTEM_EVENT_TRIGGER_INIT(
            # _Out_    PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG Config,
            # _In_opt_ PCWSTR TriggerId
            # )
            # {
            # RtlZeroMemory(Config, (ctypes.sizeof(CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG));
            # }

        # ENDIF not defined(MIDL_PASS)

        # _Must_inspect_result_
        # _IRQL_requires_max_(PASSIVE_LEVEL)
        # DWORD
        # NTAPI
        # RtlRaiseCustomSystemEventTrigger(
        # _In_ PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG TriggerConfig
        # );
        RtlRaiseCustomSystemEventTrigger = (
            ntoskrnl.RtlRaiseCustomSystemEventTrigger
        )
        RtlRaiseCustomSystemEventTrigger.restype = DWORD

    # END IF   NTDDI_VERSION >= NTDDI_WIN10_RS4

    # Support for process policy settings embedded into executable
    # image.
    IMAGE_POLICY_METADATA_VERSION = 1
    IMAGE_POLICY_SECTION_NAME = ".tPolicy"
    IMAGE_POLICY_METADATA_NAME = __ImagePolicyMetadata


    class _IMAGE_POLICY_ENTRY_TYPE(ENUM):
        ImagePolicyEntryTypeNone = 0
        ImagePolicyEntryTypeBool = 1
        ImagePolicyEntryTypeInt8 = 2
        ImagePolicyEntryTypeUInt8 = 3
        ImagePolicyEntryTypeInt16 = 4
        ImagePolicyEntryTypeUInt16 = 5
        ImagePolicyEntryTypeInt32 = 6
        ImagePolicyEntryTypeUInt32 = 7
        ImagePolicyEntryTypeInt64 = 8
        ImagePolicyEntryTypeUInt64 = 9
        ImagePolicyEntryTypeAnsiString = 10
        ImagePolicyEntryTypeUnicodeString = 11
        ImagePolicyEntryTypeOverride = 12
        ImagePolicyEntryTypeMaximum = 13


    IMAGE_POLICY_ENTRY_TYPE = _IMAGE_POLICY_ENTRY_TYPE


    class _IMAGE_POLICY_ID(ENUM):
        ImagePolicyIdNone = 0
        ImagePolicyIdEtw = 1
        ImagePolicyIdDebug = 2
        ImagePolicyIdCrashDump = 3
        ImagePolicyIdCrashDumpKey = 4
        ImagePolicyIdCrashDumpKeyGuid = 5
        ImagePolicyIdParentSd = 6
        ImagePolicyIdParentSdRev = 7
        ImagePolicyIdSvn = 8
        ImagePolicyIdDeviceId = 9
        ImagePolicyIdCapability = 10
        ImagePolicyIdScenarioId = 11
        ImagePolicyIdMaximum = 12


    IMAGE_POLICY_ID = _IMAGE_POLICY_ID


    class u(ctypes.Union):
        pass


    u._fields_ = [
        ('None', POINTER(VOID)),
        ('BoolValue', BOOLEAN),
        ('Int8Value', INT8),
        ('UInt8Value', UINT8),
        ('Int16Value', INT16),
        ('UInt16Value', UINT16),
        ('Int32Value', INT32),
        ('UInt32Value', UINT32),
        ('Int64Value', INT64),
        ('UInt64Value', UINT64),
        ('AnsiStringValue', PCSTR),
        ('UnicodeStringValue', PCWSTR),
    ]
    _IMAGE_POLICY_ENTRY.u = u

    _IMAGE_POLICY_ENTRY._fields_ = [
        ('Type', IMAGE_POLICY_ENTRY_TYPE),
        ('PolicyId', IMAGE_POLICY_ID),
        ('u', _IMAGE_POLICY_ENTRY.u),
    ]

    PCIMAGE_POLICY_ENTRY = POINTER(IMAGE_POLICY_ENTRY)

    _IMAGE_POLICY_METADATA._fields_ = [
        ('Version', BYTE),
        ('Reserved0', BYTE * 7),
        ('ApplicationId', ULONGLONG),
        ('Policies', IMAGE_POLICY_ENTRY * 0),
    ]

    PCIMAGE_POLICY_METADATA = POINTER(IMAGE_POLICY_METADATA)


    def IMAGE_POLICY_START(_ApplicationId_):
        pass


    def IMAGE_POLICY_END():
        pass


    def IMAGE_POLICY_BOOL(_PolicyId_, _Value_):
        pass


    def IMAGE_POLICY_INT8(_PolicyId_, _Value_):
        pass


    def IMAGE_POLICY_UINT8(_PolicyId_, _Value_):
        pass


    def IMAGE_POLICY_INT16(_PolicyId_, _Value_):
        pass


    def IMAGE_POLICY_UINT16(_PolicyId_, _Value_):
        pass


    def IMAGE_POLICY_INT32(_PolicyId_, _Value_):
        pass


    def IMAGE_POLICY_UINT32(_PolicyId_, _Value_):
        pass


    def IMAGE_POLICY_INT64(_PolicyId_, _Value_):
        pass


    def IMAGE_POLICY_UINT64(_PolicyId_, _Value_):
        pass


    def IMAGE_POLICY_ANSI_STRING(_PolicyId_, _Value_):
        pass


    def IMAGE_POLICY_UNICODE_STRING(_PolicyId_, _Value_):
        pass


    def IMAGE_POLICY_OVERRIDE(_PolicyId_):
        pass


    _RTL_CRITICAL_SECTION_DEBUG._fields_ = [
        ('Type', WORD),
        ('CreatorBackTraceIndex', WORD),
        ('CriticalSection', POINTER(_RTL_CRITICAL_SECTION)),
        ('ProcessLocksList', LIST_ENTRY),
        ('EntryCount', DWORD),
        ('ContentionCount', DWORD),
        ('Flags', DWORD),
        ('CreatorBackTraceIndexHigh', WORD),
        ('SpareWORD', WORD),
    ]

    # These flags define the upper byte of the critical section
    # SpinCount field
    RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO = 0x01000000
    RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN = 0x02000000
    RTL_CRITICAL_SECTION_FLAG_STATIC_INIT = 0x04000000
    RTL_CRITICAL_SECTION_FLAG_RESOURCE_TYPE = 0x08000000
    RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO = 0x10000000
    RTL_CRITICAL_SECTION_ALL_FLAG_BITS = 0xFF000000
    RTL_CRITICAL_SECTION_FLAG_RESERVED = (
        RTL_CRITICAL_SECTION_ALL_FLAG_BITS & (
            ~(
                RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO |
                  RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN |
                  RTL_CRITICAL_SECTION_FLAG_STATIC_INIT |
                  RTL_CRITICAL_SECTION_FLAG_RESOURCE_TYPE |
                  RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO
            )
        )
    )

    # These flags define possible values stored in the Flags field
    # of a critsec debuginfo.
    RTL_CRITICAL_SECTION_DEBUG_FLAG_STATIC_INIT = 0x00000001

    _RTL_CRITICAL_SECTION._fields_ = [
        ('DebugInfo', PRTL_CRITICAL_SECTION_DEBUG),
        # section for the resource
        ('LockCount', LONG),
        ('RecursionCount', LONG),
        # from the thread's ClientId - >UniqueThread
        ('OwningThread', HANDLE),
        ('LockSemaphore', HANDLE),
        # force size on 64 - bit systems when packed
        ('SpinCount', ULONG_PTR),
    ]

    _RTL_SRWLOCK._fields_ = [
        ('Ptr', PVOID),
    ]
    RTL_SRWLOCK_INIT = [0]

    _RTL_CONDITION_VARIABLE._fields_ = [
        ('Ptr', PVOID),
    ]
    RTL_CONDITION_VARIABLE_INIT = [0]
    RTL_CONDITION_VARIABLE_LOCKMODE_SHARED = 0x1

    # VOID
    # (NTAPI *PAPCFUNC)(
    # _In_ ULONG_PTR Parameter
    # );
    PAPCFUNC = NTAPI(VOID, ULONG_PTR)


    # typedef LONG (NTAPI *PVECTORED_EXCEPTION_HANDLER)(
    # struct _EXCEPTION_POINTERS *ExceptionInfo
    # );
    PVECTORED_EXCEPTION_HANDLER = NTAPI(
        LONG,
        POINTER(_EXCEPTION_POINTERS)
    )


    class _HEAP_INFORMATION_CLASS(ENUM):
        HeapCompatibilityInformation = 0
        HeapEnableTerminationOnCorruption = 1


    if (
        NTDDI_VERSION > NTDDI_WINBLUE or
        (NTDDI_VERSION == NTDDI_WINBLUE and defined(WINBLUE_KBSPRING14))
    ):
        HeapOptimizeResources = 3
    # END IF

    HEAP_INFORMATION_CLASS = _HEAP_INFORMATION_CLASS
    if (NTDDI_VERSION > NTDDI_WINBLUE) or (
        NTDDI_VERSION == NTDDI_WINBLUE and defined(WINBLUE_KBSPRING14)):
        HEAP_OPTIMIZE_RESOURCES_CURRENT_VERSION = 1

        _HEAP_OPTIMIZE_RESOURCES_INFORMATION._fields_ = [
            ('Version', DWORD),
            ('Flags', DWORD),
        ]
    # END IF

    WT_EXECUTEDEFAULT = 0x00000000
    WT_EXECUTEINIOTHREAD = 0x00000001
    WT_EXECUTEINUITHREAD = 0x00000002
    WT_EXECUTEINWAITTHREAD = 0x00000004
    WT_EXECUTEONLYONCE = 0x00000008
    WT_EXECUTEINTIMERTHREAD = 0x00000020
    WT_EXECUTELONGFUNCTION = 0x00000010
    WT_EXECUTEINPERSISTENTIOTHREAD = 0x00000040
    WT_EXECUTEINPERSISTENTTHREAD = 0x00000080
    WT_TRANSFER_IMPERSONATION = 0x00000100


    def WT_SET_MAX_THREADPOOL_THREADS(Flags, Limit):
        return Flags | (Limit << 16)

    # typedef VOID (NTAPI * WAITORTIMERCALLBACKFUNC) (PVOID, BOOLEAN );
    WAITORTIMERCALLBACKFUNC = NTAPI(VOID, PVOID, BOOLEAN)

    # typedef VOID (NTAPI * WORKERCALLBACKFUNC) (PVOID );
    WORKERCALLBACKFUNC = NTAPI(VOID, PVOID)

    # typedef VOID (NTAPI * APC_CALLBACK_FUNCTION) (DWORD   , PVOID, PVOID);
    APC_CALLBACK_FUNCTION = NTAPI(VOID, DWORD, PVOID, PVOID)

    # VOID
    # (NTAPI *PFLS_CALLBACK_FUNCTION) (
    # IN PVOID lpFlsData
    # );
    PFLS_CALLBACK_FUNCTION = NTAPI(VOID, PVOID)

    # BOOLEAN
    # (NTAPI *PSECURE_MEMORY_CACHE_CALLBACK) (
    # _In_reads_bytes_(Range) PVOID Addr,
    # _In_ SIZE_T Range
    # );
    PSECURE_MEMORY_CACHE_CALLBACK = NTAPI(BOOLEAN, PVOID, SIZE_T)

    WT_EXECUTEINLONGTHREAD = 0x00000010
    WT_EXECUTEDELETEWAIT = 0x00000008


    class _ACTIVATION_CONTEXT_INFO_CLASS(ENUM):
        ActivationContextBasicInformation = 1
        ActivationContextDetailedInformation = 2
        AssemblyDetailedInformationInActivationContext = 3
        FileInformationInAssemblyOfAssemblyInActivationContext = 4
        RunlevelInformationInActivationContext = 5
        CompatibilityInformationInActivationContext = 6
        ActivationContextManifestResourceName = 7
        MaxActivationContextInfoClass = 8
        AssemblyDetailedInformationInActivationContxt = 3
        FileInformationInAssemblyOfAssemblyInActivationContxt = 4


    ACTIVATION_CONTEXT_INFO_CLASS = _ACTIVATION_CONTEXT_INFO_CLASS
    ACTIVATIONCONTEXTINFOCLASS = ACTIVATION_CONTEXT_INFO_CLASS

    _ACTIVATION_CONTEXT_QUERY_INDEX._fields_ = [
        ('ulAssemblyIndex', DWORD),
        ('ulFileIndexInAssembly', DWORD),
    ]

    PCACTIVATION_CONTEXT_QUERY_INDEX = POINTER(_ACTIVATION_CONTEXT_QUERY_INDEX)

    ACTIVATION_CONTEXT_PATH_TYPE_NONE = 1
    ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE = 2
    ACTIVATION_CONTEXT_PATH_TYPE_URL = 3
    ACTIVATION_CONTEXT_PATH_TYPE_ASSEMBLYREF = 4

    _ASSEMBLY_FILE_DETAILED_INFORMATION._fields_ = [
        ('ulFlags', DWORD),
        ('ulFilenameLength', DWORD),
        ('ulPathLength', DWORD),
        ('lpFileName', PCWSTR),
        ('lpFilePath', PCWSTR),
    ]

    # compatibility with old names
    # The new names use "file" consistently.
    _ASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION = (
        _ASSEMBLY_FILE_DETAILED_INFORMATION
    )
    ASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION = (
        ASSEMBLY_FILE_DETAILED_INFORMATION
    )
    PASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION = (
        PASSEMBLY_FILE_DETAILED_INFORMATION
    )
    PCASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION = (
        PCASSEMBLY_FILE_DETAILED_INFORMATION
    )

    _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION._fields_ = [
        ('ulFlags', DWORD),
        # in bytes
        ('ulEncodedAssemblyIdentityLength', DWORD),
        # ACTIVATION_CONTEXT_PATH_TYPE_*
        ('ulManifestPathType', DWORD),
        # in bytes
        ('ulManifestPathLength', DWORD),
        # FILETIME
        ('liManifestLastWriteTime', LARGE_INTEGER),
        # ACTIVATION_CONTEXT_PATH_TYPE_*
        ('ulPolicyPathType', DWORD),
        # in bytes
        ('ulPolicyPathLength', DWORD),
        # FILETIME
        ('liPolicyLastWriteTime', LARGE_INTEGER),
        ('ulMetadataSatelliteRosterIndex', DWORD),
        # 1
        ('ulManifestVersionMajor', DWORD),
        # 0
        ('ulManifestVersionMinor', DWORD),
        # 0
        ('ulPolicyVersionMajor', DWORD),
        # 0
        ('ulPolicyVersionMinor', DWORD),
        # in bytes
        ('ulAssemblyDirectoryNameLength', DWORD),
        ('lpAssemblyEncodedAssemblyIdentity', PCWSTR),
        ('lpAssemblyManifestPath', PCWSTR),
        ('lpAssemblyPolicyPath', PCWSTR),
        ('lpAssemblyDirectoryName', PCWSTR),
        ('ulFileCount', DWORD),
    ]

    PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION = POINTER(ASSEMBLY_FILE_DETAILED_INFORMATION)


    class ACTCTX_REQUESTED_RUN_LEVEL(ENUM):
        ACTCTX_RUN_LEVEL_UNSPECIFIED = 0
        ACTCTX_RUN_LEVEL_AS_INVOKER = 1
        ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE = 2
        ACTCTX_RUN_LEVEL_REQUIRE_ADMIN = 3
        ACTCTX_RUN_LEVEL_NUMBERS = 4


    ACTCTX_RUN_LEVEL_UNSPECIFIED = ACTCTX_REQUESTED_RUN_LEVEL.ACTCTX_RUN_LEVEL_UNSPECIFIED
    ACTCTX_RUN_LEVEL_AS_INVOKER = ACTCTX_REQUESTED_RUN_LEVEL.ACTCTX_RUN_LEVEL_AS_INVOKER
    ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE = ACTCTX_REQUESTED_RUN_LEVEL.ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE
    ACTCTX_RUN_LEVEL_REQUIRE_ADMIN = ACTCTX_REQUESTED_RUN_LEVEL.ACTCTX_RUN_LEVEL_REQUIRE_ADMIN
    ACTCTX_RUN_LEVEL_NUMBERS = ACTCTX_REQUESTED_RUN_LEVEL.ACTCTX_RUN_LEVEL_NUMBERS

    _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION._fields_ = [
        ('ulFlags', DWORD),
        ('RunLevel', ACTCTX_REQUESTED_RUN_LEVEL),
        ('UiAccess', DWORD),
    ]

    PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = POINTER(_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION)


    class ACTCTX_COMPATIBILITY_ELEMENT_TYPE(ENUM):
        ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0
        ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS = 1
        ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION = 2


    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = ACTCTX_COMPATIBILITY_ELEMENT_TYPE.ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS = ACTCTX_COMPATIBILITY_ELEMENT_TYPE.ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION = ACTCTX_COMPATIBILITY_ELEMENT_TYPE.ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION

    _COMPATIBILITY_CONTEXT_ELEMENT._fields_ = [
        ('Id', GUID),
        ('Type', ACTCTX_COMPATIBILITY_ELEMENT_TYPE),
    ]
    PCCOMPATIBILITY_CONTEXT_ELEMENT = POINTER(_COMPATIBILITY_CONTEXT_ELEMENT)


    if defined(_MSC_EXTENSIONS):
        if _MSC_VER >= 1200:
            pass
        # END IF
        _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION._fields_ = [
            ('ElementCount', DWORD),
            ('Elements', COMPATIBILITY_CONTEXT_ELEMENT * 0),
        ]
        if _MSC_VER >= 1200:
            pass
        # END IF
        PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION = POINTER(_ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION)

    # END IF

    _SUPPORTED_OS_INFO._fields_ = [
        ('MajorVersion', WORD),
        ('MinorVersion', WORD),
    ]

    _ACTIVATION_CONTEXT_DETAILED_INFORMATION._fields_ = [
        ('dwFlags', DWORD),
        ('ulFormatVersion', DWORD),
        ('ulAssemblyCount', DWORD),
        ('ulRootManifestPathType', DWORD),
        ('ulRootManifestPathChars', DWORD),
        ('ulRootConfigurationPathType', DWORD),
        ('ulRootConfigurationPathChars', DWORD),
        ('ulAppDirPathType', DWORD),
        ('ulAppDirPathChars', DWORD),
        ('lpRootManifestPath', PCWSTR),
        ('lpRootConfigurationPath', PCWSTR),
        ('lpAppDirPath', PCWSTR),
    ]
    PCACTIVATION_CONTEXT_DETAILED_INFORMATION = POINTER(
        _ACTIVATION_CONTEXT_DETAILED_INFORMATION
    )

    CREATE_BOUNDARY_DESCRIPTOR_ADD_APPCONTAINER_SID = 0x1

    _HARDWARE_COUNTER_DATA._fields_ = [
        ('Type', HARDWARE_COUNTER_TYPE),
        ('Reserved', DWORD),
        ('Value', DWORD64),
    ]
    PERFORMANCE_DATA_VERSION = 1

    _PERFORMANCE_DATA._fields_ = [
        ('Size', WORD),
        ('Version', BYTE),
        ('HwCountersCount', BYTE),
        ('ContextSwitchCount', DWORD),
        ('WaitReasonBitMap', DWORD64),
        ('CycleTime', DWORD64),
        ('RetryCount', DWORD),
        ('Reserved', DWORD),
        ('HwCounters', HARDWARE_COUNTER_DATA * MAX_HW_COUNTERS),
    ]
    READ_THREAD_PROFILING_FLAG_DISPATCHING = 0x00000001
    READ_THREAD_PROFILING_FLAG_HARDWARE_COUNTERS = 0x00000002

    if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP):
        if NTDDI_VERSION >= NTDDI_WINTHRESHOLD:
            UNIFIEDBUILDREVISION_KEY = (
                "\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion"
            )
            UNIFIEDBUILDREVISION_VALUE = "UBR"
            UNIFIEDBUILDREVISION_MIN = 0x00000000
            DEVICEFAMILYDEVICEFORM_KEY = (
                "\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\OEM"
            )
            DEVICEFAMILYDEVICEFORM_VALUE = "DeviceForm"
            DEVICEFAMILYINFOENUM_UAP = 0x00000000
            DEVICEFAMILYINFOENUM_WINDOWS_8X = 0x00000001
            DEVICEFAMILYINFOENUM_WINDOWS_PHONE_8X = 0x00000002
            DEVICEFAMILYINFOENUM_DESKTOP = 0x00000003
            DEVICEFAMILYINFOENUM_MOBILE = 0x00000004
            DEVICEFAMILYINFOENUM_XBOX = 0x00000005
            DEVICEFAMILYINFOENUM_TEAM = 0x00000006
            DEVICEFAMILYINFOENUM_IOT = 0x00000007
            DEVICEFAMILYINFOENUM_IOT_HEADLESS = 0x00000008
            DEVICEFAMILYINFOENUM_SERVER = 0x00000009
            DEVICEFAMILYINFOENUM_HOLOGRAPHIC = 0x0000000A
            DEVICEFAMILYINFOENUM_XBOXSRA = 0x0000000B
            DEVICEFAMILYINFOENUM_XBOXERA = 0x0000000C
            DEVICEFAMILYINFOENUM_SERVER_NANO = 0x0000000D
            DEVICEFAMILYINFOENUM_8828080 = 0x0000000E
            DEVICEFAMILYINFOENUM_7067329 = 0x0000000F
            DEVICEFAMILYINFOENUM_MAX = 0x0000000F
            DEVICEFAMILYDEVICEFORM_UNKNOWN = 0x00000000
            DEVICEFAMILYDEVICEFORM_PHONE = 0x00000001
            DEVICEFAMILYDEVICEFORM_TABLET = 0x00000002
            DEVICEFAMILYDEVICEFORM_DESKTOP = 0x00000003
            DEVICEFAMILYDEVICEFORM_NOTEBOOK = 0x00000004
            DEVICEFAMILYDEVICEFORM_CONVERTIBLE = 0x00000005
            DEVICEFAMILYDEVICEFORM_DETACHABLE = 0x00000006
            DEVICEFAMILYDEVICEFORM_ALLINONE = 0x00000007
            DEVICEFAMILYDEVICEFORM_STICKPC = 0x00000008
            DEVICEFAMILYDEVICEFORM_PUCK = 0x00000009
            DEVICEFAMILYDEVICEFORM_LARGESCREEN = 0x0000000A
            DEVICEFAMILYDEVICEFORM_HMD = 0x0000000B
            DEVICEFAMILYDEVICEFORM_INDUSTRY_HANDHELD = 0x0000000C
            DEVICEFAMILYDEVICEFORM_INDUSTRY_TABLET = 0x0000000D
            DEVICEFAMILYDEVICEFORM_BANKING = 0x0000000E
            DEVICEFAMILYDEVICEFORM_BUILDING_AUTOMATION = 0x0000000F
            DEVICEFAMILYDEVICEFORM_DIGITAL_SIGNAGE = 0x00000010
            DEVICEFAMILYDEVICEFORM_GAMING = 0x00000011
            DEVICEFAMILYDEVICEFORM_HOME_AUTOMATION = 0x00000012
            DEVICEFAMILYDEVICEFORM_INDUSTRIAL_AUTOMATION = (
                0x00000013
            )
            DEVICEFAMILYDEVICEFORM_KIOSK = 0x00000014
            DEVICEFAMILYDEVICEFORM_MAKER_BOARD = 0x00000015
            DEVICEFAMILYDEVICEFORM_MEDICAL = 0x00000016
            DEVICEFAMILYDEVICEFORM_NETWORKING = 0x00000017
            DEVICEFAMILYDEVICEFORM_POINT_OF_SERVICE = 0x00000018
            DEVICEFAMILYDEVICEFORM_PRINTING = 0x00000019
            DEVICEFAMILYDEVICEFORM_THIN_CLIENT = 0x0000001A
            DEVICEFAMILYDEVICEFORM_TOY = 0x0000001B
            DEVICEFAMILYDEVICEFORM_VENDING = 0x0000001C
            DEVICEFAMILYDEVICEFORM_INDUSTRY_OTHER = 0x0000001D
            DEVICEFAMILYDEVICEFORM_XBOX_ONE = 0x0000001E
            DEVICEFAMILYDEVICEFORM_XBOX_ONE_S = 0x0000001F
            DEVICEFAMILYDEVICEFORM_XBOX_ONE_X = 0x00000020
            DEVICEFAMILYDEVICEFORM_XBOX_ONE_X_DEVKIT = 0x00000021
            DEVICEFAMILYDEVICEFORM_MAX = 0x00000021
        # END IF   (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)
    # END IF   WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
    DLL_PROCESS_ATTACH = 1
    DLL_THREAD_ATTACH = 2
    DLL_THREAD_DETACH = 3
    DLL_PROCESS_DETACH = 0

    # Defines for the READ flags for Eventlogging
    EVENTLOG_SEQUENTIAL_READ = 0x0001
    EVENTLOG_SEEK_READ = 0x0002
    EVENTLOG_FORWARDS_READ = 0x0004
    EVENTLOG_BACKWARDS_READ = 0x0008

    # The types of events that can be logged.
    EVENTLOG_SUCCESS = 0x0000
    EVENTLOG_ERROR_TYPE = 0x0001
    EVENTLOG_WARNING_TYPE = 0x0002
    EVENTLOG_INFORMATION_TYPE = 0x0004
    EVENTLOG_AUDIT_SUCCESS = 0x0008
    EVENTLOG_AUDIT_FAILURE = 0x0010

    # Defines for the WRITE flags used by Auditing for paired
    # events
    # These are not implemented in Product 1
    EVENTLOG_START_PAIRED_EVENT = 0x0001
    EVENTLOG_END_PAIRED_EVENT = 0x0002
    EVENTLOG_END_ALL_PAIRED_EVENTS = 0x0004
    EVENTLOG_PAIRED_EVENT_ACTIVE = 0x0008
    EVENTLOG_PAIRED_EVENT_INACTIVE = 0x0010

    # Structure that defines the header of the Eventlog record.
    # This is the
    # fixed - sized portion before all the variable - length
    # strings, binary
    # data and pad bytes.
    # TimeGenerated is the time it was generated at the client.
    # TimeWritten is the time it was put into the log at the
    # server end.
    _EVENTLOGRECORD._fields_ = [
        # Length of full record
        ('Length', DWORD),
        # Used by the service
        ('Reserved', DWORD),
        # Absolute record number
        ('RecordNumber', DWORD),
        # Seconds since 1 - 1 - 1970
        ('TimeGenerated', DWORD),
        # Seconds since 1 - 1 - 1970
        ('TimeWritten', DWORD),
        ('EventID', DWORD),
        ('EventType', WORD),
        ('NumStrings', WORD),
        ('EventCategory', WORD),
        # For use with paired events (auditing)
        ('ReservedFlags', WORD),
        # For use with paired events (auditing)
        ('ClosingRecordNumber', DWORD),
        # Offset from beginning of record
        ('StringOffset', DWORD),
        ('UserSidLength', DWORD),
        ('UserSidOffset', DWORD),
        ('DataLength', DWORD),
        # Offset from beginning of record
        ('DataOffset', DWORD),
    ]

    # SS: start of changes to support clustering
    # SS: ideally the
    MAXLOGICALLOGNAMESIZE = 256

    if _MSC_VER >= 1200:
        pass
    # END IF

    _EVENTSFORLOGFILE = ctypes.Structure
    EVENTSFORLOGFILE = _EVENTSFORLOGFILE
    PEVENTSFORLOGFILE = POINTER(_EVENTSFORLOGFILE)

    _PACKEDEVENTINFO = ctypes.Structure
    PACKEDEVENTINFO = _PACKEDEVENTINFO
    PPACKEDEVENTINFO = POINTER(_PACKEDEVENTINFO)

    if defined(_MSC_EXTENSIONS):
        _EVENTSFORLOGFILE._fields_ = [
            ('ulSize', DWORD),
            # name of the logical file -
            # security/application/system
            ('szLogicalLogFile', WCHAR * MAXLOGICALLOGNAMESIZE),
            ('ulNumRecords', DWORD),
            ('pEventLogRecords', EVENTLOGRECORD * 0),
        ]

        _PACKEDEVENTINFO._fields_ = [
            # total size of the structure
            ('ulSize', DWORD),
            # number of EventsForLogFile structure that follow
            ('ulNumEventsForLogFile', DWORD),
            # the offsets from the start of this structure to the
            # EVENTSFORLOGFILE structure
            ('ulOffsets', DWORD * 0),
        ]
    # END IF
    if _MSC_VER >= 1200:
        pass
    else:
        pass
    # END IF

    # SS: end of changes to support clustering
    # begin_wdm
    # begin_access
    # Registry Specific Access Rights.
    KEY_QUERY_VALUE = 0x0001
    KEY_SET_VALUE = 0x0002
    KEY_CREATE_SUB_KEY = 0x0004
    KEY_ENUMERATE_SUB_KEYS = 0x0008
    KEY_NOTIFY = 0x0010
    KEY_CREATE_LINK = 0x0020
    KEY_WOW64_32KEY = 0x0200
    KEY_WOW64_64KEY = 0x0100
    KEY_WOW64_RES = 0x0300
    KEY_READ = (
        (STANDARD_RIGHTS_READ |
         KEY_QUERY_VALUE |
         KEY_ENUMERATE_SUB_KEYS |
         KEY_NOTIFY) & (~SYNCHRONIZE)
    )
    KEY_WRITE = (
        (STANDARD_RIGHTS_WRITE |
         KEY_SET_VALUE |
         KEY_CREATE_SUB_KEY) & (~SYNCHRONIZE)
    )
    KEY_EXECUTE = (KEY_READ) & (~SYNCHRONIZE)
    KEY_ALL_ACCESS = (
        (STANDARD_RIGHTS_ALL |
         KEY_QUERY_VALUE |
         KEY_SET_VALUE |
         KEY_CREATE_SUB_KEY |
         KEY_ENUMERATE_SUB_KEYS |
         KEY_NOTIFY |
         KEY_CREATE_LINK) & (~SYNCHRONIZE)
    )

    # end_access
    # Open/Create Options
    REG_OPTION_RESERVED = 0x00000000  # Parameter is reserved
    REG_OPTION_NON_VOLATILE = 0x00000000  # Key is preserved

    # when system is rebooted
    REG_OPTION_VOLATILE = 0x00000001  # Key is not preserved

    # when system is rebooted
    REG_OPTION_CREATE_LINK = 0x00000002  # Created key is a

    # symbolic link
    REG_OPTION_BACKUP_RESTORE = 0x00000004  # open for backup or restore

    # special access rules
    # privilege required
    REG_OPTION_OPEN_LINK = 0x00000008  # Open symbolic link
    REG_OPTION_DONT_VIRTUALIZE = 0x00000010  # Disable Open/Read/Write

    # virtualization for this
    # open and the resulting
    # handle.
    REG_LEGAL_OPTION = (
        REG_OPTION_RESERVED |
        REG_OPTION_NON_VOLATILE |
        REG_OPTION_VOLATILE |
        REG_OPTION_CREATE_LINK |
        REG_OPTION_BACKUP_RESTORE |
        REG_OPTION_OPEN_LINK |
        REG_OPTION_DONT_VIRTUALIZE
    )
    REG_OPEN_LEGAL_OPTION = (
        REG_OPTION_RESERVED |
        REG_OPTION_BACKUP_RESTORE |
        REG_OPTION_OPEN_LINK |
        REG_OPTION_DONT_VIRTUALIZE
    )

    # Key creation/open disposition
    REG_CREATED_NEW_KEY = 0x00000001  # New Registry Key created
    REG_OPENED_EXISTING_KEY = 0x00000002  # Existing Key opened

    # hive format to be used by Reg(Nt)SaveKeyEx
    REG_STANDARD_FORMAT = 1
    REG_LATEST_FORMAT = 2
    REG_NO_COMPRESSION = 4

    # Key restore & hive load flags
    REG_WHOLE_HIVE_VOLATILE = 0x00000001  # Restore whole hive volatile
    REG_REFRESH_HIVE = 0x00000002  # Unwind changes to last flush
    REG_NO_LAZY_FLUSH = 0x00000004  # Never lazy flush this hive

    # Force the restore process even when we have open handles on
    # subkeys
    REG_FORCE_RESTORE = 0x00000008
    REG_APP_HIVE = 0x00000010  # Loads the hive visible to the calling process
    REG_PROCESS_PRIVATE = 0x00000020  # Hive cannot be mounted by any other process while in use
    REG_START_JOURNAL = 0x00000040  # Starts Hive Journal
    REG_HIVE_EXACT_FILE_GROWTH = 0x00000080  # Grow hive file in exact 4k increments
    REG_HIVE_NO_RM = 0x00000100  # No RM is started for this hive (no transactions)
    REG_HIVE_SINGLE_LOG = 0x00000200  # Legacy single logging is used for this hive
    REG_LOAD_HIVE_OPEN_HANDLE = 0x00000800  # Load the hive and return a handle to its root kcb

    # Flush changes to primary hive file size as part of all
    # flushes
    REG_FLUSH_HIVE_FILE_GROWTH = 0x00001000
    REG_OPEN_READ_ONLY = 0x00002000  # Open a hive's files in read - only mode
    REG_IMMUTABLE = 0x00004000  # Load the hive, but don't allow any modification of it

    # Open an app hive's files in read - only mode
    # (if the hive was not previously loaded)
    REG_APP_HIVE_OPEN_READ_ONLY = REG_OPEN_READ_ONLY

    # Unload Flags
    REG_FORCE_UNLOAD = 1
    REG_UNLOAD_LEGAL_FLAGS = REG_FORCE_UNLOAD

    # Notify filter values
    REG_NOTIFY_CHANGE_NAME = 0x00000001  # Create or delete (child)
    REG_NOTIFY_CHANGE_ATTRIBUTES = 0x00000002
    REG_NOTIFY_CHANGE_LAST_SET = 0x00000004  # time stamp
    REG_NOTIFY_CHANGE_SECURITY = 0x00000008
    REG_NOTIFY_THREAD_AGNOSTIC = 0x10000000  # Not associated with a calling thread, can only be used

    # for async user event based notification
    REG_LEGAL_CHANGE_FILTER = (
        REG_NOTIFY_CHANGE_NAME |
        REG_NOTIFY_CHANGE_ATTRIBUTES |
        REG_NOTIFY_CHANGE_LAST_SET |
        REG_NOTIFY_CHANGE_SECURITY |
        REG_NOTIFY_THREAD_AGNOSTIC
    )

    # end_wdm
    # Predefined Value Types.
    REG_NONE = 0
    ul  # No value type
    REG_SZ = 1
    ul  # Unicode nul terminated string
    REG_EXPAND_SZ = 2
    ul  # Unicode nul terminated string

    # (with environment variable references)
    REG_BINARY = 3
    ul  # Free form binary
    REG_DWORD = 4
    ul  # 32 - bit number
    REG_DWORD_LITTLE_ENDIAN = 4
    ul  # 32 - bit number (same as REG_DWORD)
    REG_DWORD_BIG_ENDIAN = 5
    ul  # 32 - bit number
    REG_LINK = 6
    ul  # Symbolic Link (unicode)
    REG_MULTI_SZ = 7
    ul  # Multiple Unicode strings
    REG_RESOURCE_LIST = 8
    ul  # Resource list in the resource map
    REG_FULL_RESOURCE_DESCRIPTOR = 9
    ul  # Resource list in the hardware description
    REG_RESOURCE_REQUIREMENTS_LIST = 10
    ul
    REG_QWORD = 11
    ul  # 64 - bit number
    REG_QWORD_LITTLE_ENDIAN = 11
    ul  # 64 - bit number (same as REG_QWORD)

    # end_wdm
    # begin_wdm
    # Service Types (Bit Mask)
    SERVICE_KERNEL_DRIVER = 0x00000001
    SERVICE_FILE_SYSTEM_DRIVER = 0x00000002
    SERVICE_ADAPTER = 0x00000004
    SERVICE_RECOGNIZER_DRIVER = 0x00000008
    SERVICE_DRIVER = (
        SERVICE_KERNEL_DRIVER |
        SERVICE_FILE_SYSTEM_DRIVER |
        SERVICE_RECOGNIZER_DRIVER
    )
    SERVICE_WIN32_OWN_PROCESS = 0x00000010
    SERVICE_WIN32_SHARE_PROCESS = 0x00000020
    SERVICE_WIN32 = (
        SERVICE_WIN32_OWN_PROCESS |
        SERVICE_WIN32_SHARE_PROCESS
    )
    SERVICE_USER_SERVICE = 0x00000040
    SERVICE_USERSERVICE_INSTANCE = 0x00000080
    SERVICE_USER_SHARE_PROCESS = (
        SERVICE_USER_SERVICE |
        SERVICE_WIN32_SHARE_PROCESS
    )
    SERVICE_USER_OWN_PROCESS = (
        SERVICE_USER_SERVICE |
        SERVICE_WIN32_OWN_PROCESS
    )
    SERVICE_INTERACTIVE_PROCESS = 0x00000100
    SERVICE_PKG_SERVICE = 0x00000200
    SERVICE_TYPE_ALL = (
        SERVICE_WIN32 |
        SERVICE_ADAPTER |
        SERVICE_DRIVER |
        SERVICE_INTERACTIVE_PROCESS |
        SERVICE_USER_SERVICE |
        SERVICE_USERSERVICE_INSTANCE |
        SERVICE_PKG_SERVICE
    )

    # Start Type
    SERVICE_BOOT_START = 0x00000000
    SERVICE_SYSTEM_START = 0x00000001
    SERVICE_AUTO_START = 0x00000002
    SERVICE_DEMAND_START = 0x00000003
    SERVICE_DISABLED = 0x00000004

    # Error control type
    SERVICE_ERROR_IGNORE = 0x00000000
    SERVICE_ERROR_NORMAL = 0x00000001
    SERVICE_ERROR_SEVERE = 0x00000002
    SERVICE_ERROR_CRITICAL = 0x00000003


    # Define the registry driver node enumerations
    class _CM_SERVICE_NODE_TYPE(ENUM):
        DriverType = SERVICE_KERNEL_DRIVER
        FileSystemType = SERVICE_FILE_SYSTEM_DRIVER
        Win32ServiceOwnProcess = SERVICE_WIN32_OWN_PROCESS
        Win32ServiceShareProcess = SERVICE_WIN32_SHARE_PROCESS
        AdapterType = SERVICE_ADAPTER
        RecognizerType = SERVICE_RECOGNIZER_DRIVER


    SERVICE_NODE_TYPE = _CM_SERVICE_NODE_TYPE


    class _CM_SERVICE_LOAD_TYPE(ENUM):
        BootLoad = SERVICE_BOOT_START
        SystemLoad = SERVICE_SYSTEM_START
        AutoLoad = SERVICE_AUTO_START
        DemandLoad = SERVICE_DEMAND_START
        DisableLoad = SERVICE_DISABLED



    SERVICE_LOAD_TYPE = _CM_SERVICE_LOAD_TYPE


    class _CM_ERROR_CONTROL_TYPE(ENUM):
       IgnoreError = SERVICE_ERROR_IGNORE
       NormalError = SERVICE_ERROR_NORMAL
       SevereError = SERVICE_ERROR_SEVERE
       CriticalError = SERVICE_ERROR_CRITICAL


    SERVICE_ERROR_TYPE = _CM_ERROR_CONTROL_TYPE

    # Service node Flags. These flags are used by the OS loader to
    # promote
    # a driver's start type to boot start if the system is booting
    # using
    # the specified mechanism. The flags should be set in the
    # driver's
    # registry configuration.
    # CM_SERVICE_NETWORK_BOOT_LOAD - Specified if a driver should
    # be
    # promoted on network boot.
    # CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD - Specified if a driver
    # should be
    # promoted on booting from a VHD.
    # CM_SERVICE_USB_DISK_BOOT_LOAD - Specified if a driver should
    # be promoted
    # while booting from a USB disk.
    # CM_SERVICE_SD_DISK_BOOT_LOAD - Specified if a driver should
    # be promoted
    # while booting from SD storage.
    # CM_SERVICE_USB3_DISK_BOOT_LOAD - Specified if a driver
    # should be promoted
    # while booting from a disk on a USB3 controller.
    # CM_SERVICE_MEASURED_BOOT_LOAD - Specified if a driver should
    # be promoted
    # while booting with measured boot enabled.
    # CM_SERVICE_VERIFIER_BOOT_LOAD - Specified if a driver should
    # be promoted
    # while booting with verifier boot enabled.
    # CM_SERVICE_WINPE_BOOT_LOAD - Specified if a driver should be
    # promoted
    # on WinPE boot.
    CM_SERVICE_NETWORK_BOOT_LOAD = 0x00000001
    CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD = 0x00000002
    CM_SERVICE_USB_DISK_BOOT_LOAD = 0x00000004
    CM_SERVICE_SD_DISK_BOOT_LOAD = 0x00000008
    CM_SERVICE_USB3_DISK_BOOT_LOAD = 0x00000010
    CM_SERVICE_MEASURED_BOOT_LOAD = 0x00000020
    CM_SERVICE_VERIFIER_BOOT_LOAD = 0x00000040
    CM_SERVICE_WINPE_BOOT_LOAD = 0x00000080

    # Mask defining the legal promotion flag values.
    CM_SERVICE_VALID_PROMOTION_MASK = (
        CM_SERVICE_NETWORK_BOOT_LOAD |
        CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD |
        CM_SERVICE_USB_DISK_BOOT_LOAD |
        CM_SERVICE_SD_DISK_BOOT_LOAD |
        CM_SERVICE_USB3_DISK_BOOT_LOAD |
        CM_SERVICE_MEASURED_BOOT_LOAD |
        CM_SERVICE_VERIFIER_BOOT_LOAD |
        CM_SERVICE_WINPE_BOOT_LOAD
    )

    _NTDDTAPE_WINNT_ = None
    if not defined(_NTDDTAPE_WINNT_):
        _NTDDTAPE_WINNT_ = 1
        # IOCTL_TAPE_ERASE definitions
        TAPE_ERASE_SHORT = 0
        TAPE_ERASE_LONG = 1

        _TAPE_ERASE._fields_ = [
            ('Type', DWORD),
            ('Immediate', BOOLEAN),
        ]

        # IOCTL_TAPE_PREPARE definitions
        TAPE_LOAD = 0
        TAPE_UNLOAD = 1
        TAPE_TENSION = 2
        TAPE_LOCK = 3
        TAPE_UNLOCK = 4
        TAPE_FORMAT = 5

        _TAPE_PREPARE._fields_ = [
            ('Operation', DWORD),
            ('Immediate', BOOLEAN),
        ]

        # IOCTL_TAPE_WRITE_MARKS definitions
        TAPE_SETMARKS = 0
        TAPE_FILEMARKS = 1
        TAPE_SHORT_FILEMARKS = 2
        TAPE_LONG_FILEMARKS = 3

        _TAPE_WRITE_MARKS._fields_ = [
            ('Type', DWORD),
            ('Count', DWORD),
            ('Immediate', BOOLEAN),
        ]

        # IOCTL_TAPE_GET_POSITION definitions
        TAPE_ABSOLUTE_POSITION = 0
        TAPE_LOGICAL_POSITION = 1
        TAPE_PSEUDO_LOGICAL_POSITION = 2

        _TAPE_GET_POSITION._fields_ = [
            ('Type', DWORD),
            ('Partition', DWORD),
            ('Offset', LARGE_INTEGER),
        ]

        # IOCTL_TAPE_SET_POSITION definitions
        TAPE_REWIND = 0
        TAPE_ABSOLUTE_BLOCK = 1
        TAPE_LOGICAL_BLOCK = 2
        TAPE_PSEUDO_LOGICAL_BLOCK = 3
        TAPE_SPACE_END_OF_DATA = 4
        TAPE_SPACE_RELATIVE_BLOCKS = 5
        TAPE_SPACE_FILEMARKS = 6
        TAPE_SPACE_SEQUENTIAL_FMKS = 7
        TAPE_SPACE_SETMARKS = 8
        TAPE_SPACE_SEQUENTIAL_SMKS = 9

        _TAPE_SET_POSITION._fields_ = [
            ('Method', DWORD),
            ('Partition', DWORD),
            ('Offset', LARGE_INTEGER),
            ('Immediate', BOOLEAN),
        ]

        # IOCTL_TAPE_GET_DRIVE_PARAMS definitions
        # Definitions for FeaturesLow parameter
        TAPE_DRIVE_FIXED = 0x00000001
        TAPE_DRIVE_SELECT = 0x00000002
        TAPE_DRIVE_INITIATOR = 0x00000004
        TAPE_DRIVE_ERASE_SHORT = 0x00000010
        TAPE_DRIVE_ERASE_LONG = 0x00000020
        TAPE_DRIVE_ERASE_BOP_ONLY = 0x00000040
        TAPE_DRIVE_ERASE_IMMEDIATE = 0x00000080
        TAPE_DRIVE_TAPE_CAPACITY = 0x00000100
        TAPE_DRIVE_TAPE_REMAINING = 0x00000200
        TAPE_DRIVE_FIXED_BLOCK = 0x00000400
        TAPE_DRIVE_VARIABLE_BLOCK = 0x00000800
        TAPE_DRIVE_WRITE_PROTECT = 0x00001000
        TAPE_DRIVE_EOT_WZ_SIZE = 0x00002000
        TAPE_DRIVE_ECC = 0x00010000
        TAPE_DRIVE_COMPRESSION = 0x00020000
        TAPE_DRIVE_PADDING = 0x00040000
        TAPE_DRIVE_REPORT_SMKS = 0x00080000
        TAPE_DRIVE_GET_ABSOLUTE_BLK = 0x00100000
        TAPE_DRIVE_GET_LOGICAL_BLK = 0x00200000
        TAPE_DRIVE_SET_EOT_WZ_SIZE = 0x00400000
        TAPE_DRIVE_EJECT_MEDIA = 0x01000000
        TAPE_DRIVE_CLEAN_REQUESTS = 0x02000000
        TAPE_DRIVE_SET_CMP_BOP_ONLY = 0x04000000
        TAPE_DRIVE_RESERVED_BIT = 0x80000000  # don't use this bitnot

        # //can't be a low features bitnot
        # //reserved; high features only
        # Definitions for FeaturesHigh parameter
        TAPE_DRIVE_LOAD_UNLOAD = 0x80000001
        TAPE_DRIVE_TENSION = 0x80000002
        TAPE_DRIVE_LOCK_UNLOCK = 0x80000004
        TAPE_DRIVE_REWIND_IMMEDIATE = 0x80000008
        TAPE_DRIVE_SET_BLOCK_SIZE = 0x80000010
        TAPE_DRIVE_LOAD_UNLD_IMMED = 0x80000020
        TAPE_DRIVE_TENSION_IMMED = 0x80000040
        TAPE_DRIVE_LOCK_UNLK_IMMED = 0x80000080
        TAPE_DRIVE_SET_ECC = 0x80000100
        TAPE_DRIVE_SET_COMPRESSION = 0x80000200
        TAPE_DRIVE_SET_PADDING = 0x80000400
        TAPE_DRIVE_SET_REPORT_SMKS = 0x80000800
        TAPE_DRIVE_ABSOLUTE_BLK = 0x80001000
        TAPE_DRIVE_ABS_BLK_IMMED = 0x80002000
        TAPE_DRIVE_LOGICAL_BLK = 0x80004000
        TAPE_DRIVE_LOG_BLK_IMMED = 0x80008000
        TAPE_DRIVE_END_OF_DATA = 0x80010000
        TAPE_DRIVE_RELATIVE_BLKS = 0x80020000
        TAPE_DRIVE_FILEMARKS = 0x80040000
        TAPE_DRIVE_SEQUENTIAL_FMKS = 0x80080000
        TAPE_DRIVE_SETMARKS = 0x80100000
        TAPE_DRIVE_SEQUENTIAL_SMKS = 0x80200000
        TAPE_DRIVE_REVERSE_POSITION = 0x80400000
        TAPE_DRIVE_SPACE_IMMEDIATE = 0x80800000
        TAPE_DRIVE_WRITE_SETMARKS = 0x81000000
        TAPE_DRIVE_WRITE_FILEMARKS = 0x82000000
        TAPE_DRIVE_WRITE_SHORT_FMKS = 0x84000000
        TAPE_DRIVE_WRITE_LONG_FMKS = 0x88000000
        TAPE_DRIVE_WRITE_MARK_IMMED = 0x90000000
        TAPE_DRIVE_FORMAT = 0xA0000000
        TAPE_DRIVE_FORMAT_IMMEDIATE = 0xC0000000
        TAPE_DRIVE_HIGH_FEATURES = 0x80000000  # mask for high features flag

        _TAPE_GET_DRIVE_PARAMETERS._fields_ = [
            ('ECC', BOOLEAN),
            ('Compression', BOOLEAN),
            ('DataPadding', BOOLEAN),
            ('ReportSetmarks', BOOLEAN),
            ('DefaultBlockSize', DWORD),
            ('MaximumBlockSize', DWORD),
            ('MinimumBlockSize', DWORD),
            ('MaximumPartitionCount', DWORD),
            ('FeaturesLow', DWORD),
            ('FeaturesHigh', DWORD),
            ('EOTWarningZoneSize', DWORD),
        ]

        # IOCTL_TAPE_SET_DRIVE_PARAMETERS definitions
        _TAPE_SET_DRIVE_PARAMETERS._fields_ = [
            ('ECC', BOOLEAN),
            ('Compression', BOOLEAN),
            ('DataPadding', BOOLEAN),
            ('ReportSetmarks', BOOLEAN),
            ('EOTWarningZoneSize', DWORD),
        ]

        # IOCTL_TAPE_GET_MEDIA_PARAMETERS definitions
        _TAPE_GET_MEDIA_PARAMETERS._fields_ = [
            ('Capacity', LARGE_INTEGER),
            ('Remaining', LARGE_INTEGER),
            ('BlockSize', DWORD),
            ('PartitionCount', DWORD),
            ('WriteProtected', BOOLEAN),
        ]

        # IOCTL_TAPE_SET_MEDIA_PARAMETERS definitions
        _TAPE_SET_MEDIA_PARAMETERS._fields_ = [
            ('BlockSize', DWORD),
        ]

        # IOCTL_TAPE_CREATE_PARTITION definitions
        TAPE_FIXED_PARTITIONS = 0
        TAPE_SELECT_PARTITIONS = 1
        TAPE_INITIATOR_PARTITIONS = 2

        _TAPE_CREATE_PARTITION._fields_ = [
            ('Method', DWORD),
            ('Count', DWORD),
            ('Size', DWORD),
        ]

        # WMI Methods
        TAPE_QUERY_DRIVE_PARAMETERS = 0
        TAPE_QUERY_MEDIA_CAPACITY = 1
        TAPE_CHECK_FOR_DRIVE_PROBLEM = 2
        TAPE_QUERY_IO_ERROR_DATA = 3
        TAPE_QUERY_DEVICE_ERROR_DATA = 4

        _TAPE_WMI_OPERATIONS._fields_ = [
            ('Method', DWORD),
            ('DataBufferSize', DWORD),
            ('DataBuffer', PVOID),
        ]


        # Type of drive errors
        class _TAPE_DRIVE_PROBLEM_TYPE(ENUM):
            TapeDriveProblemNone = 1
            TapeDriveReadWriteWarning = 2
            TapeDriveReadWriteError = 3
            TapeDriveReadWarning = 4
            TapeDriveWriteWarning = 5
            TapeDriveReadError = 6
            TapeDriveWriteError = 7
            TapeDriveHardwareError = 8
            TapeDriveUnsupportedMedia = 9
            TapeDriveScsiConnectionError = 10
            TapeDriveTimetoClean = 11
            TapeDriveCleanDriveNow = 12
            TapeDriveMediaLifeExpired = 13
            TapeDriveSnappedTape = 14


        TAPE_DRIVE_PROBLEM_TYPE = _TAPE_DRIVE_PROBLEM_TYPE
    # END IF

    _NTTMAPI_ = None
    if not defined(_NTTMAPI_):
        _NTTMAPI_ = 1
        if defined(__cplusplus):
            pass
        # END IF

        from pyWinAPI.shared.ktmtypes_h import *  # NOQA


        if _MSC_VER >= 1200:
            pass
        # END IF
        # Types for Nt level TM calls
        # begin_access
        # KTM Tm object rights
        TRANSACTIONMANAGER_QUERY_INFORMATION = 0x0001
        TRANSACTIONMANAGER_SET_INFORMATION = 0x0002
        TRANSACTIONMANAGER_RECOVER = 0x0004
        TRANSACTIONMANAGER_RENAME = 0x0008
        TRANSACTIONMANAGER_CREATE_RM = 0x0010

        # The following right is intended for DTC's use only; it
        # will be
        # deprecated, and no one else should take a dependency on
        # it.
        TRANSACTIONMANAGER_BIND_TRANSACTION = 0x0020

        # Generic mappings for transaction manager rights.
        TRANSACTIONMANAGER_GENERIC_READ = (
            STANDARD_RIGHTS_READ |
            TRANSACTIONMANAGER_QUERY_INFORMATION
        )
        TRANSACTIONMANAGER_GENERIC_WRITE = (
            STANDARD_RIGHTS_WRITE |
            TRANSACTIONMANAGER_SET_INFORMATION |
            TRANSACTIONMANAGER_RECOVER |
            TRANSACTIONMANAGER_RENAME |
            TRANSACTIONMANAGER_CREATE_RM
        )
        TRANSACTIONMANAGER_GENERIC_EXECUTE = (
            STANDARD_RIGHTS_EXECUTE
        )
        TRANSACTIONMANAGER_ALL_ACCESS = (
            STANDARD_RIGHTS_REQUIRED |
            TRANSACTIONMANAGER_GENERIC_READ |
            TRANSACTIONMANAGER_GENERIC_WRITE |
            TRANSACTIONMANAGER_GENERIC_EXECUTE |
            TRANSACTIONMANAGER_BIND_TRANSACTION
        )

        # KTM transaction object rights.
        TRANSACTION_QUERY_INFORMATION = 0x0001
        TRANSACTION_SET_INFORMATION = 0x0002
        TRANSACTION_ENLIST = 0x0004
        TRANSACTION_COMMIT = 0x0008
        TRANSACTION_ROLLBACK = 0x0010
        TRANSACTION_PROPAGATE = 0x0020
        TRANSACTION_RIGHT_RESERVED1 = 0x0040

        # Generic mappings for transaction rights.
        # Resource managers, when enlisting, should generally use
        # the macro
        # TRANSACTION_RESOURCE_MANAGER_RIGHTS when opening a
        # transaction.
        # It's the same as generic read and write except that it
        # does not allow
        # a commit decision to be made.
        TRANSACTION_GENERIC_READ = (
            STANDARD_RIGHTS_READ |
            TRANSACTION_QUERY_INFORMATION |
            SYNCHRONIZE
        )
        TRANSACTION_GENERIC_WRITE = (
            STANDARD_RIGHTS_WRITE |
            TRANSACTION_SET_INFORMATION |
            TRANSACTION_COMMIT |
            TRANSACTION_ENLIST |
            TRANSACTION_ROLLBACK |
            TRANSACTION_PROPAGATE |
            SYNCHRONIZE
        )
        TRANSACTION_GENERIC_EXECUTE = (
            STANDARD_RIGHTS_EXECUTE |
            TRANSACTION_COMMIT |
            TRANSACTION_ROLLBACK |
            SYNCHRONIZE
        )
        TRANSACTION_ALL_ACCESS = (
            STANDARD_RIGHTS_REQUIRED |
            TRANSACTION_GENERIC_READ |
            TRANSACTION_GENERIC_WRITE |
            TRANSACTION_GENERIC_EXECUTE
        )
        TRANSACTION_RESOURCE_MANAGER_RIGHTS = (
            TRANSACTION_GENERIC_READ |
            STANDARD_RIGHTS_WRITE |
            TRANSACTION_SET_INFORMATION |
            TRANSACTION_ENLIST |
            TRANSACTION_ROLLBACK |
            TRANSACTION_PROPAGATE |
            SYNCHRONIZE
        )

        # KTM resource manager object rights.
        RESOURCEMANAGER_QUERY_INFORMATION = 0x0001
        RESOURCEMANAGER_SET_INFORMATION = 0x0002
        RESOURCEMANAGER_RECOVER = 0x0004
        RESOURCEMANAGER_ENLIST = 0x0008
        RESOURCEMANAGER_GET_NOTIFICATION = 0x0010
        RESOURCEMANAGER_REGISTER_PROTOCOL = 0x0020
        RESOURCEMANAGER_COMPLETE_PROPAGATION = 0x0040

        # Generic mappings for resource manager rights.
        RESOURCEMANAGER_GENERIC_READ = (
            STANDARD_RIGHTS_READ |
            RESOURCEMANAGER_QUERY_INFORMATION |
            SYNCHRONIZE
        )
        RESOURCEMANAGER_GENERIC_WRITE = (
            STANDARD_RIGHTS_WRITE |
            RESOURCEMANAGER_SET_INFORMATION |
            RESOURCEMANAGER_RECOVER |
            RESOURCEMANAGER_ENLIST |
            RESOURCEMANAGER_GET_NOTIFICATION |
            RESOURCEMANAGER_REGISTER_PROTOCOL |
            RESOURCEMANAGER_COMPLETE_PROPAGATION |
            SYNCHRONIZE
        )
        RESOURCEMANAGER_GENERIC_EXECUTE = (
            STANDARD_RIGHTS_EXECUTE |
            RESOURCEMANAGER_RECOVER |
            RESOURCEMANAGER_ENLIST |
            RESOURCEMANAGER_GET_NOTIFICATION |
            RESOURCEMANAGER_COMPLETE_PROPAGATION |
            SYNCHRONIZE
        )
        RESOURCEMANAGER_ALL_ACCESS = (
            STANDARD_RIGHTS_REQUIRED |
            RESOURCEMANAGER_GENERIC_READ |
            RESOURCEMANAGER_GENERIC_WRITE |
            RESOURCEMANAGER_GENERIC_EXECUTE
        )

        # KTM enlistment object rights.
        ENLISTMENT_QUERY_INFORMATION = 0x0001
        ENLISTMENT_SET_INFORMATION = 0x0002
        ENLISTMENT_RECOVER = 0x0004
        ENLISTMENT_SUBORDINATE_RIGHTS = 0x0008
        ENLISTMENT_SUPERIOR_RIGHTS = 0x0010

        # Generic mappings for enlistment rights.
        ENLISTMENT_GENERIC_READ = (
            STANDARD_RIGHTS_READ |
            ENLISTMENT_QUERY_INFORMATION
        )
        ENLISTMENT_GENERIC_WRITE = (
            STANDARD_RIGHTS_WRITE |
            ENLISTMENT_SET_INFORMATION |
            ENLISTMENT_RECOVER |
            ENLISTMENT_SUBORDINATE_RIGHTS |
            ENLISTMENT_SUPERIOR_RIGHTS
        )
        ENLISTMENT_GENERIC_EXECUTE = (
            STANDARD_RIGHTS_EXECUTE |
            ENLISTMENT_RECOVER |
            ENLISTMENT_SUBORDINATE_RIGHTS |
            ENLISTMENT_SUPERIOR_RIGHTS
        )
        ENLISTMENT_ALL_ACCESS = (
            STANDARD_RIGHTS_REQUIRED |
            ENLISTMENT_GENERIC_READ |
            ENLISTMENT_GENERIC_WRITE |
            ENLISTMENT_GENERIC_EXECUTE
        )


        # end_access
        # Transaction outcomes.
        # TODO: warning, must match values in KTRANSACTION_OUTCOME
        # duplicated def
        # in tm.h.
        class _TRANSACTION_OUTCOME(ENUM):
            TransactionOutcomeUndetermined = 1
            TransactionOutcomeCommitted = 2
            TransactionOutcomeAborted = 3


        TRANSACTION_OUTCOME = _TRANSACTION_OUTCOME


        class _TRANSACTION_STATE(ENUM):
            TransactionStateNormal = 1
            TransactionStateIndoubt = 2
            TransactionStateCommittedNotify = 3


        TRANSACTION_STATE = _TRANSACTION_STATE

        _TRANSACTION_BASIC_INFORMATION._fields_ = [
            ('TransactionId', GUID),
            ('State', DWORD),
            ('Outcome', DWORD),
        ]

        _TRANSACTIONMANAGER_BASIC_INFORMATION._fields_ = [
            ('TmIdentity', GUID),
            ('VirtualClock', LARGE_INTEGER),
        ]

        _TRANSACTIONMANAGER_LOG_INFORMATION._fields_ = [
            ('LogIdentity', GUID),
        ]

        _TRANSACTIONMANAGER_LOGPATH_INFORMATION._fields_ = [
            ('LogPathLength', DWORD),
            # Variable size
            ('LogPath', WCHAR * 1),
        ]

        _TRANSACTIONMANAGER_RECOVERY_INFORMATION._fields_ = [
            ('LastRecoveredLsn', ULONGLONG),
        ]

        # end_wdm
        _TRANSACTIONMANAGER_OLDEST_INFORMATION._fields_ = [
            ('OldestTransactionGuid', GUID),
        ]

        # begin_wdm
        _TRANSACTION_PROPERTIES_INFORMATION._fields_ = [
            ('IsolationLevel', DWORD),
            ('IsolationFlags', DWORD),
            ('Timeout', LARGE_INTEGER),
            ('Outcome', DWORD),
            ('DescriptionLength', DWORD),
            # Variable size
            ('Description', WCHAR * 1),
        ]

        # The following info - class is intended for DTC's use
        # only; it will be
        # deprecated, and no one else should take a dependency on
        # it.
        _TRANSACTION_BIND_INFORMATION._fields_ = [
            ('TmHandle', HANDLE),
        ]

        _TRANSACTION_ENLISTMENT_PAIR._fields_ = [
            ('EnlistmentId', GUID),
            ('ResourceManagerId', GUID),
        ]

        _TRANSACTION_ENLISTMENTS_INFORMATION._fields_ = [
            ('NumberOfEnlistments', DWORD),
            # Variable size
            ('EnlistmentPair', TRANSACTION_ENLISTMENT_PAIR * 1),
        ]

        _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION._fields_ = [
            ('SuperiorEnlistmentPair', TRANSACTION_ENLISTMENT_PAIR),
        ]

        _RESOURCEMANAGER_BASIC_INFORMATION._fields_ = [
            ('ResourceManagerId', GUID),
            ('DescriptionLength', DWORD),
            # Variable size
            ('Description', WCHAR * 1),
        ]

        _RESOURCEMANAGER_COMPLETION_INFORMATION._fields_ = [
            ('IoCompletionPortHandle', HANDLE),
            ('CompletionKey', ULONG_PTR),
        ]


        # end_wdm
        # begin_wdm
        class _TRANSACTION_INFORMATION_CLASS(ENUM):
            TransactionBasicInformation = 1
            TransactionPropertiesInformation = 2
            TransactionEnlistmentInformation = 3
            TransactionSuperiorEnlistmentInformation = 4
            TransactionBindInformation = 5
            TransactionDTCPrivateInformation = 6


        TRANSACTION_INFORMATION_CLASS = _TRANSACTION_INFORMATION_CLASS


        # begin_wdm
        class _TRANSACTIONMANAGER_INFORMATION_CLASS(ENUM):
            TransactionManagerBasicInformation = 1
            TransactionManagerLogInformation = 2
            TransactionManagerLogPathInformation = 3
            TransactionManagerRecoveryInformation = 4
            TransactionManagerOnlineProbeInformation = 3
            TransactionManagerOldestTransactionInformation = 5


        TRANSACTIONMANAGER_INFORMATION_CLASS = _TRANSACTIONMANAGER_INFORMATION_CLASS


        # begin_wdm
        class _RESOURCEMANAGER_INFORMATION_CLASS(ENUM):
            ResourceManagerBasicInformation = 1
            ResourceManagerCompletionInformation = 2


        RESOURCEMANAGER_INFORMATION_CLASS = _RESOURCEMANAGER_INFORMATION_CLASS

        _ENLISTMENT_BASIC_INFORMATION._fields_ = [
            ('EnlistmentId', GUID),
            ('TransactionId', GUID),
            ('ResourceManagerId', GUID),
        ]

        _ENLISTMENT_CRM_INFORMATION._fields_ = [
            ('CrmTransactionManagerId', GUID),
            ('CrmResourceManagerId', GUID),
            ('CrmEnlistmentId', GUID),
        ]


        # begin_wdm
        class _ENLISTMENT_INFORMATION_CLASS(ENUM):
            EnlistmentBasicInformation = 1
            EnlistmentRecoveryInformation = 2
            EnlistmentCrmInformation = 3


        ENLISTMENT_INFORMATION_CLASS = _ENLISTMENT_INFORMATION_CLASS

        _TRANSACTION_LIST_INFORMATION._fields_ = [
            ('NumberOfTransactions', DWORD),
            # Var size
            ('TransactionInformation', TRANSACTION_LIST_ENTRY * 1),
        ]


        # Types of objects known to the kernel transaction manager.
        class _KTMOBJECT_TYPE(ENUM):
            KTMOBJECT_TRANSACTION = 1
            KTMOBJECT_TRANSACTION_MANAGER = 2
            KTMOBJECT_RESOURCE_MANAGER = 3
            KTMOBJECT_ENLISTMENT = 4
            KTMOBJECT_INVALID = 5


        KTMOBJECT_TYPE = _KTMOBJECT_TYPE
        PKTMOBJECT_TYPE = POINTER(_KTMOBJECT_TYPE)

        # KTMOBJECT_CURSOR
        # Used by NtEnumerateTransactionObject to enumerate a
        # transaction
        # object namespace
        # (e.g. enlistments in a resource manager).
        _KTMOBJECT_CURSOR._fields_ = [
            # The last GUID enumerated; zero if beginning
            # enumeration.
            ('LastQuery', GUID),
            # A count of GUIDs filled in by this last enumeration.
            ('ObjectIdCount', DWORD),
            # ObjectIdCount GUIDs from the namespace specified.
            ('ObjectIds', GUID * 1),
        ]

        # begin_wdm
        if _MSC_VER >= 1200:
            pass
        # END IF
        if defined(__cplusplus):
            pass
        # END IF
    # END IF   _NTTMAPI_

    TP_CALLBACK_INSTANCE = _TP_CALLBACK_INSTANCE
    PTP_CALLBACK_INSTANCE = POINTER(_TP_CALLBACK_INSTANCE)


    # typedef VOID (NTAPI *PTP_SIMPLE_CALLBACK)(
    # _Inout_     PTP_CALLBACK_INSTANCE Instance,
    # _Inout_opt_ PVOID                 Context
    # );
    PTP_SIMPLE_CALLBACK = NTAPI(VOID, PTP_CALLBACK_INSTANCE, PVOID)

    TP_POOL = _TP_POOL
    PTP_POOL = POINTER(_TP_POOL)


    class _TP_CALLBACK_PRIORITY(ENUM):
        TP_CALLBACK_PRIORITY_HIGH = 1
        TP_CALLBACK_PRIORITY_NORMAL = 2
        TP_CALLBACK_PRIORITY_LOW = 3
        TP_CALLBACK_PRIORITY_INVALID = 4
        TP_CALLBACK_PRIORITY_COUNT = TP_CALLBACK_PRIORITY_INVALID


    TP_CALLBACK_PRIORITY = _TP_CALLBACK_PRIORITY

    _TP_POOL_STACK_INFORMATION._fields_ = [
        ('StackReserve', SIZE_T),
        ('StackCommit', SIZE_T),
    ]

    TP_CLEANUP_GROUP = _TP_CLEANUP_GROUP
    PTP_CLEANUP_GROUP = POINTER(_TP_CLEANUP_GROUP)


    # typedef VOID (NTAPI *PTP_CLEANUP_GROUP_CANCEL_CALLBACK)(
    # _Inout_opt_ PVOID ObjectContext,
    # _Inout_opt_ PVOID CleanupContext
    # );
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK = NTAPI(VOID, PVOID, PVOID)

    # Do not manipulate this structure directlynot Allocate space
    # for it
    # and use the inline interfaces below.
    if _WIN32_WINNT >= _WIN32_WINNT_WIN7:
        class u(ctypes.Union):
            pass


        class s(ctypes.Structure):
            pass


        s._fields_ = [
            ('LongFunction', DWORD, 1),
            ('Persistent', DWORD, 1),
            ('Private', DWORD, 30),
        ]
        u.s = s

        u._fields_ = [
            ('Flags', DWORD),
            ('s', u.s),
        ]
        _TP_CALLBACK_ENVIRON_V3.u = u

        _TP_CALLBACK_ENVIRON_V3._fields_ = [
            ('Version', TP_VERSION),
            ('Pool', PTP_POOL),
            ('CleanupGroup', PTP_CLEANUP_GROUP),
            ('CleanupGroupCancelCallback', PTP_CLEANUP_GROUP_CANCEL_CALLBACK),
            ('RaceDll', PVOID),
            ('ActivationContext', POINTER(_ACTIVATION_CONTEXT)),
            ('FinalizationCallback', PTP_SIMPLE_CALLBACK),
            ('u', _TP_CALLBACK_ENVIRON_V3.u),
            ('CallbackPriority', TP_CALLBACK_PRIORITY),
            ('Size', DWORD),
        ]
        TP_CALLBACK_ENVIRON = TP_CALLBACK_ENVIRON_V3
        PTP_CALLBACK_ENVIRON = POINTER(TP_CALLBACK_ENVIRON_V3)

    else:
        class u(ctypes.Union):
            pass


        class s(ctypes.Structure):
            pass


        s._fields_ = [
            ('LongFunction', DWORD, 1),
            ('Persistent', DWORD, 1),
            ('Private', DWORD, 30),
        ]
        u.s = s

        u._fields_ = [
            ('Flags', DWORD),
            ('s', u.s),
        ]
        _TP_CALLBACK_ENVIRON_V1.u = u

        _TP_CALLBACK_ENVIRON_V1._fields_ = [
            ('Version', TP_VERSION),
            ('Pool', PTP_POOL),
            ('CleanupGroup', PTP_CLEANUP_GROUP),
            ('CleanupGroupCancelCallback', PTP_CLEANUP_GROUP_CANCEL_CALLBACK),
            ('RaceDll', PVOID),
            ('ActivationContext', POINTER(_ACTIVATION_CONTEXT)),
            ('FinalizationCallback', PTP_SIMPLE_CALLBACK),
            ('u', _TP_CALLBACK_ENVIRON_V1.u),
        ]
        TP_CALLBACK_ENVIRON = TP_CALLBACK_ENVIRON_V1
        PTP_CALLBACK_ENVIRON = POINTER(TP_CALLBACK_ENVIRON_V1)
    # END IF

    if not defined(MIDL_PASS):
        if _WIN32_WINNT >= _WIN32_WINNT_WIN7:
            pass
        else:
            pass
        # END IF

        if _WIN32_WINNT >= _WIN32_WINNT_WIN7:
            pass
        # END IF

        # INVALID_ACTIVATION_CONTEXT
        if _WIN32_WINNT >= _WIN32_WINNT_WIN7:
            pass
        # END IF

        # For the current version of the callback environment, no
        # actions
        # need to be taken to tear down an initialized structure.
        # This
        # may change in a future release.
    # END IF   not defined(MIDL_PASS)

    TP_WORK = _TP_WORK
    PTP_WORK = POINTER(_TP_WORK)


    # typedef VOID (NTAPI *PTP_WORK_CALLBACK)(
    # _Inout_     PTP_CALLBACK_INSTANCE Instance,
    # _Inout_opt_ PVOID                 Context,
    # _Inout_     PTP_WORK              Work
    # );
    PTP_WORK_CALLBACK = NTAPI(VOID, PTP_CALLBACK_INSTANCE, PVOID, PTP_WORK)

    TP_TIMER = _TP_TIMER
    PTP_TIMER = POINTER(_TP_TIMER)


    # typedef VOID (NTAPI *PTP_TIMER_CALLBACK)(
    # _Inout_     PTP_CALLBACK_INSTANCE Instance,
    # _Inout_opt_ PVOID                 Context,
    # _Inout_     PTP_TIMER             Timer
    # );
    PTP_TIMER_CALLBACK = NTAPI(VOID, PTP_CALLBACK_INSTANCE, PVOID, PTP_TIMER)

    TP_WAIT_RESULT = DWORD
    TP_WAIT = _TP_WAIT
    PTP_WAIT = POINTER(_TP_WAIT)


    # typedef VOID (NTAPI *PTP_WAIT_CALLBACK)(
    # _Inout_     PTP_CALLBACK_INSTANCE Instance,
    # _Inout_opt_ PVOID                 Context,
    # _Inout_     PTP_WAIT              Wait,
    # _In_        TP_WAIT_RESULT        WaitResult
    # );
    PTP_WAIT_CALLBACK = NTAPI(
        VOID,
        PTP_CALLBACK_INSTANCE,
        PTP_WAIT,
        TY_WAIT_RESULT
    )
    TP_IO = _TP_IO
    PTP_IO = POINTER(_TP_IO)

    if defined(_M_AMD64) and not defined(__midl):
        pass
    # END IF _M_AMD64 && !defined(__midl)

    if defined(_M_ARM) and not defined(__midl) and not defined(_M_CEE_PURE):
        pass

    # END IF _M_ARM && !defined(__midl) && !defined(_M_CEE_PURE)

    if defined(_M_ARM64) and not defined(__midl) and not defined(_M_CEE_PURE):
        pass
    # END IF _M_ARM64 && !defined(__midl) && !defined(_M_CEE_PURE)

    if defined(_M_IX86) and not defined(MIDL_PASS):
        PcTeb = 0x18

        if not defined(_M_CEE_PURE):
            pass
        # END IF !defined(_M_CEE_PURE)

    # END IF defined(_M_IX86) && !defined(MIDL_PASS)

    if (
        _WIN32_WINNT > 0x0500 or
        _WIN32_FUSION >= 0x0100 or
        ISOLATION_AWARE_ENABLED
    ):
        ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION = 1
        ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION = 2
        ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION = 3
        ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION = 4
        ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION = 5
        ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION = 6
        ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION = 7
        ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE = 8
        ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES = 9
        ACTIVATION_CONTEXT_SECTION_APPLICATION_SETTINGS = 10
        ACTIVATION_CONTEXT_SECTION_COMPATIBILITY_INFO = 11

    # END IF

    if defined(__cplusplus):
        pass
    # END IF
    if _MSC_VER >= 1200:
        pass
    else:
        pass
    # END IF
# NED IF _WINNT_
