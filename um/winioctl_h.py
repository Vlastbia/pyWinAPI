import ctypes
from pyWinAPI import *
from pyWinAPI.shared.wtypes_h import *
from pyWinAPI.shared.winapifamily_h import *
from pyWinAPI.shared.sdkddkver_h import *
from pyWinAPI.shared.guiddef_h import *


DEFINE_GUID = None
FAR = None
DEFINE_DEVPROPKEY = None
_WINIOCTL_ = None
_DEVIOCTL_ = None
_NTDDSTOR_H_ = None
SRB_TYPE_SCSI_REQUEST_BLOCK = None
SRB_TYPE_STORAGE_REQUEST_BLOCK = None
STORAGE_ADDRESS_TYPE_BTL8 = None
_MSC_EXTENSIONS = None
_NTDDDISK_H_ = None
_FILESYSTEMFSCTL_ = None
USE_TXF_DEPRECATED_FUNCTIONALITY = None
DEPRECATE_SUPPORTED = None
_VIRTUAL_STORAGE_TYPE_DEFINED = None
WIM_PROVIDER_HASH_SIZE = None
SMB_CCF_APP_INSTANCE_EA_NAME = None
_NETWORK_APP_INSTANCE_EA_DEFINED = None
NETWORK_APP_INSTANCE_CSV_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR = None
_IO_IRP_EXT_TRACK_OFFSET_HEADER_ = None

class _STORAGE_HOTPLUG_INFO(ctypes.Structure):
    pass


STORAGE_HOTPLUG_INFO = _STORAGE_HOTPLUG_INFO
PSTORAGE_HOTPLUG_INFO = POINTER(_STORAGE_HOTPLUG_INFO)


class _STORAGE_DEVICE_NUMBER(ctypes.Structure):
    pass


STORAGE_DEVICE_NUMBER = _STORAGE_DEVICE_NUMBER
PSTORAGE_DEVICE_NUMBER = POINTER(_STORAGE_DEVICE_NUMBER)


class _STORAGE_DEVICE_NUMBERS(ctypes.Structure):
    pass


STORAGE_DEVICE_NUMBERS = _STORAGE_DEVICE_NUMBERS
PSTORAGE_DEVICE_NUMBERS = POINTER(_STORAGE_DEVICE_NUMBERS)


class _STORAGE_DEVICE_NUMBER_EX(ctypes.Structure):
    pass


STORAGE_DEVICE_NUMBER_EX = _STORAGE_DEVICE_NUMBER_EX
PSTORAGE_DEVICE_NUMBER_EX = POINTER(_STORAGE_DEVICE_NUMBER_EX)


class _STORAGE_BUS_RESET_REQUEST(ctypes.Structure):
    pass


STORAGE_BUS_RESET_REQUEST = _STORAGE_BUS_RESET_REQUEST
PSTORAGE_BUS_RESET_REQUEST = POINTER(_STORAGE_BUS_RESET_REQUEST)


class STORAGE_BREAK_RESERVATION_REQUEST(ctypes.Structure):
    pass


PSTORAGE_BREAK_RESERVATION_REQUEST = POINTER(STORAGE_BREAK_RESERVATION_REQUEST)


class _PREVENT_MEDIA_REMOVAL(ctypes.Structure):
    pass


PREVENT_MEDIA_REMOVAL = _PREVENT_MEDIA_REMOVAL
PPREVENT_MEDIA_REMOVAL = POINTER(_PREVENT_MEDIA_REMOVAL)


class _CLASS_MEDIA_CHANGE_CONTEXT(ctypes.Structure):
    pass


CLASS_MEDIA_CHANGE_CONTEXT = _CLASS_MEDIA_CHANGE_CONTEXT
PCLASS_MEDIA_CHANGE_CONTEXT = POINTER(_CLASS_MEDIA_CHANGE_CONTEXT)


class _TAPE_STATISTICS(ctypes.Structure):
    pass


TAPE_STATISTICS = _TAPE_STATISTICS
PTAPE_STATISTICS = POINTER(_TAPE_STATISTICS)


class _TAPE_GET_STATISTICS(ctypes.Structure):
    pass


TAPE_GET_STATISTICS = _TAPE_GET_STATISTICS
PTAPE_GET_STATISTICS = POINTER(_TAPE_GET_STATISTICS)


class _DEVICE_MEDIA_INFO(ctypes.Structure):
    pass


DEVICE_MEDIA_INFO = _DEVICE_MEDIA_INFO
PDEVICE_MEDIA_INFO = POINTER(_DEVICE_MEDIA_INFO)


class _GET_MEDIA_TYPES(ctypes.Structure):
    pass


GET_MEDIA_TYPES = _GET_MEDIA_TYPES
PGET_MEDIA_TYPES = POINTER(_GET_MEDIA_TYPES)


class _STORAGE_PREDICT_FAILURE(ctypes.Structure):
    pass


STORAGE_PREDICT_FAILURE = _STORAGE_PREDICT_FAILURE
PSTORAGE_PREDICT_FAILURE = POINTER(_STORAGE_PREDICT_FAILURE)


class _STORAGE_FAILURE_PREDICTION_CONFIG(ctypes.Structure):
    pass


STORAGE_FAILURE_PREDICTION_CONFIG = _STORAGE_FAILURE_PREDICTION_CONFIG
PSTORAGE_FAILURE_PREDICTION_CONFIG = POINTER(_STORAGE_FAILURE_PREDICTION_CONFIG)


class _STORAGE_PROPERTY_QUERY(ctypes.Structure):
    pass


STORAGE_PROPERTY_QUERY = _STORAGE_PROPERTY_QUERY
PSTORAGE_PROPERTY_QUERY = POINTER(_STORAGE_PROPERTY_QUERY)


class _STORAGE_DESCRIPTOR_HEADER(ctypes.Structure):
    pass


STORAGE_DESCRIPTOR_HEADER = _STORAGE_DESCRIPTOR_HEADER
PSTORAGE_DESCRIPTOR_HEADER = POINTER(_STORAGE_DESCRIPTOR_HEADER)


class _STORAGE_DEVICE_DESCRIPTOR(ctypes.Structure):
    pass


STORAGE_DEVICE_DESCRIPTOR = _STORAGE_DEVICE_DESCRIPTOR
PSTORAGE_DEVICE_DESCRIPTOR = POINTER(_STORAGE_DEVICE_DESCRIPTOR)


class _STORAGE_ADAPTER_DESCRIPTOR(ctypes.Structure):
    pass


STORAGE_ADAPTER_DESCRIPTOR = _STORAGE_ADAPTER_DESCRIPTOR
PSTORAGE_ADAPTER_DESCRIPTOR = POINTER(_STORAGE_ADAPTER_DESCRIPTOR)


class _STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR(ctypes.Structure):
    pass


STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR = _STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR
PSTORAGE_ACCESS_ALIGNMENT_DESCRIPTOR = POINTER(_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR)


class _STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR(ctypes.Structure):
    pass


STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR = _STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR
PSTORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR = POINTER(_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR)


class _STORAGE_MINIPORT_DESCRIPTOR(ctypes.Structure):
    pass


STORAGE_MINIPORT_DESCRIPTOR = _STORAGE_MINIPORT_DESCRIPTOR
PSTORAGE_MINIPORT_DESCRIPTOR = POINTER(_STORAGE_MINIPORT_DESCRIPTOR)


class _STORAGE_IDENTIFIER(ctypes.Structure):
    pass


STORAGE_IDENTIFIER = _STORAGE_IDENTIFIER
PSTORAGE_IDENTIFIER = POINTER(_STORAGE_IDENTIFIER)


class _STORAGE_DEVICE_ID_DESCRIPTOR(ctypes.Structure):
    pass


STORAGE_DEVICE_ID_DESCRIPTOR = _STORAGE_DEVICE_ID_DESCRIPTOR
PSTORAGE_DEVICE_ID_DESCRIPTOR = POINTER(_STORAGE_DEVICE_ID_DESCRIPTOR)


class _DEVICE_SEEK_PENALTY_DESCRIPTOR(ctypes.Structure):
    pass


DEVICE_SEEK_PENALTY_DESCRIPTOR = _DEVICE_SEEK_PENALTY_DESCRIPTOR
PDEVICE_SEEK_PENALTY_DESCRIPTOR = POINTER(_DEVICE_SEEK_PENALTY_DESCRIPTOR)


class _DEVICE_WRITE_AGGREGATION_DESCRIPTOR(ctypes.Structure):
    pass


DEVICE_WRITE_AGGREGATION_DESCRIPTOR = _DEVICE_WRITE_AGGREGATION_DESCRIPTOR
PDEVICE_WRITE_AGGREGATION_DESCRIPTOR = POINTER(_DEVICE_WRITE_AGGREGATION_DESCRIPTOR)


class _DEVICE_TRIM_DESCRIPTOR(ctypes.Structure):
    pass


DEVICE_TRIM_DESCRIPTOR = _DEVICE_TRIM_DESCRIPTOR
PDEVICE_TRIM_DESCRIPTOR = POINTER(_DEVICE_TRIM_DESCRIPTOR)


class _DEVICE_LB_PROVISIONING_DESCRIPTOR(ctypes.Structure):
    pass


DEVICE_LB_PROVISIONING_DESCRIPTOR = _DEVICE_LB_PROVISIONING_DESCRIPTOR
PDEVICE_LB_PROVISIONING_DESCRIPTOR = POINTER(_DEVICE_LB_PROVISIONING_DESCRIPTOR)


class _STORAGE_LB_PROVISIONING_MAP_RESOURCES(ctypes.Structure):
    pass


STORAGE_LB_PROVISIONING_MAP_RESOURCES = _STORAGE_LB_PROVISIONING_MAP_RESOURCES
PSTORAGE_LB_PROVISIONING_MAP_RESOURCES = POINTER(_STORAGE_LB_PROVISIONING_MAP_RESOURCES)


class _DEVICE_POWER_DESCRIPTOR(ctypes.Structure):
    pass


DEVICE_POWER_DESCRIPTOR = _DEVICE_POWER_DESCRIPTOR
PDEVICE_POWER_DESCRIPTOR = POINTER(_DEVICE_POWER_DESCRIPTOR)


class _DEVICE_COPY_OFFLOAD_DESCRIPTOR(ctypes.Structure):
    pass


DEVICE_COPY_OFFLOAD_DESCRIPTOR = _DEVICE_COPY_OFFLOAD_DESCRIPTOR
PDEVICE_COPY_OFFLOAD_DESCRIPTOR = POINTER(_DEVICE_COPY_OFFLOAD_DESCRIPTOR)


class _STORAGE_DEVICE_RESILIENCY_DESCRIPTOR(ctypes.Structure):
    pass


STORAGE_DEVICE_RESILIENCY_DESCRIPTOR = _STORAGE_DEVICE_RESILIENCY_DESCRIPTOR
PSTORAGE_DEVICE_RESILIENCY_DESCRIPTOR = POINTER(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR)


class _STORAGE_RPMB_DESCRIPTOR(ctypes.Structure):
    pass


STORAGE_RPMB_DESCRIPTOR = _STORAGE_RPMB_DESCRIPTOR
PSTORAGE_RPMB_DESCRIPTOR = POINTER(_STORAGE_RPMB_DESCRIPTOR)


class _STORAGE_CRYPTO_CAPABILITY(ctypes.Structure):
    pass


STORAGE_CRYPTO_CAPABILITY = _STORAGE_CRYPTO_CAPABILITY
PSTORAGE_CRYPTO_CAPABILITY = POINTER(_STORAGE_CRYPTO_CAPABILITY)


class _STORAGE_CRYPTO_DESCRIPTOR(ctypes.Structure):
    pass


STORAGE_CRYPTO_DESCRIPTOR = _STORAGE_CRYPTO_DESCRIPTOR
PSTORAGE_CRYPTO_DESCRIPTOR = POINTER(_STORAGE_CRYPTO_DESCRIPTOR)


class _STORAGE_TIER(ctypes.Structure):
    pass


STORAGE_TIER = _STORAGE_TIER
PSTORAGE_TIER = POINTER(_STORAGE_TIER)


class _STORAGE_DEVICE_TIERING_DESCRIPTOR(ctypes.Structure):
    pass


STORAGE_DEVICE_TIERING_DESCRIPTOR = _STORAGE_DEVICE_TIERING_DESCRIPTOR
PSTORAGE_DEVICE_TIERING_DESCRIPTOR = POINTER(_STORAGE_DEVICE_TIERING_DESCRIPTOR)


class _STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR(ctypes.Structure):
    pass


STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR = _STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR
PSTORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR = POINTER(_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR)


class _STORAGE_PROTOCOL_SPECIFIC_DATA(ctypes.Structure):
    pass


STORAGE_PROTOCOL_SPECIFIC_DATA = _STORAGE_PROTOCOL_SPECIFIC_DATA
PSTORAGE_PROTOCOL_SPECIFIC_DATA = POINTER(_STORAGE_PROTOCOL_SPECIFIC_DATA)


class _STORAGE_PROTOCOL_DATA_DESCRIPTOR(ctypes.Structure):
    pass


STORAGE_PROTOCOL_DATA_DESCRIPTOR = _STORAGE_PROTOCOL_DATA_DESCRIPTOR
PSTORAGE_PROTOCOL_DATA_DESCRIPTOR = POINTER(_STORAGE_PROTOCOL_DATA_DESCRIPTOR)


class _STORAGE_TEMPERATURE_INFO(ctypes.Structure):
    pass


STORAGE_TEMPERATURE_INFO = _STORAGE_TEMPERATURE_INFO
PSTORAGE_TEMPERATURE_INFO = POINTER(_STORAGE_TEMPERATURE_INFO)


class _STORAGE_TEMPERATURE_DATA_DESCRIPTOR(ctypes.Structure):
    pass


STORAGE_TEMPERATURE_DATA_DESCRIPTOR = _STORAGE_TEMPERATURE_DATA_DESCRIPTOR
PSTORAGE_TEMPERATURE_DATA_DESCRIPTOR = POINTER(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR)


class _STORAGE_TEMPERATURE_THRESHOLD(ctypes.Structure):
    pass


STORAGE_TEMPERATURE_THRESHOLD = _STORAGE_TEMPERATURE_THRESHOLD
PSTORAGE_TEMPERATURE_THRESHOLD = POINTER(_STORAGE_TEMPERATURE_THRESHOLD)


class _NVME_RESERVED_QUEUE_HEADER(ctypes.Structure):
    pass


NVME_RESERVED_QUEUE_HEADER = _NVME_RESERVED_QUEUE_HEADER
PNVME_RESERVED_QUEUE_HEADER = POINTER(_NVME_RESERVED_QUEUE_HEADER)


class _NVME_RESERVED_SQ_CREATE_REQUEST(ctypes.Structure):
    pass


NVME_RESERVED_SQ_CREATE_REQUEST = _NVME_RESERVED_SQ_CREATE_REQUEST
PNVME_RESERVED_SQ_CREATE_REQUEST = POINTER(_NVME_RESERVED_SQ_CREATE_REQUEST)


class _NVME_RESERVED_CQ_CREATE_REQUEST(ctypes.Structure):
    pass


NVME_RESERVED_CQ_CREATE_REQUEST = _NVME_RESERVED_CQ_CREATE_REQUEST
PNVME_RESERVED_CQ_CREATE_REQUEST = POINTER(_NVME_RESERVED_CQ_CREATE_REQUEST)


class _NVME_RESERVED_QUEUES_CREATE_REQUEST(ctypes.Structure):
    pass


NVME_RESERVED_QUEUES_CREATE_REQUEST = _NVME_RESERVED_QUEUES_CREATE_REQUEST
PNVME_RESERVED_QUEUES_CREATE_REQUEST = POINTER(_NVME_RESERVED_QUEUES_CREATE_REQUEST)


class _NVME_RESERVED_SQ_INFO(ctypes.Structure):
    pass


NVME_RESERVED_SQ_INFO = _NVME_RESERVED_SQ_INFO
PNVME_RESERVED_SQ_INFO = POINTER(_NVME_RESERVED_SQ_INFO)


class _NVME_RESERVED_CQ_INFO(ctypes.Structure):
    pass


NVME_RESERVED_CQ_INFO = _NVME_RESERVED_CQ_INFO
PNVME_RESERVED_CQ_INFO = POINTER(_NVME_RESERVED_CQ_INFO)


class _NVME_RESERVED_QUEUES_CREATE_RESPONSE(ctypes.Structure):
    pass


NVME_RESERVED_QUEUES_CREATE_RESPONSE = _NVME_RESERVED_QUEUES_CREATE_RESPONSE
PNVME_RESERVED_QUEUES_CREATE_RESPONSE = POINTER(_NVME_RESERVED_QUEUES_CREATE_RESPONSE)


class _NVME_RESERVED_QUEUES_DELETE_REQUEST(ctypes.Structure):
    pass


NVME_RESERVED_QUEUES_DELETE_REQUEST = _NVME_RESERVED_QUEUES_DELETE_REQUEST
PNVME_RESERVED_QUEUES_DELETE_REQUEST = POINTER(_NVME_RESERVED_QUEUES_DELETE_REQUEST)


class _NVME_RESERVED_QUEUES_PROPERTIES(ctypes.Structure):
    pass


NVME_RESERVED_QUEUES_PROPERTIES = _NVME_RESERVED_QUEUES_PROPERTIES
PNVME_RESERVED_QUEUES_PROPERTIES = POINTER(_NVME_RESERVED_QUEUES_PROPERTIES)


class _STORAGE_SPEC_VERSION(ctypes.Union):
    pass


STORAGE_SPEC_VERSION = _STORAGE_SPEC_VERSION
PSTORAGE_SPEC_VERSION = POINTER(_STORAGE_SPEC_VERSION)


class _STORAGE_PHYSICAL_DEVICE_DATA(ctypes.Structure):
    pass


STORAGE_PHYSICAL_DEVICE_DATA = _STORAGE_PHYSICAL_DEVICE_DATA
PSTORAGE_PHYSICAL_DEVICE_DATA = POINTER(_STORAGE_PHYSICAL_DEVICE_DATA)


class _STORAGE_PHYSICAL_ADAPTER_DATA(ctypes.Structure):
    pass


STORAGE_PHYSICAL_ADAPTER_DATA = _STORAGE_PHYSICAL_ADAPTER_DATA
PSTORAGE_PHYSICAL_ADAPTER_DATA = POINTER(_STORAGE_PHYSICAL_ADAPTER_DATA)


class _STORAGE_PHYSICAL_NODE_DATA(ctypes.Structure):
    pass


STORAGE_PHYSICAL_NODE_DATA = _STORAGE_PHYSICAL_NODE_DATA
PSTORAGE_PHYSICAL_NODE_DATA = POINTER(_STORAGE_PHYSICAL_NODE_DATA)


class _STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR(ctypes.Structure):
    pass


STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR = _STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR
PSTORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR = POINTER(_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR)


class _STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR(ctypes.Structure):
    pass


STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR = _STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR
PSTORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR = POINTER(_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR)


class _STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR(ctypes.Structure):
    pass


STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR = _STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR
PSTORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR = POINTER(_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR)


class _STORAGE_OPERATIONAL_REASON(ctypes.Structure):
    pass


STORAGE_OPERATIONAL_REASON = _STORAGE_OPERATIONAL_REASON
PSTORAGE_OPERATIONAL_REASON = POINTER(_STORAGE_OPERATIONAL_REASON)


class _STORAGE_DEVICE_MANAGEMENT_STATUS(ctypes.Structure):
    pass


STORAGE_DEVICE_MANAGEMENT_STATUS = _STORAGE_DEVICE_MANAGEMENT_STATUS
PSTORAGE_DEVICE_MANAGEMENT_STATUS = POINTER(_STORAGE_DEVICE_MANAGEMENT_STATUS)


class _STORAGE_ADAPTER_SERIAL_NUMBER(ctypes.Structure):
    pass


STORAGE_ADAPTER_SERIAL_NUMBER = _STORAGE_ADAPTER_SERIAL_NUMBER
PSTORAGE_ADAPTER_SERIAL_NUMBER = POINTER(_STORAGE_ADAPTER_SERIAL_NUMBER)


class _STORAGE_ZONE_GROUP(ctypes.Structure):
    pass


STORAGE_ZONE_GROUP = _STORAGE_ZONE_GROUP
PSTORAGE_ZONE_GROUP = POINTER(_STORAGE_ZONE_GROUP)


class _STORAGE_ZONED_DEVICE_DESCRIPTOR(ctypes.Structure):
    pass


STORAGE_ZONED_DEVICE_DESCRIPTOR = _STORAGE_ZONED_DEVICE_DESCRIPTOR
PSTORAGE_ZONED_DEVICE_DESCRIPTOR = POINTER(_STORAGE_ZONED_DEVICE_DESCRIPTOR)


class _DEVICE_LOCATION(ctypes.Structure):
    pass


DEVICE_LOCATION = _DEVICE_LOCATION
PDEVICE_LOCATION = POINTER(_DEVICE_LOCATION)


class _STORAGE_DEVICE_LOCATION_DESCRIPTOR(ctypes.Structure):
    pass


STORAGE_DEVICE_LOCATION_DESCRIPTOR = _STORAGE_DEVICE_LOCATION_DESCRIPTOR
PSTORAGE_DEVICE_LOCATION_DESCRIPTOR = POINTER(_STORAGE_DEVICE_LOCATION_DESCRIPTOR)


class _STORAGE_DEVICE_NUMA_PROPERTY(ctypes.Structure):
    pass


STORAGE_DEVICE_NUMA_PROPERTY = _STORAGE_DEVICE_NUMA_PROPERTY
PSTORAGE_DEVICE_NUMA_PROPERTY = POINTER(_STORAGE_DEVICE_NUMA_PROPERTY)


class _STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT(ctypes.Structure):
    pass


STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT = _STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT
PSTORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT = POINTER(_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT)


class _DEVICE_DATA_SET_RANGE(ctypes.Structure):
    pass


DEVICE_DATA_SET_RANGE = _DEVICE_DATA_SET_RANGE
PDEVICE_DATA_SET_RANGE = POINTER(_DEVICE_DATA_SET_RANGE)
DEVICE_DSM_RANGE = _DEVICE_DATA_SET_RANGE
PDEVICE_DSM_RANGE = POINTER(_DEVICE_DATA_SET_RANGE)


class _DEVICE_MANAGE_DATA_SET_ATTRIBUTES(ctypes.Structure):
    pass


DEVICE_MANAGE_DATA_SET_ATTRIBUTES = _DEVICE_MANAGE_DATA_SET_ATTRIBUTES
PDEVICE_MANAGE_DATA_SET_ATTRIBUTES = POINTER(_DEVICE_MANAGE_DATA_SET_ATTRIBUTES)
DEVICE_DSM_INPUT = _DEVICE_MANAGE_DATA_SET_ATTRIBUTES
PDEVICE_DSM_INPUT = POINTER(_DEVICE_MANAGE_DATA_SET_ATTRIBUTES)


class _DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT(ctypes.Structure):
    pass


DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT = _DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT
PDEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT = POINTER(_DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT)
DEVICE_DSM_OUTPUT = _DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT
PDEVICE_DSM_OUTPUT = POINTER(_DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT)


class _DEVICE_DSM_DEFINITION(ctypes.Structure):
    pass


DEVICE_DSM_DEFINITION = _DEVICE_DSM_DEFINITION
PDEVICE_DSM_DEFINITION = POINTER(_DEVICE_DSM_DEFINITION)


class _DEVICE_DSM_NOTIFICATION_PARAMETERS(ctypes.Structure):
    pass


DEVICE_DSM_NOTIFICATION_PARAMETERS = _DEVICE_DSM_NOTIFICATION_PARAMETERS
PDEVICE_DSM_NOTIFICATION_PARAMETERS = POINTER(_DEVICE_DSM_NOTIFICATION_PARAMETERS)


class _STORAGE_OFFLOAD_TOKEN(ctypes.Structure):
    pass


STORAGE_OFFLOAD_TOKEN = _STORAGE_OFFLOAD_TOKEN
PSTORAGE_OFFLOAD_TOKEN = POINTER(_STORAGE_OFFLOAD_TOKEN)


class _DEVICE_DSM_OFFLOAD_READ_PARAMETERS(ctypes.Structure):
    pass


DEVICE_DSM_OFFLOAD_READ_PARAMETERS = _DEVICE_DSM_OFFLOAD_READ_PARAMETERS
PDEVICE_DSM_OFFLOAD_READ_PARAMETERS = POINTER(_DEVICE_DSM_OFFLOAD_READ_PARAMETERS)


class _STORAGE_OFFLOAD_READ_OUTPUT(ctypes.Structure):
    pass


STORAGE_OFFLOAD_READ_OUTPUT = _STORAGE_OFFLOAD_READ_OUTPUT
PSTORAGE_OFFLOAD_READ_OUTPUT = POINTER(_STORAGE_OFFLOAD_READ_OUTPUT)


class _DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS(ctypes.Structure):
    pass


DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS = _DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS
PDEVICE_DSM_OFFLOAD_WRITE_PARAMETERS = POINTER(_DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS)


class _STORAGE_OFFLOAD_WRITE_OUTPUT(ctypes.Structure):
    pass


STORAGE_OFFLOAD_WRITE_OUTPUT = _STORAGE_OFFLOAD_WRITE_OUTPUT
PSTORAGE_OFFLOAD_WRITE_OUTPUT = POINTER(_STORAGE_OFFLOAD_WRITE_OUTPUT)


class _DEVICE_DATA_SET_LBP_STATE_PARAMETERS(ctypes.Structure):
    pass


DEVICE_DATA_SET_LBP_STATE_PARAMETERS = _DEVICE_DATA_SET_LBP_STATE_PARAMETERS
PDEVICE_DATA_SET_LBP_STATE_PARAMETERS = POINTER(_DEVICE_DATA_SET_LBP_STATE_PARAMETERS)
DEVICE_DSM_ALLOCATION_PARAMETERS = _DEVICE_DATA_SET_LBP_STATE_PARAMETERS
PDEVICE_DSM_ALLOCATION_PARAMETERS = POINTER(_DEVICE_DATA_SET_LBP_STATE_PARAMETERS)


class _DEVICE_DATA_SET_LB_PROVISIONING_STATE(ctypes.Structure):
    pass


DEVICE_DATA_SET_LB_PROVISIONING_STATE = _DEVICE_DATA_SET_LB_PROVISIONING_STATE
PDEVICE_DATA_SET_LB_PROVISIONING_STATE = POINTER(_DEVICE_DATA_SET_LB_PROVISIONING_STATE)
DEVICE_DSM_ALLOCATION_OUTPUT = _DEVICE_DATA_SET_LB_PROVISIONING_STATE
PDEVICE_DSM_ALLOCATION_OUTPUT = POINTER(_DEVICE_DATA_SET_LB_PROVISIONING_STATE)


class _DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2(ctypes.Structure):
    pass


DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 = _DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2
PDEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 = POINTER(_DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2)
DEVICE_DSM_ALLOCATION_OUTPUT2 = _DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2
PDEVICE_DSM_ALLOCATION_OUTPUT2 = POINTER(_DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2)


class _DEVICE_DATA_SET_REPAIR_PARAMETERS(ctypes.Structure):
    pass


DEVICE_DATA_SET_REPAIR_PARAMETERS = _DEVICE_DATA_SET_REPAIR_PARAMETERS
PDEVICE_DATA_SET_REPAIR_PARAMETERS = POINTER(_DEVICE_DATA_SET_REPAIR_PARAMETERS)
DEVICE_DSM_REPAIR_PARAMETERS = _DEVICE_DATA_SET_REPAIR_PARAMETERS
PDEVICE_DSM_REPAIR_PARAMETERS = POINTER(_DEVICE_DATA_SET_REPAIR_PARAMETERS)


class _DEVICE_DATA_SET_REPAIR_OUTPUT(ctypes.Structure):
    pass


DEVICE_DATA_SET_REPAIR_OUTPUT = _DEVICE_DATA_SET_REPAIR_OUTPUT
PDEVICE_DATA_SET_REPAIR_OUTPUT = POINTER(_DEVICE_DATA_SET_REPAIR_OUTPUT)
DEVICE_DSM_REPAIR_OUTPUT = _DEVICE_DATA_SET_REPAIR_OUTPUT
PDEVICE_DSM_REPAIR_OUTPUT = POINTER(_DEVICE_DATA_SET_REPAIR_OUTPUT)


class _DEVICE_DATA_SET_SCRUB_OUTPUT(ctypes.Structure):
    pass


DEVICE_DATA_SET_SCRUB_OUTPUT = _DEVICE_DATA_SET_SCRUB_OUTPUT
PDEVICE_DATA_SET_SCRUB_OUTPUT = POINTER(_DEVICE_DATA_SET_SCRUB_OUTPUT)
DEVICE_DSM_SCRUB_OUTPUT = _DEVICE_DATA_SET_SCRUB_OUTPUT
PDEVICE_DSM_SCRUB_OUTPUT = POINTER(_DEVICE_DATA_SET_SCRUB_OUTPUT)


class _DEVICE_DATA_SET_SCRUB_EX_OUTPUT(ctypes.Structure):
    pass


DEVICE_DATA_SET_SCRUB_EX_OUTPUT = _DEVICE_DATA_SET_SCRUB_EX_OUTPUT
PDEVICE_DATA_SET_SCRUB_EX_OUTPUT = POINTER(_DEVICE_DATA_SET_SCRUB_EX_OUTPUT)
DEVICE_DSM_SCRUB_OUTPUT2 = _DEVICE_DATA_SET_SCRUB_EX_OUTPUT
PDEVICE_DSM_SCRUB_OUTPUT2 = POINTER(_DEVICE_DATA_SET_SCRUB_EX_OUTPUT)


class _DEVICE_DSM_TIERING_QUERY_INPUT(ctypes.Structure):
    pass


DEVICE_DSM_TIERING_QUERY_INPUT = _DEVICE_DSM_TIERING_QUERY_INPUT
PDEVICE_DSM_TIERING_QUERY_INPUT = POINTER(_DEVICE_DSM_TIERING_QUERY_INPUT)
DEVICE_DSM_TIERING_QUERY_PARAMETERS = _DEVICE_DSM_TIERING_QUERY_INPUT
PDEVICE_DSM_TIERING_QUERY_PARAMETERS = POINTER(_DEVICE_DSM_TIERING_QUERY_INPUT)


class _STORAGE_TIER_REGION(ctypes.Structure):
    pass


STORAGE_TIER_REGION = _STORAGE_TIER_REGION
PSTORAGE_TIER_REGION = POINTER(_STORAGE_TIER_REGION)


class _DEVICE_DSM_TIERING_QUERY_OUTPUT(ctypes.Structure):
    pass


DEVICE_DSM_TIERING_QUERY_OUTPUT = _DEVICE_DSM_TIERING_QUERY_OUTPUT
PDEVICE_DSM_TIERING_QUERY_OUTPUT = POINTER(_DEVICE_DSM_TIERING_QUERY_OUTPUT)


class _DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS(ctypes.Structure):
    pass


DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS = _DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS
PDEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS = POINTER(_DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS)


class _DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT(ctypes.Structure):
    pass


DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT = _DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT
PDEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT = POINTER(_DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT)
DEVICE_DSM_TOPOLOGY_ID_QUERY_OUTPUT = _DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT
PDEVICE_DSM_TOPOLOGY_ID_QUERY_OUTPUT = POINTER(_DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT)


class _DEVICE_STORAGE_ADDRESS_RANGE(ctypes.Structure):
    pass


DEVICE_STORAGE_ADDRESS_RANGE = _DEVICE_STORAGE_ADDRESS_RANGE
PDEVICE_STORAGE_ADDRESS_RANGE = POINTER(_DEVICE_STORAGE_ADDRESS_RANGE)


class _DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT(ctypes.Structure):
    pass


DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT = _DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT
PDEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT = POINTER(_DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT)


class _DEVICE_DSM_REPORT_ZONES_PARAMETERS(ctypes.Structure):
    pass


DEVICE_DSM_REPORT_ZONES_PARAMETERS = _DEVICE_DSM_REPORT_ZONES_PARAMETERS
PDEVICE_DSM_REPORT_ZONES_PARAMETERS = POINTER(_DEVICE_DSM_REPORT_ZONES_PARAMETERS)


class _STORAGE_ZONE_DESCRIPTOR(ctypes.Structure):
    pass


STORAGE_ZONE_DESCRIPTOR = _STORAGE_ZONE_DESCRIPTOR
PSTORAGE_ZONE_DESCRIPTOR = POINTER(_STORAGE_ZONE_DESCRIPTOR)


class _DEVICE_DSM_REPORT_ZONES_DATA(ctypes.Structure):
    pass


DEVICE_DSM_REPORT_ZONES_DATA = _DEVICE_DSM_REPORT_ZONES_DATA
PDEVICE_DSM_REPORT_ZONES_DATA = POINTER(_DEVICE_DSM_REPORT_ZONES_DATA)
DEVICE_DSM_REPORT_ZONES_OUTPUT = _DEVICE_DSM_REPORT_ZONES_DATA
PDEVICE_DSM_REPORT_ZONES_OUTPUT = POINTER(_DEVICE_DSM_REPORT_ZONES_DATA)


class _DEVICE_STORAGE_RANGE_ATTRIBUTES(ctypes.Structure):
    pass


DEVICE_STORAGE_RANGE_ATTRIBUTES = _DEVICE_STORAGE_RANGE_ATTRIBUTES
PDEVICE_STORAGE_RANGE_ATTRIBUTES = POINTER(_DEVICE_STORAGE_RANGE_ATTRIBUTES)


class _DEVICE_DSM_RANGE_ERROR_INFO(ctypes.Structure):
    pass


DEVICE_DSM_RANGE_ERROR_INFO = _DEVICE_DSM_RANGE_ERROR_INFO
PDEVICE_DSM_RANGE_ERROR_INFO = POINTER(_DEVICE_DSM_RANGE_ERROR_INFO)
DEVICE_DSM_RANGE_ERROR_OUTPUT = _DEVICE_DSM_RANGE_ERROR_INFO
PDEVICE_DSM_RANGE_ERROR_OUTPUT = POINTER(_DEVICE_DSM_RANGE_ERROR_INFO)


class _DEVICE_DSM_LOST_QUERY_PARAMETERS(ctypes.Structure):
    pass


DEVICE_DSM_LOST_QUERY_PARAMETERS = _DEVICE_DSM_LOST_QUERY_PARAMETERS
PDEVICE_DSM_LOST_QUERY_PARAMETERS = POINTER(_DEVICE_DSM_LOST_QUERY_PARAMETERS)


class _DEVICE_DSM_LOST_QUERY_OUTPUT(ctypes.Structure):
    pass


DEVICE_DSM_LOST_QUERY_OUTPUT = _DEVICE_DSM_LOST_QUERY_OUTPUT
PDEVICE_DSM_LOST_QUERY_OUTPUT = POINTER(_DEVICE_DSM_LOST_QUERY_OUTPUT)


class _DEVICE_DSM_FREE_SPACE_OUTPUT(ctypes.Structure):
    pass


DEVICE_DSM_FREE_SPACE_OUTPUT = _DEVICE_DSM_FREE_SPACE_OUTPUT
PDEVICE_DSM_FREE_SPACE_OUTPUT = POINTER(_DEVICE_DSM_FREE_SPACE_OUTPUT)


class _STORAGE_GET_BC_PROPERTIES_OUTPUT(ctypes.Structure):
    pass


STORAGE_GET_BC_PROPERTIES_OUTPUT = _STORAGE_GET_BC_PROPERTIES_OUTPUT
PSTORAGE_GET_BC_PROPERTIES_OUTPUT = POINTER(_STORAGE_GET_BC_PROPERTIES_OUTPUT)


class _STORAGE_ALLOCATE_BC_STREAM_INPUT(ctypes.Structure):
    pass


STORAGE_ALLOCATE_BC_STREAM_INPUT = _STORAGE_ALLOCATE_BC_STREAM_INPUT
PSTORAGE_ALLOCATE_BC_STREAM_INPUT = POINTER(_STORAGE_ALLOCATE_BC_STREAM_INPUT)


class _STORAGE_ALLOCATE_BC_STREAM_OUTPUT(ctypes.Structure):
    pass


STORAGE_ALLOCATE_BC_STREAM_OUTPUT = _STORAGE_ALLOCATE_BC_STREAM_OUTPUT
PSTORAGE_ALLOCATE_BC_STREAM_OUTPUT = POINTER(_STORAGE_ALLOCATE_BC_STREAM_OUTPUT)


class _STORAGE_PRIORITY_HINT_SUPPORT(ctypes.Structure):
    pass


STORAGE_PRIORITY_HINT_SUPPORT = _STORAGE_PRIORITY_HINT_SUPPORT
PSTORAGE_PRIORITY_HINT_SUPPORT = POINTER(_STORAGE_PRIORITY_HINT_SUPPORT)


class _STORAGE_DIAGNOSTIC_REQUEST(ctypes.Structure):
    pass


STORAGE_DIAGNOSTIC_REQUEST = _STORAGE_DIAGNOSTIC_REQUEST
PSTORAGE_DIAGNOSTIC_REQUEST = POINTER(_STORAGE_DIAGNOSTIC_REQUEST)


class _STORAGE_DIAGNOSTIC_DATA(ctypes.Structure):
    pass


STORAGE_DIAGNOSTIC_DATA = _STORAGE_DIAGNOSTIC_DATA
PSTORAGE_DIAGNOSTIC_DATA = POINTER(_STORAGE_DIAGNOSTIC_DATA)


class _PHYSICAL_ELEMENT_STATUS_REQUEST(ctypes.Structure):
    pass


PHYSICAL_ELEMENT_STATUS_REQUEST = _PHYSICAL_ELEMENT_STATUS_REQUEST
PPHYSICAL_ELEMENT_STATUS_REQUEST = POINTER(_PHYSICAL_ELEMENT_STATUS_REQUEST)


class _PHYSICAL_ELEMENT_STATUS_DESCRIPTOR(ctypes.Structure):
    pass


PHYSICAL_ELEMENT_STATUS_DESCRIPTOR = _PHYSICAL_ELEMENT_STATUS_DESCRIPTOR
PPHYSICAL_ELEMENT_STATUS_DESCRIPTOR = POINTER(_PHYSICAL_ELEMENT_STATUS_DESCRIPTOR)


class _PHYSICAL_ELEMENT_STATUS(ctypes.Structure):
    pass


PHYSICAL_ELEMENT_STATUS = _PHYSICAL_ELEMENT_STATUS
PPHYSICAL_ELEMENT_STATUS = POINTER(_PHYSICAL_ELEMENT_STATUS)


class _REMOVE_ELEMENT_AND_TRUNCATE_REQUEST(ctypes.Structure):
    pass


REMOVE_ELEMENT_AND_TRUNCATE_REQUEST = _REMOVE_ELEMENT_AND_TRUNCATE_REQUEST
PREMOVE_ELEMENT_AND_TRUNCATE_REQUEST = POINTER(_REMOVE_ELEMENT_AND_TRUNCATE_REQUEST)


class _STORAGE_MEDIA_SERIAL_NUMBER_DATA(ctypes.Structure):
    pass


STORAGE_MEDIA_SERIAL_NUMBER_DATA = _STORAGE_MEDIA_SERIAL_NUMBER_DATA
PSTORAGE_MEDIA_SERIAL_NUMBER_DATA = POINTER(_STORAGE_MEDIA_SERIAL_NUMBER_DATA)


class _STORAGE_READ_CAPACITY(ctypes.Structure):
    pass


STORAGE_READ_CAPACITY = _STORAGE_READ_CAPACITY
PSTORAGE_READ_CAPACITY = POINTER(_STORAGE_READ_CAPACITY)


class _STORAGE_WRITE_CACHE_PROPERTY(ctypes.Structure):
    pass


STORAGE_WRITE_CACHE_PROPERTY = _STORAGE_WRITE_CACHE_PROPERTY
PSTORAGE_WRITE_CACHE_PROPERTY = POINTER(_STORAGE_WRITE_CACHE_PROPERTY)


class _PERSISTENT_RESERVE_COMMAND(ctypes.Structure):
    pass


PERSISTENT_RESERVE_COMMAND = _PERSISTENT_RESERVE_COMMAND
PPERSISTENT_RESERVE_COMMAND = POINTER(_PERSISTENT_RESERVE_COMMAND)


class _DEVICEDUMP_SUBSECTION_POINTER(ctypes.Structure):
    pass


DEVICEDUMP_SUBSECTION_POINTER = _DEVICEDUMP_SUBSECTION_POINTER
PDEVICEDUMP_SUBSECTION_POINTER = POINTER(_DEVICEDUMP_SUBSECTION_POINTER)


class _DEVICEDUMP_STRUCTURE_VERSION(ctypes.Structure):
    pass


DEVICEDUMP_STRUCTURE_VERSION = _DEVICEDUMP_STRUCTURE_VERSION
PDEVICEDUMP_STRUCTURE_VERSION = POINTER(_DEVICEDUMP_STRUCTURE_VERSION)


class _DEVICEDUMP_SECTION_HEADER(ctypes.Structure):
    pass


DEVICEDUMP_SECTION_HEADER = _DEVICEDUMP_SECTION_HEADER
PDEVICEDUMP_SECTION_HEADER = POINTER(_DEVICEDUMP_SECTION_HEADER)


class _GP_LOG_PAGE_DESCRIPTOR(ctypes.Structure):
    pass


GP_LOG_PAGE_DESCRIPTOR = _GP_LOG_PAGE_DESCRIPTOR
PGP_LOG_PAGE_DESCRIPTOR = POINTER(_GP_LOG_PAGE_DESCRIPTOR)


class _DEVICEDUMP_PUBLIC_SUBSECTION(ctypes.Structure):
    pass


DEVICEDUMP_PUBLIC_SUBSECTION = _DEVICEDUMP_PUBLIC_SUBSECTION
PDEVICEDUMP_PUBLIC_SUBSECTION = POINTER(_DEVICEDUMP_PUBLIC_SUBSECTION)


class _DEVICEDUMP_RESTRICTED_SUBSECTION(ctypes.Structure):
    pass


DEVICEDUMP_RESTRICTED_SUBSECTION = _DEVICEDUMP_RESTRICTED_SUBSECTION
PDEVICEDUMP_RESTRICTED_SUBSECTION = POINTER(_DEVICEDUMP_RESTRICTED_SUBSECTION)


class _DEVICEDUMP_PRIVATE_SUBSECTION(ctypes.Structure):
    pass


DEVICEDUMP_PRIVATE_SUBSECTION = _DEVICEDUMP_PRIVATE_SUBSECTION
PDEVICEDUMP_PRIVATE_SUBSECTION = POINTER(_DEVICEDUMP_PRIVATE_SUBSECTION)


class _DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD(ctypes.Structure):
    pass


DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD = _DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD
PDEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD = POINTER(_DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD)


class _STORAGE_IDLE_POWER(ctypes.Structure):
    pass


STORAGE_IDLE_POWER = _STORAGE_IDLE_POWER
PSTORAGE_IDLE_POWER = POINTER(_STORAGE_IDLE_POWER)


class _STORAGE_IDLE_POWERUP_REASON(ctypes.Structure):
    pass


STORAGE_IDLE_POWERUP_REASON = _STORAGE_IDLE_POWERUP_REASON
PSTORAGE_IDLE_POWERUP_REASON = POINTER(_STORAGE_IDLE_POWERUP_REASON)


class _STORAGE_DEVICE_POWER_CAP(ctypes.Structure):
    pass


STORAGE_DEVICE_POWER_CAP = _STORAGE_DEVICE_POWER_CAP
PSTORAGE_DEVICE_POWER_CAP = POINTER(_STORAGE_DEVICE_POWER_CAP)


class _STORAGE_RPMB_DATA_FRAME(ctypes.Structure):
    pass


STORAGE_RPMB_DATA_FRAME = _STORAGE_RPMB_DATA_FRAME
PSTORAGE_RPMB_DATA_FRAME = POINTER(_STORAGE_RPMB_DATA_FRAME)


class _STORAGE_EVENT_NOTIFICATION(ctypes.Structure):
    pass


STORAGE_EVENT_NOTIFICATION = _STORAGE_EVENT_NOTIFICATION
PSTORAGE_EVENT_NOTIFICATION = POINTER(_STORAGE_EVENT_NOTIFICATION)


class _STORAGE_COUNTER(ctypes.Structure):
    pass


STORAGE_COUNTER = _STORAGE_COUNTER
PSTORAGE_COUNTER = POINTER(_STORAGE_COUNTER)


class _STORAGE_COUNTERS(ctypes.Structure):
    pass


STORAGE_COUNTERS = _STORAGE_COUNTERS
PSTORAGE_COUNTERS = POINTER(_STORAGE_COUNTERS)


class _STORAGE_HW_FIRMWARE_INFO_QUERY(ctypes.Structure):
    pass


STORAGE_HW_FIRMWARE_INFO_QUERY = _STORAGE_HW_FIRMWARE_INFO_QUERY
PSTORAGE_HW_FIRMWARE_INFO_QUERY = POINTER(_STORAGE_HW_FIRMWARE_INFO_QUERY)


class _STORAGE_HW_FIRMWARE_SLOT_INFO(ctypes.Structure):
    pass


STORAGE_HW_FIRMWARE_SLOT_INFO = _STORAGE_HW_FIRMWARE_SLOT_INFO
PSTORAGE_HW_FIRMWARE_SLOT_INFO = POINTER(_STORAGE_HW_FIRMWARE_SLOT_INFO)


class _STORAGE_HW_FIRMWARE_INFO(ctypes.Structure):
    pass


STORAGE_HW_FIRMWARE_INFO = _STORAGE_HW_FIRMWARE_INFO
PSTORAGE_HW_FIRMWARE_INFO = POINTER(_STORAGE_HW_FIRMWARE_INFO)


class _STORAGE_HW_FIRMWARE_DOWNLOAD(ctypes.Structure):
    pass


STORAGE_HW_FIRMWARE_DOWNLOAD = _STORAGE_HW_FIRMWARE_DOWNLOAD
PSTORAGE_HW_FIRMWARE_DOWNLOAD = POINTER(_STORAGE_HW_FIRMWARE_DOWNLOAD)


class _STORAGE_HW_FIRMWARE_DOWNLOAD_V2(ctypes.Structure):
    pass


STORAGE_HW_FIRMWARE_DOWNLOAD_V2 = _STORAGE_HW_FIRMWARE_DOWNLOAD_V2
PSTORAGE_HW_FIRMWARE_DOWNLOAD_V2 = POINTER(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2)


class _STORAGE_HW_FIRMWARE_ACTIVATE(ctypes.Structure):
    pass


STORAGE_HW_FIRMWARE_ACTIVATE = _STORAGE_HW_FIRMWARE_ACTIVATE
PSTORAGE_HW_FIRMWARE_ACTIVATE = POINTER(_STORAGE_HW_FIRMWARE_ACTIVATE)


class _STORAGE_PROTOCOL_COMMAND(ctypes.Structure):
    pass


STORAGE_PROTOCOL_COMMAND = _STORAGE_PROTOCOL_COMMAND
PSTORAGE_PROTOCOL_COMMAND = POINTER(_STORAGE_PROTOCOL_COMMAND)


class _STORAGE_ATTRIBUTE_MGMT(ctypes.Structure):
    pass


STORAGE_ATTRIBUTE_MGMT = _STORAGE_ATTRIBUTE_MGMT
PSTORAGE_ATTRIBUTE_MGMT = POINTER(_STORAGE_ATTRIBUTE_MGMT)


class _FORMAT_PARAMETERS(ctypes.Structure):
    pass


FORMAT_PARAMETERS = _FORMAT_PARAMETERS
PFORMAT_PARAMETERS = POINTER(_FORMAT_PARAMETERS)


class _FORMAT_EX_PARAMETERS(ctypes.Structure):
    pass


FORMAT_EX_PARAMETERS = _FORMAT_EX_PARAMETERS
PFORMAT_EX_PARAMETERS = POINTER(_FORMAT_EX_PARAMETERS)


class _DISK_GEOMETRY(ctypes.Structure):
    pass


DISK_GEOMETRY = _DISK_GEOMETRY
PDISK_GEOMETRY = POINTER(_DISK_GEOMETRY)


class _PARTITION_INFORMATION(ctypes.Structure):
    pass


PARTITION_INFORMATION = _PARTITION_INFORMATION
PPARTITION_INFORMATION = POINTER(_PARTITION_INFORMATION)


class _SET_PARTITION_INFORMATION(ctypes.Structure):
    pass


SET_PARTITION_INFORMATION = _SET_PARTITION_INFORMATION
PSET_PARTITION_INFORMATION = POINTER(_SET_PARTITION_INFORMATION)


class _DRIVE_LAYOUT_INFORMATION(ctypes.Structure):
    pass


DRIVE_LAYOUT_INFORMATION = _DRIVE_LAYOUT_INFORMATION
PDRIVE_LAYOUT_INFORMATION = POINTER(_DRIVE_LAYOUT_INFORMATION)


class _VERIFY_INFORMATION(ctypes.Structure):
    pass


VERIFY_INFORMATION = _VERIFY_INFORMATION
PVERIFY_INFORMATION = POINTER(_VERIFY_INFORMATION)


class _REASSIGN_BLOCKS(ctypes.Structure):
    pass


REASSIGN_BLOCKS = _REASSIGN_BLOCKS
PREASSIGN_BLOCKS = POINTER(_REASSIGN_BLOCKS)


class _REASSIGN_BLOCKS_EX(ctypes.Structure):
    pass


REASSIGN_BLOCKS_EX = _REASSIGN_BLOCKS_EX
PREASSIGN_BLOCKS_EX = POINTER(_REASSIGN_BLOCKS_EX)


class _PARTITION_INFORMATION_GPT(ctypes.Structure):
    pass


PARTITION_INFORMATION_GPT = _PARTITION_INFORMATION_GPT
PPARTITION_INFORMATION_GPT = POINTER(_PARTITION_INFORMATION_GPT)


class _PARTITION_INFORMATION_MBR(ctypes.Structure):
    pass


PARTITION_INFORMATION_MBR = _PARTITION_INFORMATION_MBR
PPARTITION_INFORMATION_MBR = POINTER(_PARTITION_INFORMATION_MBR)


class _SET_PARTITION_INFORMATION_EX(ctypes.Structure):
    pass


SET_PARTITION_INFORMATION_EX = _SET_PARTITION_INFORMATION_EX
PSET_PARTITION_INFORMATION_EX = POINTER(_SET_PARTITION_INFORMATION_EX)


class _CREATE_DISK_GPT(ctypes.Structure):
    pass


CREATE_DISK_GPT = _CREATE_DISK_GPT
PCREATE_DISK_GPT = POINTER(_CREATE_DISK_GPT)


class _CREATE_DISK_MBR(ctypes.Structure):
    pass


CREATE_DISK_MBR = _CREATE_DISK_MBR
PCREATE_DISK_MBR = POINTER(_CREATE_DISK_MBR)


class _CREATE_DISK(ctypes.Structure):
    pass


CREATE_DISK = _CREATE_DISK
PCREATE_DISK = POINTER(_CREATE_DISK)


class _GET_LENGTH_INFORMATION(ctypes.Structure):
    pass


GET_LENGTH_INFORMATION = _GET_LENGTH_INFORMATION
PGET_LENGTH_INFORMATION = POINTER(_GET_LENGTH_INFORMATION)


class _PARTITION_INFORMATION_EX(ctypes.Structure):
    pass


PARTITION_INFORMATION_EX = _PARTITION_INFORMATION_EX
PPARTITION_INFORMATION_EX = POINTER(_PARTITION_INFORMATION_EX)


class _DRIVE_LAYOUT_INFORMATION_GPT(ctypes.Structure):
    pass


DRIVE_LAYOUT_INFORMATION_GPT = _DRIVE_LAYOUT_INFORMATION_GPT
PDRIVE_LAYOUT_INFORMATION_GPT = POINTER(_DRIVE_LAYOUT_INFORMATION_GPT)


class _DRIVE_LAYOUT_INFORMATION_MBR(ctypes.Structure):
    pass


DRIVE_LAYOUT_INFORMATION_MBR = _DRIVE_LAYOUT_INFORMATION_MBR
PDRIVE_LAYOUT_INFORMATION_MBR = POINTER(_DRIVE_LAYOUT_INFORMATION_MBR)


class _DRIVE_LAYOUT_INFORMATION_EX(ctypes.Structure):
    pass


DRIVE_LAYOUT_INFORMATION_EX = _DRIVE_LAYOUT_INFORMATION_EX
PDRIVE_LAYOUT_INFORMATION_EX = POINTER(_DRIVE_LAYOUT_INFORMATION_EX)


class _DISK_INT13_INFO(ctypes.Structure):
    pass


DISK_INT13_INFO = _DISK_INT13_INFO
PDISK_INT13_INFO = POINTER(_DISK_INT13_INFO)


class _DISK_EX_INT13_INFO(ctypes.Structure):
    pass


DISK_EX_INT13_INFO = _DISK_EX_INT13_INFO
PDISK_EX_INT13_INFO = POINTER(_DISK_EX_INT13_INFO)


class _DISK_DETECTION_INFO(ctypes.Structure):
    pass


DISK_DETECTION_INFO = _DISK_DETECTION_INFO
PDISK_DETECTION_INFO = POINTER(_DISK_DETECTION_INFO)


class _DISK_PARTITION_INFO(ctypes.Structure):
    pass


DISK_PARTITION_INFO = _DISK_PARTITION_INFO
PDISK_PARTITION_INFO = POINTER(_DISK_PARTITION_INFO)


class _DISK_GEOMETRY_EX(ctypes.Structure):
    pass


DISK_GEOMETRY_EX = _DISK_GEOMETRY_EX
PDISK_GEOMETRY_EX = POINTER(_DISK_GEOMETRY_EX)


class _DISK_CONTROLLER_NUMBER(ctypes.Structure):
    pass


DISK_CONTROLLER_NUMBER = _DISK_CONTROLLER_NUMBER
PDISK_CONTROLLER_NUMBER = POINTER(_DISK_CONTROLLER_NUMBER)


class _DISK_CACHE_INFORMATION(ctypes.Structure):
    pass


DISK_CACHE_INFORMATION = _DISK_CACHE_INFORMATION
PDISK_CACHE_INFORMATION = POINTER(_DISK_CACHE_INFORMATION)


class _DISK_GROW_PARTITION(ctypes.Structure):
    pass


DISK_GROW_PARTITION = _DISK_GROW_PARTITION
PDISK_GROW_PARTITION = POINTER(_DISK_GROW_PARTITION)


class _HISTOGRAM_BUCKET(ctypes.Structure):
    pass


HISTOGRAM_BUCKET = _HISTOGRAM_BUCKET
PHISTOGRAM_BUCKET = POINTER(_HISTOGRAM_BUCKET)


class _DISK_HISTOGRAM(ctypes.Structure):
    pass


DISK_HISTOGRAM = _DISK_HISTOGRAM
PDISK_HISTOGRAM = POINTER(_DISK_HISTOGRAM)


class _DISK_PERFORMANCE(ctypes.Structure):
    pass


DISK_PERFORMANCE = _DISK_PERFORMANCE
PDISK_PERFORMANCE = POINTER(_DISK_PERFORMANCE)


class _DISK_RECORD(ctypes.Structure):
    pass


DISK_RECORD = _DISK_RECORD
PDISK_RECORD = POINTER(_DISK_RECORD)


class _DISK_LOGGING(ctypes.Structure):
    pass


DISK_LOGGING = _DISK_LOGGING
PDISK_LOGGING = POINTER(_DISK_LOGGING)


class _BIN_RANGE(ctypes.Structure):
    pass


BIN_RANGE = _BIN_RANGE
PBIN_RANGE = POINTER(_BIN_RANGE)


class _PERF_BIN(ctypes.Structure):
    pass


PERF_BIN = _PERF_BIN
PPERF_BIN = POINTER(_PERF_BIN)


class _BIN_COUNT(ctypes.Structure):
    pass


BIN_COUNT = _BIN_COUNT
PBIN_COUNT = POINTER(_BIN_COUNT)


class _BIN_RESULTS(ctypes.Structure):
    pass


BIN_RESULTS = _BIN_RESULTS
PBIN_RESULTS = POINTER(_BIN_RESULTS)


class _GETVERSIONINPARAMS(ctypes.Structure):
    pass


GETVERSIONINPARAMS = _GETVERSIONINPARAMS
PGETVERSIONINPARAMS = POINTER(_GETVERSIONINPARAMS)
LPGETVERSIONINPARAMS = POINTER(_GETVERSIONINPARAMS)


class _IDEREGS(ctypes.Structure):
    pass


IDEREGS = _IDEREGS
PIDEREGS = POINTER(_IDEREGS)
LPIDEREGS = POINTER(_IDEREGS)


class _SENDCMDINPARAMS(ctypes.Structure):
    pass


SENDCMDINPARAMS = _SENDCMDINPARAMS
PSENDCMDINPARAMS = POINTER(_SENDCMDINPARAMS)
LPSENDCMDINPARAMS = POINTER(_SENDCMDINPARAMS)


class _DRIVERSTATUS(ctypes.Structure):
    pass


DRIVERSTATUS = _DRIVERSTATUS
PDRIVERSTATUS = POINTER(_DRIVERSTATUS)
LPDRIVERSTATUS = POINTER(_DRIVERSTATUS)


class _SENDCMDOUTPARAMS(ctypes.Structure):
    pass


SENDCMDOUTPARAMS = _SENDCMDOUTPARAMS
PSENDCMDOUTPARAMS = POINTER(_SENDCMDOUTPARAMS)
LPSENDCMDOUTPARAMS = POINTER(_SENDCMDOUTPARAMS)


class _GET_DISK_ATTRIBUTES(ctypes.Structure):
    pass


GET_DISK_ATTRIBUTES = _GET_DISK_ATTRIBUTES
PGET_DISK_ATTRIBUTES = POINTER(_GET_DISK_ATTRIBUTES)


class _SET_DISK_ATTRIBUTES(ctypes.Structure):
    pass


SET_DISK_ATTRIBUTES = _SET_DISK_ATTRIBUTES
PSET_DISK_ATTRIBUTES = POINTER(_SET_DISK_ATTRIBUTES)


class _CHANGER_ELEMENT(ctypes.Structure):
    pass


CHANGER_ELEMENT = _CHANGER_ELEMENT
PCHANGER_ELEMENT = POINTER(_CHANGER_ELEMENT)


class _CHANGER_ELEMENT_LIST(ctypes.Structure):
    pass


CHANGER_ELEMENT_LIST = _CHANGER_ELEMENT_LIST
PCHANGER_ELEMENT_LIST = POINTER(_CHANGER_ELEMENT_LIST)


class _GET_CHANGER_PARAMETERS(ctypes.Structure):
    pass


GET_CHANGER_PARAMETERS = _GET_CHANGER_PARAMETERS
PGET_CHANGER_PARAMETERS = POINTER(_GET_CHANGER_PARAMETERS)


class _CHANGER_PRODUCT_DATA(ctypes.Structure):
    pass


CHANGER_PRODUCT_DATA = _CHANGER_PRODUCT_DATA
PCHANGER_PRODUCT_DATA = POINTER(_CHANGER_PRODUCT_DATA)


class _CHANGER_SET_ACCESS(ctypes.Structure):
    pass


CHANGER_SET_ACCESS = _CHANGER_SET_ACCESS
PCHANGER_SET_ACCESS = POINTER(_CHANGER_SET_ACCESS)


class _CHANGER_READ_ELEMENT_STATUS(ctypes.Structure):
    pass


CHANGER_READ_ELEMENT_STATUS = _CHANGER_READ_ELEMENT_STATUS
PCHANGER_READ_ELEMENT_STATUS = POINTER(_CHANGER_READ_ELEMENT_STATUS)


class _CHANGER_ELEMENT_STATUS(ctypes.Structure):
    pass


CHANGER_ELEMENT_STATUS = _CHANGER_ELEMENT_STATUS
PCHANGER_ELEMENT_STATUS = POINTER(_CHANGER_ELEMENT_STATUS)


class _CHANGER_ELEMENT_STATUS_EX(ctypes.Structure):
    pass


CHANGER_ELEMENT_STATUS_EX = _CHANGER_ELEMENT_STATUS_EX
PCHANGER_ELEMENT_STATUS_EX = POINTER(_CHANGER_ELEMENT_STATUS_EX)


class _CHANGER_INITIALIZE_ELEMENT_STATUS(ctypes.Structure):
    pass


CHANGER_INITIALIZE_ELEMENT_STATUS = _CHANGER_INITIALIZE_ELEMENT_STATUS
PCHANGER_INITIALIZE_ELEMENT_STATUS = POINTER(_CHANGER_INITIALIZE_ELEMENT_STATUS)


class _CHANGER_SET_POSITION(ctypes.Structure):
    pass


CHANGER_SET_POSITION = _CHANGER_SET_POSITION
PCHANGER_SET_POSITION = POINTER(_CHANGER_SET_POSITION)


class _CHANGER_EXCHANGE_MEDIUM(ctypes.Structure):
    pass


CHANGER_EXCHANGE_MEDIUM = _CHANGER_EXCHANGE_MEDIUM
PCHANGER_EXCHANGE_MEDIUM = POINTER(_CHANGER_EXCHANGE_MEDIUM)


class _CHANGER_MOVE_MEDIUM(ctypes.Structure):
    pass


CHANGER_MOVE_MEDIUM = _CHANGER_MOVE_MEDIUM
PCHANGER_MOVE_MEDIUM = POINTER(_CHANGER_MOVE_MEDIUM)


class _CHANGER_SEND_VOLUME_TAG_INFORMATION(ctypes.Structure):
    pass


CHANGER_SEND_VOLUME_TAG_INFORMATION = _CHANGER_SEND_VOLUME_TAG_INFORMATION
PCHANGER_SEND_VOLUME_TAG_INFORMATION = POINTER(_CHANGER_SEND_VOLUME_TAG_INFORMATION)


class _READ_ELEMENT_ADDRESS_INFO(ctypes.Structure):
    pass


READ_ELEMENT_ADDRESS_INFO = _READ_ELEMENT_ADDRESS_INFO
PREAD_ELEMENT_ADDRESS_INFO = POINTER(_READ_ELEMENT_ADDRESS_INFO)


class _PATHNAME_BUFFER(ctypes.Structure):
    pass


PATHNAME_BUFFER = _PATHNAME_BUFFER
PPATHNAME_BUFFER = POINTER(_PATHNAME_BUFFER)


class _FSCTL_QUERY_FAT_BPB_BUFFER(ctypes.Structure):
    pass


FSCTL_QUERY_FAT_BPB_BUFFER = _FSCTL_QUERY_FAT_BPB_BUFFER
PFSCTL_QUERY_FAT_BPB_BUFFER = POINTER(_FSCTL_QUERY_FAT_BPB_BUFFER)


class NTFS_VOLUME_DATA_BUFFER(ctypes.Structure):
    pass


PNTFS_VOLUME_DATA_BUFFER = POINTER(NTFS_VOLUME_DATA_BUFFER)


class NTFS_EXTENDED_VOLUME_DATA(ctypes.Structure):
    pass


PNTFS_EXTENDED_VOLUME_DATA = POINTER(NTFS_EXTENDED_VOLUME_DATA)


class REFS_VOLUME_DATA_BUFFER(ctypes.Structure):
    pass


PREFS_VOLUME_DATA_BUFFER = POINTER(REFS_VOLUME_DATA_BUFFER)


class STARTING_LCN_INPUT_BUFFER(ctypes.Structure):
    pass


PSTARTING_LCN_INPUT_BUFFER = POINTER(STARTING_LCN_INPUT_BUFFER)


class STARTING_LCN_INPUT_BUFFER_EX(ctypes.Structure):
    pass


PSTARTING_LCN_INPUT_BUFFER_EX = POINTER(STARTING_LCN_INPUT_BUFFER_EX)


class VOLUME_BITMAP_BUFFER(ctypes.Structure):
    pass


PVOLUME_BITMAP_BUFFER = POINTER(VOLUME_BITMAP_BUFFER)


class STARTING_VCN_INPUT_BUFFER(ctypes.Structure):
    pass


PSTARTING_VCN_INPUT_BUFFER = POINTER(STARTING_VCN_INPUT_BUFFER)


class RETRIEVAL_POINTERS_BUFFER(ctypes.Structure):
    pass


PRETRIEVAL_POINTERS_BUFFER = POINTER(RETRIEVAL_POINTERS_BUFFER)


class RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER(ctypes.Structure):
    pass


PRETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER = POINTER(RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER)


class NTFS_FILE_RECORD_INPUT_BUFFER(ctypes.Structure):
    pass


PNTFS_FILE_RECORD_INPUT_BUFFER = POINTER(NTFS_FILE_RECORD_INPUT_BUFFER)


class NTFS_FILE_RECORD_OUTPUT_BUFFER(ctypes.Structure):
    pass


PNTFS_FILE_RECORD_OUTPUT_BUFFER = POINTER(NTFS_FILE_RECORD_OUTPUT_BUFFER)


class MOVE_FILE_DATA(ctypes.Structure):
    pass


PMOVE_FILE_DATA = POINTER(MOVE_FILE_DATA)


class MOVE_FILE_RECORD_DATA(ctypes.Structure):
    pass


PMOVE_FILE_RECORD_DATA = POINTER(MOVE_FILE_RECORD_DATA)


class _MOVE_FILE_DATA32(ctypes.Structure):
    pass


MOVE_FILE_DATA32 = _MOVE_FILE_DATA32
PMOVE_FILE_DATA32 = POINTER(_MOVE_FILE_DATA32)


class FIND_BY_SID_DATA(ctypes.Structure):
    pass


PFIND_BY_SID_DATA = POINTER(FIND_BY_SID_DATA)


class FIND_BY_SID_OUTPUT(ctypes.Structure):
    pass


PFIND_BY_SID_OUTPUT = POINTER(FIND_BY_SID_OUTPUT)


class MFT_ENUM_DATA_V0(ctypes.Structure):
    pass


PMFT_ENUM_DATA_V0 = POINTER(MFT_ENUM_DATA_V0)


class MFT_ENUM_DATA_V1(ctypes.Structure):
    pass


PMFT_ENUM_DATA_V1 = POINTER(MFT_ENUM_DATA_V1)


class CREATE_USN_JOURNAL_DATA(ctypes.Structure):
    pass


PCREATE_USN_JOURNAL_DATA = POINTER(CREATE_USN_JOURNAL_DATA)


class READ_FILE_USN_DATA(ctypes.Structure):
    pass


PREAD_FILE_USN_DATA = POINTER(READ_FILE_USN_DATA)


class READ_USN_JOURNAL_DATA_V0(ctypes.Structure):
    pass


PREAD_USN_JOURNAL_DATA_V0 = POINTER(READ_USN_JOURNAL_DATA_V0)


class READ_USN_JOURNAL_DATA_V1(ctypes.Structure):
    pass


PREAD_USN_JOURNAL_DATA_V1 = POINTER(READ_USN_JOURNAL_DATA_V1)


class USN_TRACK_MODIFIED_RANGES(ctypes.Structure):
    pass


PUSN_TRACK_MODIFIED_RANGES = POINTER(USN_TRACK_MODIFIED_RANGES)


class USN_RANGE_TRACK_OUTPUT(ctypes.Structure):
    pass


PUSN_RANGE_TRACK_OUTPUT = POINTER(USN_RANGE_TRACK_OUTPUT)


class USN_RECORD_V2(ctypes.Structure):
    pass


PUSN_RECORD_V2 = POINTER(USN_RECORD_V2)


class USN_RECORD_V3(ctypes.Structure):
    pass


PUSN_RECORD_V3 = POINTER(USN_RECORD_V3)


class USN_RECORD_COMMON_HEADER(ctypes.Structure):
    pass


PUSN_RECORD_COMMON_HEADER = POINTER(USN_RECORD_COMMON_HEADER)


class USN_RECORD_EXTENT(ctypes.Structure):
    pass


PUSN_RECORD_EXTENT = POINTER(USN_RECORD_EXTENT)


class USN_RECORD_V4(ctypes.Structure):
    pass


PUSN_RECORD_V4 = POINTER(USN_RECORD_V4)


class USN_RECORD_UNION(ctypes.Union):
    pass


PUSN_RECORD_UNION = POINTER(USN_RECORD_UNION)


class USN_JOURNAL_DATA_V0(ctypes.Structure):
    pass


PUSN_JOURNAL_DATA_V0 = POINTER(USN_JOURNAL_DATA_V0)


class USN_JOURNAL_DATA_V1(ctypes.Structure):
    pass


PUSN_JOURNAL_DATA_V1 = POINTER(USN_JOURNAL_DATA_V1)


class USN_JOURNAL_DATA_V2(ctypes.Structure):
    pass


PUSN_JOURNAL_DATA_V2 = POINTER(USN_JOURNAL_DATA_V2)


class DELETE_USN_JOURNAL_DATA(ctypes.Structure):
    pass


PDELETE_USN_JOURNAL_DATA = POINTER(DELETE_USN_JOURNAL_DATA)


class MARK_HANDLE_INFO(ctypes.Structure):
    pass


PMARK_HANDLE_INFO = POINTER(MARK_HANDLE_INFO)


class MARK_HANDLE_INFO32(ctypes.Structure):
    pass


PMARK_HANDLE_INFO32 = POINTER(MARK_HANDLE_INFO32)


class BULK_SECURITY_TEST_DATA(ctypes.Structure):
    pass


PBULK_SECURITY_TEST_DATA = POINTER(BULK_SECURITY_TEST_DATA)


class _FILE_PREFETCH(ctypes.Structure):
    pass


FILE_PREFETCH = _FILE_PREFETCH
PFILE_PREFETCH = POINTER(_FILE_PREFETCH)


class _FILE_PREFETCH_EX(ctypes.Structure):
    pass


FILE_PREFETCH_EX = _FILE_PREFETCH_EX
PFILE_PREFETCH_EX = POINTER(_FILE_PREFETCH_EX)


class _FILESYSTEM_STATISTICS(ctypes.Structure):
    pass


FILESYSTEM_STATISTICS = _FILESYSTEM_STATISTICS
PFILESYSTEM_STATISTICS = POINTER(_FILESYSTEM_STATISTICS)


class _FAT_STATISTICS(ctypes.Structure):
    pass


FAT_STATISTICS = _FAT_STATISTICS
PFAT_STATISTICS = POINTER(_FAT_STATISTICS)


class _EXFAT_STATISTICS(ctypes.Structure):
    pass


EXFAT_STATISTICS = _EXFAT_STATISTICS
PEXFAT_STATISTICS = POINTER(_EXFAT_STATISTICS)


class _NTFS_STATISTICS(ctypes.Structure):
    pass


NTFS_STATISTICS = _NTFS_STATISTICS
PNTFS_STATISTICS = POINTER(_NTFS_STATISTICS)


class _FILESYSTEM_STATISTICS_EX(ctypes.Structure):
    pass


FILESYSTEM_STATISTICS_EX = _FILESYSTEM_STATISTICS_EX
PFILESYSTEM_STATISTICS_EX = POINTER(_FILESYSTEM_STATISTICS_EX)


class _NTFS_STATISTICS_EX(ctypes.Structure):
    pass


NTFS_STATISTICS_EX = _NTFS_STATISTICS_EX
PNTFS_STATISTICS_EX = POINTER(_NTFS_STATISTICS_EX)


class _FILE_OBJECTID_BUFFER(ctypes.Structure):
    pass


FILE_OBJECTID_BUFFER = _FILE_OBJECTID_BUFFER
PFILE_OBJECTID_BUFFER = POINTER(_FILE_OBJECTID_BUFFER)


class _FILE_SET_SPARSE_BUFFER(ctypes.Structure):
    pass


FILE_SET_SPARSE_BUFFER = _FILE_SET_SPARSE_BUFFER
PFILE_SET_SPARSE_BUFFER = POINTER(_FILE_SET_SPARSE_BUFFER)


class _FILE_ZERO_DATA_INFORMATION(ctypes.Structure):
    pass


FILE_ZERO_DATA_INFORMATION = _FILE_ZERO_DATA_INFORMATION
PFILE_ZERO_DATA_INFORMATION = POINTER(_FILE_ZERO_DATA_INFORMATION)


class _FILE_ZERO_DATA_INFORMATION_EX(ctypes.Structure):
    pass


FILE_ZERO_DATA_INFORMATION_EX = _FILE_ZERO_DATA_INFORMATION_EX
PFILE_ZERO_DATA_INFORMATION_EX = POINTER(_FILE_ZERO_DATA_INFORMATION_EX)


class _FILE_ALLOCATED_RANGE_BUFFER(ctypes.Structure):
    pass


FILE_ALLOCATED_RANGE_BUFFER = _FILE_ALLOCATED_RANGE_BUFFER
PFILE_ALLOCATED_RANGE_BUFFER = POINTER(_FILE_ALLOCATED_RANGE_BUFFER)


class _ENCRYPTION_BUFFER(ctypes.Structure):
    pass


ENCRYPTION_BUFFER = _ENCRYPTION_BUFFER
PENCRYPTION_BUFFER = POINTER(_ENCRYPTION_BUFFER)


class _DECRYPTION_STATUS_BUFFER(ctypes.Structure):
    pass


DECRYPTION_STATUS_BUFFER = _DECRYPTION_STATUS_BUFFER
PDECRYPTION_STATUS_BUFFER = POINTER(_DECRYPTION_STATUS_BUFFER)


class _REQUEST_RAW_ENCRYPTED_DATA(ctypes.Structure):
    pass


REQUEST_RAW_ENCRYPTED_DATA = _REQUEST_RAW_ENCRYPTED_DATA
PREQUEST_RAW_ENCRYPTED_DATA = POINTER(_REQUEST_RAW_ENCRYPTED_DATA)


class _ENCRYPTED_DATA_INFO(ctypes.Structure):
    pass


ENCRYPTED_DATA_INFO = _ENCRYPTED_DATA_INFO
PENCRYPTED_DATA_INFO = POINTER(_ENCRYPTED_DATA_INFO)


class _EXTENDED_ENCRYPTED_DATA_INFO(ctypes.Structure):
    pass


EXTENDED_ENCRYPTED_DATA_INFO = _EXTENDED_ENCRYPTED_DATA_INFO
PEXTENDED_ENCRYPTED_DATA_INFO = POINTER(_EXTENDED_ENCRYPTED_DATA_INFO)


class _PLEX_READ_DATA_REQUEST(ctypes.Structure):
    pass


PLEX_READ_DATA_REQUEST = _PLEX_READ_DATA_REQUEST
PPLEX_READ_DATA_REQUEST = POINTER(_PLEX_READ_DATA_REQUEST)


class _SI_COPYFILE(ctypes.Structure):
    pass


SI_COPYFILE = _SI_COPYFILE
PSI_COPYFILE = POINTER(_SI_COPYFILE)


class _FILE_MAKE_COMPATIBLE_BUFFER(ctypes.Structure):
    pass


FILE_MAKE_COMPATIBLE_BUFFER = _FILE_MAKE_COMPATIBLE_BUFFER
PFILE_MAKE_COMPATIBLE_BUFFER = POINTER(_FILE_MAKE_COMPATIBLE_BUFFER)


class _FILE_SET_DEFECT_MGMT_BUFFER(ctypes.Structure):
    pass


FILE_SET_DEFECT_MGMT_BUFFER = _FILE_SET_DEFECT_MGMT_BUFFER
PFILE_SET_DEFECT_MGMT_BUFFER = POINTER(_FILE_SET_DEFECT_MGMT_BUFFER)


class _FILE_QUERY_SPARING_BUFFER(ctypes.Structure):
    pass


FILE_QUERY_SPARING_BUFFER = _FILE_QUERY_SPARING_BUFFER
PFILE_QUERY_SPARING_BUFFER = POINTER(_FILE_QUERY_SPARING_BUFFER)


class _FILE_QUERY_ON_DISK_VOL_INFO_BUFFER(ctypes.Structure):
    pass


FILE_QUERY_ON_DISK_VOL_INFO_BUFFER = _FILE_QUERY_ON_DISK_VOL_INFO_BUFFER
PFILE_QUERY_ON_DISK_VOL_INFO_BUFFER = POINTER(_FILE_QUERY_ON_DISK_VOL_INFO_BUFFER)


class _FILE_INITIATE_REPAIR_OUTPUT_BUFFER(ctypes.Structure):
    pass


FILE_INITIATE_REPAIR_OUTPUT_BUFFER = _FILE_INITIATE_REPAIR_OUTPUT_BUFFER
PFILE_INITIATE_REPAIR_OUTPUT_BUFFER = POINTER(_FILE_INITIATE_REPAIR_OUTPUT_BUFFER)


class _SHRINK_VOLUME_INFORMATION(ctypes.Structure):
    pass


SHRINK_VOLUME_INFORMATION = _SHRINK_VOLUME_INFORMATION
PSHRINK_VOLUME_INFORMATION = POINTER(_SHRINK_VOLUME_INFORMATION)


class _TXFS_MODIFY_RM(ctypes.Structure):
    pass


TXFS_MODIFY_RM = _TXFS_MODIFY_RM
PTXFS_MODIFY_RM = POINTER(_TXFS_MODIFY_RM)


class _TXFS_QUERY_RM_INFORMATION(ctypes.Structure):
    pass


TXFS_QUERY_RM_INFORMATION = _TXFS_QUERY_RM_INFORMATION
PTXFS_QUERY_RM_INFORMATION = POINTER(_TXFS_QUERY_RM_INFORMATION)


class _TXFS_ROLLFORWARD_REDO_INFORMATION(ctypes.Structure):
    pass


TXFS_ROLLFORWARD_REDO_INFORMATION = _TXFS_ROLLFORWARD_REDO_INFORMATION
PTXFS_ROLLFORWARD_REDO_INFORMATION = POINTER(_TXFS_ROLLFORWARD_REDO_INFORMATION)


class _TXFS_START_RM_INFORMATION(ctypes.Structure):
    pass


TXFS_START_RM_INFORMATION = _TXFS_START_RM_INFORMATION
PTXFS_START_RM_INFORMATION = POINTER(_TXFS_START_RM_INFORMATION)


class _TXFS_GET_METADATA_INFO_OUT(ctypes.Structure):
    pass


TXFS_GET_METADATA_INFO_OUT = _TXFS_GET_METADATA_INFO_OUT
PTXFS_GET_METADATA_INFO_OUT = POINTER(_TXFS_GET_METADATA_INFO_OUT)


class _TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY(ctypes.Structure):
    pass


TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY = _TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY
PTXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY = POINTER(_TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY)


class _TXFS_LIST_TRANSACTION_LOCKED_FILES(ctypes.Structure):
    pass


TXFS_LIST_TRANSACTION_LOCKED_FILES = _TXFS_LIST_TRANSACTION_LOCKED_FILES
PTXFS_LIST_TRANSACTION_LOCKED_FILES = POINTER(_TXFS_LIST_TRANSACTION_LOCKED_FILES)


class _TXFS_LIST_TRANSACTIONS_ENTRY(ctypes.Structure):
    pass


TXFS_LIST_TRANSACTIONS_ENTRY = _TXFS_LIST_TRANSACTIONS_ENTRY
PTXFS_LIST_TRANSACTIONS_ENTRY = POINTER(_TXFS_LIST_TRANSACTIONS_ENTRY)


class _TXFS_LIST_TRANSACTIONS(ctypes.Structure):
    pass


TXFS_LIST_TRANSACTIONS = _TXFS_LIST_TRANSACTIONS
PTXFS_LIST_TRANSACTIONS = POINTER(_TXFS_LIST_TRANSACTIONS)


class _TXFS_READ_BACKUP_INFORMATION_OUT(ctypes.Structure):
    pass


TXFS_READ_BACKUP_INFORMATION_OUT = _TXFS_READ_BACKUP_INFORMATION_OUT
PTXFS_READ_BACKUP_INFORMATION_OUT = POINTER(_TXFS_READ_BACKUP_INFORMATION_OUT)


class _TXFS_WRITE_BACKUP_INFORMATION(ctypes.Structure):
    pass


TXFS_WRITE_BACKUP_INFORMATION = _TXFS_WRITE_BACKUP_INFORMATION
PTXFS_WRITE_BACKUP_INFORMATION = POINTER(_TXFS_WRITE_BACKUP_INFORMATION)


class _TXFS_GET_TRANSACTED_VERSION(ctypes.Structure):
    pass


TXFS_GET_TRANSACTED_VERSION = _TXFS_GET_TRANSACTED_VERSION
PTXFS_GET_TRANSACTED_VERSION = POINTER(_TXFS_GET_TRANSACTED_VERSION)


class _TXFS_SAVEPOINT_INFORMATION(ctypes.Structure):
    pass


TXFS_SAVEPOINT_INFORMATION = _TXFS_SAVEPOINT_INFORMATION
PTXFS_SAVEPOINT_INFORMATION = POINTER(_TXFS_SAVEPOINT_INFORMATION)


class _TXFS_CREATE_MINIVERSION_INFO(ctypes.Structure):
    pass


TXFS_CREATE_MINIVERSION_INFO = _TXFS_CREATE_MINIVERSION_INFO
PTXFS_CREATE_MINIVERSION_INFO = POINTER(_TXFS_CREATE_MINIVERSION_INFO)


class _TXFS_TRANSACTION_ACTIVE_INFO(ctypes.Structure):
    pass


TXFS_TRANSACTION_ACTIVE_INFO = _TXFS_TRANSACTION_ACTIVE_INFO
PTXFS_TRANSACTION_ACTIVE_INFO = POINTER(_TXFS_TRANSACTION_ACTIVE_INFO)


class _BOOT_AREA_INFO(ctypes.Structure):
    pass


BOOT_AREA_INFO = _BOOT_AREA_INFO
PBOOT_AREA_INFO = POINTER(_BOOT_AREA_INFO)


class _RETRIEVAL_POINTER_BASE(ctypes.Structure):
    pass


RETRIEVAL_POINTER_BASE = _RETRIEVAL_POINTER_BASE
PRETRIEVAL_POINTER_BASE = POINTER(_RETRIEVAL_POINTER_BASE)


class _FILE_FS_PERSISTENT_VOLUME_INFORMATION(ctypes.Structure):
    pass


FILE_FS_PERSISTENT_VOLUME_INFORMATION = _FILE_FS_PERSISTENT_VOLUME_INFORMATION
PFILE_FS_PERSISTENT_VOLUME_INFORMATION = POINTER(_FILE_FS_PERSISTENT_VOLUME_INFORMATION)


class _FILE_SYSTEM_RECOGNITION_INFORMATION(ctypes.Structure):
    pass


FILE_SYSTEM_RECOGNITION_INFORMATION = _FILE_SYSTEM_RECOGNITION_INFORMATION
PFILE_SYSTEM_RECOGNITION_INFORMATION = POINTER(_FILE_SYSTEM_RECOGNITION_INFORMATION)


class _REQUEST_OPLOCK_INPUT_BUFFER(ctypes.Structure):
    pass


REQUEST_OPLOCK_INPUT_BUFFER = _REQUEST_OPLOCK_INPUT_BUFFER
PREQUEST_OPLOCK_INPUT_BUFFER = POINTER(_REQUEST_OPLOCK_INPUT_BUFFER)


class _REQUEST_OPLOCK_OUTPUT_BUFFER(ctypes.Structure):
    pass


REQUEST_OPLOCK_OUTPUT_BUFFER = _REQUEST_OPLOCK_OUTPUT_BUFFER
PREQUEST_OPLOCK_OUTPUT_BUFFER = POINTER(_REQUEST_OPLOCK_OUTPUT_BUFFER)


class _VIRTUAL_STORAGE_TYPE(ctypes.Structure):
    pass


VIRTUAL_STORAGE_TYPE = _VIRTUAL_STORAGE_TYPE
PVIRTUAL_STORAGE_TYPE = POINTER(_VIRTUAL_STORAGE_TYPE)


class _STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST(ctypes.Structure):
    pass


STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST = _STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST
PSTORAGE_QUERY_DEPENDENT_VOLUME_REQUEST = POINTER(_STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST)


class _STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY(ctypes.Structure):
    pass


STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY = _STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY
PSTORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY = POINTER(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY)


class _STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY(ctypes.Structure):
    pass


STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY = _STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY
PSTORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY = POINTER(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY)


class _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE(ctypes.Structure):
    pass


STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE = _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE
PSTORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE = POINTER(_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE)


class _SD_CHANGE_MACHINE_SID_INPUT(ctypes.Structure):
    pass


SD_CHANGE_MACHINE_SID_INPUT = _SD_CHANGE_MACHINE_SID_INPUT
PSD_CHANGE_MACHINE_SID_INPUT = POINTER(_SD_CHANGE_MACHINE_SID_INPUT)


class _SD_CHANGE_MACHINE_SID_OUTPUT(ctypes.Structure):
    pass


SD_CHANGE_MACHINE_SID_OUTPUT = _SD_CHANGE_MACHINE_SID_OUTPUT
PSD_CHANGE_MACHINE_SID_OUTPUT = POINTER(_SD_CHANGE_MACHINE_SID_OUTPUT)


class _SD_QUERY_STATS_INPUT(ctypes.Structure):
    pass


SD_QUERY_STATS_INPUT = _SD_QUERY_STATS_INPUT
PSD_QUERY_STATS_INPUT = POINTER(_SD_QUERY_STATS_INPUT)


class _SD_QUERY_STATS_OUTPUT(ctypes.Structure):
    pass


SD_QUERY_STATS_OUTPUT = _SD_QUERY_STATS_OUTPUT
PSD_QUERY_STATS_OUTPUT = POINTER(_SD_QUERY_STATS_OUTPUT)


class _SD_ENUM_SDS_INPUT(ctypes.Structure):
    pass


SD_ENUM_SDS_INPUT = _SD_ENUM_SDS_INPUT
PSD_ENUM_SDS_INPUT = POINTER(_SD_ENUM_SDS_INPUT)


class _SD_ENUM_SDS_ENTRY(ctypes.Structure):
    pass


SD_ENUM_SDS_ENTRY = _SD_ENUM_SDS_ENTRY
PSD_ENUM_SDS_ENTRY = POINTER(_SD_ENUM_SDS_ENTRY)


class _SD_ENUM_SDS_OUTPUT(ctypes.Structure):
    pass


SD_ENUM_SDS_OUTPUT = _SD_ENUM_SDS_OUTPUT
PSD_ENUM_SDS_OUTPUT = POINTER(_SD_ENUM_SDS_OUTPUT)


class _SD_GLOBAL_CHANGE_INPUT(ctypes.Structure):
    pass


SD_GLOBAL_CHANGE_INPUT = _SD_GLOBAL_CHANGE_INPUT
PSD_GLOBAL_CHANGE_INPUT = POINTER(_SD_GLOBAL_CHANGE_INPUT)


class _SD_GLOBAL_CHANGE_OUTPUT(ctypes.Structure):
    pass


SD_GLOBAL_CHANGE_OUTPUT = _SD_GLOBAL_CHANGE_OUTPUT
PSD_GLOBAL_CHANGE_OUTPUT = POINTER(_SD_GLOBAL_CHANGE_OUTPUT)


class _LOOKUP_STREAM_FROM_CLUSTER_INPUT(ctypes.Structure):
    pass


LOOKUP_STREAM_FROM_CLUSTER_INPUT = _LOOKUP_STREAM_FROM_CLUSTER_INPUT
PLOOKUP_STREAM_FROM_CLUSTER_INPUT = POINTER(_LOOKUP_STREAM_FROM_CLUSTER_INPUT)


class _LOOKUP_STREAM_FROM_CLUSTER_OUTPUT(ctypes.Structure):
    pass


LOOKUP_STREAM_FROM_CLUSTER_OUTPUT = _LOOKUP_STREAM_FROM_CLUSTER_OUTPUT
PLOOKUP_STREAM_FROM_CLUSTER_OUTPUT = POINTER(_LOOKUP_STREAM_FROM_CLUSTER_OUTPUT)


class _LOOKUP_STREAM_FROM_CLUSTER_ENTRY(ctypes.Structure):
    pass


LOOKUP_STREAM_FROM_CLUSTER_ENTRY = _LOOKUP_STREAM_FROM_CLUSTER_ENTRY
PLOOKUP_STREAM_FROM_CLUSTER_ENTRY = POINTER(_LOOKUP_STREAM_FROM_CLUSTER_ENTRY)


class _FILE_TYPE_NOTIFICATION_INPUT(ctypes.Structure):
    pass


FILE_TYPE_NOTIFICATION_INPUT = _FILE_TYPE_NOTIFICATION_INPUT
PFILE_TYPE_NOTIFICATION_INPUT = POINTER(_FILE_TYPE_NOTIFICATION_INPUT)


class _CSV_MGMT_LOCK(ctypes.Structure):
    pass


CSV_MGMT_LOCK = _CSV_MGMT_LOCK
PCSV_MGMT_LOCK = POINTER(_CSV_MGMT_LOCK)


class _CSV_NAMESPACE_INFO(ctypes.Structure):
    pass


CSV_NAMESPACE_INFO = _CSV_NAMESPACE_INFO
PCSV_NAMESPACE_INFO = POINTER(_CSV_NAMESPACE_INFO)


class _CSV_CONTROL_PARAM(ctypes.Structure):
    pass


CSV_CONTROL_PARAM = _CSV_CONTROL_PARAM
PCSV_CONTROL_PARAM = POINTER(_CSV_CONTROL_PARAM)


class _CSV_QUERY_REDIRECT_STATE(ctypes.Structure):
    pass


CSV_QUERY_REDIRECT_STATE = _CSV_QUERY_REDIRECT_STATE
PCSV_QUERY_REDIRECT_STATE = POINTER(_CSV_QUERY_REDIRECT_STATE)


class _CSV_QUERY_FILE_REVISION(ctypes.Structure):
    pass


CSV_QUERY_FILE_REVISION = _CSV_QUERY_FILE_REVISION
PCSV_QUERY_FILE_REVISION = POINTER(_CSV_QUERY_FILE_REVISION)


class _CSV_QUERY_FILE_REVISION_FILE_ID_128(ctypes.Structure):
    pass


CSV_QUERY_FILE_REVISION_FILE_ID_128 = _CSV_QUERY_FILE_REVISION_FILE_ID_128
PCSV_QUERY_FILE_REVISION_FILE_ID_128 = POINTER(_CSV_QUERY_FILE_REVISION_FILE_ID_128)


class _CSV_QUERY_MDS_PATH(ctypes.Structure):
    pass


CSV_QUERY_MDS_PATH = _CSV_QUERY_MDS_PATH
PCSV_QUERY_MDS_PATH = POINTER(_CSV_QUERY_MDS_PATH)


class _CSV_QUERY_VOLUME_REDIRECT_STATE(ctypes.Structure):
    pass


CSV_QUERY_VOLUME_REDIRECT_STATE = _CSV_QUERY_VOLUME_REDIRECT_STATE
PCSV_QUERY_VOLUME_REDIRECT_STATE = POINTER(_CSV_QUERY_VOLUME_REDIRECT_STATE)


class _CSV_QUERY_MDS_PATH_V2(ctypes.Structure):
    pass


CSV_QUERY_MDS_PATH_V2 = _CSV_QUERY_MDS_PATH_V2
PCSV_QUERY_MDS_PATH_V2 = POINTER(_CSV_QUERY_MDS_PATH_V2)


class _CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT(ctypes.Structure):
    pass


CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT = _CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT
PCSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT = POINTER(_CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT)


class _CSV_IS_OWNED_BY_CSVFS(ctypes.Structure):
    pass


CSV_IS_OWNED_BY_CSVFS = _CSV_IS_OWNED_BY_CSVFS
PCSV_IS_OWNED_BY_CSVFS = POINTER(_CSV_IS_OWNED_BY_CSVFS)


class _FILE_LEVEL_TRIM_RANGE(ctypes.Structure):
    pass


FILE_LEVEL_TRIM_RANGE = _FILE_LEVEL_TRIM_RANGE
PFILE_LEVEL_TRIM_RANGE = POINTER(_FILE_LEVEL_TRIM_RANGE)


class _FILE_LEVEL_TRIM(ctypes.Structure):
    pass


FILE_LEVEL_TRIM = _FILE_LEVEL_TRIM
PFILE_LEVEL_TRIM = POINTER(_FILE_LEVEL_TRIM)


class _FILE_LEVEL_TRIM_OUTPUT(ctypes.Structure):
    pass


FILE_LEVEL_TRIM_OUTPUT = _FILE_LEVEL_TRIM_OUTPUT
PFILE_LEVEL_TRIM_OUTPUT = POINTER(_FILE_LEVEL_TRIM_OUTPUT)


class _CLUSTER_RANGE(ctypes.Structure):
    pass


CLUSTER_RANGE = _CLUSTER_RANGE
PCLUSTER_RANGE = POINTER(_CLUSTER_RANGE)


class _FILE_REFERENCE_RANGE(ctypes.Structure):
    pass


FILE_REFERENCE_RANGE = _FILE_REFERENCE_RANGE
PFILE_REFERENCE_RANGE = POINTER(_FILE_REFERENCE_RANGE)


class _QUERY_FILE_LAYOUT_INPUT(ctypes.Structure):
    pass


QUERY_FILE_LAYOUT_INPUT = _QUERY_FILE_LAYOUT_INPUT
PQUERY_FILE_LAYOUT_INPUT = POINTER(_QUERY_FILE_LAYOUT_INPUT)


class _QUERY_FILE_LAYOUT_OUTPUT(ctypes.Structure):
    pass


QUERY_FILE_LAYOUT_OUTPUT = _QUERY_FILE_LAYOUT_OUTPUT
PQUERY_FILE_LAYOUT_OUTPUT = POINTER(_QUERY_FILE_LAYOUT_OUTPUT)


class _FILE_LAYOUT_ENTRY(ctypes.Structure):
    pass


FILE_LAYOUT_ENTRY = _FILE_LAYOUT_ENTRY
PFILE_LAYOUT_ENTRY = POINTER(_FILE_LAYOUT_ENTRY)


class _FILE_LAYOUT_NAME_ENTRY(ctypes.Structure):
    pass


FILE_LAYOUT_NAME_ENTRY = _FILE_LAYOUT_NAME_ENTRY
PFILE_LAYOUT_NAME_ENTRY = POINTER(_FILE_LAYOUT_NAME_ENTRY)


class _FILE_LAYOUT_INFO_ENTRY(ctypes.Structure):
    pass


FILE_LAYOUT_INFO_ENTRY = _FILE_LAYOUT_INFO_ENTRY
PFILE_LAYOUT_INFO_ENTRY = POINTER(_FILE_LAYOUT_INFO_ENTRY)


class _STREAM_LAYOUT_ENTRY(ctypes.Structure):
    pass


STREAM_LAYOUT_ENTRY = _STREAM_LAYOUT_ENTRY
PSTREAM_LAYOUT_ENTRY = POINTER(_STREAM_LAYOUT_ENTRY)


class _STREAM_EXTENT_ENTRY(ctypes.Structure):
    pass


STREAM_EXTENT_ENTRY = _STREAM_EXTENT_ENTRY
PSTREAM_EXTENT_ENTRY = POINTER(_STREAM_EXTENT_ENTRY)


class _FSCTL_GET_INTEGRITY_INFORMATION_BUFFER(ctypes.Structure):
    pass


FSCTL_GET_INTEGRITY_INFORMATION_BUFFER = _FSCTL_GET_INTEGRITY_INFORMATION_BUFFER
PFSCTL_GET_INTEGRITY_INFORMATION_BUFFER = POINTER(_FSCTL_GET_INTEGRITY_INFORMATION_BUFFER)


class _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER(ctypes.Structure):
    pass


FSCTL_SET_INTEGRITY_INFORMATION_BUFFER = _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER
PFSCTL_SET_INTEGRITY_INFORMATION_BUFFER = POINTER(_FSCTL_SET_INTEGRITY_INFORMATION_BUFFER)


class _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX(ctypes.Structure):
    pass


FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX = _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX
PFSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX = POINTER(_FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX)


class _FSCTL_OFFLOAD_READ_INPUT(ctypes.Structure):
    pass


FSCTL_OFFLOAD_READ_INPUT = _FSCTL_OFFLOAD_READ_INPUT
PFSCTL_OFFLOAD_READ_INPUT = POINTER(_FSCTL_OFFLOAD_READ_INPUT)


class _FSCTL_OFFLOAD_READ_OUTPUT(ctypes.Structure):
    pass


FSCTL_OFFLOAD_READ_OUTPUT = _FSCTL_OFFLOAD_READ_OUTPUT
PFSCTL_OFFLOAD_READ_OUTPUT = POINTER(_FSCTL_OFFLOAD_READ_OUTPUT)


class _FSCTL_OFFLOAD_WRITE_INPUT(ctypes.Structure):
    pass


FSCTL_OFFLOAD_WRITE_INPUT = _FSCTL_OFFLOAD_WRITE_INPUT
PFSCTL_OFFLOAD_WRITE_INPUT = POINTER(_FSCTL_OFFLOAD_WRITE_INPUT)


class _FSCTL_OFFLOAD_WRITE_OUTPUT(ctypes.Structure):
    pass


FSCTL_OFFLOAD_WRITE_OUTPUT = _FSCTL_OFFLOAD_WRITE_OUTPUT
PFSCTL_OFFLOAD_WRITE_OUTPUT = POINTER(_FSCTL_OFFLOAD_WRITE_OUTPUT)


class _SET_PURGE_FAILURE_MODE_INPUT(ctypes.Structure):
    pass


SET_PURGE_FAILURE_MODE_INPUT = _SET_PURGE_FAILURE_MODE_INPUT
PSET_PURGE_FAILURE_MODE_INPUT = POINTER(_SET_PURGE_FAILURE_MODE_INPUT)


class _REPAIR_COPIES_INPUT(ctypes.Structure):
    pass


REPAIR_COPIES_INPUT = _REPAIR_COPIES_INPUT
PREPAIR_COPIES_INPUT = POINTER(_REPAIR_COPIES_INPUT)


class _REPAIR_COPIES_OUTPUT(ctypes.Structure):
    pass


REPAIR_COPIES_OUTPUT = _REPAIR_COPIES_OUTPUT
PREPAIR_COPIES_OUTPUT = POINTER(_REPAIR_COPIES_OUTPUT)


class _FILE_REGION_INFO(ctypes.Structure):
    pass


FILE_REGION_INFO = _FILE_REGION_INFO
PFILE_REGION_INFO = POINTER(_FILE_REGION_INFO)


class _FILE_REGION_OUTPUT(ctypes.Structure):
    pass


FILE_REGION_OUTPUT = _FILE_REGION_OUTPUT
PFILE_REGION_OUTPUT = POINTER(_FILE_REGION_OUTPUT)


class _FILE_REGION_INPUT(ctypes.Structure):
    pass


FILE_REGION_INPUT = _FILE_REGION_INPUT
PFILE_REGION_INPUT = POINTER(_FILE_REGION_INPUT)


class _WRITE_USN_REASON_INPUT(ctypes.Structure):
    pass


WRITE_USN_REASON_INPUT = _WRITE_USN_REASON_INPUT
PWRITE_USN_REASON_INPUT = POINTER(_WRITE_USN_REASON_INPUT)


class _FILE_STORAGE_TIER(ctypes.Structure):
    pass


FILE_STORAGE_TIER = _FILE_STORAGE_TIER
PFILE_STORAGE_TIER = POINTER(_FILE_STORAGE_TIER)


class _FSCTL_QUERY_STORAGE_CLASSES_OUTPUT(ctypes.Structure):
    pass


FSCTL_QUERY_STORAGE_CLASSES_OUTPUT = _FSCTL_QUERY_STORAGE_CLASSES_OUTPUT
PFSCTL_QUERY_STORAGE_CLASSES_OUTPUT = POINTER(_FSCTL_QUERY_STORAGE_CLASSES_OUTPUT)


class _STREAM_INFORMATION_ENTRY(ctypes.Structure):
    pass


STREAM_INFORMATION_ENTRY = _STREAM_INFORMATION_ENTRY
PSTREAM_INFORMATION_ENTRY = POINTER(_STREAM_INFORMATION_ENTRY)


class _FSCTL_QUERY_REGION_INFO_INPUT(ctypes.Structure):
    pass


FSCTL_QUERY_REGION_INFO_INPUT = _FSCTL_QUERY_REGION_INFO_INPUT
PFSCTL_QUERY_REGION_INFO_INPUT = POINTER(_FSCTL_QUERY_REGION_INFO_INPUT)


class _FILE_STORAGE_TIER_REGION(ctypes.Structure):
    pass


FILE_STORAGE_TIER_REGION = _FILE_STORAGE_TIER_REGION
PFILE_STORAGE_TIER_REGION = POINTER(_FILE_STORAGE_TIER_REGION)


class _FSCTL_QUERY_REGION_INFO_OUTPUT(ctypes.Structure):
    pass


FSCTL_QUERY_REGION_INFO_OUTPUT = _FSCTL_QUERY_REGION_INFO_OUTPUT
PFSCTL_QUERY_REGION_INFO_OUTPUT = POINTER(_FSCTL_QUERY_REGION_INFO_OUTPUT)


class _FILE_DESIRED_STORAGE_CLASS_INFORMATION(ctypes.Structure):
    pass


FILE_DESIRED_STORAGE_CLASS_INFORMATION = _FILE_DESIRED_STORAGE_CLASS_INFORMATION
PFILE_DESIRED_STORAGE_CLASS_INFORMATION = POINTER(_FILE_DESIRED_STORAGE_CLASS_INFORMATION)


class _DUPLICATE_EXTENTS_DATA(ctypes.Structure):
    pass


DUPLICATE_EXTENTS_DATA = _DUPLICATE_EXTENTS_DATA
PDUPLICATE_EXTENTS_DATA = POINTER(_DUPLICATE_EXTENTS_DATA)


class _DUPLICATE_EXTENTS_DATA32(ctypes.Structure):
    pass


DUPLICATE_EXTENTS_DATA32 = _DUPLICATE_EXTENTS_DATA32
PDUPLICATE_EXTENTS_DATA32 = POINTER(_DUPLICATE_EXTENTS_DATA32)


class _DUPLICATE_EXTENTS_DATA_EX(ctypes.Structure):
    pass


DUPLICATE_EXTENTS_DATA_EX = _DUPLICATE_EXTENTS_DATA_EX
PDUPLICATE_EXTENTS_DATA_EX = POINTER(_DUPLICATE_EXTENTS_DATA_EX)


class _DUPLICATE_EXTENTS_DATA_EX32(ctypes.Structure):
    pass


DUPLICATE_EXTENTS_DATA_EX32 = _DUPLICATE_EXTENTS_DATA_EX32
PDUPLICATE_EXTENTS_DATA_EX32 = POINTER(_DUPLICATE_EXTENTS_DATA_EX32)


class _REFS_SMR_VOLUME_INFO_OUTPUT(ctypes.Structure):
    pass


REFS_SMR_VOLUME_INFO_OUTPUT = _REFS_SMR_VOLUME_INFO_OUTPUT
PREFS_SMR_VOLUME_INFO_OUTPUT = POINTER(_REFS_SMR_VOLUME_INFO_OUTPUT)


class _REFS_SMR_VOLUME_GC_PARAMETERS(ctypes.Structure):
    pass


REFS_SMR_VOLUME_GC_PARAMETERS = _REFS_SMR_VOLUME_GC_PARAMETERS
PREFS_SMR_VOLUME_GC_PARAMETERS = POINTER(_REFS_SMR_VOLUME_GC_PARAMETERS)


class _STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER(ctypes.Structure):
    pass


STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER = _STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER
PSTREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER = POINTER(_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER)


class _STREAMS_ASSOCIATE_ID_INPUT_BUFFER(ctypes.Structure):
    pass


STREAMS_ASSOCIATE_ID_INPUT_BUFFER = _STREAMS_ASSOCIATE_ID_INPUT_BUFFER
PSTREAMS_ASSOCIATE_ID_INPUT_BUFFER = POINTER(_STREAMS_ASSOCIATE_ID_INPUT_BUFFER)


class _STREAMS_QUERY_ID_OUTPUT_BUFFER(ctypes.Structure):
    pass


STREAMS_QUERY_ID_OUTPUT_BUFFER = _STREAMS_QUERY_ID_OUTPUT_BUFFER
PSTREAMS_QUERY_ID_OUTPUT_BUFFER = POINTER(_STREAMS_QUERY_ID_OUTPUT_BUFFER)


class _QUERY_BAD_RANGES_INPUT_RANGE(ctypes.Structure):
    pass


QUERY_BAD_RANGES_INPUT_RANGE = _QUERY_BAD_RANGES_INPUT_RANGE
PQUERY_BAD_RANGES_INPUT_RANGE = POINTER(_QUERY_BAD_RANGES_INPUT_RANGE)


class _QUERY_BAD_RANGES_INPUT(ctypes.Structure):
    pass


QUERY_BAD_RANGES_INPUT = _QUERY_BAD_RANGES_INPUT
PQUERY_BAD_RANGES_INPUT = POINTER(_QUERY_BAD_RANGES_INPUT)


class _QUERY_BAD_RANGES_OUTPUT_RANGE(ctypes.Structure):
    pass


QUERY_BAD_RANGES_OUTPUT_RANGE = _QUERY_BAD_RANGES_OUTPUT_RANGE
PQUERY_BAD_RANGES_OUTPUT_RANGE = POINTER(_QUERY_BAD_RANGES_OUTPUT_RANGE)


class _QUERY_BAD_RANGES_OUTPUT(ctypes.Structure):
    pass


QUERY_BAD_RANGES_OUTPUT = _QUERY_BAD_RANGES_OUTPUT
PQUERY_BAD_RANGES_OUTPUT = POINTER(_QUERY_BAD_RANGES_OUTPUT)


class _SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT(ctypes.Structure):
    pass


SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT = _SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT
PSET_DAX_ALLOC_ALIGNMENT_HINT_INPUT = POINTER(_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT)


class _VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT(ctypes.Structure):
    pass


VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT = _VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT
PVIRTUAL_STORAGE_SET_BEHAVIOR_INPUT = POINTER(_VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT)


class _ENCRYPTION_KEY_CTRL_INPUT(ctypes.Structure):
    pass


ENCRYPTION_KEY_CTRL_INPUT = _ENCRYPTION_KEY_CTRL_INPUT
PENCRYPTION_KEY_CTRL_INPUT = POINTER(_ENCRYPTION_KEY_CTRL_INPUT)


class _WOF_EXTERNAL_INFO(ctypes.Structure):
    pass


WOF_EXTERNAL_INFO = _WOF_EXTERNAL_INFO
PWOF_EXTERNAL_INFO = POINTER(_WOF_EXTERNAL_INFO)


class _WOF_EXTERNAL_FILE_ID(ctypes.Structure):
    pass


WOF_EXTERNAL_FILE_ID = _WOF_EXTERNAL_FILE_ID
PWOF_EXTERNAL_FILE_ID = POINTER(_WOF_EXTERNAL_FILE_ID)


class _WOF_VERSION_INFO(ctypes.Structure):
    pass


WOF_VERSION_INFO = _WOF_VERSION_INFO
PWOF_VERSION_INFO = POINTER(_WOF_VERSION_INFO)


class _WIM_PROVIDER_EXTERNAL_INFO(ctypes.Structure):
    pass


WIM_PROVIDER_EXTERNAL_INFO = _WIM_PROVIDER_EXTERNAL_INFO
PWIM_PROVIDER_EXTERNAL_INFO = POINTER(_WIM_PROVIDER_EXTERNAL_INFO)


class _WIM_PROVIDER_ADD_OVERLAY_INPUT(ctypes.Structure):
    pass


WIM_PROVIDER_ADD_OVERLAY_INPUT = _WIM_PROVIDER_ADD_OVERLAY_INPUT
PWIM_PROVIDER_ADD_OVERLAY_INPUT = POINTER(_WIM_PROVIDER_ADD_OVERLAY_INPUT)


class _WIM_PROVIDER_UPDATE_OVERLAY_INPUT(ctypes.Structure):
    pass


WIM_PROVIDER_UPDATE_OVERLAY_INPUT = _WIM_PROVIDER_UPDATE_OVERLAY_INPUT
PWIM_PROVIDER_UPDATE_OVERLAY_INPUT = POINTER(_WIM_PROVIDER_UPDATE_OVERLAY_INPUT)


class _WIM_PROVIDER_REMOVE_OVERLAY_INPUT(ctypes.Structure):
    pass


WIM_PROVIDER_REMOVE_OVERLAY_INPUT = _WIM_PROVIDER_REMOVE_OVERLAY_INPUT
PWIM_PROVIDER_REMOVE_OVERLAY_INPUT = POINTER(_WIM_PROVIDER_REMOVE_OVERLAY_INPUT)


class _WIM_PROVIDER_SUSPEND_OVERLAY_INPUT(ctypes.Structure):
    pass


WIM_PROVIDER_SUSPEND_OVERLAY_INPUT = _WIM_PROVIDER_SUSPEND_OVERLAY_INPUT
PWIM_PROVIDER_SUSPEND_OVERLAY_INPUT = POINTER(_WIM_PROVIDER_SUSPEND_OVERLAY_INPUT)


class _WIM_PROVIDER_OVERLAY_ENTRY(ctypes.Structure):
    pass


WIM_PROVIDER_OVERLAY_ENTRY = _WIM_PROVIDER_OVERLAY_ENTRY
PWIM_PROVIDER_OVERLAY_ENTRY = POINTER(_WIM_PROVIDER_OVERLAY_ENTRY)


class _FILE_PROVIDER_EXTERNAL_INFO_V0(ctypes.Structure):
    pass


FILE_PROVIDER_EXTERNAL_INFO_V0 = _FILE_PROVIDER_EXTERNAL_INFO_V0
PFILE_PROVIDER_EXTERNAL_INFO_V0 = POINTER(_FILE_PROVIDER_EXTERNAL_INFO_V0)


class _FILE_PROVIDER_EXTERNAL_INFO_V1(ctypes.Structure):
    pass


FILE_PROVIDER_EXTERNAL_INFO_V1 = _FILE_PROVIDER_EXTERNAL_INFO_V1
PFILE_PROVIDER_EXTERNAL_INFO_V1 = POINTER(_FILE_PROVIDER_EXTERNAL_INFO_V1)


class _CONTAINER_VOLUME_STATE(ctypes.Structure):
    pass


CONTAINER_VOLUME_STATE = _CONTAINER_VOLUME_STATE
PCONTAINER_VOLUME_STATE = POINTER(_CONTAINER_VOLUME_STATE)


class _CONTAINER_ROOT_INFO_INPUT(ctypes.Structure):
    pass


CONTAINER_ROOT_INFO_INPUT = _CONTAINER_ROOT_INFO_INPUT
PCONTAINER_ROOT_INFO_INPUT = POINTER(_CONTAINER_ROOT_INFO_INPUT)


class _CONTAINER_ROOT_INFO_OUTPUT(ctypes.Structure):
    pass


CONTAINER_ROOT_INFO_OUTPUT = _CONTAINER_ROOT_INFO_OUTPUT
PCONTAINER_ROOT_INFO_OUTPUT = POINTER(_CONTAINER_ROOT_INFO_OUTPUT)


class _VIRTUALIZATION_INSTANCE_INFO_INPUT(ctypes.Structure):
    pass


VIRTUALIZATION_INSTANCE_INFO_INPUT = _VIRTUALIZATION_INSTANCE_INFO_INPUT
PVIRTUALIZATION_INSTANCE_INFO_INPUT = POINTER(_VIRTUALIZATION_INSTANCE_INFO_INPUT)


class _VIRTUALIZATION_INSTANCE_INFO_INPUT_EX(ctypes.Structure):
    pass


VIRTUALIZATION_INSTANCE_INFO_INPUT_EX = _VIRTUALIZATION_INSTANCE_INFO_INPUT_EX
PVIRTUALIZATION_INSTANCE_INFO_INPUT_EX = POINTER(_VIRTUALIZATION_INSTANCE_INFO_INPUT_EX)


class _VIRTUALIZATION_INSTANCE_INFO_OUTPUT(ctypes.Structure):
    pass


VIRTUALIZATION_INSTANCE_INFO_OUTPUT = _VIRTUALIZATION_INSTANCE_INFO_OUTPUT
PVIRTUALIZATION_INSTANCE_INFO_OUTPUT = POINTER(_VIRTUALIZATION_INSTANCE_INFO_OUTPUT)


class _GET_FILTER_FILE_IDENTIFIER_INPUT(ctypes.Structure):
    pass


GET_FILTER_FILE_IDENTIFIER_INPUT = _GET_FILTER_FILE_IDENTIFIER_INPUT
PGET_FILTER_FILE_IDENTIFIER_INPUT = POINTER(_GET_FILTER_FILE_IDENTIFIER_INPUT)


class _GET_FILTER_FILE_IDENTIFIER_OUTPUT(ctypes.Structure):
    pass


GET_FILTER_FILE_IDENTIFIER_OUTPUT = _GET_FILTER_FILE_IDENTIFIER_OUTPUT
PGET_FILTER_FILE_IDENTIFIER_OUTPUT = POINTER(_GET_FILTER_FILE_IDENTIFIER_OUTPUT)


class _NETWORK_APP_INSTANCE_EA(ctypes.Structure):
    pass


NETWORK_APP_INSTANCE_EA = _NETWORK_APP_INSTANCE_EA
PNETWORK_APP_INSTANCE_EA = POINTER(_NETWORK_APP_INSTANCE_EA)


class _DISK_EXTENT(ctypes.Structure):
    pass


DISK_EXTENT = _DISK_EXTENT
PDISK_EXTENT = POINTER(_DISK_EXTENT)


class _VOLUME_DISK_EXTENTS(ctypes.Structure):
    pass


VOLUME_DISK_EXTENTS = _VOLUME_DISK_EXTENTS
PVOLUME_DISK_EXTENTS = POINTER(_VOLUME_DISK_EXTENTS)


class _VOLUME_GET_GPT_ATTRIBUTES_INFORMATION(ctypes.Structure):
    pass


VOLUME_GET_GPT_ATTRIBUTES_INFORMATION = _VOLUME_GET_GPT_ATTRIBUTES_INFORMATION
PVOLUME_GET_GPT_ATTRIBUTES_INFORMATION = POINTER(_VOLUME_GET_GPT_ATTRIBUTES_INFORMATION)


class _IO_IRP_EXT_TRACK_OFFSET_HEADER(ctypes.Structure):
    pass


IO_IRP_EXT_TRACK_OFFSET_HEADER = _IO_IRP_EXT_TRACK_OFFSET_HEADER
PIO_IRP_EXT_TRACK_OFFSET_HEADER = POINTER(_IO_IRP_EXT_TRACK_OFFSET_HEADER)



# /* + + BUILD Version: 0031 // Increment this if a change has global effects
# Copyright (c) Microsoft Corporation. All rights reserved. Module Name:
# winioctl.h Abstract: This module defines the 32-Bit Windows Device I/O
# control codes. Revision History: --
# Device interface class GUIDs.
# need these GUIDs outside conditional includes so that user can
# include < winioctl.h > in precompiled header
# include < initguid.h > in a single source file
# include < winioctl.h > in that source file a second time to instantiate the
# GUIDs
if defined(DEFINE_GUID):
    # Make sure FAR is defined...
    if not defined(FAR):
        if defined(_WIN32):
            FAR = VOID
        else:
            FAR = VOID
        # END IF

    # END IF


    if not defined(__WRAPPED__):
        __WRAPPED__ = VOID
    # END IF


    GUID_DEVINTERFACE_DISK = DEFINE_GUID(
        0x53F56307,
        0xB6BF,
        0x11D0,
        0x94,
        0xF2,
        0x00,
        0xA0,
        0xC9,
        0x1E,
        0xFB,
        0x8B
    )
    GUID_DEVINTERFACE_CDROM = DEFINE_GUID(
        0x53F56308,
        0xB6BF,
        0x11D0,
        0x94,
        0xF2,
        0x00,
        0xA0,
        0xC9,
        0x1E,
        0xFB,
        0x8B
    )
    GUID_DEVINTERFACE_PARTITION = DEFINE_GUID(
        0x53F5630A,
        0xB6BF,
        0x11D0,
        0x94,
        0xF2,
        0x00,
        0xA0,
        0xC9,
        0x1E,
        0xFB,
        0x8B
    )
    GUID_DEVINTERFACE_TAPE = DEFINE_GUID(
        0x53F5630B,
        0xB6BF,
        0x11D0,
        0x94,
        0xF2,
        0x00,
        0xA0,
        0xC9,
        0x1E,
        0xFB,
        0x8B
    )
    GUID_DEVINTERFACE_WRITEONCEDISK = DEFINE_GUID(
        0x53F5630C,
        0xB6BF,
        0x11D0,
        0x94,
        0xF2,
        0x00,
        0xA0,
        0xC9,
        0x1E,
        0xFB,
        0x8B
    )
    GUID_DEVINTERFACE_VOLUME = DEFINE_GUID(
        0x53F5630D,
        0xB6BF,
        0x11D0,
        0x94,
        0xF2,
        0x00,
        0xA0,
        0xC9,
        0x1E,
        0xFB,
        0x8B
    )
    GUID_DEVINTERFACE_MEDIUMCHANGER = DEFINE_GUID(
        0x53F56310,
        0xB6BF,
        0x11D0,
        0x94,
        0xF2,
        0x00,
        0xA0,
        0xC9,
        0x1E,
        0xFB,
        0x8B
    )
    GUID_DEVINTERFACE_FLOPPY = DEFINE_GUID(
        0x53F56311,
        0xB6BF,
        0x11D0,
        0x94,
        0xF2,
        0x00,
        0xA0,
        0xC9,
        0x1E,
        0xFB,
        0x8B
    )
    GUID_DEVINTERFACE_CDCHANGER = DEFINE_GUID(
        0x53F56312,
        0xB6BF,
        0x11D0,
        0x94,
        0xF2,
        0x00,
        0xA0,
        0xC9,
        0x1E,
        0xFB,
        0x8B
    )
    GUID_DEVINTERFACE_STORAGEPORT = DEFINE_GUID(
        0x2ACCFE60,
        0xC130,
        0x11D2,
        0xB0,
        0x82,
        0x00,
        0xA0,
        0xC9,
        0x1E,
        0xFB,
        0x8B
    )
    GUID_DEVINTERFACE_VMLUN = DEFINE_GUID(
        0x6F416619,
        0x9F29,
        0x42A5,
        0xB2,
        0x0B,
        0x37,
        0xE2,
        0x19,
        0xCA,
        0x02,
        0xB0
    )
    GUID_DEVINTERFACE_SES = DEFINE_GUID(
        0x1790C9EC,
        0x47D5,
        0x4DF3,
        0xB5,
        0xAF,
        0x9A,
        0xDF,
        0x3C,
        0xF2,
        0x3E,
        0x48
    )
    WDI_STORAGE_PREDICT_FAILURE_DPS_GUID = [
        0xE9F2D03A,
        0x747C,
        0x41C2,
        [0xBB, 0x9A, 0x02, 0xC6, 0x2B, 0x6D, 0x5F, 0xCB]
    ]

    # Interfaces to discover devices that are
    # not reported through conventional APIs
    GUID_DEVINTERFACE_SERVICE_VOLUME = DEFINE_GUID(
        0x6EAD3D82,
        0x25EC,
        0x46BC,
        0xB7,
        0xFD,
        0xC1,
        0xF0,
        0xDF,
        0x8F,
        0x50,
        0x37
    )
    GUID_DEVINTERFACE_HIDDEN_VOLUME = DEFINE_GUID(
        0x7F108A28,
        0x9833,
        0x4B3B,
        0xB7,
        0x80,
        0x2C,
        0x6B,
        0x5F,
        0xA5,
        0xC0,
        0x62
    )

    # Interface to register for RPMB commands
    GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB = DEFINE_GUID(
        0x27447C21,
        0xBCC3,
        0x4D07,
        0xA0,
        0x5B,
        0xA3,
        0x39,
        0x5B,
        0xB4,
        0xEE,
        0xE7
    )

    # {86E0D1E0-8089-11D0-9CE4-08003E301F73}
    GUID_DEVINTERFACE_COMPORT = DEFINE_GUID(
        0x86E0D1E0,
        0x8089,
        0x11D0,
        0x9C,
        0xE4,
        0x08,
        0x00,
        0x3E,
        0x30,
        0x1F,
        0x73
    )

    # {4D36E978-E325-11CE-BFC1-08002BE10318}
    GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR = DEFINE_GUID(
        0x4D36E978,
        0xE325,
        0x11CE,
        0xBF,
        0xC1,
        0x08,
        0x00,
        0x2B,
        0xE1,
        0x03,
        0x18
    )

    # Obsolete device interface class GUID names.
    # (use of above GUID_DEVINTERFACE_* names is recommended).
    if not defined(__WRAPPED__):
        __WRAPPED__ = VOID
    # END IF


    DiskClassGuid = GUID_DEVINTERFACE_DISK
    CdRomClassGuid = GUID_DEVINTERFACE_CDROM
    PartitionClassGuid = GUID_DEVINTERFACE_PARTITION
    TapeClassGuid = GUID_DEVINTERFACE_TAPE
    WriteOnceDiskClassGuid = GUID_DEVINTERFACE_WRITEONCEDISK
    VolumeClassGuid = GUID_DEVINTERFACE_VOLUME
    MediumChangerClassGuid = GUID_DEVINTERFACE_MEDIUMCHANGER
    FloppyClassGuid = GUID_DEVINTERFACE_FLOPPY
    CdChangerClassGuid = GUID_DEVINTERFACE_CDCHANGER
    StoragePortClassGuid = GUID_DEVINTERFACE_STORAGEPORT
    HiddenVolumeClassGuid = GUID_DEVINTERFACE_HIDDEN_VOLUME
    GUID_CLASS_COMPORT = GUID_DEVINTERFACE_COMPORT
    GUID_SERENUM_BUS_ENUMERATOR = GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR
# END IF   DEFINE_GUID

# Interface DEVPROPKEY
# need these DEVPROPKEYs outside conditional includes so that user can
# include < winioctl.h > in precompiled header
# include < devpropdef.h > in a single source file
# include < winioctl.h > in that source file a second time to instantiate the
# DEVPROPKEYs
if defined(DEFINE_DEVPROPKEY):
    if not defined(__WRAPPED__):
        __WRAPPED__ = VOID
    # END IF

    # Properties associated with the volume interface.
    DEVPKEY_Storage_Portable = DEFINE_DEVPROPKEY(
        0x4D1EBEE8,
        0x803,
        0x4774,
        0x98,
        0x42,
        0xB7,
        0x7D,
        0xB5,
        0x2,
        0x65,
        0xE9
    )
    DEVPKEY_Storage_Removable_Media = DEFINE_DEVPROPKEY(
        0x4D1EBEE8,
        0x803,
        0x4774,
        0x98,
        0x42,
        0xB7,
        0x7D,
        0xB5,
        0x2,
        0x65,
        0xE9
    )
    DEVPKEY_Storage_System_Critical = DEFINE_DEVPROPKEY(
        0x4D1EBEE8,
        0x803,
        0x4774,
        0x98,
        0x42,
        0xB7,
        0x7D,
        0xB5,
        0x2,
        0x65,
        0xE9
    )
    DEVPKEY_Storage_Disk_Number = DEFINE_DEVPROPKEY(
        0x4D1EBEE8,
        0x803,
        0x4774,
        0x98,
        0x42,
        0xB7,
        0x7D,
        0xB5,
        0x2,
        0x65,
        0xE9
    )
    DEVPKEY_Storage_Partition_Number = DEFINE_DEVPROPKEY(
        0x4D1EBEE8,
        0x803,
        0x4774,
        0x98,
        0x42,
        0xB7,
        0x7D,
        0xB5,
        0x2,
        0x65,
        0xE9
    )
    DEVPKEY_Storage_Mbr_Type = DEFINE_DEVPROPKEY(
        0x4D1EBEE8,
        0x803,
        0x4774,
        0x98,
        0x42,
        0xB7,
        0x7D,
        0xB5,
        0x2,
        0x65,
        0xE9
    )
    DEVPKEY_Storage_Gpt_Type = DEFINE_DEVPROPKEY(
        0x4D1EBEE8,
        0x803,
        0x4774,
        0x98,
        0x42,
        0xB7,
        0x7D,
        0xB5,
        0x2,
        0x65,
        0xE9
    )
    DEVPKEY_Storage_Gpt_Name = DEFINE_DEVPROPKEY(
        0x4D1EBEE8,
        0x803,
        0x4774,
        0x98,
        0x42,
        0xB7,
        0x7D,
        0xB5,
        0x2,
        0x65,
        0xE9
    )
# END IF   DEFINE_DEVPROPKEY

if not defined(_WINIOCTL_):
    _WINIOCTL_ = VOID
    if _MSC_VER  >= 1200:
        pass
    # END IF

    if not defined(_DEVIOCTL_):
        _DEVIOCTL_ = VOID

        # begin_ntddk begin_wdm begin_nthal begin_ntifs
        # Define the various device type values. Note that values used by
        # Microsoft
        # Corporation are in the range 0-32767, and 32768-65535 are reserved
        # for use
        # by customers.
        DEVICE_TYPE = DWORD
        FILE_DEVICE_BEEP = 0x00000001
        FILE_DEVICE_CD_ROM = 0x00000002
        FILE_DEVICE_CD_ROM_FILE_SYSTEM = 0x00000003
        FILE_DEVICE_CONTROLLER = 0x00000004
        FILE_DEVICE_DATALINK = 0x00000005
        FILE_DEVICE_DFS = 0x00000006
        FILE_DEVICE_DISK = 0x00000007
        FILE_DEVICE_DISK_FILE_SYSTEM = 0x00000008
        FILE_DEVICE_FILE_SYSTEM = 0x00000009
        FILE_DEVICE_INPORT_PORT = 0x0000000A
        FILE_DEVICE_KEYBOARD = 0x0000000B
        FILE_DEVICE_MAILSLOT = 0x0000000C
        FILE_DEVICE_MIDI_IN = 0x0000000D
        FILE_DEVICE_MIDI_OUT = 0x0000000E
        FILE_DEVICE_MOUSE = 0x0000000F
        FILE_DEVICE_MULTI_UNC_PROVIDER = 0x00000010
        FILE_DEVICE_NAMED_PIPE = 0x00000011
        FILE_DEVICE_NETWORK = 0x00000012
        FILE_DEVICE_NETWORK_BROWSER = 0x00000013
        FILE_DEVICE_NETWORK_FILE_SYSTEM = 0x00000014
        FILE_DEVICE_NULL = 0x00000015
        FILE_DEVICE_PARALLEL_PORT = 0x00000016
        FILE_DEVICE_PHYSICAL_NETCARD = 0x00000017
        FILE_DEVICE_PRINTER = 0x00000018
        FILE_DEVICE_SCANNER = 0x00000019
        FILE_DEVICE_SERIAL_MOUSE_PORT = 0x0000001A
        FILE_DEVICE_SERIAL_PORT = 0x0000001B
        FILE_DEVICE_SCREEN = 0x0000001C
        FILE_DEVICE_SOUND = 0x0000001D
        FILE_DEVICE_STREAMS = 0x0000001E
        FILE_DEVICE_TAPE = 0x0000001F
        FILE_DEVICE_TAPE_FILE_SYSTEM = 0x00000020
        FILE_DEVICE_TRANSPORT = 0x00000021
        FILE_DEVICE_UNKNOWN = 0x00000022
        FILE_DEVICE_VIDEO = 0x00000023
        FILE_DEVICE_VIRTUAL_DISK = 0x00000024
        FILE_DEVICE_WAVE_IN = 0x00000025
        FILE_DEVICE_WAVE_OUT = 0x00000026
        FILE_DEVICE_8042_PORT = 0x00000027
        FILE_DEVICE_NETWORK_REDIRECTOR = 0x00000028
        FILE_DEVICE_BATTERY = 0x00000029
        FILE_DEVICE_BUS_EXTENDER = 0x0000002A
        FILE_DEVICE_MODEM = 0x0000002B
        FILE_DEVICE_VDM = 0x0000002C
        FILE_DEVICE_MASS_STORAGE = 0x0000002D
        FILE_DEVICE_SMB = 0x0000002E
        FILE_DEVICE_KS = 0x0000002F
        FILE_DEVICE_CHANGER = 0x00000030
        FILE_DEVICE_SMARTCARD = 0x00000031
        FILE_DEVICE_ACPI = 0x00000032
        FILE_DEVICE_DVD = 0x00000033
        FILE_DEVICE_FULLSCREEN_VIDEO = 0x00000034
        FILE_DEVICE_DFS_FILE_SYSTEM = 0x00000035
        FILE_DEVICE_DFS_VOLUME = 0x00000036
        FILE_DEVICE_SERENUM = 0x00000037
        FILE_DEVICE_TERMSRV = 0x00000038
        FILE_DEVICE_KSEC = 0x00000039
        FILE_DEVICE_FIPS = 0x0000003A
        FILE_DEVICE_INFINIBAND = 0x0000003B
        FILE_DEVICE_VMBUS = 0x0000003E
        FILE_DEVICE_CRYPT_PROVIDER = 0x0000003F
        FILE_DEVICE_WPD = 0x00000040
        FILE_DEVICE_BLUETOOTH = 0x00000041
        FILE_DEVICE_MT_COMPOSITE = 0x00000042
        FILE_DEVICE_MT_TRANSPORT = 0x00000043
        FILE_DEVICE_BIOMETRIC = 0x00000044
        FILE_DEVICE_PMI = 0x00000045
        FILE_DEVICE_EHSTOR = 0x00000046
        FILE_DEVICE_DEVAPI = 0x00000047
        FILE_DEVICE_GPIO = 0x00000048
        FILE_DEVICE_USBEX = 0x00000049
        FILE_DEVICE_CONSOLE = 0x00000050
        FILE_DEVICE_NFP = 0x00000051
        FILE_DEVICE_SYSENV = 0x00000052
        FILE_DEVICE_VIRTUAL_BLOCK = 0x00000053
        FILE_DEVICE_POINT_OF_SERVICE = 0x00000054
        FILE_DEVICE_STORAGE_REPLICATION = 0x00000055
        FILE_DEVICE_TRUST_ENV = 0x00000056
        FILE_DEVICE_UCM = 0x00000057
        FILE_DEVICE_UCMTCPCI = 0x00000058
        FILE_DEVICE_PERSISTENT_MEMORY = 0x00000059
        FILE_DEVICE_NVDIMM = 0x0000005A
        FILE_DEVICE_HOLOGRAPHIC = 0x0000005B
        FILE_DEVICE_SDFXHCI = 0x0000005C


        # Macro definition for defining IOCTL and FSCTL function control
        # codes. Note
        # that function codes 0-2047 are reserved for Microsoft Corporation,
        # and
        # 2048-4095 are reserved for customers.
        def CTL_CODE(DeviceType, Function, Method, Access):
            return (
                (DeviceType << 16) |
                (Access << 14) |
                (Function << 2) |
                Method
            )


        # Macro to extract device type out of the device io control code
        def DEVICE_TYPE_FROM_CTL_CODE(ctrlCode):
            return (ctrlCode & 0xFFFF0000) >> 16


        # Macro to extract buffering method out of the device io control code
        def METHOD_FROM_CTL_CODE(ctrlCode):
            return ctrlCode & 3


        # Define the method codes for how buffers are passed for I/O and FS
        # controls
        METHOD_BUFFERED = 0
        METHOD_IN_DIRECT = 1
        METHOD_OUT_DIRECT = 2
        METHOD_NEITHER = 3


        # Define some easier to comprehend aliases:
        # METHOD_DIRECT_TO_HARDWARE (writes, aka METHOD_IN_DIRECT)
        # METHOD_DIRECT_FROM_HARDWARE (reads, aka METHOD_OUT_DIRECT)
        METHOD_DIRECT_TO_HARDWARE = METHOD_IN_DIRECT
        METHOD_DIRECT_FROM_HARDWARE = METHOD_OUT_DIRECT


        # Define the access check value for any access
        # The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also
        # defined in
        # ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
        # constants *MUST* always be in sync.
        # FILE_SPECIAL_ACCESS is checked by the NT I/O system the same as
        # FILE_ANY_ACCESS.
        # The file systems, however, may add additional access checks for I/O
        # and FS controls
        # that use this value.
        FILE_ANY_ACCESS = 0
        FILE_SPECIAL_ACCESS = FILE_ANY_ACCESS

        # file & pipe
        FILE_READ_ACCESS = 0x0001

        # file & pipe
        FILE_WRITE_ACCESS = 0x0002

        # end_ntddk end_wdm end_nthal end_ntifs    # END IF   _DEVIOCTL_
    if not defined(__WRAPPED__):
        __WRAPPED__ = VOID
    # END IF


    if not defined(_NTDDSTOR_H_):
        _NTDDSTOR_H_ = VOID
        if defined(__cplusplus) and not defined(__ALT_GENERATOR__):
            pass
        # END IF

        if _MSC_VER  >= 1200:
            pass
        # END IF

        # IoControlCode values for storage devices
        IOCTL_STORAGE_BASE = FILE_DEVICE_MASS_STORAGE

        # The following device control codes are common for all class drivers.
        # They
        # should be used in place of the older IOCTL_DISK, IOCTL_CDROM and
        # IOCTL_TAPE
        # common codes
        IOCTL_STORAGE_CHECK_VERIFY = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0200,
            METHOD_BUFFERED,
            FILE_READ_ACCESS,
        )
        IOCTL_STORAGE_CHECK_VERIFY2 = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0200,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )
        IOCTL_STORAGE_MEDIA_REMOVAL = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0201,
            METHOD_BUFFERED,
            FILE_READ_ACCESS,
        )
        IOCTL_STORAGE_EJECT_MEDIA = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0202,
            METHOD_BUFFERED,
            FILE_READ_ACCESS,
        )
        IOCTL_STORAGE_LOAD_MEDIA = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0203,
            METHOD_BUFFERED,
            FILE_READ_ACCESS,
        )
        IOCTL_STORAGE_LOAD_MEDIA2 = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0203,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )
        IOCTL_STORAGE_RESERVE = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0204,
            METHOD_BUFFERED,
            FILE_READ_ACCESS,
        )
        IOCTL_STORAGE_RELEASE = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0205,
            METHOD_BUFFERED,
            FILE_READ_ACCESS,
        )
        IOCTL_STORAGE_FIND_NEW_DEVICES = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0206,
            METHOD_BUFFERED,
            FILE_READ_ACCESS,
        )
        IOCTL_STORAGE_EJECTION_CONTROL = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0250,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )
        IOCTL_STORAGE_MCN_CONTROL = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0251,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )
        IOCTL_STORAGE_GET_MEDIA_TYPES = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0300,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )
        IOCTL_STORAGE_GET_MEDIA_TYPES_EX = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0301,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )
        IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0304,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )
        IOCTL_STORAGE_GET_HOTPLUG_INFO = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0305,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )
        IOCTL_STORAGE_SET_HOTPLUG_INFO = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0306,
            METHOD_BUFFERED,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS
        )
        IOCTL_STORAGE_RESET_BUS = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0400,
            METHOD_BUFFERED,
            FILE_READ_ACCESS,
        )
        IOCTL_STORAGE_RESET_DEVICE = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0401,
            METHOD_BUFFERED,
            FILE_READ_ACCESS,
        )
        IOCTL_STORAGE_BREAK_RESERVATION = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0405,
            METHOD_BUFFERED,
            FILE_READ_ACCESS,
        )
        IOCTL_STORAGE_PERSISTENT_RESERVE_IN = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0406,
            METHOD_BUFFERED,
            FILE_READ_ACCESS,
        )
        IOCTL_STORAGE_PERSISTENT_RESERVE_OUT = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0407,
            METHOD_BUFFERED,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS
        )
        IOCTL_STORAGE_GET_DEVICE_NUMBER = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0420,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )


        # This IOCTL includes the same information as
        # IOCTL_STORAGE_GET_DEVICE_NUMBER, plus the device GUID.
        IOCTL_STORAGE_GET_DEVICE_NUMBER_EX = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0421,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )
        IOCTL_STORAGE_PREDICT_FAILURE = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0440,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )
        IOCTL_STORAGE_FAILURE_PREDICTION_CONFIG = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0441,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )


        # This IOCTL retrieves reliability counters for a device.
        IOCTL_STORAGE_GET_COUNTERS = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x442,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )
        IOCTL_STORAGE_READ_CAPACITY = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0450,
            METHOD_BUFFERED,
            FILE_READ_ACCESS,
        )

        # IOCTLs 0x0463 to 0x0468 reserved for dependent disk support.
        # IOCTLs 0x0470 to 0x047f reserved for device and stack telemetry
        # interfaces
        IOCTL_STORAGE_GET_DEVICE_TELEMETRY = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0470,
            METHOD_BUFFERED,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS,
        )
        IOCTL_STORAGE_DEVICE_TELEMETRY_NOTIFY = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0471,
            METHOD_BUFFERED,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS,
        )
        IOCTL_STORAGE_DEVICE_TELEMETRY_QUERY_CAPS = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0472,
            METHOD_BUFFERED,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS,
        )
        IOCTL_STORAGE_GET_DEVICE_TELEMETRY_RAW = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0473,
            METHOD_BUFFERED,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS,
        )
        IOCTL_STORAGE_SET_TEMPERATURE_THRESHOLD = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0480,
            METHOD_BUFFERED,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS,
        )
        IOCTL_STORAGE_PROTOCOL_COMMAND = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x04F0,
            METHOD_BUFFERED,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS,
        )
        IOCTL_STORAGE_QUERY_PROPERTY = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0500,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )
        IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0501,
            METHOD_BUFFERED,
            FILE_WRITE_ACCESS,
        )
        IOCTL_STORAGE_GET_LB_PROVISIONING_MAP_RESOURCES = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0502,
            METHOD_BUFFERED,
            FILE_READ_ACCESS,
        )
        IOCTL_STORAGE_SET_PROPERTY = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0503,
            METHOD_BUFFERED,
            FILE_WRITE_ACCESS,
        )


        # IOCTLs 0x0503 to 0x0580 reserved for Enhanced Storage devices.
        # This IOCTL offloads the erasure process to the storage device. There
        # is no guarantee as to the successful
        # deletion or recoverability of the data on the storage device after
        # command completion. This IOCTL is limited
        # to data disks in regular Windows. In WinPE, this IOCTL is supported
        # for both boot and data disks.
        # Initial implementation requires no input and returns no output other
        # than status. Callers should first
        # call FSCTL_LOCK_VOLUME before calling this ioctl to flush out cached
        # data in upper layers. No waiting of
        # outstanding request completion is done before issuing the command to
        # the device.
        IOCTL_STORAGE_REINITIALIZE_MEDIA = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0590,
            METHOD_BUFFERED,
            FILE_WRITE_ACCESS,
        )

        # IOCTLs for bandwidth contracts on storage devices
        # (Move this to ntddsfio if we decide to use a new base)
        IOCTL_STORAGE_GET_BC_PROPERTIES = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0600,
            METHOD_BUFFERED,
            FILE_READ_ACCESS,
        )
        IOCTL_STORAGE_ALLOCATE_BC_STREAM = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0601,
            METHOD_BUFFERED,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS
        )
        IOCTL_STORAGE_FREE_BC_STREAM = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0602,
            METHOD_BUFFERED,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS
        )

        # IOCTL to check for priority support
        IOCTL_STORAGE_CHECK_PRIORITY_HINT_SUPPORT = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0620,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )

        # IOCTL for data integrity check support
        IOCTL_STORAGE_START_DATA_INTEGRITY_CHECK = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0621,
            METHOD_BUFFERED,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS
        )
        IOCTL_STORAGE_STOP_DATA_INTEGRITY_CHECK = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0622,
            METHOD_BUFFERED,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS
        )

        # These ioctl codes are obsolete. They are defined here to avoid
        # resuing them
        # and to allow class drivers to respond to them more easily.
        OBSOLETE_IOCTL_STORAGE_RESET_BUS = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0400,
            METHOD_BUFFERED,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS
        )
        OBSOLETE_IOCTL_STORAGE_RESET_DEVICE = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0401,
            METHOD_BUFFERED,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS
        )

        # IOCTLs 0x0643 to 0x0655 reserved for VHD disk support.
        # IOCTLs for firmware upgrade on storage devices
        IOCTL_STORAGE_FIRMWARE_GET_INFO = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0700,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )
        IOCTL_STORAGE_FIRMWARE_DOWNLOAD = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0701,
            METHOD_BUFFERED,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS
        )
        IOCTL_STORAGE_FIRMWARE_ACTIVATE = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0702,
            METHOD_BUFFERED,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS
        )

        # IOCTL to support Idle Power Management, including Device Wake
        IOCTL_STORAGE_ENABLE_IDLE_POWER = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0720,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )
        IOCTL_STORAGE_GET_IDLE_POWERUP_REASON = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0721,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )

        # IOCTLs to allow class drivers to acquire and release active
        # references on
        # a unit. These should only be used if the class driver previously
        # sent a
        # successful IOCTL_STORAGE_ENABLE_IDLE_POWER request to the port
        # driver.
        IOCTL_STORAGE_POWER_ACTIVE = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0722,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )
        IOCTL_STORAGE_POWER_IDLE = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0723,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )

        # This IOCTL indicates that the physical device has triggered some
        # sort of event.
        IOCTL_STORAGE_EVENT_NOTIFICATION = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0724,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )

        # IOCTL to specify a power cap for a storage device.
        IOCTL_STORAGE_DEVICE_POWER_CAP = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0725,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )

        # IOCTL to send commands to the RPMB for a storage device.
        IOCTL_STORAGE_RPMB_COMMAND = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0726,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )

        # IOCTL to manage attributes for storage devices
        IOCTL_STORAGE_ATTRIBUTE_MANAGEMENT = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0727,
            METHOD_BUFFERED,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS
        )

        # IOCTL_STORAGE_DIAGNOSTIC IOCTL to query diagnostic data from the
        # storage driver stack
        IOCTL_STORAGE_DIAGNOSTIC = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0728,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )

        # IOCTLs for storage device depopulation support.
        # IOCTL_STORAGE_GET_PHYSICAL_ELEMENT_STATUS IOCTL to query physical
        # element status from device.
        IOCTL_STORAGE_GET_PHYSICAL_ELEMENT_STATUS = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0729,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )

        # IOCTL_STORAGE_REMOVE_ELEMENT_AND_TRUNCATE IOCTL to remove and
        # truncate element from device.
        IOCTL_STORAGE_REMOVE_ELEMENT_AND_TRUNCATE = CTL_CODE(
            IOCTL_STORAGE_BASE,
            0x0730,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )

        # Note: Function code values of less than 0x800 are reserved for
        # Microsoft. Values of 0x800 and higher can be used by vendors.
        # So do not use function code of 0x800 and higher to define new IOCTLs
        # in this file.
        # IOCTL_STORAGE_GET_HOTPLUG_INFO
        # version
        _STORAGE_HOTPLUG_INFO._fields_ = [
            ('Size', DWORD),
            # ie. zip, jaz, cdrom, mo, etc. vs hdd
            ('MediaRemovable', BOOLEAN),
            # ie. does the device succeed a lock even though its not lockable
            # media?
            ('MediaHotplug', BOOLEAN),
            # ie. 1394, USB, etc.
            ('DeviceHotplug', BOOLEAN),
            # This field should not be relied upon because it is no longer used
            ('WriteCacheEnableOverride', BOOLEAN),
        ]

        # IOCTL_STORAGE_GET_DEVICE_NUMBER
        # input - none
        # output - STORAGE_DEVICE_NUMBER structure
        # The values in the STORAGE_DEVICE_NUMBER structure are guaranteed
        # to remain unchanged until the system is rebooted. They are not
        # guaranteed to be persistant across boots.
        _STORAGE_DEVICE_NUMBER._fields_ = [
            # The FILE_DEVICE_XXX type for this device.
            ('DeviceType', DEVICE_TYPE),
            # The number of this device
            ('DeviceNumber', DWORD),
            # Otherwise -1
            ('PartitionNumber', DWORD),
        ]

        _STORAGE_DEVICE_NUMBERS._fields_ = [
            ('NumberOfDevices', DWORD),
            ('Devices', STORAGE_DEVICE_NUMBER * ANYSIZE_ARRAY),
        ]

        # IOCTL_STORAGE_GET_DEVICE_NUMBER_EX
        # input - none
        # output - STORAGE_DEVICE_NUMBER_EX structure
        # Possible flags that can be set in Flags field of
        # STORAGE_DEVICE_NUMBER_EX structure defined below
        # This flag indicates that deviceguid is randomly created because a
        # deviceguid conflict was observed
        STORAGE_DEVICE_FLAGS_RANDOM_DEVICEGUID_REASON_CONFLICT = 0x1

        # This flag indicates that deviceguid is randomly created because the
        # HW ID was not available
        STORAGE_DEVICE_FLAGS_RANDOM_DEVICEGUID_REASON_NOHWID = 0x2

        # This flag indicates that deviceguid is created from the scsi page83
        # data.
        # If this flag is not set this implies it's created from serial number
        # or is randomly generated.
        STORAGE_DEVICE_FLAGS_PAGE_83_DEVICEGUID = 0x4


        _STORAGE_DEVICE_NUMBER_EX._fields_ = [
            # Sizeof(STORAGE_DEVICE_NUMBER_EX).
            ('Version', DWORD),
            # this will always be the same as
            # (ctypes.sizeof(STORAGE_DEVICE_NUMBER_EX).
            ('Size', DWORD),
            # that gives more information about the members of this structure.
            ('Flags', DWORD),
            # supported for disk devices.
            ('DeviceType', DEVICE_TYPE),
            # The number of this device.
            ('DeviceNumber', DWORD),
            # A random GUID is not persisted and will not be the same after a
            # reboot.
            ('DeviceGuid', GUID),
            # Otherwise -1.
            ('PartitionNumber', DWORD),
        ]
        # Define the structures for scsi resets
        _STORAGE_BUS_RESET_REQUEST._fields_ = [
            ('PathId', BYTE),
        ]
        # Break reservation is sent to the Adapter/FDO with the given lun
        # information.
        STORAGE_BREAK_RESERVATION_REQUEST._fields_ = [
            ('Length', DWORD),
            ('_unused', BYTE),
            ('PathId', BYTE),
            ('TargetId', BYTE),
            ('Lun', BYTE),
        ]
        # IOCTL_STORAGE_MEDIA_REMOVAL disables the mechanism
        # on a storage device that ejects media. This function
        # may or may not be supported on storage devices that
        # support removable media.
        # TRUE means prevent media from being removed.
        # FALSE means allow media removal.
        _PREVENT_MEDIA_REMOVAL._fields_ = [
            ('PreventMediaRemoval', BOOLEAN),
        ]
        # This is the format of
        # TARGET_DEVICE_CUSTOM_NOTIFICATION.CustomDataBuffer
        # passed to applications by the classpnp autorun code
        # (via IoReportTargetDeviceChangeAsynchronous).
        _CLASS_MEDIA_CHANGE_CONTEXT._fields_ = [
            ('MediaChangeCount', DWORD),
            # see MEDIA_CHANGE_DETECTION_STATE enum in classpnp.h in DDK
            ('NewState', DWORD),
        ]
        # begin_ntminitape
        if not defined(__WRAPPED__):
            __WRAPPED__ = VOID
        # END IF

        _TAPE_STATISTICS._fields_ = [
            ('Version', DWORD),
            ('Flags', DWORD),
            ('RecoveredWrites', LARGE_INTEGER),
            ('UnrecoveredWrites', LARGE_INTEGER),
            ('RecoveredReads', LARGE_INTEGER),
            ('UnrecoveredReads', LARGE_INTEGER),
            ('CompressionRatioReads', BYTE),
            ('CompressionRatioWrites', BYTE),
        ]
        RECOVERED_WRITES_VALID = 0x00000001
        UNRECOVERED_WRITES_VALID = 0x00000002
        RECOVERED_READS_VALID = 0x00000004
        UNRECOVERED_READS_VALID = 0x00000008
        WRITE_COMPRESSION_INFO_VALID = 0x00000010
        READ_COMPRESSION_INFO_VALID = 0x00000020


        _TAPE_GET_STATISTICS._fields_ = [
            ('Operation', DWORD),
        ]
        TAPE_RETURN_STATISTICS = 0L
        TAPE_RETURN_ENV_INFO = 1L
        TAPE_RESET_STATISTICS = 2L

        # IOCTL_STORAGE_GET_MEDIA_TYPES_EX will return an array of
        # DEVICE_MEDIA_INFO
        # structures, one per supported type, embedded in the GET_MEDIA_TYPES
        # struct.
        class _STORAGE_MEDIA_TYPE(ENUM):
            DDS_4mm = 0x20
            MiniQic = 33
            Travan = 34
            QIC = 35
            MP_8mm = 36
            AME_8mm = 37
            AIT1_8mm = 38
            DLT = 39
            NCTP = 40
            IBM_3480 = 41
            IBM_3490E = 42
            IBM_Magstar_3590 = 43
            IBM_Magstar_MP = 44
            STK_DATA_D3 = 45
            SONY_DTF = 46
            DV_6mm = 47
            DMI = 48
            SONY_D2 = 49
            CLEANER_CARTRIDGE = 50
            CD_ROM = 51
            CD_R = 52
            CD_RW = 53
            DVD_ROM = 54
            DVD_R = 55
            DVD_RW = 56
            MO_3_RW = 57
            MO_5_WO = 58
            MO_5_RW = 59
            MO_5_LIMDOW = 60
            PC_5_WO = 61
            PC_5_RW = 62
            PD_5_RW = 63
            ABL_5_WO = 64
            PINNACLE_APEX_5_RW = 65
            SONY_12_WO = 66
            PHILIPS_12_WO = 67
            HITACHI_12_WO = 68
            CYGNET_12_WO = 69
            KODAK_14_WO = 70
            MO_NFR_525 = 71
            NIKON_12_RW = 72
            IOMEGA_ZIP = 73
            IOMEGA_JAZ = 74
            SYQUEST_EZ135 = 75
            SYQUEST_EZFLYER = 76
            SYQUEST_SYJET = 77
            AVATAR_F2 = 78
            MP2_8mm = 79
            DST_S = 80
            DST_M = 81
            DST_L = 82
            VXATape_1 = 83
            VXATape_2 = 84
            if NTDDI_VERSION  <  NTDDI_WINXP:
                STK_EAGLE = 85
            else:
                STK_9840 = 86
            # END IF

            LTO_Ultrium = 87
            LTO_Accelis = 88
            DVD_RAM = 89
            AIT_8mm = 90
            ADR_1 = 91
            ADR_2 = 92
            STK_9940 = 93
            SAIT = 94
            VXATape = 95


        STORAGE_MEDIA_TYPE = _STORAGE_MEDIA_TYPE
        PSTORAGE_MEDIA_TYPE = POINTER(_STORAGE_MEDIA_TYPE)

        MEDIA_ERASEABLE = 0x00000001
        MEDIA_WRITE_ONCE = 0x00000002
        MEDIA_READ_ONLY = 0x00000004
        MEDIA_READ_WRITE = 0x00000008
        MEDIA_WRITE_PROTECTED = 0x00000100
        MEDIA_CURRENTLY_MOUNTED = 0x80000000


        # Define the different storage bus types
        # Bus types below 128 (0x80) are reserved for Microsoft use
        class _STORAGE_BUS_TYPE(ENUM):
            BusTypeUnknown = 0x00
            BusTypeScsi = 1
            BusTypeAtapi = 2
            BusTypeAta = 3
            BusType1394 = 4
            BusTypeSsa = 5
            BusTypeFibre = 6
            BusTypeUsb = 7
            BusTypeRAID = 8
            BusTypeiScsi = 9
            BusTypeSas = 10
            BusTypeSata = 11
            BusTypeSd = 12
            BusTypeMmc = 13
            BusTypeVirtual = 14
            BusTypeFileBackedVirtual = 15
            BusTypeSpaces = 16
            BusTypeNvme = 17
            BusTypeSCM = 18
            BusTypeUfs = 19
            BusTypeMax = 20
            BusTypeMaxReserved = 0x7F

        STORAGE_BUS_TYPE = _STORAGE_BUS_TYPE
        PSTORAGE_BUS_TYPE = POINTER(_STORAGE_BUS_TYPE)


        # Macro to identify which bus types
        # support shared storage
        def SupportsDeviceSharing(BusType):
            return BusType in (
                BusTypeScsi,
                BusTypeFibre,
                BusTypeiScsi,
                BusTypeSas,
                BusTypeSpaces
            )


        class DeviceSpecific(ctypes.Union):
            pass


        class DiskInfo(ctypes.Structure):
            pass


        DiskInfo._fields_ = [
            ('Cylinders', LARGE_INTEGER),
            ('MediaType', STORAGE_MEDIA_TYPE),
            ('TracksPerCylinder', DWORD),
            ('SectorsPerTrack', DWORD),
            ('BytesPerSector', DWORD),
            ('NumberMediaSides', DWORD),
            # Bitmask of MEDIA_XXX values.
            ('MediaCharacteristics', DWORD),
        ]
        DeviceSpecific.DiskInfo = DiskInfo


        class RemovableDiskInfo(ctypes.Structure):
            pass


        RemovableDiskInfo._fields_ = [
            ('Cylinders', LARGE_INTEGER),
            ('MediaType', STORAGE_MEDIA_TYPE),
            ('TracksPerCylinder', DWORD),
            ('SectorsPerTrack', DWORD),
            ('BytesPerSector', DWORD),
            ('NumberMediaSides', DWORD),
            # Bitmask of MEDIA_XXX values.
            ('MediaCharacteristics', DWORD),
        ]
        DeviceSpecific.RemovableDiskInfo = RemovableDiskInfo


        class TapeInfo(ctypes.Structure):
            pass


        class BusSpecificData(ctypes.Union):
            pass


        class ScsiInformation(ctypes.Structure):
            pass


        ScsiInformation._fields_ = [
            ('MediumType', BYTE),
            ('DensityCode', BYTE),
        ]
        BusSpecificData.ScsiInformation = ScsiInformation


        BusSpecificData._fields_ = [
            ('ScsiInformation', BusSpecificData.ScsiInformation),
        ]
        TapeInfo.BusSpecificData = BusSpecificData


        TapeInfo._fields_ = [
            ('MediaType', STORAGE_MEDIA_TYPE),
            # Bitmask of MEDIA_XXX values.
            ('MediaCharacteristics', DWORD),
            ('CurrentBlockSize', DWORD),
            ('BusType', STORAGE_BUS_TYPE),
            # Bus specific information describing the medium supported.
            ('BusSpecificData', TapeInfo.BusSpecificData),
        ]
        DeviceSpecific.TapeInfo = TapeInfo


        DeviceSpecific._fields_ = [
            ('DiskInfo', DeviceSpecific.DiskInfo),
            ('RemovableDiskInfo', DeviceSpecific.RemovableDiskInfo),
            ('TapeInfo', DeviceSpecific.TapeInfo),
        ]
        _DEVICE_MEDIA_INFO.DeviceSpecific = DeviceSpecific


        _DEVICE_MEDIA_INFO._fields_ = [
            ('DeviceSpecific', _DEVICE_MEDIA_INFO.DeviceSpecific),
        ]

        # FILE_DEVICE_XXX values
        _GET_MEDIA_TYPES._fields_ = [
            ('DeviceType', DWORD),
            ('MediaInfoCount', DWORD),
            ('MediaInfo', DEVICE_MEDIA_INFO * 1),
        ]


        # IOCTL_STORAGE_PREDICT_FAILURE
        # input - none
        # output - STORAGE_PREDICT_FAILURE structure
        # PredictFailure returns zero if no failure predicted and non zero
        # if a failure is predicted.
        # VendorSpecific returns 512 bytes of vendor specific information
        # if a failure is predicted
        _STORAGE_PREDICT_FAILURE._fields_ = [
            ('PredictFailure', DWORD),
            ('VendorSpecific', BYTE * 512),
        ]

        # IOCTL_STORAGE_FAILURE_PREDICTION_CONFIG
        # Input - STORAGE_FAILURE_PREDICTION_CONFIG structure.
        # If the sender wants to enable or disable failure prediction then
        # the sender should set the "Set" field to TRUE.
        # Output - STORAGE_FAILURE_PREDICTION_CONFIG structure.
        # If successful, the "Enabled" field will indicate if failure
        # prediction is currently enabled or not.
        # Set to 1 for Blue.
        _STORAGE_FAILURE_PREDICTION_CONFIG._fields_ = [
            ('Version', DWORD),
            ('Size', DWORD),
            # TRUE if the sender wants to enable/disable failure prediction.
            ('Set', BOOLEAN),
            ('Enabled', BOOLEAN),
            ('Reserved', WORD),
        ]
        STORAGE_FAILURE_PREDICTION_CONFIG_V1 = 1

        # end_ntminitape
        # Property Query Structures
        # IOCTL_STORAGE_QUERY_PROPERTY
        # Input Buffer:
        # a STORAGE_PROPERTY_QUERY structure which describes what type of query
        # is being done, what property is being queried for, and any additional
        # parameters which a particular property query requires.
        # Output Buffer:
        # Contains a buffer to place the results of the query into. Since all
        # property descriptors can be cast into a STORAGE_DESCRIPTOR_HEADER,
        # the IOCTL can be called once with a small buffer then again using
        # a buffer as large as the header reports is necessary.
        # Types of queries
        class _STORAGE_QUERY_TYPE(ENUM):
            PropertyStandardQuery = 0
            PropertyExistsQuery = 1
            PropertyMaskQuery = 2
            PropertyQueryMaxDefined = 3

        STORAGE_QUERY_TYPE = _STORAGE_QUERY_TYPE
        PSTORAGE_QUERY_TYPE = POINTER(_STORAGE_QUERY_TYPE)


        # define some initial property id's
        class _STORAGE_PROPERTY_ID(ENUM):
            StorageDeviceProperty = 0
            StorageAdapterProperty = 1
            StorageDeviceIdProperty = 2
            StorageDeviceUniqueIdProperty = 3
            StorageDeviceWriteCacheProperty = 4
            StorageMiniportProperty = 5
            StorageAccessAlignmentProperty = 6
            StorageDeviceSeekPenaltyProperty = 7
            StorageDeviceTrimProperty = 8
            StorageDeviceWriteAggregationProperty = 9
            StorageDeviceDeviceTelemetryProperty = 10
            StorageDeviceLBProvisioningProperty = 11
            StorageDevicePowerProperty = 12
            StorageDeviceCopyOffloadProperty = 13
            StorageDeviceResiliencyProperty = 14
            StorageDeviceMediumProductType = 15
            StorageAdapterRpmbProperty = 16
            StorageAdapterCryptoProperty = 17
            StorageDeviceIoCapabilityProperty = 48
            StorageAdapterProtocolSpecificProperty = 49
            StorageDeviceProtocolSpecificProperty = 50
            StorageAdapterTemperatureProperty = 51
            StorageDeviceTemperatureProperty = 52
            StorageAdapterPhysicalTopologyProperty = 53
            StorageDevicePhysicalTopologyProperty = 54
            StorageDeviceAttributesProperty = 55
            StorageDeviceManagementStatus = 56
            StorageAdapterSerialNumberProperty = 57
            StorageDeviceLocationProperty = 58
            StorageDeviceNumaProperty = 59
            StorageDeviceZonedDeviceProperty = 60
            StorageDeviceUnsafeShutdownCount = 61

        STORAGE_PROPERTY_ID = _STORAGE_PROPERTY_ID
        PSTORAGE_PROPERTY_ID = POINTER(_STORAGE_PROPERTY_ID)


        # Query structure - additional parameters for specific queries can
        # follow
        # the header
        _STORAGE_PROPERTY_QUERY._fields_ = [
            # ID of the property being retrieved
            ('PropertyId', STORAGE_PROPERTY_ID),
            # Flags indicating the type of query being performed
            ('QueryType', STORAGE_QUERY_TYPE),
            # Space for additional parameters if necessary
            ('AdditionalParameters', BYTE * 1),
        ]

        # Standard property descriptor header. All property pages should use
        # this
        # as their first element or should contain these two elements
        _STORAGE_DESCRIPTOR_HEADER._fields_ = [
            ('Version', DWORD),
            ('Size', DWORD),
        ]

        # Device property descriptor - this is really just a rehash of the
        # inquiry
        # data retrieved from a scsi device
        # This may only be retrieved from a target device. Sending this to the
        # bus
        # will result in an error
        _STORAGE_DEVICE_DESCRIPTOR._fields_ = [
            # Sizeof(STORAGE_DEVICE_DESCRIPTOR)
            ('Version', DWORD),
            # data and id strings
            ('Size', DWORD),
            # The SCSI-2 device type
            ('DeviceType', BYTE),
            # The SCSI-2 device type modifier (if any) - this may be zero
            ('DeviceTypeModifier', BYTE),
            # field should be ignored for media-less devices
            ('RemovableMedia', BOOLEAN),
            # of the port driver.
            ('CommandQueueing', BOOLEAN),
            # vendor id string. For devices with no such ID this will be zero
            ('VendorIdOffset', DWORD),
            # product id string. For devices with no such ID this will be zero
            ('ProductIdOffset', DWORD),
            # zero
            ('ProductRevisionOffset', DWORD),
            # serial number. For devices with no serial number this will be
            # zero
            ('SerialNumberOffset', DWORD),
            # (if any)
            ('BusType', STORAGE_BUS_TYPE),
            # this descriptor
            ('RawPropertiesLength', DWORD),
            # Place holder for the first byte of the bus specific property data
            ('RawDeviceProperties', BYTE * 1),
        ]
        # Adapter properties
        # This descriptor can be retrieved from a target device object of from
        # the
        # device object for the bus. Retrieving from the target device object
        # will
        # forward the request to the underlying bus
        _TEMP__STORAGE_ADAPTER_DESCRIPTOR = [
            ('Version', DWORD),
            ('Size', DWORD),
            ('MaximumTransferLength', DWORD),
            ('MaximumPhysicalPages', DWORD),
            ('AlignmentMask', DWORD),
            ('AdapterUsesPio', BOOLEAN),
            ('AdapterScansDown', BOOLEAN),
            ('CommandQueueing', BOOLEAN),
            ('AcceleratedTransfer', BOOLEAN),
        ]
        if NTDDI_VERSION  <  NTDDI_WINXP:
            _TEMP__STORAGE_ADAPTER_DESCRIPTOR += [
                ('BusType', BOOLEAN),
            ]
        else:
            _TEMP__STORAGE_ADAPTER_DESCRIPTOR += [
                ('BusType', BYTE),
            ]
        # END IF


        _TEMP__STORAGE_ADAPTER_DESCRIPTOR += [
            ('BusMajorVersion', WORD),
            ('BusMinorVersion', WORD),
        ]
        if NTDDI_VERSION  >= NTDDI_WIN8:
            _TEMP__STORAGE_ADAPTER_DESCRIPTOR += [
                ('SrbType', BYTE),
                ('AddressType', BYTE),
            ]
        # END IF


        _STORAGE_ADAPTER_DESCRIPTOR._fields_ = _TEMP__STORAGE_ADAPTER_DESCRIPTOR
        if NTDDI_VERSION  >= NTDDI_WIN8:
            NO_SRBTYPE_ADAPTER_DESCRIPTOR_SIZE = (
                UFIELD_OFFSET(STORAGE_ADAPTER_DESCRIPTOR, 'SrbType')
            )
            if not defined(SRB_TYPE_SCSI_REQUEST_BLOCK):
                SRB_TYPE_SCSI_REQUEST_BLOCK = 0
            # END IF


            if not defined(SRB_TYPE_STORAGE_REQUEST_BLOCK):
                SRB_TYPE_STORAGE_REQUEST_BLOCK = 1
            # END IF


            if not defined(STORAGE_ADDRESS_TYPE_BTL8):
                STORAGE_ADDRESS_TYPE_BTL8 = 0
            # END IF

        # END IF   (NTDDI_VERSION  >= NTDDI_WIN8)


        _STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR._fields_ = [
            # Sizeof(STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR)
            ('Version', DWORD),
            # data and id strings
            ('Size', DWORD),
            # The number of bytes in a cache line of the device
            ('BytesPerCacheLine', DWORD),
            # The address offset neccessary for proper cache access alignment
            # in bytes
            ('BytesOffsetForCacheAlignment', DWORD),
            # The number of bytes in a physical sector of the device
            ('BytesPerLogicalSector', DWORD),
            # The number of bytes in an addressable logical sector (LBA)of the
            # device
            ('BytesPerPhysicalSector', DWORD),
            # The address offset neccessary for proper sector access alignment
            # in bytes
            ('BytesOffsetForSectorAlignment', DWORD),
        ]

        _STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR._fields_ = [
            # Sizeof(STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR)
            ('Version', DWORD),
            # Total size of the descriptor, including the space for additional
            # data
            ('Size', DWORD),
            # Product type of the supporting storage medium
            ('MediumProductType', DWORD),
        ]


        class _STORAGE_PORT_CODE_SET(ENUM):
            StoragePortCodeSetReserved = 0
            StoragePortCodeSetStorport = 1
            StoragePortCodeSetSCSIport = 2
            StoragePortCodeSetSpaceport = 3
            StoragePortCodeSetATAport = 4
            StoragePortCodeSetUSBport = 5
            StoragePortCodeSetSBP2port = 6
            StoragePortCodeSetSDport = 7

        STORAGE_PORT_CODE_SET = _STORAGE_PORT_CODE_SET
        PSTORAGE_PORT_CODE_SET = POINTER(_STORAGE_PORT_CODE_SET)
        if NTDDI_VERSION  >= NTDDI_WIN8:
            STORAGE_MINIPORT_DESCRIPTOR_V1_SIZE = (
                RTL_SIZEOF_THROUGH_FIELD(STORAGE_MINIPORT_DESCRIPTOR,
                IoTimeoutValue)
            )
        # END IF


        _TEMP__STORAGE_MINIPORT_DESCRIPTOR = [
            ('Version', DWORD),
            ('Size', DWORD),
            ('Portdriver', STORAGE_PORT_CODE_SET),
            ('LUNResetSupported', BOOLEAN),
            ('TargetResetSupported', BOOLEAN),
        ]
        if NTDDI_VERSION  >= NTDDI_WIN8:
            _TEMP__STORAGE_MINIPORT_DESCRIPTOR += [
                ('IoTimeoutValue', WORD),
            ]
        # END IF

        if NTDDI_VERSION  >= NTDDI_WINBLUE:
            _TEMP__STORAGE_MINIPORT_DESCRIPTOR += [
                ('ExtraIoInfoSupported', BOOLEAN),
                ('Reserved0', BYTE * 3),
                ('Reserved1', DWORD),
            ]
        # END IF

        _STORAGE_MINIPORT_DESCRIPTOR._fields_ = _TEMP__STORAGE_MINIPORT_DESCRIPTOR

        # Storage identification descriptor.
        # The definitions here are based on the SCSI/SBP vital product data
        # device identifier page.
        class _STORAGE_IDENTIFIER_CODE_SET(ENUM):
            StorageIdCodeSetReserved = 0
            StorageIdCodeSetBinary = 1
            StorageIdCodeSetAscii = 2
            StorageIdCodeSetUtf8 = 3

        STORAGE_IDENTIFIER_CODE_SET = _STORAGE_IDENTIFIER_CODE_SET
        PSTORAGE_IDENTIFIER_CODE_SET = POINTER(_STORAGE_IDENTIFIER_CODE_SET)


        class _STORAGE_IDENTIFIER_TYPE(ENUM):
            StorageIdTypeVendorSpecific = 0
            StorageIdTypeVendorId = 1
            StorageIdTypeEUI64 = 2
            StorageIdTypeFCPHName = 3
            StorageIdTypePortRelative = 4
            StorageIdTypeTargetPortGroup = 5
            StorageIdTypeLogicalUnitGroup = 6
            StorageIdTypeMD5LogicalUnitIdentifier = 7
            StorageIdTypeScsiNameString = 8

        STORAGE_IDENTIFIER_TYPE = _STORAGE_IDENTIFIER_TYPE
        PSTORAGE_IDENTIFIER_TYPE = POINTER(_STORAGE_IDENTIFIER_TYPE)

        # Mislabeled above but need to keep it for backwards compatibility
        StorageIdTypeNAA = StorageIdTypeFCPHName

        # NAA formats (Used with StorageIdTypeNAA)
        class _STORAGE_ID_NAA_FORMAT(ENUM):
            StorageIdNAAFormatIEEEExtended = 2
            StorageIdNAAFormatIEEERegistered = 3
            StorageIdNAAFormatIEEEERegisteredExtended = 5

        STORAGE_ID_NAA_FORMAT = _STORAGE_ID_NAA_FORMAT
        PSTORAGE_ID_NAA_FORMAT = POINTER(_STORAGE_ID_NAA_FORMAT)


        class _STORAGE_ASSOCIATION_TYPE(ENUM):
            StorageIdAssocDevice = 0
            StorageIdAssocPort = 1
            StorageIdAssocTarget = 2

        STORAGE_ASSOCIATION_TYPE = _STORAGE_ASSOCIATION_TYPE
        PSTORAGE_ASSOCIATION_TYPE = POINTER(_STORAGE_ASSOCIATION_TYPE)

        _STORAGE_IDENTIFIER._fields_ = [
            ('CodeSet', STORAGE_IDENTIFIER_CODE_SET),
            ('Type', STORAGE_IDENTIFIER_TYPE),
            ('IdentifierSize', WORD),
            ('NextOffset', WORD),
            # the above layout not changing.
            ('Association', STORAGE_ASSOCIATION_TYPE),
            # The identifier is a variable length array of bytes.
            ('Identifier', BYTE * 1),
        ]

        _STORAGE_DEVICE_ID_DESCRIPTOR._fields_ = [
            ('Version', DWORD),
            ('Size', DWORD),
            # The number of identifiers reported by the device.
            ('NumberOfIdentifiers', DWORD),
            # variable length structures so we're forced to just pretend.
            ('Identifiers', BYTE * 1),
        ]

        # output buffer for StorageDeviceSeekPenaltyProperty &
        # PropertyStandardQuery
        _DEVICE_SEEK_PENALTY_DESCRIPTOR._fields_ = [
            # keep compatible with STORAGE_DESCRIPTOR_HEADER
            ('Version', DWORD),
            # keep compatible with STORAGE_DESCRIPTOR_HEADER
            ('Size', DWORD),
            ('IncursSeekPenalty', BOOLEAN),
        ]

        # output buffer for StorageDeviceWriteAggregationProperty &
        # PropertyStandardQuery
        # keep compatible with STORAGE_DESCRIPTOR_HEADER
        _DEVICE_WRITE_AGGREGATION_DESCRIPTOR._fields_ = [
            ('Version', DWORD),
            # keep compatible with STORAGE_DESCRIPTOR_HEADER
            ('Size', DWORD),
            ('BenefitsFromWriteAggregation', BOOLEAN),
        ]

        # output buffer for StorageDeviceTrimProperty & PropertyStandardQuery
        _DEVICE_TRIM_DESCRIPTOR._fields_ = [
            # keep compatible with STORAGE_DESCRIPTOR_HEADER
            ('Version', DWORD),
            # keep compatible with STORAGE_DESCRIPTOR_HEADER
            ('Size', DWORD),
            ('TrimEnabled', BOOLEAN),
        ]


        # Output buffer for StorageDeviceLBProvisioningProperty &
        # PropertyStandardQuery
        _TEMP__DEVICE_LB_PROVISIONING_DESCRIPTOR = [
            # keep compatible with STORAGE_DESCRIPTOR_HEADER
            ('Version', DWORD),
            # keep compatible with STORAGE_DESCRIPTOR_HEADER
            ('Size', DWORD),
            ('ThinProvisioningEnabled', BYTE, 1),
            ('ThinProvisioningReadZeros', BYTE, 1),
            ('AnchorSupported', BYTE, 3),
            ('UnmapGranularityAlignmentValid', BYTE, 1),
            ('Reserved0', BYTE, 2),
            ('Reserved1', BYTE * 7),
            # Granularity in bytes.
            ('OptimalUnmapGranularity', DWORDLONG),
            # Granularity alignment in bytes.
            ('UnmapGranularityAlignment', DWORDLONG),
        ]
        if NTDDI_VERSION  >= NTDDI_WINBLUE:
            _TEMP__DEVICE_LB_PROVISIONING_DESCRIPTOR += [
                # Max LBAs that can be unmapped in a single UNMAP command, in
                # logical blocks.
                ('MaxUnmapLbaCount', DWORD),
                # Max number of descriptors allowed in a single UNMAP command.
                ('MaxUnmapBlockDescriptorCount', DWORD),
            ]
        # END IF


        _DEVICE_LB_PROVISIONING_DESCRIPTOR._fields_ = _TEMP__DEVICE_LB_PROVISIONING_DESCRIPTOR
        DEVICE_LB_PROVISIONING_DESCRIPTOR_V1_SIZE = (
            RTL_SIZEOF_THROUGH_FIELD(DEVICE_LB_PROVISIONING_DESCRIPTOR,
            UnmapGranularityAlignment)
        )


        # IOCTL_STORAGE_GET_LB_PROVISIONING_MAP_RESOURCES
        # Input Buffer:
        # None
        # Output Buffer:
        # Structure of type STORAGE_LB_PROVISIONING_MAP_RESOURCES
        _STORAGE_LB_PROVISIONING_MAP_RESOURCES._fields_ = [
            ('Size', DWORD),
            ('Version', DWORD),
            ('AvailableMappingResourcesValid', BYTE, 1),
            ('UsedMappingResourcesValid', BYTE, 1),
            ('Reserved0', BYTE, 6),
            ('Reserved1', BYTE * 3),
            # See LOG_PAGE_LBP_RESOURCE_SCOPE_* definitions in scsi.h for
            # scope values.
            ('AvailableMappingResourcesScope', BYTE, 2),
            ('UsedMappingResourcesScope', BYTE, 2),
            ('Reserved2', BYTE, 4),
            ('Reserved3', BYTE * 3),
            # Available LBA mapping resources, in bytes.
            ('AvailableMappingResources', DWORDLONG),
            # Used LBA mapping resources, in bytes.
            ('UsedMappingResources', DWORDLONG),
        ]

        # output buffer for StorageDevicePowerProperty & PropertyStandardQuery
        # keep compatible with STORAGE_DESCRIPTOR_HEADER
        _DEVICE_POWER_DESCRIPTOR._fields_ = [
            ('Version', DWORD),
            # keep compatible with STORAGE_DESCRIPTOR_HEADER
            ('Size', DWORD),
            # The device supports "device attention".
            ('DeviceAttentionSupported', BOOLEAN),
            # The device supports asynchronous notifications, delivered via
            # IOCTL_STORAGE_EVENT_NOTIFICATION.
            ('AsynchronousNotificationSupported', BOOLEAN),
            # The device has been registered for runtime idle power management.
            ('IdlePowerManagementEnabled', BOOLEAN),
            # The device will be powered off when put into D3.
            ('D3ColdEnabled', BOOLEAN),
            # The platform supports D3Cold for this device.
            ('D3ColdSupported', BOOLEAN),
            # Device require no verification during idle power transitions.
            ('NoVerifyDuringIdlePower', BOOLEAN),
            ('Reserved', BYTE * 2),
            # The idle timeout value in milliseconds. Only valid if
            # IdlePowerManagementEnabled == TRUE.
            ('IdleTimeoutInMS', DWORD),
        ]


        # Output buffer for StorageDeviceCopyOffloadProperty &
        # PropertyStandardQuery
        # keep compatible with STORAGE_DESCRIPTOR_HEADER
        _DEVICE_COPY_OFFLOAD_DESCRIPTOR._fields_ = [
            ('Version', DWORD),
            # keep compatible with STORAGE_DESCRIPTOR_HEADER
            ('Size', DWORD),
            ('MaximumTokenLifetime', DWORD),
            ('DefaultTokenLifetime', DWORD),
            ('MaximumTransferSize', DWORDLONG),
            ('OptimalTransferCount', DWORDLONG),
            ('MaximumDataDescriptors', DWORD),
            ('MaximumTransferLengthPerDescriptor', DWORD),
            ('OptimalTransferLengthPerDescriptor', DWORD),
            ('OptimalTransferLengthGranularity', WORD),
            ('Reserved', BYTE * 2),
        ]


        # Output buffer for StorageDeviceResiliencyProperty &
        # PropertyStandardQuery
        _STORAGE_DEVICE_RESILIENCY_DESCRIPTOR._fields_ = [
            # as the version
            ('Version', DWORD),
            # all the variable sized fields
            ('Size', DWORD),
            # this descriptor
            ('NameOffset', DWORD),
            # data that are available
            ('NumberOfLogicalCopies', DWORD),
            # data that are stored
            ('NumberOfPhysicalCopies', DWORD),
            # without leading to data loss
            ('PhysicalDiskRedundancy', DWORD),
            # with this descriptor
            ('NumberOfColumns', DWORD),
            # this descriptor, in bytes
            ('Interleave', DWORD),
        ]


        # Output buffer for StorageAdapterRpmbProperty & PropertyStandardQuery
        class _STORAGE_RPMB_FRAME_TYPE(ENUM):
            StorageRpmbFrameTypeUnknown = 0
            StorageRpmbFrameTypeStandard = 1
            StorageRpmbFrameTypeMax = 2

        STORAGE_RPMB_FRAME_TYPE = _STORAGE_RPMB_FRAME_TYPE
        PSTORAGE_RPMB_FRAME_TYPE = POINTER(_STORAGE_RPMB_FRAME_TYPE)
        STORAGE_RPMB_DESCRIPTOR_VERSION_1 = 1
        STORAGE_RPMB_MINIMUM_RELIABLE_WRITE_SIZE = 512


        _STORAGE_RPMB_DESCRIPTOR._fields_ = [
            # Shall be set to STORAGE_RPMB_DESCRIPTOR_VERSION_1
            ('Version', DWORD),
            # Shall be set to (ctypes.sizeof(STORAGE_RPMB_DESCRIPTOR)
            ('Size', DWORD),
            # 0 if not supported, RPMB size in bytes otherwise
            ('SizeInBytes', DWORD),
            # 0 if not supported, minimum 512 bytes
            ('MaxReliableWriteSizeInBytes', DWORD),
            # can take the appropriate action
            ('FrameFormat', STORAGE_RPMB_FRAME_TYPE),
        ]
        # Output buffer for StorageAdapterCryptoProperty &
        # PropertyStandardQuery
        class _STORAGE_CRYPTO_ALGORITHM_ID(ENUM):
            StorageCryptoAlgorithmUnknown = 0
            StorageCryptoAlgorithmXTSAES = 1
            StorageCryptoAlgorithmBitlockerAESCBC = 2
            StorageCryptoAlgorithmAESECB = 3
            StorageCryptoAlgorithmESSIVAESCBC = 4
            StorageCryptoAlgorithmMax = 5

        STORAGE_CRYPTO_ALGORITHM_ID = _STORAGE_CRYPTO_ALGORITHM_ID
        PSTORAGE_CRYPTO_ALGORITHM_ID = POINTER(_STORAGE_CRYPTO_ALGORITHM_ID)


        class _STORAGE_CRYPTO_KEY_SIZE(ENUM):
            StorageCryptoKeySizeUnknown = 0
            StorageCryptoKeySize128Bits = 1
            StorageCryptoKeySize192Bits = 2
            StorageCryptoKeySize256Bits = 3
            StorageCryptoKeySize512Bits = 4

        STORAGE_CRYPTO_KEY_SIZE = _STORAGE_CRYPTO_KEY_SIZE
        PSTORAGE_CRYPTO_KEY_SIZE = POINTER(_STORAGE_CRYPTO_KEY_SIZE)
        STORAGE_CRYPTO_CAPABILITY_VERSION_1 = 1


        _STORAGE_CRYPTO_CAPABILITY._fields_ = [
            # to STORAGE_CRYPTO_CAPABILITY_VERSION_1
            ('Version', DWORD),
            # (ctypes.sizeof(STORAGE_CRYPTO_CAPABILITY)
            ('Size', DWORD),
            # The index for this crypto capability
            ('CryptoCapabilityIndex', DWORD),
            # Supported algorithm for this crypto capability
            ('AlgorithmId', STORAGE_CRYPTO_ALGORITHM_ID),
            # The supported key size for this algorithm
            ('KeySize', STORAGE_CRYPTO_KEY_SIZE),
            # Bit 0 represents 512 bytes, 1 represents 1 KB, bit 7 represents
            # 64 KB
            ('DataUnitSizeBitmask', DWORD),
        ]
        STORAGE_CRYPTO_DESCRIPTOR_VERSION_1 = 1
        _STORAGE_CRYPTO_DESCRIPTOR._fields_ = [
            # Shall be set to STORAGE_CRYPTO_DESCRIPTOR_VERSION_1
            ('Version', DWORD),
            # Shall be set to (ctypes.sizeof(STORAGE_CRYPTO_DESCRIPTOR)
            ('Size', DWORD),
            # The number of keys the crypto engine in the adapter supports
            ('NumKeysSupported', DWORD),
            # crypto configurations the adapter supports
            ('NumCryptoCapabilities', DWORD),
            # Array of Crypto Capabilities
            ('CryptoCapabilities', STORAGE_CRYPTO_CAPABILITY * ANYSIZE_ARRAY),
        ]
        # The STORAGE_TIER is an identifier for the storage tier relative to
        # the volume/LUN.
        # The storage tier ID for a particular volume has no relationship to
        # the storage tier
        # ID with the same value on a different volume.
        STORAGE_TIER_NAME_LENGTH = 256
        STORAGE_TIER_DESCRIPTION_LENGTH = 512
        STORAGE_TIER_FLAG_NO_SEEK_PENALTY = 0x00020000
        STORAGE_TIER_FLAG_WRITE_BACK_CACHE = 0x00200000
        STORAGE_TIER_FLAG_READ_CACHE = 0x00400000
        STORAGE_TIER_FLAG_PARITY = 0x00800000
        STORAGE_TIER_FLAG_SMR = 0x01000000


        class _STORAGE_TIER_MEDIA_TYPE(ENUM):
            StorageTierMediaTypeUnspecified = 0
            StorageTierMediaTypeDisk = 1
            StorageTierMediaTypeSsd = 2
            StorageTierMediaTypeScm = 4
            StorageTierMediaTypeMax = 5

        STORAGE_TIER_MEDIA_TYPE = _STORAGE_TIER_MEDIA_TYPE
        PSTORAGE_TIER_MEDIA_TYPE = POINTER(_STORAGE_TIER_MEDIA_TYPE)


        class _STORAGE_TIER_CLASS(ENUM):
            StorageTierClassUnspecified = 0
            StorageTierClassCapacity = 1
            StorageTierClassPerformance = 2
            StorageTierClassMax = 3

        STORAGE_TIER_CLASS = _STORAGE_TIER_CLASS
        PSTORAGE_TIER_CLASS = POINTER(_STORAGE_TIER_CLASS)

        _STORAGE_TIER._fields_ = [
            # Tier ID
            ('Id', GUID),
            # Name for the tier
            ('Name', WCHAR * STORAGE_TIER_NAME_LENGTH),
            # Note for the tier
            ('Description', WCHAR * STORAGE_TIER_NAME_LENGTH),
            # Flags: STORAGE_TIER_FLAG_xxx
            ('Flags', DWORDLONG),
            # Provisioned capacity of the tier
            ('ProvisionedCapacity', DWORDLONG),
            # Media type of the tier
            ('MediaType', STORAGE_TIER_MEDIA_TYPE),
            # Classification of the tier
            ('Class', STORAGE_TIER_CLASS),
        ]


        # The response returns a single structure of
        # STORAGE_DEVICE_TIERING_DESCRIPTOR that has
        # all the tiers for this disk.
        _STORAGE_DEVICE_TIERING_DESCRIPTOR._fields_ = [
            # as the version
            ('Version', DWORD),
            # all the variable sized fields
            ('Size', DWORD),
            # this structure is returned slightly tweaked in
            # FSCTL_QUERY_STORAGE_CLASSES_OUTPUT.
            ('Flags', DWORD),
            # The total number of available tiers for this disk
            ('TotalNumberOfTiers', DWORD),
            # The number of tiers that fit in the output
            ('NumberOfTiersReturned', DWORD),
            # Detailed info on the storage tiers.
            ('Tiers', STORAGE_TIER * ANYSIZE_ARRAY),
        ]


        # Output buffer for StorageDeviceFaultDomainProperty &
        # PropertyStandardQuery
        _STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR._fields_ = [
            # as the version
            ('Version', DWORD),
            # all the variable sized fields
            ('Size', DWORD),
            # Number of fault domains
            ('NumberOfFaultDomains', DWORD),
            # Fault domain ids
            ('FaultDomainIds', GUID * ANYSIZE_ARRAY),
        ]


        # Parameters for StorageAdapterProtocolSpecificProperty
        # (or StorageDeviceProtocolSpecificProperty) & PropertyStandardQuery
        # Define the different storage command protocols that used between
        # software and hardware.
        # e.g. command protocol software uses to communicate with hardware.
        # Protocol types below 128 (0x80) are reserved for Microsoft use.
        class _STORAGE_PROTOCOL_TYPE(ENUM):
            ProtocolTypeUnknown = 0x00
            ProtocolTypeScsi = 1
            ProtocolTypeAta = 2
            ProtocolTypeNvme = 3
            ProtocolTypeSd = 4
            ProtocolTypeUfs = 5
            ProtocolTypeProprietary = 0x7E
            ProtocolTypeMaxReserved = 0x7F

        STORAGE_PROTOCOL_TYPE = _STORAGE_PROTOCOL_TYPE
        PSTORAGE_PROTOCOL_TYPE = POINTER(_STORAGE_PROTOCOL_TYPE)


        class _STORAGE_PROTOCOL_NVME_DATA_TYPE(ENUM):
            NVMeDataTypeUnknown = 0
            NVMeDataTypeIdentify = 1
            NVMeDataTypeLogPage = 2
            NVMeDataTypeFeature = 3

        STORAGE_PROTOCOL_NVME_DATA_TYPE = _STORAGE_PROTOCOL_NVME_DATA_TYPE
        PSTORAGE_PROTOCOL_NVME_DATA_TYPE = POINTER(_STORAGE_PROTOCOL_NVME_DATA_TYPE)


        class _STORAGE_PROTOCOL_ATA_DATA_TYPE(ENUM):
            AtaDataTypeUnknown = 0
            AtaDataTypeIdentify = 1
            AtaDataTypeLogPage = 2

        STORAGE_PROTOCOL_ATA_DATA_TYPE = _STORAGE_PROTOCOL_ATA_DATA_TYPE
        PSTORAGE_PROTOCOL_ATA_DATA_TYPE = POINTER(_STORAGE_PROTOCOL_ATA_DATA_TYPE)


        class _STORAGE_PROTOCOL_UFS_DATA_TYPE(ENUM):
            UfsDataTypeUnknown = 0
            UfsDataTypeQueryDescriptor = 1
            UfsDataTypeMax = 2

        STORAGE_PROTOCOL_UFS_DATA_TYPE = _STORAGE_PROTOCOL_UFS_DATA_TYPE
        PSTORAGE_PROTOCOL_UFS_DATA_TYPE = POINTER(_STORAGE_PROTOCOL_UFS_DATA_TYPE)


        # Protocol Data should follow this data structure in the same buffer.
        # The offset of Protocol Data from the beginning of this data structure
        # is reported in data field - "ProtocolDataOffset".
        _STORAGE_PROTOCOL_SPECIFIC_DATA._fields_ = [
            ('ProtocolType', STORAGE_PROTOCOL_TYPE),
            # The value will be protocol specific, as defined in
            # STORAGE_PROTOCOL_NVME_DATA_TYPE or
            # STORAGE_PROTOCOL_ATA_DATA_TYPE.
            ('DataType', DWORD),
            ('ProtocolDataRequestValue', DWORD),
            ('ProtocolDataRequestSubValue', DWORD),
            # The offset of data buffer is from beginning of this data
            # structure.
            ('ProtocolDataOffset', DWORD),
            ('ProtocolDataLength', DWORD),
            # This is returned data, especially from NVMe feature data that
            # doesn't need separate device data transfer.
            ('FixedProtocolReturnData', DWORD),
            ('Reserved', DWORD * 3),
        ]


        # Input parameters for StorageAdapterProtocolSpecificProperty
        # (or StorageDeviceProtocolSpecificProperty) & PropertyStandardQuery
        # will be data structure STORAGE_PROPERTY_QUERY, where the data field
        # "AdditionalParameters" is a buffer
        # in format of STORAGE_PROTOCOL_SPECIFIC_DATA.
        # Out parameters for StorageAdapterProtocolSpecificProperty
        # (or StorageDeviceProtocolSpecificProperty) & PropertyStandardQuery
        _STORAGE_PROTOCOL_DATA_DESCRIPTOR._fields_ = [
            ('Version', DWORD),
            ('Size', DWORD),
            ('ProtocolSpecificData', STORAGE_PROTOCOL_SPECIFIC_DATA),
        ]


        # Parameters for StorageAdapterTemperatureProperty
        # (or StorageDeviceTemperatureProperty) & PropertyStandardQuery
        # Input parameters for StorageAdapterTemperatureProperty
        # (or StorageDeviceTemperatureProperty) & PropertyStandardQuery
        # uses data structure STORAGE_PROPERTY_QUERY.
        # Out parameters for StorageAdapterTemperatureProperty
        # (or StorageDeviceTemperatureProperty) & PropertyStandardQuery
        # For temperature/threshold data fields, the smallest value of SHORT
        # type - 0x8000 indicates the value is not reported.
        STORAGE_TEMPERATURE_VALUE_NOT_REPORTED = 0x8000


        _STORAGE_TEMPERATURE_INFO._fields_ = [
            # Starts from 0. Index 0 may indicate a composite value.
            ('Index', WORD),
            # Signed value; in Celsius.
            ('Temperature', SHORT),
            # Signed value; in Celsius.
            ('OverThreshold', SHORT),
            # Signed value; in Celsius.
            ('UnderThreshold', SHORT),
            # Can the threshold value being changed by using
            # IOCTL_STORAGE_SET_TEMPERATURE_THRESHOLD.
            ('OverThresholdChangable', BOOLEAN),
            # Can the threshold value being changed by using
            # IOCTL_STORAGE_SET_TEMPERATURE_THRESHOLD.
            ('UnderThresholdChangable', BOOLEAN),
            # Indicates that notification will be generated when temperature
            # cross threshold.
            ('EventGenerated', BOOLEAN),
            ('Reserved0', BYTE),
            ('Reserved1', DWORD),
        ]

        _STORAGE_TEMPERATURE_DATA_DESCRIPTOR._fields_ = [
            ('Version', DWORD),
            ('Size', DWORD),
            # Signed value; in Celsius.
            ('CriticalTemperature', SHORT),
            # Signed value; in Celsius.
            ('WarningTemperature', SHORT),
            # Some devices may report more than one temperature information as
            # there can be multiple sensors implemented.
            ('InfoCount', WORD),
            ('Reserved0', BYTE * 2),
            ('Reserved1', DWORD * 2),
            ('TemperatureInfo', STORAGE_TEMPERATURE_INFO * ANYSIZE_ARRAY),
        ]


        # Input parameters for IOCTL_STORAGE_SET_TEMPERATURE_THRESHOLD
        # Indicate the target of the request other than the device
        # handle/object itself.
        # This is used in "Flags" field of data structures.
        STORAGE_TEMPERATURE_THRESHOLD_FLAG_ADAPTER_REQUEST = 0x0001


        _STORAGE_TEMPERATURE_THRESHOLD._fields_ = [
            ('Version', DWORD),
            ('Size', DWORD),
            ('Flags', WORD),
            ('Index', WORD),
            # Signed value; in Celsius.
            ('Threshold', SHORT),
            # If TRUE, set the OverThreshold value; Otherwise, set the
            # UnderThreshold value.
            ('OverThreshold', BOOLEAN),
            ('Reserved', BYTE),
        ]


        # Parameters for StorageAdapterPhysicalTopologyProperty
        # (or StorageDevicePhysicalTopologyProperty) & PropertyStandardQuery
        # Input parameters for StorageAdapterPhysicalTopologyProperty
        # (or StorageDevicePhysicalTopologyProperty) & PropertyStandardQuery
        # uses data structure STORAGE_PROPERTY_QUERY.
        # Out parameters for StorageAdapterPhysicalTopologyProperty
        # (or StorageDevicePhysicalTopologyProperty) & PropertyStandardQuery
        # uses data structure STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR
        # NVME header data structure
        _NVME_RESERVED_QUEUE_HEADER._fields_ = [
            # Version of header; by default 0. Added for version compatibility
            ('Version', DWORD),
            # Size of the information including header
            ('Size', DWORD),
        ]


        # Details of Create request for reserved Submission queue, provided by
        # FPGA driver
        _NVME_RESERVED_SQ_CREATE_REQUEST._fields_ = [
            # SQ base physical Address
            ('PhysicalAddress', DWORD64),
            # SQ priority
            ('QueuePriority', WORD),
            # SQ depth
            ('QueueDepth', WORD),
            # Physically Contiguous,
            ('PhysicalContiguous', BOOLEAN),
        ]


        # Details of Create request for reserved Completion queue, provided by
        # FPGA driver
        _NVME_RESERVED_CQ_CREATE_REQUEST._fields_ = [
            # CQ base physical Address
            ('PhysicalAddress', DWORD64),
            # CQ Interrupt Vector, corresponds to MSI-X or MSI vector
            ('InterruptVector', DWORD),
            # CQ depth
            ('QueueDepth', WORD),
            # Interrupt Enabled for the queue
            ('InterruptEnabled', BOOLEAN),
            # Physically Contiguous,
            ('PhysicalContiguous', BOOLEAN),
        ]


        # Request to create one completion queue and one or more submission
        # queues
        # for FPGA use
        _NVME_RESERVED_QUEUES_CREATE_REQUEST._fields_ = [
            ('Header', NVME_RESERVED_QUEUE_HEADER),
            # Completion queue information
            ('CompletionQueue', NVME_RESERVED_CQ_CREATE_REQUEST),
            # Number of submission queues requested
            ('SubmissionQueueCount', WORD),
            # Submission queue(s) information
            ('SubmissionQueue', NVME_RESERVED_SQ_CREATE_REQUEST * ANYSIZE_ARRAY),
        ]


        # Details of reserved Submission queue, provided as create response
        # and queue query
        _NVME_RESERVED_SQ_INFO._fields_ = [
            # SQ base physical address
            ('PhysicalAddress', DWORD64),
            # SQ tail doorbell register address
            ('DoorbellRegisterAddress', DWORD64),
            # SQ ID
            ('QueueID', WORD),
            # SQ depth
            ('QueueDepth', WORD),
            # Physically Contiguous
            ('PhysicalContiguous', BOOLEAN),
            # Completion queue identifier
            ('CompletionQueueID', WORD),
            # SQ priority
            ('QueuePriority', BYTE),
        ]


        # Details of reserved Completion queue, provided as create response
        # and queue query
        _NVME_RESERVED_CQ_INFO._fields_ = [
            # CQ base physical Address
            ('PhysicalAddress', DWORD64),
            # CQ head doorbell register
            ('DoorbellRegisterAddress', DWORD64),
            # CQ ID
            ('QueueID', WORD),
            # CQ depth
            ('QueueDepth', WORD),
            # Interrupt Enabled
            ('InterruptEnabled', BOOLEAN),
            # Physically Contiguous
            ('PhysicalContiguous', BOOLEAN),
            # Interrupt Vector, corresponds to MSI-X or MSI vector
            ('InterruptVector', DWORD),
        ]


        # Response to create request of one completion queue and one or more
        # submission queues
        # for FPGA use
        _NVME_RESERVED_QUEUES_CREATE_RESPONSE._fields_ = [
            ('Header', NVME_RESERVED_QUEUE_HEADER),
            # Completion queue information
            ('CompletionQueue', NVME_RESERVED_CQ_INFO),
            # Number of submission queues created
            ('SubmissionQueueCount', WORD),
            # Submission queue(s) information
            ('SubmissionQueue', NVME_RESERVED_SQ_INFO * ANYSIZE_ARRAY),
        ]


        # Request to delete queue pair
        # (completion queue and corresponding submission queue)
        # for FPGA use
        _NVME_RESERVED_QUEUES_DELETE_REQUEST._fields_ = [
            ('Header', NVME_RESERVED_QUEUE_HEADER),
            # Completion queue ID
            ('QueueID', WORD),
        ]


        # Out parameters for IOCTL_MINIPORT_SIGNATURE_QUERY_QUEUE_INFO through
        # IOCTL_STORAGE_QUERY_PROPERTY
        # Reserved Queue properties returned on queue information query
        # Completion queue information
        class QueueMapping(ctypes.Structure):
            pass


        QueueMapping._fields_ = [
            ('CompletionQueue', NVME_RESERVED_CQ_INFO),
            # Number of submission queues created
            ('SubmissionQueueCount', WORD),
            # Submission queue(s) information
            ('SubmissionQueue', NVME_RESERVED_SQ_INFO * ANYSIZE_ARRAY),
        ]
        _NVME_RESERVED_QUEUES_PROPERTIES.QueueMapping = QueueMapping


        _NVME_RESERVED_QUEUES_PROPERTIES._fields_ = [
            ('Header', NVME_RESERVED_QUEUE_HEADER),
            # Number of reserved queue pair in the controller
            ('QueuePairCount', WORD),
            ('QueueMapping', _NVME_RESERVED_QUEUES_PROPERTIES.QueueMapping * ANYSIZE_ARRAY),
        ]


        # Multiple roles are allowed for a single device.
        STORAGE_COMPONENT_ROLE_CACHE = 0x00000001
        STORAGE_COMPONENT_ROLE_TIERING = 0x00000002
        STORAGE_COMPONENT_ROLE_DATA = 0x00000004


        class _STORAGE_DEVICE_FORM_FACTOR(ENUM):
            FormFactorUnknown = 0
            FormFactor3_5 = 1
            FormFactor2_5 = 2
            FormFactor1_8 = 3
            FormFactor1_8Less = 4
            FormFactorEmbedded = 5
            FormFactorMemoryCard = 6
            FormFactormSata = 7
            FormFactorM_2 = 8
            FormFactorPCIeBoard = 9
            FormFactorDimm = 10

        STORAGE_DEVICE_FORM_FACTOR = _STORAGE_DEVICE_FORM_FACTOR
        PSTORAGE_DEVICE_FORM_FACTOR = POINTER(_STORAGE_DEVICE_FORM_FACTOR)


        class _STORAGE_COMPONENT_HEALTH_STATUS(ENUM):
            HealthStatusUnknown = 0
            HealthStatusNormal = 1
            HealthStatusThrottled = 2
            HealthStatusWarning = 3
            HealthStatusDisabled = 4
            HealthStatusFailed = 5

        STORAGE_COMPONENT_HEALTH_STATUS = _STORAGE_COMPONENT_HEALTH_STATUS
        PSTORAGE_COMPONENT_HEALTH_STATUS = POINTER(_STORAGE_COMPONENT_HEALTH_STATUS)


        class DUMMYSTRUCTNAME(ctypes.Structure):
            pass


        class MinorVersion(ctypes.Union):
            pass


        class DUMMYSTRUCTNAME(ctypes.Structure):
            pass


        DUMMYSTRUCTNAME._fields_ = [
            ('SubMinor', BYTE),
            ('Minor', BYTE),
        ]
        MinorVersion.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


        MinorVersion._fields_ = [
            ('DUMMYSTRUCTNAME', MinorVersion.DUMMYSTRUCTNAME),
            ('AsUshort', WORD),
        ]
        DUMMYSTRUCTNAME.MinorVersion = MinorVersion


        DUMMYSTRUCTNAME._fields_ = [
            ('MinorVersion', DUMMYSTRUCTNAME.MinorVersion),
            ('MajorVersion', WORD),
        ]
        _STORAGE_SPEC_VERSION.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


        _STORAGE_SPEC_VERSION._fields_ = [
            ('DUMMYSTRUCTNAME', _STORAGE_SPEC_VERSION.DUMMYSTRUCTNAME),
            ('AsUlong', DWORD),
        ]

        _STORAGE_PHYSICAL_DEVICE_DATA._fields_ = [
            ('DeviceId', DWORD),
            # Value(s) of bitmask from STORAGE_COMPONENT_ROLE_xxx
            ('Role', DWORD),
            ('HealthStatus', STORAGE_COMPONENT_HEALTH_STATUS),
            ('CommandProtocol', STORAGE_PROTOCOL_TYPE),
            # Supported storage spec version. For example: SBC 3, SATA 3.2,
            # NVMe 1.2
            ('SpecVersion', STORAGE_SPEC_VERSION),
            ('FormFactor', STORAGE_DEVICE_FORM_FACTOR),
            ('Vendor', BYTE * 8),
            ('Model', BYTE * 40),
            ('FirmwareRevision', BYTE * 16),
            # in unit of Kilo-Bytes (1024 bytes).
            ('Capacity', DWORDLONG),
            # Reserved for future.
            ('PhysicalLocation', BYTE * 32),
            ('Reserved', DWORD * 2),
        ]

        _STORAGE_PHYSICAL_ADAPTER_DATA._fields_ = [
            ('AdapterId', DWORD),
            ('HealthStatus', STORAGE_COMPONENT_HEALTH_STATUS),
            ('CommandProtocol', STORAGE_PROTOCOL_TYPE),
            # Supported storage spec version. For example: AHCI 1.3.1
            ('SpecVersion', STORAGE_SPEC_VERSION),
            ('Vendor', BYTE * 8),
            ('Model', BYTE * 40),
            ('FirmwareRevision', BYTE * 16),
            # Reserve for future.
            ('PhysicalLocation', BYTE * 32),
            ('ExpanderConnected', BOOLEAN),
            ('Reserved0', BYTE * 3),
            ('Reserved1', DWORD * 3),
        ]

        _STORAGE_PHYSICAL_NODE_DATA._fields_ = [
            ('NodeId', DWORD),
            # 0 or 1
            ('AdapterCount', DWORD),
            ('AdapterDataLength', DWORD),
            # Offset from beginning of this data structure. The buffer
            # contains an array of STORAGE_PHYSICAL_ADAPTER_DATA.
            ('AdapterDataOffset', DWORD),
            # >= 1
            ('DeviceCount', DWORD),
            ('DeviceDataLength', DWORD),
            # Offset from beginning of this data structure. The buffer
            # contains an array of STORAGE_PHYSICAL_DEVICE_DATA.
            ('DeviceDataOffset', DWORD),
            ('Reserved', DWORD * 3),
        ]

        _STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR._fields_ = [
            # (ctypes.sizeof(STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR)
            ('Version', DWORD),
            # Total size of the data. Should be >=
            # (ctypes.sizeof(STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR)
            ('Size', DWORD),
            ('NodeCount', DWORD),
            ('Reserved', DWORD),
            ('Node', STORAGE_PHYSICAL_NODE_DATA * ANYSIZE_ARRAY),
        ]
        # Output buffer for StorageDeviceIoCapabilityProperty &
        # PropertyStandardQuery
        _STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR._fields_ = [
            # as the version
            ('Version', DWORD),
            # Size of this structure
            ('Size', DWORD),
            # LUN max outstanding IO count
            ('LunMaxIoCount', DWORD),
            # Adapter max outstanding IO count
            ('AdapterMaxIoCount', DWORD),
        ]
        # Output buffer for StorageDeviceAttributesProperty &
        # PropertyStandardQuery
        _STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR._fields_ = [
            # as the version
            ('Version', DWORD),
            # Size of this structure
            ('Size', DWORD),
            # Attributes (bit flags)
            ('Attributes', DWORD64),
        ]
        # Storage Device Attributes Flags
        STORAGE_ATTRIBUTE_BYTE_ADDRESSABLE_IO = 0x01
        STORAGE_ATTRIBUTE_BLOCK_IO = 0x02
        STORAGE_ATTRIBUTE_DYNAMIC_PERSISTENCE = 0x04
        STORAGE_ATTRIBUTE_VOLATILE = 0x08
        STORAGE_ATTRIBUTE_ASYNC_EVENT_NOTIFICATION = 0x10
        STORAGE_ATTRIBUTE_PERF_SIZE_INDEPENDENT = 0x20
        # Constants for StorageDeviceManagementStatus
        class _STORAGE_DISK_HEALTH_STATUS(ENUM):
            DiskHealthUnknown = 0
            DiskHealthUnhealthy = 1
            DiskHealthWarning = 2
            DiskHealthHealthy = 3
            DiskHealthMax = 4

        STORAGE_DISK_HEALTH_STATUS = _STORAGE_DISK_HEALTH_STATUS
        PSTORAGE_DISK_HEALTH_STATUS = POINTER(_STORAGE_DISK_HEALTH_STATUS)


        # Operational States
        class _STORAGE_DISK_OPERATIONAL_STATUS(ENUM):
            DiskOpStatusNone = 0
            DiskOpStatusUnknown = 1
            DiskOpStatusOk = 2
            DiskOpStatusPredictingFailure = 3
            DiskOpStatusInService = 4
            DiskOpStatusHardwareError = 5
            DiskOpStatusNotUsable = 6
            DiskOpStatusTransientError = 7
            DiskOpStatusMissing = 8

        STORAGE_DISK_OPERATIONAL_STATUS = _STORAGE_DISK_OPERATIONAL_STATUS
        PSTORAGE_DISK_OPERATIONAL_STATUS = POINTER(_STORAGE_DISK_OPERATIONAL_STATUS)


        # Operational Reasons
        class _STORAGE_OPERATIONAL_STATUS_REASON(ENUM):
            DiskOpReasonUnknown = 0
            DiskOpReasonScsiSenseCode = 1
            DiskOpReasonMedia = 2
            DiskOpReasonIo = 3
            DiskOpReasonThresholdExceeded = 4
            DiskOpReasonLostData = 5
            DiskOpReasonEnergySource = 6
            DiskOpReasonConfiguration = 7
            DiskOpReasonDeviceController = 8
            DiskOpReasonMediaController = 9
            DiskOpReasonComponent = 10
            DiskOpReasonNVDIMM_N = 11
            DiskOpReasonBackgroundOperation = 12
            DiskOpReasonInvalidFirmware = 13
            DiskOpReasonHealthCheck = 14
            DiskOpReasonLostDataPersistence = 15
            DiskOpReasonDisabledByPlatform = 16
            DiskOpReasonLostWritePersistence = 17
            DiskOpReasonDataPersistenceLossImminent = 18
            DiskOpReasonWritePersistenceLossImminent = 19
            DiskOpReasonMax = 20

        STORAGE_OPERATIONAL_STATUS_REASON = _STORAGE_OPERATIONAL_STATUS_REASON
        PSTORAGE_OPERATIONAL_STATUS_REASON = POINTER(_STORAGE_OPERATIONAL_STATUS_REASON)


        class RawBytes(ctypes.Union):
            pass


        class ScsiSenseKey(ctypes.Structure):
            pass


        ScsiSenseKey._fields_ = [
            ('SenseKey', BYTE),
            ('ASC', BYTE),
            ('ASCQ', BYTE),
            ('Reserved', BYTE),
        ]
        RawBytes.ScsiSenseKey = ScsiSenseKey


        class NVDIMM_N(ctypes.Structure):
            pass


        NVDIMM_N._fields_ = [
            ('CriticalHealth', BYTE),
            ('ModuleHealth', BYTE * 2),
            ('ErrorThresholdStatus', BYTE),
        ]
        RawBytes.NVDIMM_N = NVDIMM_N


        RawBytes._fields_ = [
            # This is the format if Reason == DiskOpReasonScsiSenseCode.
            ('ScsiSenseKey', RawBytes.ScsiSenseKey),
            # This is the format if Reason == DiskOpReasonNVDIMM_N.
            ('NVDIMM_N', RawBytes.NVDIMM_N),
            ('AsUlong', DWORD),
        ]
        _STORAGE_OPERATIONAL_REASON.RawBytes = RawBytes


        _STORAGE_OPERATIONAL_REASON._fields_ = [
            ('Version', DWORD),
            ('Size', DWORD),
            ('Reason', STORAGE_OPERATIONAL_STATUS_REASON),
            ('RawBytes', _STORAGE_OPERATIONAL_REASON.RawBytes),
        ]


        # Output buffer for StorageDeviceManagementStatus &
        # PropertyStandardQuery
        STORAGE_DEVICE_MAX_OPERATIONAL_STATUS = 16


        _STORAGE_DEVICE_MANAGEMENT_STATUS._fields_ = [
            # as the version.
            ('Version', DWORD),
            # how big the input buffer should be to contain all the available
            # information.
            ('Size', DWORD),
            # Health status.
            ('Health', STORAGE_DISK_HEALTH_STATUS),
            # The number of operational status returned.
            ('NumberOfOperationalStatus', DWORD),
            # The number of additional reasons returned.
            ('NumberOfAdditionalReasons', DWORD),
            # in the array. There are NumberOfOperationalStatus valid elements
            # in the array.
            ('OperationalStatus', STORAGE_DISK_OPERATIONAL_STATUS * STORAGE_DEVICE_MAX_OPERATIONAL_STATUS),
            # Additional reasons. There are NumberOfAdditionalReasons valid
            # elements in the array.
            ('AdditionalReasons', STORAGE_OPERATIONAL_REASON * ANYSIZE_ARRAY),
        ]


        # Parameter for StorageAdapterSerialNumberProperty.
        # Use this to get the serial number of the storage adapter. Note that
        # not all
        # controllers and host controller interfaces may provide a serial
        # number for
        # the adapter. If the serial number is malformed or cannot be obtained
        # this
        # query will fail.
        # The serial number can have a maximum of 128 Unicode characters,
        # including
        # the trailing NULL character.
        STORAGE_ADAPTER_SERIAL_NUMBER_V1_MAX_LENGTH = 128


        _STORAGE_ADAPTER_SERIAL_NUMBER._fields_ = [
            ('Version', DWORD),
            ('Size', DWORD),
            # NULL-terminated Unicode string of the adapter's serial number.
            ('SerialNumber', WCHAR * STORAGE_ADAPTER_SERIAL_NUMBER_V1_MAX_LENGTH),
        ]
        STORAGE_ADAPTER_SERIAL_NUMBER_V1_VERSION = (
            ctypes.sizeof(STORAGE_ADAPTER_SERIAL_NUMBER)
        )
        STORAGE_ADAPTER_SERIAL_NUMBER_V1_SIZE = (
            ctypes.sizeof(STORAGE_ADAPTER_SERIAL_NUMBER)
        )
        # Output buffer for StorageDeviceZonedDeviceProperty &
        # PropertyStandardQuery
        class _STORAGE_ZONED_DEVICE_TYPES(ENUM):
            ZonedDeviceTypeUnknown = 0
            ZonedDeviceTypeHostManaged = 1
            ZonedDeviceTypeHostAware = 2
            ZonedDeviceTypeDeviceManaged = 3

        STORAGE_ZONED_DEVICE_TYPES = _STORAGE_ZONED_DEVICE_TYPES
        PSTORAGE_ZONED_DEVICE_TYPES = POINTER(_STORAGE_ZONED_DEVICE_TYPES)


        class _STORAGE_ZONE_TYPES(ENUM):
            ZoneTypeUnknown = 0
            ZoneTypeConventional = 1
            ZoneTypeSequentialWriteRequired = 2
            ZoneTypeSequentialWritePreferred = 3
            ZoneTypeMax = 4

        STORAGE_ZONE_TYPES = _STORAGE_ZONE_TYPES
        PSTORAGE_ZONE_TYPES = POINTER(_STORAGE_ZONE_TYPES)

        _STORAGE_ZONE_GROUP._fields_ = [
            # Count of zones in this group.
            ('ZoneCount', DWORD),
            ('ZoneType', STORAGE_ZONE_TYPES),
            # In Bytes
            ('ZoneSize', DWORDLONG),
        ]


        class ZoneAttributes(ctypes.Union):
            pass


        class SequentialRequiredZone(ctypes.Structure):
            pass


        SequentialRequiredZone._fields_ = [
            ('MaxOpenZoneCount', DWORD),
            ('UnrestrictedRead', BOOLEAN),
            ('Reserved', BYTE * 3),
        ]
        ZoneAttributes.SequentialRequiredZone = SequentialRequiredZone


        class SequentialPreferredZone(ctypes.Structure):
            pass


        SequentialPreferredZone._fields_ = [
            ('OptimalOpenZoneCount', DWORD),
            ('Reserved', DWORD),
        ]
        ZoneAttributes.SequentialPreferredZone = SequentialPreferredZone


        ZoneAttributes._fields_ = [
            ('SequentialRequiredZone', ZoneAttributes.SequentialRequiredZone),
            ('SequentialPreferredZone', ZoneAttributes.SequentialPreferredZone),
        ]
        _STORAGE_ZONED_DEVICE_DESCRIPTOR.ZoneAttributes = ZoneAttributes


        _STORAGE_ZONED_DEVICE_DESCRIPTOR._fields_ = [
            # Size of this structure serves as the version
            ('Version', DWORD),
            # to store complete data.
            ('Size', DWORD),
            # Zoned device type
            ('DeviceType', STORAGE_ZONED_DEVICE_TYPES),
            # Total zone count
            ('ZoneCount', DWORD),
            # Zone Attributes
            ('ZoneAttributes', _STORAGE_ZONED_DEVICE_DESCRIPTOR.ZoneAttributes),
            # The zone layout starts from the first zone, and groups together
            # zones with same type and size.
            ('ZoneGroupCount', DWORD),
            ('ZoneGroup', STORAGE_ZONE_GROUP * ANYSIZE_ARRAY),
        ]


        # Output buffer for StorageDeviceLocationProperty &
        # PropertyStandardQuery
        class DUMMYUNIONNAME(ctypes.Union):
            pass


        class DUMMYSTRUCTNAME(ctypes.Structure):
            pass


        DUMMYSTRUCTNAME._fields_ = [
            ('Channel', DWORD),
            ('Device', DWORD),
        ]
        DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


        class DUMMYSTRUCTNAME2(ctypes.Structure):
            pass


        DUMMYSTRUCTNAME2._fields_ = [
            ('Target', DWORD),
            ('Lun', DWORD),
        ]
        DUMMYUNIONNAME.DUMMYSTRUCTNAME2 = DUMMYSTRUCTNAME2


        DUMMYUNIONNAME._fields_ = [
            ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
            ('DUMMYSTRUCTNAME2', DUMMYUNIONNAME.DUMMYSTRUCTNAME2),
        ]
        _DEVICE_LOCATION.DUMMYUNIONNAME = DUMMYUNIONNAME


        _DEVICE_LOCATION._fields_ = [
            ('Socket', DWORD),
            ('Slot', DWORD),
            ('Adapter', DWORD),
            ('Port', DWORD),
            ('DUMMYUNIONNAME', _DEVICE_LOCATION.DUMMYUNIONNAME),
        ]

        _STORAGE_DEVICE_LOCATION_DESCRIPTOR._fields_ = [
            ('Version', DWORD),
            ('Size', DWORD),
            ('Location', DEVICE_LOCATION),
            ('StringOffset', DWORD),
        ]


        # Output buffer for StorageDeviceNumaProperty.
        # If the query for this property is successful, then the caller should
        # validate the NumaNode field before using it to optimize any
        # operations.
        # That is, the caller should ensure the NumaNode value is less than or
        # equal
        # to the system's highest NUMA node value and the NumaNode value is
        # not equal
        # to STORAGE_DEVICE_NUMA_NODE_UNKNOWN.
        _STORAGE_DEVICE_NUMA_PROPERTY._fields_ = [
            ('Version', DWORD),
            ('Size', DWORD),
            ('NumaNode', DWORD),
        ]
        STORAGE_DEVICE_NUMA_NODE_UNKNOWN = MAXDWORD

        # Output buffer for StorageDeviceUnsafeShutdownCount.
        # On persistent memory devices, the unsafe shutdown count is the
        # number of times
        # the logical persistent memory disk was shut down in a way that might
        # have caused
        # data loss.
        _STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT._fields_ = [
            ('Version', DWORD),
            ('Size', DWORD),
            ('UnsafeShutdownCount', DWORD),
        ]

        # ////////////////////////////////////////////////////////////////////
        # IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES
        # Input Buffer:
        # Structure of type DEVICE_DSM_INPUT
        # Output Buffer:
        # Structure of type DEVICE_DSM_OUTPUT
        # DEVICE_DSM_INPUT.Action

        DEVICE_DATA_MANAGEMENT_SET_ACTION = DWORD
        DEVICE_DSM_ACTION = DWORD
        # This indicates that the action is
        # non-destructive and a driver that
        # does not understand it may safely
        # forward the IOCTL
        DeviceDsmActionFlag_NonDestructive = 0x80000000


        def IsDsmActionNonDestructive(_Action):
            return (_Action & DeviceDsmActionFlag_NonDestructive) != 0

        DeviceDsmAction_None = 0x00000000
        DeviceDsmAction_Trim = 0x00000001
        DeviceDsmAction_Notification = (
            0x00000002 |
            DeviceDsmActionFlag_NonDestructive
        )
        DeviceDsmAction_OffloadRead = (
            0x00000003 |
            DeviceDsmActionFlag_NonDestructive
        )
        DeviceDsmAction_OffloadWrite = 0x00000004
        DeviceDsmAction_Allocation = (
            0x00000005 |
            DeviceDsmActionFlag_NonDestructive
        )
        DeviceDsmAction_Repair = (
            0x00000006 |
            DeviceDsmActionFlag_NonDestructive
        )
        DeviceDsmAction_Scrub = 0x00000007 | DeviceDsmActionFlag_NonDestructive
        DeviceDsmAction_DrtQuery = (
            0x00000008 |
            DeviceDsmActionFlag_NonDestructive
        )
        DeviceDsmAction_DrtClear = (
            0x00000009 |
            DeviceDsmActionFlag_NonDestructive
        )
        DeviceDsmAction_DrtDisable = (
            0x0000000A |
            DeviceDsmActionFlag_NonDestructive
        )
        DeviceDsmAction_TieringQuery = (
            0x0000000B |
            DeviceDsmActionFlag_NonDestructive
        )
        DeviceDsmAction_Map = 0x0000000C | DeviceDsmActionFlag_NonDestructive
        DeviceDsmAction_RegenerateParity = (
            0x0000000D |
            DeviceDsmActionFlag_NonDestructive
        )
        DeviceDsmAction_NvCache_Change_Priority = (
            0x0000000E |
            DeviceDsmActionFlag_NonDestructive
        )
        DeviceDsmAction_NvCache_Evict = (
            0x0000000F |
            DeviceDsmActionFlag_NonDestructive
        )
        DeviceDsmAction_TopologyIdQuery = (
            0x00000010 |
            DeviceDsmActionFlag_NonDestructive
        )
        DeviceDsmAction_GetPhysicalAddresses = (
            0x00000011 |
            DeviceDsmActionFlag_NonDestructive
        )
        DeviceDsmAction_ScopeRegen = (
            0x00000012 |
            DeviceDsmActionFlag_NonDestructive
        )
        DeviceDsmAction_ReportZones = (
            0x00000013 |
            DeviceDsmActionFlag_NonDestructive
        )
        DeviceDsmAction_OpenZone = (
            0x00000014 |
            DeviceDsmActionFlag_NonDestructive
        )
        DeviceDsmAction_FinishZone = (
            0x00000015 |
            DeviceDsmActionFlag_NonDestructive
        )
        DeviceDsmAction_CloseZone = (
            0x00000016 |
            DeviceDsmActionFlag_NonDestructive
        )
        DeviceDsmAction_ResetWritePointer = 0x00000017
        DeviceDsmAction_GetRangeErrorInfo = (
            0x00000018 |
            DeviceDsmActionFlag_NonDestructive
        )
        DeviceDsmAction_WriteZeroes = 0x00000019
        DeviceDsmAction_LostQuery = (
            0x0000001A |
            DeviceDsmActionFlag_NonDestructive
        )
        DeviceDsmAction_GetFreeSpace = (
            0x0000001B |
            DeviceDsmActionFlag_NonDestructive
        )


        # DEVICE_DSM_INPUT.Flags
        # Flags that are not specific to an
        # action are in the lower 16-bits
        # Action-specific flags are in the
        # higher 16-bits
        # When specified, the DataSetRanges
        # fields should be 0
        DEVICE_DSM_FLAG_ENTIRE_DATA_SET_RANGE = 0x00000001


        _DEVICE_DATA_SET_RANGE._fields_ = [
            # size, in bytes
            ('StartingOffset', LONGLONG),
            ('LengthInBytes', DWORDLONG),
        ]

        _DEVICE_MANAGE_DATA_SET_ATTRIBUTES._fields_ = [
            # as the version
            ('Size', DWORD),
            ('Action', DEVICE_DSM_ACTION),
            ('Flags', DWORD),
            # Must be aligned to __alignof(action-specific struct)
            ('ParameterBlockOffset', DWORD),
            ('ParameterBlockLength', DWORD),
            # Must be aligned to __alignof(DEVICE_DSM_RANGE)
            ('DataSetRangesOffset', DWORD),
            ('DataSetRangesLength', DWORD),
        ]

        _DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT._fields_ = [
            # as the version
            ('Size', DWORD),
            ('Action', DEVICE_DSM_ACTION),
            ('Flags', DWORD),
            ('OperationStatus', DWORD),
            ('ExtendedError', DWORD),
            ('TargetDetailedError', DWORD),
            ('ReservedStatus', DWORD),
            # Must be aligned to __alignof(corresponding struct)
            ('OutputBlockOffset', DWORD),
            ('OutputBlockLength', DWORD),
        ]

        _DEVICE_DSM_DEFINITION._fields_ = [
            ('Action', DEVICE_DSM_ACTION),
            ('SingleRange', BOOLEAN),
            ('ParameterBlockAlignment', DWORD),
            ('ParameterBlockLength', DWORD),
            ('HasOutput', BOOLEAN),
            ('OutputBlockAlignment', DWORD),
            ('OutputBlockLength', DWORD),
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_None
        # SingleRange - No
        # ParameterBlock - No
        # Output  - No
        # OutputBlock - No
        DeviceDsmDefinition_None = [
            DeviceDsmAction_None,
            FALSE,
            0,
            0,
            FALSE,
            0,
            0
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_Trim
        # DEVICE_DSM_INPUT.Flags
        # Indicates that the ranges are not
        # part of any file
        DEVICE_DSM_FLAG_TRIM_NOT_FS_ALLOCATED = 0x80000000


        # Indicates that RZAT is not needed
        # RZAT only applies to ranges that
        # are part of a file that need the
        # additional protection
        DEVICE_DSM_FLAG_TRIM_BYPASS_RZAT = 0x40000000


        # SingleRange - No
        # ParameterBlock - No
        # Output  - No
        # OutputBlock - No
        DeviceDsmDefinition_Trim = [
            DeviceDsmAction_Trim,
            FALSE,
            0,
            0,
            FALSE,
            0,
            0
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_Notification
        # DEVICE_DSM_NOTIFICATION_PARAMETERS.Flags
        # The ranges are now in use by the
        # file type identifier
        DEVICE_DSM_NOTIFY_FLAG_BEGIN = 0x00000001


        # The ranges are no longer in use
        # by the file type identifier
        DEVICE_DSM_NOTIFY_FLAG_END = 0x00000002


        _DEVICE_DSM_NOTIFICATION_PARAMETERS._fields_ = [
            ('Size', DWORD),
            ('Flags', DWORD),
            ('NumFileTypeIDs', DWORD),
            ('FileTypeID', GUID * ANYSIZE_ARRAY),
        ]


        # SingleRange - No
        # ParameterBlock - Yes
        # Output  - No
        # OutputBlock - No
        DeviceDsmDefinition_Notification = [
            DeviceDsmAction_Notification,
            FALSE,
            DEVICE_DSM_NOTIFICATION_PARAMETERS,
            ctypes.sizeof(DEVICE_DSM_NOTIFICATION_PARAMETERS),
            FALSE,
            0,
            0
        ]
        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_OffloadRead
        # Keep as DWORD multiple
        STORAGE_OFFLOAD_MAX_TOKEN_LENGTH = 512
        STORAGE_OFFLOAD_TOKEN_ID_LENGTH = 0x1F8
        STORAGE_OFFLOAD_TOKEN_TYPE_ZERO_DATA = 0xFFFF0001


        class DUMMYUNIONNAME(ctypes.Union):
            pass


        class StorageOffloadZeroDataToken(ctypes.Structure):
            pass


        StorageOffloadZeroDataToken._fields_ = [
            ('Reserved2', BYTE * STORAGE_OFFLOAD_TOKEN_ID_LENGTH),
        ]
        DUMMYUNIONNAME.StorageOffloadZeroDataToken = StorageOffloadZeroDataToken


        DUMMYUNIONNAME._fields_ = [
            ('StorageOffloadZeroDataToken', DUMMYUNIONNAME.StorageOffloadZeroDataToken),
            ('Token', BYTE * STORAGE_OFFLOAD_TOKEN_ID_LENGTH),
        ]
        _STORAGE_OFFLOAD_TOKEN.DUMMYUNIONNAME = DUMMYUNIONNAME


        _STORAGE_OFFLOAD_TOKEN._fields_ = [
            ('TokenType', BYTE * 4),
            ('Reserved', BYTE * 2),
            ('TokenIdLength', BYTE * 2),
            ('DUMMYUNIONNAME', _STORAGE_OFFLOAD_TOKEN.DUMMYUNIONNAME),
        ]


        def MAKE_ZERO_TOKEN(T):
            T.TokenType[0] = 0xFF
            T.TokenType[1] = 0xFF
            T.TokenType[2] = 0x00
            T.TokenType[3] = 0x01
            T.TokenIdLength[0] = 0x01
            T.TokenIdLength[1] = 0xF8
            return T


        def IS_ZERO_TOKEN(T):
            return (
                T.TokenType[0] == 0xFF and
                T.TokenType[1] == 0xFF and
                T.TokenType[2] == 0x00 and
                T.TokenType[3] == 0x01 and
                T.TokenIdLength[0] == 0x01 and
                T.TokenIdLength[1] == 0xF8
            )


        _DEVICE_DSM_OFFLOAD_READ_PARAMETERS._fields_ = [
            # Reserved for future use
            ('Flags', DWORD),
            # requested by the initiator
            ('TimeToLive', DWORD),
            ('Reserved', DWORD * 2),
        ]


        # STORAGE_OFFLOAD_READ_OUTPUT.OffloadReadFlags
        STORAGE_OFFLOAD_READ_RANGE_TRUNCATED = 0x00000001


        # The token returned by the target
        # uniquely identifies a "point in
        # time" snapshot of ranges taken by
        # the target. Its format is opaque
        # We arbitrarily limit token length to 512. The SCSI interface
        # will/may enable
        # negotiable size. If we want to add support, we'll need to create a
        # new action
        _STORAGE_OFFLOAD_READ_OUTPUT._fields_ = [
            ('OffloadReadFlags', DWORD),
            ('Reserved', DWORD),
            # be from the lowest range
            ('LengthProtected', DWORDLONG),
            ('TokenLength', DWORD),
            ('Token', STORAGE_OFFLOAD_TOKEN),
        ]

        # SingleRange - No
        # ParameterBlock - Yes
        # Output  - No
        # OutputBlock - Yes
        DeviceDsmDefinition_OffloadRead = [
            DeviceDsmAction_OffloadRead,
            FALSE,
            DEVICE_DSM_OFFLOAD_READ_PARAMETERS,
            ctypes.sizeof(DEVICE_DSM_OFFLOAD_READ_PARAMETERS),
            FALSE,
            STORAGE_OFFLOAD_READ_OUTPUT,
            ctypes.sizeof(STORAGE_OFFLOAD_READ_OUTPUT)
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_OffloadWrite
        _DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS._fields_ = [
            # Reserved for future use
            ('Flags', DWORD),
            ('Reserved', DWORD),
            # "snapshot" bound to the token
            ('TokenOffset', DWORDLONG),
            ('Token', STORAGE_OFFLOAD_TOKEN),
        ]
        # STORAGE_OFFLOAD_WRITE_OUTPUT.OffloadWriteFlags
        STORAGE_OFFLOAD_WRITE_RANGE_TRUNCATED = 0x0001
        STORAGE_OFFLOAD_TOKEN_INVALID = 0x0002
        _STORAGE_OFFLOAD_WRITE_OUTPUT._fields_ = [
            ('OffloadWriteFlags', DWORD),
            ('Reserved', DWORD),
            # the "snapshot" from the start
            ('LengthCopied', DWORDLONG),
        ]
        # SingleRange - No
        # ParameterBlock - Yes
        # Output  - No
        # OutputBlock - Yes
        DeviceDsmDefinition_OffloadWrite = [
            DeviceDsmAction_OffloadWrite,
            FALSE,
            DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS,
            ctypes.sizeof(DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS),
            FALSE,
            STORAGE_OFFLOAD_WRITE_OUTPUT,
            ctypes.sizeof(STORAGE_OFFLOAD_WRITE_OUTPUT)
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_Allocation
        # DEVICE_DSM_INPUT.Flags
        DEVICE_DSM_FLAG_ALLOCATION_CONSOLIDATEABLE_ONLY = 0x40000000
        _DEVICE_DATA_SET_LBP_STATE_PARAMETERS._fields_ = [
            ('Version', DWORD),
            ('Size', DWORD),
            # Reserved for future use
            ('Flags', DWORD),
            # DEVICE_DSM_ALLOCATION_OUTPUT_V2
            ('OutputVersion', DWORD),
        ]
        DEVICE_DSM_PARAMETERS_V1 = 1
        DEVICE_DATA_SET_LBP_STATE_PARAMETERS_VERSION_V1 = (
            DEVICE_DSM_PARAMETERS_V1
        )
        _DEVICE_DATA_SET_LB_PROVISIONING_STATE._fields_ = [
            ('Size', DWORD),
            ('Version', DWORD),
            ('SlabSizeInBytes', DWORDLONG),
            # aligned to a slab boundary
            ('SlabOffsetDeltaInBytes', DWORD),
            # Number of bits that are valid
            ('SlabAllocationBitMapBitCount', DWORD),
            # Count of DWORDs in the bitmap
            ('SlabAllocationBitMapLength', DWORD),
            # 1 = mapped, 0 = unmapped
            ('SlabAllocationBitMap', DWORD * ANYSIZE_ARRAY),
        ]
        DEVICE_DSM_ALLOCATION_OUTPUT_V1 = (
            ctypes.sizeof(DEVICE_DSM_ALLOCATION_OUTPUT)
        )
        DEVICE_DATA_SET_LB_PROVISIONING_STATE_VERSION_V1 = (
            DEVICE_DSM_ALLOCATION_OUTPUT_V1
        )
        _DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2._fields_ = [
            ('Size', DWORD),
            ('Version', DWORD),
            ('SlabSizeInBytes', DWORDLONG),
            # aligned to a slab boundary
            ('SlabOffsetDeltaInBytes', DWORDLONG),
            # Number of bits that are valid
            ('SlabAllocationBitMapBitCount', DWORD),
            # Count of DWORDs in the bitmap
            ('SlabAllocationBitMapLength', DWORD),
            # 1 = mapped, 0 = unmapped
            ('SlabAllocationBitMap', DWORD * ANYSIZE_ARRAY),
        ]
        DEVICE_DSM_ALLOCATION_OUTPUT_V2 = (
            ctypes.sizeof(DEVICE_DSM_ALLOCATION_OUTPUT2)
        )
        DEVICE_DATA_SET_LB_PROVISIONING_STATE_VERSION_V2 = (
            DEVICE_DSM_ALLOCATION_OUTPUT_V2
        )
        # SingleRange - Yes
        # ParameterBlock - Yes
        # Output  - Yes
        # OutputBlock - Yes
        DeviceDsmDefinition_Allocation = [
            DeviceDsmAction_Allocation,
            TRUE,
            DEVICE_DSM_ALLOCATION_PARAMETERS,
            ctypes.sizeof(DEVICE_DSM_ALLOCATION_PARAMETERS),
            TRUE,
            DEVICE_DSM_ALLOCATION_OUTPUT2,
            ctypes.sizeof(DEVICE_DSM_ALLOCATION_OUTPUT2)
        ]
        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_Repair
        # DEVICE_DSM_INPUT.Flags
        DEVICE_DSM_FLAG_REPAIR_INPUT_TOPOLOGY_ID_PRESENT = 0x40000000
        _DEVICE_DATA_SET_REPAIR_PARAMETERS._fields_ = [
            ('NumberOfRepairCopies', DWORD),
            ('SourceCopy', DWORD),
            ('RepairCopies', DWORD * ANYSIZE_ARRAY),
        ]
        def GET_REPAIR_TOPOLOGY_ID(R):
        # DEFINE ERROR 4: #define GET_REPAIR_TOPOLOGY_ID(R) RtlOffsetToPointer(R, ALIGN_UP_BY(FIELD_OFFSET(DEVICE_DATA_SET_REPAIR_PARAMETERS, RepairCopies) + (ctypes.sizeof(DWORD) * R.NumberOfRepairCopies, 8))
            pass
        # DEVICE_DSM_OUTPUT.Flags
        DEVICE_DSM_FLAG_REPAIR_OUTPUT_PARITY_EXTENT = 0x20000000
        _DEVICE_DATA_SET_REPAIR_OUTPUT._fields_ = [
            # Valid iff DEVICE_DSM_FLAG_REPAIR_OUTPUT_PARITY_EXTENT is set
            ('ParityExtent', DEVICE_DSM_RANGE),
        ]
        # SingleRange - Yes
        # ParameterBlock - Yes
        # Output  - Yes
        # OutputBlock - Yes
        DeviceDsmDefinition_Repair = [
            DeviceDsmAction_Repair,
            TRUE,
            DEVICE_DSM_REPAIR_PARAMETERS,
            ctypes.sizeof(DEVICE_DSM_REPAIR_PARAMETERS),
            TRUE,
            DEVICE_DSM_REPAIR_OUTPUT,
            ctypes.sizeof(DEVICE_DSM_REPAIR_OUTPUT)
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_Scrub
        # DEVICE_DSM_INPUT.Flags
        DEVICE_DSM_FLAG_SCRUB_SKIP_IN_SYNC = 0x10000000
        _DEVICE_DATA_SET_SCRUB_OUTPUT._fields_ = [
            ('BytesProcessed', DWORDLONG),
            ('BytesRepaired', DWORDLONG),
            ('BytesFailed', DWORDLONG),
        ]
        # DEVICE_DSM_OUTPUT.Flags
        DEVICE_DSM_FLAG_SCRUB_OUTPUT_PARITY_EXTENT = 0x20000000
        _DEVICE_DATA_SET_SCRUB_EX_OUTPUT._fields_ = [
            ('BytesProcessed', DWORDLONG),
            ('BytesRepaired', DWORDLONG),
            ('BytesFailed', DWORDLONG),
            # Valid iff DEVICE_DSM_FLAG_SCRUB_OUTPUT_PARITY_EXTENT is set
            ('ParityExtent', DEVICE_DSM_RANGE),
        ]
        # SingleRange - No
        # ParameterBlock - No
        # Output  - Yes
        # OutputBlock - Yes
        DeviceDsmDefinition_Scrub = [
            DeviceDsmAction_Scrub,
            FALSE,
            0,
            0,
            TRUE,
            DEVICE_DSM_SCRUB_OUTPUT2,
            ctypes.sizeof(DEVICE_DSM_SCRUB_OUTPUT2)
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_DrtQuery
        # SingleRange - No
        # ParameterBlock - No
        # Output  - Yes
        # OutputBlock - No
        DeviceDsmDefinition_DrtQuery = [
            DeviceDsmAction_DrtQuery,
            FALSE,
            0,
            0,
            TRUE,
            0,
            0
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_DrtClear
        # SingleRange - No
        # ParameterBlock - No
        # Output  - No
        # OutputBlock - No
        DeviceDsmDefinition_DrtClear = [
            DeviceDsmAction_DrtClear,
            FALSE,
            0,
            0,
            FALSE,
            0,
            0
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_DrtDisable
        # SingleRange - No
        # ParameterBlock - No
        # Output  - No
        # OutputBlock - No
        DeviceDsmDefinition_DrtDisable = [
            DeviceDsmAction_DrtDisable,
            FALSE,
            0,
            0,
            FALSE,
            0,
            0
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_TieringQuery
        _DEVICE_DSM_TIERING_QUERY_INPUT._fields_ = [
            ('Version', DWORD),
            ('Size', DWORD),
            # Reserved for future use
            ('Flags', DWORD),
            ('NumberOfTierIds', DWORD),
            ('TierIds', GUID * ANYSIZE_ARRAY),
        ]
        _STORAGE_TIER_REGION._fields_ = [
            ('TierId', GUID),
            ('Offset', DWORDLONG),
            ('Length', DWORDLONG),
        ]
        _DEVICE_DSM_TIERING_QUERY_OUTPUT._fields_ = [
            ('Version', DWORD),
            ('Size', DWORD),
            # Reserved for future use
            ('Flags', DWORD),
            ('Reserved', DWORD),
            # aligned to a region boundary
            ('Alignment', DWORDLONG),
            # are in the specified range
            ('TotalNumberOfRegions', DWORD),
            ('NumberOfRegionsReturned', DWORD),
            ('Regions', STORAGE_TIER_REGION * ANYSIZE_ARRAY),
        ]
        # SingleRange - Yes
        # ParameterBlock - Yes
        # Output  - Yes
        # OutputBlock - Yes
        DeviceDsmDefinition_TieringQuery = [
            DeviceDsmAction_TieringQuery,
            TRUE,
            DEVICE_DSM_TIERING_QUERY_PARAMETERS,
            ctypes.sizeof(DEVICE_DSM_TIERING_QUERY_PARAMETERS),
            TRUE,
            DEVICE_DSM_TIERING_QUERY_OUTPUT,
            ctypes.sizeof(DEVICE_DSM_TIERING_QUERY_OUTPUT)
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_Map
        # SingleRange - No
        # ParameterBlock - No
        # Output  - No
        # OutputBlock - No
        DeviceDsmDefinition_Map = [
            DeviceDsmAction_Map,
            FALSE,
            0,
            0,
            FALSE,
            0,
            0
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_RegenerateParity
        # SingleRange - No
        # ParameterBlock - No
        # Output  - No
        # OutputBlock - No
        DeviceDsmDefinition_RegenerateParity = [
            DeviceDsmAction_RegenerateParity,
            FALSE,
            0,
            0,
            FALSE,
            0,
            0
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_NvCache_Change_Priority
        _DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS._fields_ = [
            ('Size', DWORD),
            ('TargetPriority', BYTE),
            ('Reserved', BYTE * 3),
        ]
        # SingleRange - No
        # ParameterBlock - Yes
        # Output  - No
        # OutputBlock - No
        DeviceDsmDefinition_NvCache_Change_Priority = [
            DeviceDsmAction_NvCache_Change_Priority,
            FALSE,
            DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS,
            ctypes.sizeof(DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS),
            FALSE,
            0,
            0
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_NvCache_Evict
        # SingleRange - No
        # ParameterBlock - No
        # Output  - No
        # OutputBlock - No
        DeviceDsmDefinition_NvCache_Evict = [
            DeviceDsmAction_NvCache_Evict,
            FALSE,
            0,
            0,
            FALSE,
            0,
            0
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_TopologyIdQuery
        _DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT._fields_ = [
            # start of an input range
            ('TopologyRangeBytes', DWORDLONG),
            # The corresponding topology id
            ('TopologyId', BYTE * 16),
        ]
        # SingleRange - No
        # ParameterBlock - No
        # Output  - Yes
        # OutputBlock - Yes
        DeviceDsmDefinition_TopologyIdQuery = [
            DeviceDsmAction_TopologyIdQuery,
            FALSE,
            0,
            0,
            TRUE,
            DEVICE_DSM_TOPOLOGY_ID_QUERY_OUTPUT,
            ctypes.sizeof(DEVICE_DSM_TOPOLOGY_ID_QUERY_OUTPUT)
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_GetPhysicalAddresses
        # DEVICE_DSM_INPUT.Flags
        # If set, TotalNumberOfRanges field will be 0.
        # A caller that doesn't need to know the total
        # number of ranges should set this flag as a
        # performance optimization, because the device
        # might incur some cost calculating the total
        # number of ranges.
        DEVICE_DSM_FLAG_PHYSICAL_ADDRESSES_OMIT_TOTAL_RANGES = 0x10000000
        _DEVICE_STORAGE_ADDRESS_RANGE._fields_ = [
            ('StartAddress', LONGLONG),
            ('LengthInBytes', DWORDLONG),
        ]
        _DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT._fields_ = [
            ('Version', DWORD),
            # Reserved for future use
            ('Flags', DWORD),
            # buffer
            ('TotalNumberOfRanges', DWORD),
            # be returned
            ('NumberOfRangesReturned', DWORD),
            ('Ranges', DEVICE_STORAGE_ADDRESS_RANGE * ANYSIZE_ARRAY),
        ]
        DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT_V1 = 1
        DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT_VERSION_V1 = (
            DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT_V1
        )
        # SingleRange - No
        # ParameterBlock - No
        # Output  - Yes
        # OutputBlock - Yes
        DeviceDsmDefinition_GetPhysicalAddresses = [
            DeviceDsmAction_GetPhysicalAddresses,
            FALSE,
            0,
            0,
            TRUE,
            DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT,
            ctypes.sizeof(DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT)
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_ScopeRegen
        # SingleRange - No
        # ParameterBlock - No
        # Output  - No
        # OutputBlock - No
        DeviceDsmDefinition_ScopeRegen = [
            DeviceDsmAction_ScopeRegen,
            FALSE,
            0,
            0,
            FALSE,
            0,
            0
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_ReportZones
        _DEVICE_DSM_REPORT_ZONES_PARAMETERS._fields_ = [
            ('Size', DWORD),
            ('ReportOption', BYTE),
            # of the zone list length
            ('Partial', BYTE),
            ('Reserved', BYTE * 2),
        ]


        class _STORAGE_ZONES_ATTRIBUTES(ENUM):
            ZonesAttributeTypeAndLengthMayDifferent = 0
            ZonesAttributeTypeSameLengthSame = 1
            ZonesAttributeTypeSameLastZoneLengthDifferent = 2
            ZonesAttributeTypeMayDifferentLengthSame = 3

        STORAGE_ZONES_ATTRIBUTES = _STORAGE_ZONES_ATTRIBUTES
        PSTORAGE_ZONES_ATTRIBUTES = POINTER(_STORAGE_ZONES_ATTRIBUTES)


        class _STORAGE_ZONE_CONDITION(ENUM):
            ZoneConditionConventional = 0x00
            ZoneConditionEmpty = 0x01
            ZoneConditionImplicitlyOpened = 0x02
            ZoneConditionExplicitlyOpened = 0x03
            ZoneConditionClosed = 0x04
            ZoneConditionReadOnly = 0x0D
            ZoneConditionFull = 0x0E
            ZoneConditionOffline = 0x0F

        STORAGE_ZONE_CONDITION = _STORAGE_ZONE_CONDITION
        PSTORAGE_ZONE_CONDITION = POINTER(_STORAGE_ZONE_CONDITION)

        _STORAGE_ZONE_DESCRIPTOR._fields_ = [
            ('Size', DWORD),
            ('ZoneType', STORAGE_ZONE_TYPES),
            ('ZoneCondition', STORAGE_ZONE_CONDITION),
            ('ResetWritePointerRecommend', BOOLEAN),
            ('Reserved0', BYTE * 3),
            # In bytes
            ('ZoneSize', DWORDLONG),
            ('WritePointerOffset', DWORDLONG),
        ]

        _DEVICE_DSM_REPORT_ZONES_DATA._fields_ = [
            ('Size', DWORD),
            ('ZoneCount', DWORD),
            ('Attributes', STORAGE_ZONES_ATTRIBUTES),
            ('Reserved0', DWORD),
            ('ZoneDescriptors', STORAGE_ZONE_DESCRIPTOR * ANYSIZE_ARRAY),
        ]

        # SingleRange - No
        # ParameterBlock - Yes
        # Output  - Yes
        # OutputBlock - Yes
        DeviceDsmDefinition_ReportZones = [
            DeviceDsmAction_ReportZones,
            FALSE,
            DEVICE_DSM_REPORT_ZONES_PARAMETERS,
            ctypes.sizeof(DEVICE_DSM_REPORT_ZONES_PARAMETERS),
            TRUE,
            DEVICE_DSM_REPORT_ZONES_OUTPUT,
            ctypes.sizeof(DEVICE_DSM_REPORT_ZONES_OUTPUT)
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_OpenZone
        # SingleRange - No
        # ParameterBlock - No
        # Output  - No
        # OutputBlock - No
        DeviceDsmDefinition_OpenZone = [
            DeviceDsmAction_OpenZone,
            FALSE,
            0,
            0,
            FALSE,
            0,
            0
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_FinishZone
        # SingleRange - No
        # ParameterBlock - No
        # Output  - No
        # OutputBlock - No
        DeviceDsmDefinition_FinishZone = [
            DeviceDsmAction_FinishZone,
            FALSE,
            0,
            0,
            FALSE,
            0,
            0
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_CloseZone
        # SingleRange - No
        # ParameterBlock - No
        # Output  - No
        # OutputBlock - No
        DeviceDsmDefinition_CloseZone = [
            DeviceDsmAction_CloseZone,
            FALSE,
            0,
            0,
            FALSE,
            0,
            0
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_ResetWritePointer
        # SingleRange - No
        # ParameterBlock - No
        # Output  - No
        # OutputBlock - No
        DeviceDsmDefinition_ResetWritePointer = [
            DeviceDsmAction_ResetWritePointer,
            FALSE,
            0,
            0,
            FALSE,
            0,
            0
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_GetRangeErrorInfo
        class _Union_1(ctypes.Union):
            pass


        class _Struct_1(ctypes.Structure):
            pass


        _Struct_1._fields_ = [
            # 1 = bad, 0 = good
            ('IsRangeBad', DWORD, 1),
        ]
        _Union_1._Struct_1 = _Struct_1

        _Union_1._anonymous_ = (
            '_Struct_1',
        )

        _Union_1._fields_ = [
            ('AllFlags', DWORD),
            ('_Struct_1', _Union_1._Struct_1),
        ]
        _DEVICE_STORAGE_RANGE_ATTRIBUTES._Union_1 = _Union_1

        _DEVICE_STORAGE_RANGE_ATTRIBUTES._anonymous_ = (
            '_Union_1',
        )

        _DEVICE_STORAGE_RANGE_ATTRIBUTES._fields_ = [
            # size, in bytes
            ('LengthInBytes', DWORDLONG),
            ('_Union_1', _DEVICE_STORAGE_RANGE_ATTRIBUTES._Union_1),
            ('Reserved', DWORD),
        ]

        # DEVICE_DSM_RANGE_ERROR_OUTPUT.Flags
        DEVICE_STORAGE_NO_ERRORS = 0x1


        _DEVICE_DSM_RANGE_ERROR_INFO._fields_ = [
            ('Version', DWORD),
            ('Flags', DWORD),
            # buffer
            ('TotalNumberOfRanges', DWORD),
            # of the length of the output ranges.
            ('NumberOfRangesReturned', DWORD),
            ('Ranges', DEVICE_STORAGE_RANGE_ATTRIBUTES * ANYSIZE_ARRAY),
        ]
        DEVICE_DSM_RANGE_ERROR_OUTPUT_V1 = 1
        DEVICE_DSM_RANGE_ERROR_INFO_VERSION_V1 = (
            DEVICE_DSM_RANGE_ERROR_OUTPUT_V1
        )

        # SingleRange - No
        # ParameterBlock - No
        # Output  - Yes
        # OutputBlock - Yes
        DeviceDsmDefinition_GetRangeErrorInfo = [
            DeviceDsmAction_GetRangeErrorInfo,
            FALSE,
            0,
            0,
            TRUE,
            DEVICE_DSM_RANGE_ERROR_OUTPUT,
            ctypes.sizeof(DEVICE_DSM_RANGE_ERROR_OUTPUT)
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_WriteZeroes
        # ParameterBlock - No
        # Output  - No
        # SingleRange - No
        # ParameterBlock - No
        # Output  - No
        # OutputBlock - No
        DeviceDsmDefinition_WriteZeroes = [
            DeviceDsmAction_WriteZeroes,
            FALSE,
            0,
            0,
            FALSE,
            0,
            0
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_LostQuery
        _DEVICE_DSM_LOST_QUERY_PARAMETERS._fields_ = [
            # as the version
            ('Version', DWORD),
            ('Granularity', DWORDLONG),
        ]
        _DEVICE_DSM_LOST_QUERY_OUTPUT._fields_ = [
            # as the version
            ('Version', DWORD),
            # needed for the entire range
            ('Size', DWORD),
            # granularity aligned
            ('Alignment', DWORDLONG),
            # 1 = lost, 0 = readable
            ('NumberOfBits', DWORD),
            ('BitMap', DWORD * ANYSIZE_ARRAY),
        ]
        # SingleRange - Yes
        # ParameterBlock - Yes
        # Output  - Yes
        # OutputBlock - Yes
        DeviceDsmDefinition_LostQuery = [
            DeviceDsmAction_LostQuery,
            TRUE,
            DEVICE_DSM_LOST_QUERY_PARAMETERS,
            ctypes.sizeof(DEVICE_DSM_LOST_QUERY_PARAMETERS),
            TRUE,
            DEVICE_DSM_LOST_QUERY_OUTPUT,
            ctypes.sizeof(DEVICE_DSM_LOST_QUERY_OUTPUT)
        ]

        # ////////////////////////////////////////////////////////////////////
        # DeviceDsmAction_GetFreeSpace
        _DEVICE_DSM_FREE_SPACE_OUTPUT._fields_ = [
            # as the version
            ('Version', DWORD),
            # Shared free space available
            ('FreeSpace', DWORDLONG),
        ]
        # SingleRange - No
        # ParameterBlock - No
        # Output  - Yes
        # OutputBlock - Yes
        DeviceDsmDefinition_GetFreeSpace = [
            DeviceDsmAction_GetFreeSpace,
            FALSE,
            0,
            0,
            TRUE,
            DEVICE_DSM_FREE_SPACE_OUTPUT,
            ctypes.sizeof(DEVICE_DSM_FREE_SPACE_OUTPUT)
        ]

        # ////////////////////////////////////////////////////////////////////
        # Dsm helper routines
        def DEVICE_DSM_ROUND_UP(_a, _b):
            return ((_a + (_b - 1)) / _b * _b)


        def DEVICE_DSM_ROUND_DN(_a, _b):
            return (_a ) / _b * _b


        # end IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES
        # ////////////////////////////////////////////////////////////////////
        # There are some well known GUIDS for certain types of files. They are
        # defined in NTIFS.H
        # IOCTL_STORAGE_GET_BC_PROPERTIES
        # Input Buffer:
        # None
        # Output Buffer:
        # Structure of type STORAGE_GET_BC_PROPERTIES_OUTPUT
        _STORAGE_GET_BC_PROPERTIES_OUTPUT._fields_ = [
            # that can be scheduled per period of time
            ('MaximumRequestsPerPeriod', DWORD),
            # device uses when scheduling requests
            ('MinimumPeriod', DWORD),
            # requests should be of this size
            ('MaximumRequestSize', DWORDLONG),
            # is for informational purposes only
            ('EstimatedTimePerRequest', DWORD),
            # has an outstanding contract.
            ('NumOutStandingRequests', DWORD),
            # target file has an outstanding contract.
            ('RequestSize', DWORDLONG),
        ]
        # IOCTL_STORAGE_ALLOCATE_BC_STREAM
        # Input Buffer:
        # Structure of type STORAGE_ALLOCATE_BC_STREAM_INPUT
        # Output Buffer:
        # Structure of type STORAGE_ALLOCATE_BC_STREAM_OUTPUT
        # Current version
        IOCTL_STORAGE_BC_VERSION = 1
        _STORAGE_ALLOCATE_BC_STREAM_INPUT._fields_ = [
            # Specifies the corresponding structure version
            ('Version', DWORD),
            # need to complete per period of time
            ('RequestsPerPeriod', DWORD),
            # above number of requests must complete
            ('Period', DWORD),
            # should be retried or not
            ('RetryFailures', BOOLEAN),
            # their deadline should be discarded or not
            ('Discardable', BOOLEAN),
            # Helps align the following field
            ('Reserved1', BOOLEAN * 2),
            # comprised of reads, writes or both
            ('AccessType', DWORD),
            # file will be sequential or random
            ('AccessMode', DWORD),
        ]
        _STORAGE_ALLOCATE_BC_STREAM_OUTPUT._fields_ = [
            # of requests in this stream
            ('RequestSize', DWORDLONG),
            # device busy and thus obtain maximum throughput
            ('NumOutStandingRequests', DWORD),
        ]
        # IOCTL_STORAGE_FREE_BC_STREAM
        # Input Buffer:
        # None
        # Output Buffer:
        # None
        # IOCTL_STORAGE_CHECK_PRIORITY_HINT_SUPPORT
        # Input Buffer :
        # None
        # Output Buffer :
        # Structure of type STORAGE_PRIORITY_HINT_SUPPORT
        STORAGE_PRIORITY_HINT_SUPPORTED = 0x0001
        _STORAGE_PRIORITY_HINT_SUPPORT._fields_ = [
            ('SupportFlags', DWORD),
        ]
        # IOCTL_STORAGE_DIAGNOSTIC
        # Input Buffer :
        # STORAGE_DIAGNOSTIC_REQUEST
        # Output Buffer :
        # STORAGE_DIAGNOSTIC_DATA
        class _STORAGE_DIAGNOSTIC_LEVEL(ENUM):
            StorageDiagnosticLevelDefault = 0
            StorageDiagnosticLevelMax = 1

        STORAGE_DIAGNOSTIC_LEVEL = _STORAGE_DIAGNOSTIC_LEVEL
        PSTORAGE_DIAGNOSTIC_LEVEL = POINTER(_STORAGE_DIAGNOSTIC_LEVEL)


        class _STORAGE_DIAGNOSTIC_TARGET_TYPE(ENUM):
            StorageDiagnosticTargetTypeUndefined = 0
            StorageDiagnosticTargetTypePort = 1
            StorageDiagnosticTargetTypeMiniport = 2
            StorageDiagnosticTargetTypeHbaFirmware = 3
            StorageDiagnosticTargetTypeMax = 4

        STORAGE_DIAGNOSTIC_TARGET_TYPE = _STORAGE_DIAGNOSTIC_TARGET_TYPE
        PSTORAGE_DIAGNOSTIC_TARGET_TYPE = POINTER(_STORAGE_DIAGNOSTIC_TARGET_TYPE)


        # STORAGE_DIAGNOSTIC_REQUEST
        _STORAGE_DIAGNOSTIC_REQUEST._fields_ = [
            # Size of this structure.
            ('Version', DWORD),
            # (In case adding variable-sized buffer in future.)
            ('Size', DWORD),
            # Reserved for future use.
            ('Reserved', DWORD),
            # Request target type. See definitions for
            # STORAGE_DIAGNOSTIC_TARGET_TYPE.
            ('TargetType', STORAGE_DIAGNOSTIC_TARGET_TYPE),
            # Diagnostic level. See definitions for STORAGE_DIAGNOSTIC_LEVEL.
            ('Level', STORAGE_DIAGNOSTIC_LEVEL),
        ]


        # STORAGE_DIAGNOSTIC_DATA
        _STORAGE_DIAGNOSTIC_DATA._fields_ = [
            # Size of this structure.
            ('Version', DWORD),
            # Whole size of the structure and the associated data buffer.
            ('Size', DWORD),
            # GUID of diagnostic data provider.
            ('ProviderId', GUID),
            # it should be cleared to zero for other cases.
            ('BufferSize', DWORD),
            # Reserved for future use.
            ('Reserved', DWORD),
            # Diagnostic data buffer.
            ('DiagnosticDataBuffer', BYTE * ANYSIZE_ARRAY),
        ]


        # IOCTL_STORAGE_GET_PHYSICAL_ELEMENT_STATUS
        # Input:
        # PHYSICAL_ELEMENT_STATUS_REQUEST
        # Output:
        # PHYSICAL_ELEMENT_STATUS
        _PHYSICAL_ELEMENT_STATUS_REQUEST._fields_ = [
            ('Version', DWORD),
            ('Size', DWORD),
            ('StartingElement', DWORD),
            ('Filter', BYTE),
            ('ReportType', BYTE),
            ('Reserved', BYTE * 2),
        ]

        _PHYSICAL_ELEMENT_STATUS_DESCRIPTOR._fields_ = [
            ('Version', DWORD),
            ('Size', DWORD),
            ('ElementIdentifier', DWORD),
            ('PhysicalElementType', BYTE),
            ('PhysicalElementHealth', BYTE),
            ('Reserved1', BYTE * 2),
            # In unit of LBA.
            ('AssociatedCapacity', DWORDLONG),
            ('Reserved2', DWORD * 4),
        ]

        _PHYSICAL_ELEMENT_STATUS._fields_ = [
            ('Version', DWORD),
            ('Size', DWORD),
            ('DescriptorCount', DWORD),
            ('ReturnedDescriptorCount', DWORD),
            ('ElementIdentifierBeingDepoped', DWORD),
            ('Reserved', DWORD),
            ('Descriptors', PHYSICAL_ELEMENT_STATUS_DESCRIPTOR * ANYSIZE_ARRAY),
        ]

        # IOCTL_STORAGE_REMOVE_ELEMENT_AND_TRUNCATE
        # Input:
        # REMOVE_ELEMENT_AND_TRUNCATE_REQUEST
        _REMOVE_ELEMENT_AND_TRUNCATE_REQUEST._fields_ = [
            ('Version', DWORD),
            ('Size', DWORD),
            # In unit of LBA.
            ('RequestCapacity', DWORDLONG),
            ('ElementIdentifier', DWORD),
            ('Reserved', DWORD),
        ]
        if defined(_MSC_EXTENSIONS):
            _TEMP__STORAGE_MEDIA_SERIAL_NUMBER_DATA = [
                ('Reserved', WORD),
                # does not have a valid serial number.
                ('SerialNumberLength', WORD),
            ]
            if not defined(__midl):
                _TEMP__STORAGE_MEDIA_SERIAL_NUMBER_DATA += [
                    # caller.
                    ('SerialNumber', BYTE * 0),
                ]
            # END IF


            _STORAGE_MEDIA_SERIAL_NUMBER_DATA._fields_ = _TEMP__STORAGE_MEDIA_SERIAL_NUMBER_DATA
        # END IF  _MSC_EXTENSIONS


        _STORAGE_READ_CAPACITY._fields_ = [
            # The version number, size of the STORAGE_READ_CAPACITY structure
            ('Version', DWORD),
            # The size of the date returned, size of the STORAGE_READ_CAPACITY
            # structure
            ('Size', DWORD),
            # Number of bytes per block
            ('BlockLength', DWORD),
            # This will have the last LBA + 1
            ('NumberOfBlocks', LARGE_INTEGER),
            # Disk size in bytes
            ('DiskLength', LARGE_INTEGER),
        ]


        # Device write cache property
        # This property provides the write cache information
        # about the target device.
        class _WRITE_CACHE_TYPE(ENUM):
            WriteCacheTypeUnknown = 1
            WriteCacheTypeNone = 2
            WriteCacheTypeWriteBack = 3
            WriteCacheTypeWriteThrough = 4

        WRITE_CACHE_TYPE = _WRITE_CACHE_TYPE


        class _WRITE_CACHE_ENABLE(ENUM):
            WriteCacheEnableUnknown = 1
            WriteCacheDisabled = 2
            WriteCacheEnabled = 3

        WRITE_CACHE_ENABLE = _WRITE_CACHE_ENABLE


        class _WRITE_CACHE_CHANGE(ENUM):
            WriteCacheChangeUnknown = 1
            WriteCacheNotChangeable = 2
            WriteCacheChangeable = 3

        WRITE_CACHE_CHANGE = _WRITE_CACHE_CHANGE


        class _WRITE_THROUGH(ENUM):
            WriteThroughUnknown = 1
            WriteThroughNotSupported = 2
            WriteThroughSupported = 3

        WRITE_THROUGH = _WRITE_THROUGH

        _STORAGE_WRITE_CACHE_PROPERTY._fields_ = [
            # Size of STORAGE_WRITE_CACHE_PROPERTY structure
            ('Version', DWORD),
            # Size of STORAGE_WRITE_CACHE_PROPERTY structure
            ('Size', DWORD),
            # Current write cache type
            ('WriteCacheType', WRITE_CACHE_TYPE),
            # Current write cache value
            ('WriteCacheEnabled', WRITE_CACHE_ENABLE),
            # Device write cache change capability
            ('WriteCacheChangeable', WRITE_CACHE_CHANGE),
            # Device write through support capability
            ('WriteThroughSupported', WRITE_THROUGH),
            # Device flush cache capability
            ('FlushCacheSupported', BOOLEAN),
            # User selected power protection option through registry
            ('UserDefinedPowerProtection', BOOLEAN),
            # Device has battery backup for write cache
            ('NVCacheEnabled', BOOLEAN),
        ]
        if defined(_MSC_EXTENSIONS):
            class DUMMYUNIONNAME(ctypes.Union):
                pass


            class PR_IN(ctypes.Structure):
                pass


            PR_IN._fields_ = [
                # Persistent Reserve service action.
                ('ServiceAction', BYTE, 5),
                ('Reserved1', BYTE, 3),
                # Number of bytes allocated for returned parameter list.
                ('AllocationLength', WORD),
            ]
            DUMMYUNIONNAME.PR_IN = PR_IN


            class PR_OUT(ctypes.Structure):
                pass

            _TEMP_PR_OUT = [
                # Persistent Reserve service action.
                ('ServiceAction', BYTE, 5),
                ('Reserved1', BYTE, 3),
                # Persistent Reserve type and scope.
                ('Type', BYTE, 4),
                ('Scope', BYTE, 4),
            ]
            if not defined(__midl):
                _TEMP_PR_OUT += [
                    # Space for additional PR Out parameters.
                    ('ParameterList', BYTE * 0),
                ]
            # END IF


            PR_OUT._fields_ = _TEMP_PR_OUT
            DUMMYUNIONNAME.PR_OUT = PR_OUT


            DUMMYUNIONNAME._fields_ = [
                ('PR_IN', DUMMYUNIONNAME.PR_IN),
                ('PR_OUT', DUMMYUNIONNAME.PR_OUT),
            ]
            _PERSISTENT_RESERVE_COMMAND.DUMMYUNIONNAME = DUMMYUNIONNAME


            _PERSISTENT_RESERVE_COMMAND._fields_ = [
                ('Version', DWORD),
                ('Size', DWORD),
                ('DUMMYUNIONNAME', _PERSISTENT_RESERVE_COMMAND.DUMMYUNIONNAME),
            ]
        # END IF  _MSC_EXTENSIONS

        # Device telemetry definitions
        # Structures and interfaces dealing with acquistion of device and
        # driver internal telemetry.
        # For variable size fields we use byte array, defined with zero length
        # in structure template. Length of the field is stored as a separate
        # field.
        # No more than one variable size field is allowed in one structure and
        # it is always placed last.
        # Persistent data structures are versioned and "sized" by adding
        # structure version field and structure size field
        DEVICEDUMP_STRUCTURE_VERSION_V1 = 1


        # Max size of the identification string
        # Keep proportional to (ctypes.sizeof (DWORD)
        DEVICEDUMP_MAX_IDSTRING = 32
        # 128
        # (ACS specification + 1 for zero termination + 3 to align on DWORD)
        MAX_FW_BUCKET_ID_LENGTH = 132
        # Global telemetry collection parameters in the registry
        STORAGE_CRASH_TELEMETRY_REGKEY = (
            "\\Registry\\Machine\\System\\CurrentControlSet\\Control\\CrashControl\\StorageTelemetry"
        )
        STORAGE_DEVICE_TELEMETRY_REGKEY = (
            "\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Storage\\StorageTelemetry"
        )
        # Reasons for telemetry collection
        class _DEVICEDUMP_COLLECTION_TYPE(ENUM):
            TCCollectionBugCheck = 1
            TCCollectionApplicationRequested = 2
            TCCollectionDeviceRequested = 3

        DEVICEDUMP_COLLECTION_TYPEIDE_NOTIFICATION_TYPE = _DEVICEDUMP_COLLECTION_TYPE
        PDEVICEDUMP_COLLECTION_TYPE = POINTER(_DEVICEDUMP_COLLECTION_TYPE)


        # Flags for the device dump section
        DDUMP_FLAG_DATA_READ_FROM_DEVICE = 0x0001


        # Firmware issue IDs (similar to bug check reasons)
        FW_ISSUEID_NO_ISSUE = 0x00000000
        FW_ISSUEID_UNKNOWN = 0xFFFFFFFF


        # Structures are packed on a byte boundary , because parsers may run
        # on separate machines and different OS flavors
        from pyWinAPI.shared.pshpack1_h import * # NOQA

        # Device dump section contains common device dump header, followed by
        # set of relative pointers to sub sections
        # Each relative pointer contain size in bytes of the subsection and
        # starting offset from the beginning of the section
        # Layout of the device dump section is as
        # HEADER  - common descriptor
        # PUBLIC DATA - publicly accessible data (eg SMART structures)
        # RESRICTED DATA - restricted access data
        # (eg encrypted with Microsoft and IHV public keys)
        # PRIVATE DATA - private device data
        # All fields in the section definition are used cross platform = >
        # types used are platform neutral
        # Relative descript or of a subsection, contains size of the
        # subsection and relative offset (0 is the start of the section)
        # Size (in bytes) of the subsection
        _DEVICEDUMP_SUBSECTION_POINTER._fields_ = [
            ('dwSize', DWORD),
            # Parameter flags for the subsection
            ('dwFlags', DWORD),
            # Offset (in bytes) of the subsection block from the start of the
            # buffer
            ('dwOffset', DWORD),
        ]


        # Data structure tagging fields (version and size)
        _DEVICEDUMP_STRUCTURE_VERSION._fields_ = [
            # Header signature, useful for identifying the structure when
            # reading the dump
            ('dwSignature', DWORD),
            # Version of the template
            ('dwVersion', DWORD),
            # Size of the parent structure in bytes
            ('dwSize', DWORD),
        ]


        # Device data header for the secondary data (in crashdump) section ,
        # holding device dump information.
        _DEVICEDUMP_SECTION_HEADER._fields_ = [
            # GUID, identifying device dump section. Same GUID as used in
            # registering for SecondaryData callback, stored here for live
            # telemetry interface consistency
            ('guidDeviceDataId', GUID),
            # Unique identifier assigned to the organization responsible for
            # device quality (firmware quality). In most cases this is OUID
            # (IEEE) or WorldWideName of the device vendor
            ('sOrganizationID', BYTE * 16),
            # Firmware revision as indicated in IDENITFY or INQUIRY structures
            ('dwFirmwareRevision', DWORD),
            # Device model number
            # (keep the length of the field proportional to (ctypes.sizeof (DWORD))
            #
            ('sModelNumber', BYTE * DEVICEDUMP_MAX_IDSTRING),
            # Keep the length of the field proportional to
            # (ctypes.sizeof (DWORD)
            ('szDeviceManufacturingID', BYTE * DEVICEDUMP_MAX_IDSTRING),
            # Set to 0 if the device doesn't support the command and the
            # driver filled in as best it could
            ('dwFlags', DWORD),
            # Version of private data as indicated by the firmware.Initially
            # always 0 to specify Private only unspecified data
            ('bRestrictedPrivateDataVersion', DWORD),
            # currently unused
            ('dwFirmwareIssueId', DWORD),
            # zero terminated
            ('szIssueDescriptionString', BYTE * MAX_FW_BUCKET_ID_LENGTH),
        ]
        # Public subsection header - subsection is holding data, describing
        # device state and accessible to everybody.
        TC_PUBLIC_DEVICEDUMP_CONTENT_SMART = 0x01
        TC_PUBLIC_DEVICEDUMP_CONTENT_GPLOG = 0x02
        # Maximum number of log pages collected into the public section
        TC_PUBLIC_DEVICEDUMP_CONTENT_GPLOG_MAX = 16
        # Maximum length of the description of the collected pages
        # (filled by the miniport)
        TC_DEVICEDUMP_SUBSECTION_DESC_LENGTH = 16
        # Standard types of collected pages
        TC_PUBLIC_DATA_TYPE_ATAGP = "ATAGPLogPages"
        TC_PUBLIC_DATA_TYPE_ATASMART = "ATASMARTPages"
        # Public data is tagged with the table of "log descriptors". Each
        # descriptor has LogAddress and number of pages.
        # Specific meaning, assigned to the descriptor, is relative to the
        # command set used.
        _GP_LOG_PAGE_DESCRIPTOR._fields_ = [
            ('LogAddress', WORD),
            ('LogSectors', WORD),
        ]
        _DEVICEDUMP_PUBLIC_SUBSECTION._fields_ = [
            ('dwFlags', DWORD),
            ('GPLogTable', GP_LOG_PAGE_DESCRIPTOR * TC_PUBLIC_DEVICEDUMP_CONTENT_GPLOG_MAX),
            # Zero terminated
            ('szDescription', CHAR * TC_DEVICEDUMP_SUBSECTION_DESC_LENGTH),
            # Data byte array ANYSIZE_ARRAY
            ('bData', BYTE * ANYSIZE_ARRAY),
        ]
        # Restricted subsection header - subsection is holding data,
        # describing device state and accessible only to Microsoft and a
        # device vendor
        _DEVICEDUMP_RESTRICTED_SUBSECTION._fields_ = [
            # Data byte array (ANYSIZE_ARRAY)
            ('bData', BYTE * ANYSIZE_ARRAY),
        ]
        # Private subsection header - subsection is holding data, describing
        # device state and accessible only to a device vendor
        _DEVICEDUMP_PRIVATE_SUBSECTION._fields_ = [
            ('dwFlags', DWORD),
            ('GPLogId', GP_LOG_PAGE_DESCRIPTOR),
            # Data byte array (ANYSIZE_ARRAY)
            ('bData', BYTE * ANYSIZE_ARRAY),
        ]
        # Descriptor of the storage device dump section

        _DEVICEDUMP_STORAGEDEVICE_DATA._fields_ = [
            # Common descriptor (signature,version of the structure)
            ('Descriptor', DEVICEDUMP_STRUCTURE_VERSION),
            # Header - set of fields, describing dump section and device
            # (not requiring protocol communication)
            ('SectionHeader', DEVICEDUMP_SECTION_HEADER),
            # Size of the whole section buffer, in bytes , including header
            # and sum total of all the variable sized sub sections
            ('dwBufferSize', DWORD),
            # Reason for collecting telemetry
            ('dwReasonForCollection', DWORD),
            # "Pointers" to individual sub-sections. Sub sections are filled
            # with the information, obtained from the device
            ('PublicData', DEVICEDUMP_SUBSECTION_POINTER),
            ('RestrictedData', DEVICEDUMP_SUBSECTION_POINTER),
            ('PrivateData', DEVICEDUMP_SUBSECTION_POINTER)
        ]

        # Driver dump section contains common device driver context
        # information:
        # - circular buffer of the IO requests as visible by the lower edge of
        # the driver
        # (in case of storage that would be an interface to the controller stack or controller itself)
        #
        # All fields in the section definition are used cross platform = >
        # types used are platform neutral
        # Format of the single record for publicly accessible driver state
        # table
        CDB_SIZE = 16
        TELEMETRY_COMMAND_SIZE = 16
        TCRecordStorportSrbFunction = Command[0]
        # The CDB for this request. variable sized CDBs are truncated.
        class StackSpecific(ctypes.Union):
            pass


        class ExternalStack(ctypes.Structure):
            pass


        ExternalStack._fields_ = [
            ('dwReserved', DWORD),
        ]
        StackSpecific.ExternalStack = ExternalStack


        class AtaPort(ctypes.Structure):
            pass


        AtaPort._fields_ = [
            ('dwAtaPortSpecific', DWORD),
        ]
        StackSpecific.AtaPort = AtaPort


        class StorPort(ctypes.Structure):
            pass


        StorPort._fields_ = [
            ('SrbTag', DWORD),
        ]
        StackSpecific.StorPort = StorPort


        StackSpecific._fields_ = [
            ('ExternalStack', StackSpecific.ExternalStack),
            ('AtaPort', StackSpecific.AtaPort),
            ('StorPort', StackSpecific.StorPort),
        ]
        _DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD.StackSpecific = StackSpecific


        _DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD._fields_ = [
            ('Cdb', BYTE * CDB_SIZE),
            # The actual command for this request.
            ('Command', BYTE * TELEMETRY_COMMAND_SIZE),
            # the time when driver received the request
            ('StartTime', DWORDLONG),
            # the system time when the request was completed
            ('EndTime', DWORDLONG),
            # Status value ()
            ('OperationStatus', DWORD),
            # Error value (eg error reg for ATAPort, SCSI error for storport)
            ('OperationError', DWORD),
            # Stack specific information
            ('StackSpecific', _DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD.StackSpecific),
        ]

        _DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP._fields_ = [
            # Common descriptor (signature,version of the structure)
            ('Descriptor', DEVICEDUMP_STRUCTURE_VERSION ),
            # Reason for collecting telemetry
            ('dwReasonForCollection', DWORD),
            # Driver stack and instance
            ('cDriverName', BYTE * 16),
            # Standardized log of IO requests issued to the target,
            # starting with number of records.
            # Log is circular, order is not guaranteed
            ('uiNumRecords', DWORD),
            ('RecordArray', DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD * ANYSIZE_ARRAY),
        ]

        from pyWinAPI.shared.poppack_h import * # NOQA

        # Telemetry information block descriptor - bit flags in
        # DumpCapabilities field
        # Target supports private data
        DEVICEDUMP_CAP_PRIVATE_SECTION = 0x00000001
        # Target supports restricted data
        DEVICEDUMP_CAP_RESTRICTED_SECTION = 0x00000002
        # IOCTL_STORAGE_ENABLE_IDLE_POWER
        # Input Buffer:
        # A STORAGE_IDLE_POWER structure specifying the idle power management
        # properties of the device.
        # Output Buffer:
        # None.
        # Structure version, should be set to 1 for Win8.
        _STORAGE_IDLE_POWER._fields_ = [
            ('Version', DWORD),
            # Size of this structure in bytes.
            ('Size', DWORD),
            # Storage device supports wake from low power states.
            ('WakeCapableHint', DWORD, 1),
            # Storage device supports D3Cold
            ('D3ColdSupported', DWORD, 1),
            ('Reserved', DWORD, 30),
            # Idle time in msec before storage device is transitioned to D3
            # (max of ~49.7 days).
            ('D3IdleTimeout', DWORD),
        ]
        # IOCTL_STORAGE_GET_IDLE_POWERUP_REASON
        # Input Buffer:
        # None.
        # Output Buffer:
        # A STORAGE_IDLE_POWERUP_REASON structure specifying what caused the
        # power up.
        class _STORAGE_POWERUP_REASON_TYPE(ENUM):
            StoragePowerupUnknown = 0
            StoragePowerupIO = 1
            StoragePowerupDeviceAttention = 2

        STORAGE_POWERUP_REASON_TYPE = _STORAGE_POWERUP_REASON_TYPE
        PSTORAGE_POWERUP_REASON_TYPE = POINTER(_STORAGE_POWERUP_REASON_TYPE)

        # Structure version, should be set to 1 for Win8.
        _STORAGE_IDLE_POWERUP_REASON._fields_ = [
            ('Version', DWORD),
            # Size of this structure in bytes.
            ('Size', DWORD),
            # The reason for the power up (see above).
            ('PowerupReason', STORAGE_POWERUP_REASON_TYPE),
        ]
        STORAGE_IDLE_POWERUP_REASON_VERSION_V1 = 1


        # IOCTL_STORAGE_DEVICE_POWER_CAP
        # This IOCTL specifies a maximum *operational* power consumption level
        # for a
        # storage device.
        # The storage stack will do its best to transition the device to a
        # power state
        # that will not exceed the given maximum. However, this depends on
        # what the
        # device supports. The actual maximum may be less than or greater than
        # the
        # desired maximum.
        # Input buffer:
        # A STORAGE_DEVICE_POWER_CAP structure.
        # * The Units field specifies the units of the MaxPower field. It can
        # be
        # either a percentage (0-100%) or an absolute value in milliwatts.
        # * The MaxPower field is used to set the desired maximum power
        # consumption
        # value for the storage device.
        # Output buffer:
        # On success, the output buffer will contain a STORAGE_DEVICE_POWER_CAP
        # structure.
        # * The Units field will continue to specify the units of the MaxPower
        # field
        # and will match the value from the input buffer.
        # * The MaxPower field will contain the value of the actual maximum
        # power consumption level of the device. This may be equal to, less
        # than,
        # or greater than the desired cap, depending on what the device
        # supports.
        class _STORAGE_DEVICE_POWER_CAP_UNITS(ENUM):
            StorageDevicePowerCapUnitsPercent = 1
            StorageDevicePowerCapUnitsMilliwatts = 2

        STORAGE_DEVICE_POWER_CAP_UNITS = _STORAGE_DEVICE_POWER_CAP_UNITS
        PSTORAGE_DEVICE_POWER_CAP_UNITS = POINTER(_STORAGE_DEVICE_POWER_CAP_UNITS)

        _STORAGE_DEVICE_POWER_CAP._fields_ = [
            ('Version', DWORD),
            ('Size', DWORD),
            ('Units', STORAGE_DEVICE_POWER_CAP_UNITS),
            ('MaxPower', DWORDLONG),
        ]
        STORAGE_DEVICE_POWER_CAP_VERSION_V1 = 1

        # IOCTL_STORAGE_RPMB_COMMAND
        # This IOCTL sends an RPMB command to the underlying storage device.
        # Input buffer:
        # An array of STORAGE_RPMB_DATA_FRAME structures
        # * The number of frames included can be calculated by
        # InputBufferLength / (ctypes.sizeof(STORAGE_RPMB_DATA_FRAME)
        # Output buffer:
        # An array of STORAGE_RPMB_DATA_FRAME structures
        # * The number of frames included can be calculated by
        # OutputBufferLength / (ctypes.sizeof(STORAGE_RPMB_DATA_FRAME)
        # Ensure we are byte aligned
        # This is the RPMB data frame used to compose all RPMB requests and
        # responses.
        # This corresponds to StorageRpmbFrameTypeStandard
        _STORAGE_RPMB_DATA_FRAME._fields_ = [
            # Reserved
            ('Stuff', BYTE * 196),
            # Either the key to be programmed or the MAC authenticating this
            # frame or series of frames
            ('KeyOrMAC', BYTE * 32),
            # The data input or output
            ('Data', BYTE * 256),
            # Random 128-bit number generated by host
            ('Nonce', BYTE * 16),
            # 32-bit counter
            ('WriteCounter', BYTE * 4),
            # The half-sector address to operate on
            ('Address', BYTE * 2),
            # The count of half-sector blocks to read/write
            ('BlockCount', BYTE * 2),
            # The result of the operation
            ('OperationResult', BYTE * 2),
            # The type of request or response
            ('RequestOrResponseType', BYTE * 2),
        ]
        # RPMB RequestOrResponseType Values
        class _STORAGE_RPMB_COMMAND_TYPE(ENUM):
            StorRpmbProgramAuthKey = 0x00000001
            StorRpmbQueryWriteCounter = 0x00000002
            StorRpmbAuthenticatedWrite = 0x00000003
            StorRpmbAuthenticatedRead = 0x00000004
            StorRpmbReadResultRequest = 0x00000005
            StorRpmbAuthenticatedDeviceConfigWrite = 0x00000006
            StorRpmbAuthenticatedDeviceConfigRead = 0x00000007

        STORAGE_RPMB_COMMAND_TYPE = _STORAGE_RPMB_COMMAND_TYPE
        PSTORAGE_RPMB_COMMAND_TYPE = POINTER(_STORAGE_RPMB_COMMAND_TYPE)

        # IOCTL_STORAGE_EVENT_NOTIFICATION
        # Input Buffer:
        # A STORAGE_EVENT_NOTIFICATION structure specifying the event(s) that
        # occurred.
        # Output Buffer:
        # None
        # Structure version, should be set to 1 for Win8.
        _STORAGE_EVENT_NOTIFICATION._fields_ = [
            ('Version', DWORD),
            # Size of this structure in bytes.
            ('Size', DWORD),
            # Bitmask of event(s) that occurred.
            ('Events', DWORDLONG),
        ]
        STORAGE_EVENT_NOTIFICATION_VERSION_V1 = 1
        STORAGE_EVENT_MEDIA_STATUS = 0x0000000000000001
        STORAGE_EVENT_DEVICE_STATUS = 0x0000000000000002
        STORAGE_EVENT_DEVICE_OPERATION = 0x0000000000000004
        STORAGE_EVENT_ALL = (
            STORAGE_EVENT_MEDIA_STATUS |
            STORAGE_EVENT_DEVICE_STATUS |
            STORAGE_EVENT_DEVICE_OPERATION
        )

        # 'RCN'
        READ_COPY_NUMBER_KEY = 0x52434E00


        def IsKeyReadCopyNumber(_k):
            return (_k & 0xFFFFFF00) == READ_COPY_NUMBER_KEY


        def ReadCopyNumberToKey(_c):
            return READ_COPY_NUMBER_KEY | _c


        def ReadCopyNumberFromKey(_k):
            return _k & 0x000000FF

        # IOCTL_STORAGE_GET_COUNTERS
        # This IOCTL retrieves reliability counters for a storage device.
        # The caller can find out the required output buffer size by simply
        # sending
        # down a single STORAGE_COUNTERS structure. STATUS_BUFFER_OVERFLOW
        # will be
        # returned and the Size field in the STORAGE_COUNTERS structure will
        # contain
        # the total size of the required output buffer.
        # When the output buffer is sufficiently large, STATUS_SUCCESS will be
        # returned and the output buffer will contain a STORAGE_COUNTERS
        # structure
        # followed by an array of STORAGE_COUNTER structures.
        # Input Buffer:
        # STORAGE_COUNTERS with the Version field set appropriately.
        # Output Buffer:
        # When successful, a STORAGE_COUNTERS structure with the Counters array
        # filled out. NumberOfCounters will indicate the number of elements in
        # the Counters array.
        # See above for more details.
        class _STORAGE_COUNTER_TYPE(ENUM):
            StorageCounterTypeUnknown = 0
            StorageCounterTypeTemperatureCelsius = 1
            StorageCounterTypeTemperatureCelsiusMax = 2
            StorageCounterTypeReadErrorsTotal = 3
            StorageCounterTypeReadErrorsCorrected = 4
            StorageCounterTypeReadErrorsUncorrected = 5
            StorageCounterTypeWriteErrorsTotal = 6
            StorageCounterTypeWriteErrorsCorrected = 7
            StorageCounterTypeWriteErrorsUncorrected = 8
            StorageCounterTypeManufactureDate = 9
            StorageCounterTypeStartStopCycleCount = 10
            StorageCounterTypeStartStopCycleCountMax = 11
            StorageCounterTypeLoadUnloadCycleCount = 12
            StorageCounterTypeLoadUnloadCycleCountMax = 13
            StorageCounterTypeWearPercentage = 14
            StorageCounterTypeWearPercentageWarning = 15
            StorageCounterTypeWearPercentageMax = 16
            StorageCounterTypePowerOnHours = 17
            StorageCounterTypeReadLatency100NSMax = 18
            StorageCounterTypeWriteLatency100NSMax = 19
            StorageCounterTypeFlushLatency100NSMax = 20
            StorageCounterTypeMax = 21

        STORAGE_COUNTER_TYPE = _STORAGE_COUNTER_TYPE
        PSTORAGE_COUNTER_TYPE = POINTER(_STORAGE_COUNTER_TYPE)


        class Value(ctypes.Union):
            pass


        class ManufactureDate(ctypes.Structure):
            pass


        ManufactureDate._fields_ = [
            # Week is the number of the week in the year, 1-52.
            ('Week', DWORD),
            # Year is the last two digits of the year, e.g. 2016 is simply
            # "16".
            ('Year', DWORD),
        ]
        Value.ManufactureDate = ManufactureDate


        Value._fields_ = [
            ('ManufactureDate', Value.ManufactureDate),
            ('AsUlonglong', DWORDLONG),
        ]
        _STORAGE_COUNTER.Value = Value


        _STORAGE_COUNTER._fields_ = [
            ('Type', STORAGE_COUNTER_TYPE),
            ('Value', _STORAGE_COUNTER.Value),
        ]

        _STORAGE_COUNTERS._fields_ = [
            # Size of this structure serves as the version.
            ('Version', DWORD),
            # Total size of this structure plus all the variable-sized fields.
            ('Size', DWORD),
            ('NumberOfCounters', DWORD),
            ('Counters', STORAGE_COUNTER * ANYSIZE_ARRAY),
        ]
        STORAGE_COUNTERS_VERSION_V1 = ctypes.sizeof(STORAGE_COUNTERS)
        # Parameter and data structure for firmware upgrade IOCTLs
        # IOCTL_STORAGE_FIRMWARE_GET_INFO, IOCTL_STORAGE_FIRMWARE_DOWNLOAD,
        # IOCTL_STORAGE_FIRMWARE_ACTIVATE
        # Indicate the target of the request other than the device
        # handle/object itself.
        # This is used in "Flags" field of data structures for firmware
        # upgrade request.
        STORAGE_HW_FIRMWARE_REQUEST_FLAG_CONTROLLER = 0x00000001
        # Indicate that current FW image segment is the last one.
        STORAGE_HW_FIRMWARE_REQUEST_FLAG_LAST_SEGMENT = 0x00000002
        # Indicate that current FW image segment is the first one.
        STORAGE_HW_FIRMWARE_REQUEST_FLAG_FIRST_SEGMENT = 0x00000004
        # Indicate that the existing firmware in slot should be activated.
        # Only valid for IOCTL_STORAGE_FIRMWARE_ACTIVATE.
        STORAGE_HW_FIRMWARE_REQUEST_FLAG_SWITCH_TO_EXISTING_FIRMWARE = (
            0x80000000
        )
        # Input parameter for IOCTL_STORAGE_FIRMWARE_GET_INFO
        # (ctypes.sizeof(STORAGE_FIRMWARE_INFO_QUERY)
        _STORAGE_HW_FIRMWARE_INFO_QUERY._fields_ = [
            ('Version', DWORD),
            # Whole size of the buffer
            # (in case this data structure being extended to be variable length)
            ('Size', DWORD),
            ('Flags', DWORD),
            ('Reserved', DWORD),
        ]
        # Output parameter for IOCTL_STORAGE_FIRMWARE_GET_INFO
        # The total size of returned data is for Firmware Info is:
        # (ctypes.sizeof(STORAGE_HW_FIRMWARE_INFO) + (ctypes.sizeof(STORAGE_HW_FIRMWARE_SLOT_INFO) * (SlotCount - 1).
        #
        # If the buffer is not big enough, callee should set the required
        # length in "Size" field of STORAGE_HW_FIRMWARE_INFO,
        # Following value maybe used in "PendingActiveSlot" field indicating
        # there is no firmware pending to activate.
        STORAGE_HW_FIRMWARE_INVALID_SLOT = 0xFF
        STORAGE_HW_FIRMWARE_REVISION_LENGTH = 16
        _STORAGE_HW_FIRMWARE_SLOT_INFO._fields_ = [
            # (ctypes.sizeof(STORAGE_HW_FIRMWARE_SLOT_INFO)
            ('Version', DWORD),
            # size the data contained in STORAGE_HW_FIRMWARE_SLOT_INFO.
            ('Size', DWORD),
            ('SlotNumber', BYTE),
            ('ReadOnly', BYTE, 1),
            ('Reserved0', BYTE, 7),
            ('Reserved1', BYTE * 6),
            ('Revision', BYTE * STORAGE_HW_FIRMWARE_REVISION_LENGTH),
        ]
        _STORAGE_HW_FIRMWARE_INFO._fields_ = [
            # (ctypes.sizeof(STORAGE_HW_FIRMWARE_INFO)
            ('Version', DWORD),
            # size of the whole buffer including slot[]
            ('Size', DWORD),
            ('SupportUpgrade', BYTE, 1),
            ('Reserved0', BYTE, 7),
            ('SlotCount', BYTE),
            ('ActiveSlot', BYTE),
            ('PendingActivateSlot', BYTE),
            # The firmware applies to both device and adapter. For example:
            # PCIe SSD.
            ('FirmwareShared', BOOLEAN),
            ('Reserved', BYTE * 3),
            # Number of bytes. Max: PAGE_SIZE. The transfer size should be
            # multiple of this unit size. Some protocol requires at least
            # sector size. 0 means the value is not valid.
            ('ImagePayloadAlignment', DWORD),
            # for a single command.
            ('ImagePayloadMaxSize', DWORD),
            ('Slot', STORAGE_HW_FIRMWARE_SLOT_INFO * ANYSIZE_ARRAY),
        ]
        # Input parameter for IOCTL_STORAGE_FIRMWARE_DOWNLOAD
        _STORAGE_HW_FIRMWARE_DOWNLOAD._fields_ = [
            # (ctypes.sizeof(STORAGE_HW_FIRMWARE_DOWNLOAD)
            ('Version', DWORD),
            # size of the whole buffer include "ImageBuffer"
            ('Size', DWORD),
            ('Flags', DWORD),
            # Slot number that firmware image will be downloaded into.
            ('Slot', BYTE),
            ('Reserved', BYTE * 3),
            # Image file offset, should be aligned to "ImagePayloadAlignment"
            # value from STORAGE_FIRMWARE_INFO.
            ('Offset', DWORDLONG),
            # should be multiple of "ImagePayloadAlignment" value from
            # STORAGE_FIRMWARE_INFO.
            ('BufferSize', DWORDLONG),
            # firmware image file.
            ('ImageBuffer', BYTE * ANYSIZE_ARRAY),
        ]
        _STORAGE_HW_FIRMWARE_DOWNLOAD_V2._fields_ = [
            # (ctypes.sizeof(STORAGE_HW_FIRMWARE_DOWNLOAD_V2)
            ('Version', DWORD),
            # size of the whole buffer include "ImageBuffer"
            ('Size', DWORD),
            ('Flags', DWORD),
            # Slot number that firmware image will be downloaded into.
            ('Slot', BYTE),
            ('Reserved', BYTE * 3),
            # Image file offset, should be aligned to "ImagePayloadAlignment"
            # value from STORAGE_FIRMWARE_INFO.
            ('Offset', DWORDLONG),
            # should be multiple of "ImagePayloadAlignment" value from
            # STORAGE_FIRMWARE_INFO.
            ('BufferSize', DWORDLONG),
            # Firmware Image size.
            ('ImageSize', DWORD),
            ('Reserved2', DWORD),
            # firmware image file.
            ('ImageBuffer', BYTE * ANYSIZE_ARRAY),
        ]
        # Input parameter for IOCTL_STORAGE_FIRMWARE_ACTIVATE
        _STORAGE_HW_FIRMWARE_ACTIVATE._fields_ = [
            ('Version', DWORD),
            ('Size', DWORD),
            ('Flags', DWORD),
            # Slot with firmware image to be activated.
            ('Slot', BYTE),
            ('Reserved0', BYTE * 3),
        ]
        # Parameter for IOCTL_STORAGE_PROTOCOL_COMMAND
        # Buffer layout: < STORAGE_PROTOCOL_COMMAND > < Command > [Error Info
        # Buffer] [Data-to-Device Buffer] [Data-from-Device Buffer]
        STORAGE_PROTOCOL_STRUCTURE_VERSION = 0x1
        _STORAGE_PROTOCOL_COMMAND._fields_ = [
            # STORAGE_PROTOCOL_STRUCTURE_VERSION
            ('Version', DWORD),
            # (ctypes.sizeof(STORAGE_PROTOCOL_COMMAND)
            ('Length', DWORD),
            ('ProtocolType', STORAGE_PROTOCOL_TYPE),
            # Flags for the request
            ('Flags', DWORD),
            # return value
            ('ReturnStatus', DWORD),
            # return value, optional
            ('ErrorCode', DWORD),
            # non-zero value should be set by caller
            ('CommandLength', DWORD),
            # optional, can be zero
            ('ErrorInfoLength', DWORD),
            # optional, can be zero. Used by WRITE type of request.
            ('DataToDeviceTransferLength', DWORD),
            # optional, can be zero. Used by READ type of request.
            ('DataFromDeviceTransferLength', DWORD),
            # in unit of seconds
            ('TimeOutValue', DWORD),
            # offsets need to be pointer aligned
            ('ErrorInfoOffset', DWORD),
            # offsets need to be pointer aligned
            ('DataToDeviceBufferOffset', DWORD),
            # offsets need to be pointer aligned
            ('DataFromDeviceBufferOffset', DWORD),
            # optional information passed along with Command.
            ('CommandSpecific', DWORD),
            ('Reserved0', DWORD),
            # return data, optional. Some protocol, such as NVMe, may return a
            # small amount data (DWORD0 from completion queue entry) without
            # the need of separate device data transfer.
            ('FixedProtocolReturnData', DWORD),
            ('Reserved1', DWORD * 3),
            ('Command', BYTE * ANYSIZE_ARRAY),
        ]
        # Bit-mask values for STORAGE_PROTOCOL_COMMAND - "Flags" field.
        # Flag indicates the request targeting to adapter instead of device.
        STORAGE_PROTOCOL_COMMAND_FLAG_ADAPTER_REQUEST = 0x80000000
        # Status values for STORAGE_PROTOCOL_COMMAND - "ReturnStatus" field.
        STORAGE_PROTOCOL_STATUS_PENDING = 0x0
        STORAGE_PROTOCOL_STATUS_SUCCESS = 0x1
        STORAGE_PROTOCOL_STATUS_ERROR = 0x2
        STORAGE_PROTOCOL_STATUS_INVALID_REQUEST = 0x3
        STORAGE_PROTOCOL_STATUS_NO_DEVICE = 0x4
        STORAGE_PROTOCOL_STATUS_BUSY = 0x5
        STORAGE_PROTOCOL_STATUS_DATA_OVERRUN = 0x6
        STORAGE_PROTOCOL_STATUS_INSUFFICIENT_RESOURCES = 0x7
        STORAGE_PROTOCOL_STATUS_NOT_SUPPORTED = 0xFF
        # Command Length for Storage Protocols.
        # NVMe commands are always 64 bytes.
        STORAGE_PROTOCOL_COMMAND_LENGTH_NVME = 0x40
        # Command Specific Information for Storage Protocols -
        # "CommandSpecific" field.
        STORAGE_PROTOCOL_SPECIFIC_NVME_ADMIN_COMMAND = 0x01
        STORAGE_PROTOCOL_SPECIFIC_NVME_NVM_COMMAND = 0x02
        # Additional notes when STORAGE_PROTOCOL_TYPE is ProtocolTypeNvme:
        # 1. When flag STORAGE_PROTOCOL_COMMAND_FLAG_ADAPTER_REQUEST is set,
        # or the request is sent through adapter, namespace Id from "Command"
        # field is used;
        # otherwise, the underneath driver should determine namespace Id from
        # the device that receives the command.
        # 2. When a command fails, the "ErrorCode" field contains value from
        # NVMe Completion Queue Entry - DW3 - Status Field.
        # 3. "CommandLength" field must have value of 64. e.g.
        # STORAGE_PROTOCOL_COMMAND_LENGTH_NVME.
        # 4. "CommandSpecific" field must have value of either
        # STORAGE_PROTOCOL_SPECIFIC_NVME_ADMIN_COMMAND, or
        # STORAGE_PROTOCOL_SPECIFIC_NVME_NVM_COMMAND.
        # 5. When a command succeeds, field "FixedProtocolReturnData" may
        # contain value from NVMe Completion Queue Entry - DW0.
        # IOCTL_STORAGE_ATTRIBUTE_MANAGEMENT
        # This IOCTL manages an attribute
        # for a storage device.
        # When a driver receives this IOCTL it should first
        # let any lower drivers process the IOCTL.
        # The driver can override the completion status
        # from the lower driver layers, if needed.
        # For example when driver can provide
        # the required functionality after
        # doing "Action" on "Attribute", without any support
        # from lower drivers, it can choose to ignore failure
        # from lower driver layers, complete the "Action"
        # and return success.
        # Input Buffer:
        # STORAGE_ATTRIBUTE_MGMT
        # Output Buffer:
        # None.
        # Valid Management Actions allowed
        # on the Attribute
        class _STORAGE_ATTRIBUTE_MGMT_ACTION(ENUM):
            StorAttributeMgmt_ClearAttribute = 0
            StorAttributeMgmt_SetAttribute = 1
            StorAttributeMgmt_ResetAttribute = 2

        STORAGE_ATTRIBUTE_MGMT_ACTION = _STORAGE_ATTRIBUTE_MGMT_ACTION
        PSTORAGE_ATTRIBUTE_MGMT_ACTION = POINTER(_STORAGE_ATTRIBUTE_MGMT_ACTION)


        # Valid Storage Device Attributes
        # Reserved for future usage.
        STORATTRIBUTE_NONE = 0


        # When this attribute is reset, a driver reverts to its
        # default state. The definition of default state is specific
        # to each individual driver.
        # Supported actions: Reset.
        STORATTRIBUTE_MANAGEMENT_STATE = 1


        _STORAGE_ATTRIBUTE_MGMT._fields_ = [
            # as the version.
            ('Version', DWORD),
            # all the variable sized fields.
            ('Size', DWORD),
            # Indicates what action is requested.
            ('Action', STORAGE_ATTRIBUTE_MGMT_ACTION),
            # needs to be taken.
            ('Attribute', DWORD),
        ]
        if _MSC_VER  >= 1200:
            pass
        # END IF


        if defined(__cplusplus) and not defined(__ALT_GENERATOR__):
            pass
        # END IF

    # END IF   _NTDDSTOR_H_

    if not defined(_NTDDDISK_H_):
        _NTDDDISK_H_ = VOID
        from pyWinAPI.shared.winapifamily_h import * # NOQA

        # ////////////////////////////////////////////////////////////////////
        # Code generator definitions
        if not defined(__WRAPPED__):
            __WRAPPED__ = VOID
        # END IF

        if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM):
            if defined(_MSC_VER):
                if _MSC_VER  >= 1200:
                    pass
                # END IF
            # END IF
            # IoControlCode values for disk devices.
            IOCTL_DISK_BASE =  FILE_DEVICE_DISK
            IOCTL_DISK_GET_DRIVE_GEOMETRY = CTL_CODE(IOCTL_DISK_BASE, 0x0000, METHOD_BUFFERED, FILE_ANY_ACCESS)
            IOCTL_DISK_GET_PARTITION_INFO = CTL_CODE(IOCTL_DISK_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)
            IOCTL_DISK_SET_PARTITION_INFO = CTL_CODE(IOCTL_DISK_BASE, 0x0002, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
            IOCTL_DISK_GET_DRIVE_LAYOUT = CTL_CODE(IOCTL_DISK_BASE, 0x0003, METHOD_BUFFERED, FILE_READ_ACCESS)
            IOCTL_DISK_SET_DRIVE_LAYOUT = CTL_CODE(IOCTL_DISK_BASE, 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
            IOCTL_DISK_VERIFY = CTL_CODE(IOCTL_DISK_BASE, 0x0005, METHOD_BUFFERED, FILE_ANY_ACCESS)
            IOCTL_DISK_FORMAT_TRACKS = CTL_CODE(IOCTL_DISK_BASE, 0x0006, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
            IOCTL_DISK_REASSIGN_BLOCKS = CTL_CODE(IOCTL_DISK_BASE, 0x0007, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
            IOCTL_DISK_PERFORMANCE = CTL_CODE(IOCTL_DISK_BASE, 0x0008, METHOD_BUFFERED, FILE_ANY_ACCESS)
            IOCTL_DISK_IS_WRITABLE = CTL_CODE(IOCTL_DISK_BASE, 0x0009, METHOD_BUFFERED, FILE_ANY_ACCESS)
            IOCTL_DISK_LOGGING = CTL_CODE(IOCTL_DISK_BASE, 0x000a, METHOD_BUFFERED, FILE_ANY_ACCESS)
            IOCTL_DISK_FORMAT_TRACKS_EX = CTL_CODE(IOCTL_DISK_BASE, 0x000b, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
            IOCTL_DISK_HISTOGRAM_STRUCTURE = CTL_CODE(IOCTL_DISK_BASE, 0x000c, METHOD_BUFFERED, FILE_ANY_ACCESS)
            IOCTL_DISK_HISTOGRAM_DATA = CTL_CODE(IOCTL_DISK_BASE, 0x000d, METHOD_BUFFERED, FILE_ANY_ACCESS)
            IOCTL_DISK_HISTOGRAM_RESET = CTL_CODE(IOCTL_DISK_BASE, 0x000e, METHOD_BUFFERED, FILE_ANY_ACCESS)
            IOCTL_DISK_REQUEST_STRUCTURE = CTL_CODE(IOCTL_DISK_BASE, 0x000f, METHOD_BUFFERED, FILE_ANY_ACCESS)
            IOCTL_DISK_REQUEST_DATA = CTL_CODE(IOCTL_DISK_BASE, 0x0010, METHOD_BUFFERED, FILE_ANY_ACCESS)
            IOCTL_DISK_PERFORMANCE_OFF = CTL_CODE(IOCTL_DISK_BASE, 0x0018, METHOD_BUFFERED, FILE_ANY_ACCESS)

            if _WIN32_WINNT  >= 0x0400:
                IOCTL_DISK_CONTROLLER_NUMBER = CTL_CODE(IOCTL_DISK_BASE, 0x0011, METHOD_BUFFERED, FILE_ANY_ACCESS)
                # IOCTL support for SMART drive fault prediction.
                SMART_GET_VERSION = CTL_CODE(IOCTL_DISK_BASE, 0x0020, METHOD_BUFFERED, FILE_READ_ACCESS)
                SMART_SEND_DRIVE_COMMAND = CTL_CODE(IOCTL_DISK_BASE, 0x0021, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
                SMART_RCV_DRIVE_DATA = CTL_CODE(IOCTL_DISK_BASE, 0x0022, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
            # END IF  _WIN32_WINNT  >= 0x0400

            if _WIN32_WINNT  >= 0x500:
                # New IOCTLs for GUID Partition tabled disks.
                IOCTL_DISK_GET_PARTITION_INFO_EX = CTL_CODE(IOCTL_DISK_BASE, 0x0012, METHOD_BUFFERED, FILE_ANY_ACCESS)
                IOCTL_DISK_SET_PARTITION_INFO_EX = CTL_CODE(IOCTL_DISK_BASE, 0x0013, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
                IOCTL_DISK_GET_DRIVE_LAYOUT_EX = CTL_CODE(IOCTL_DISK_BASE, 0x0014, METHOD_BUFFERED, FILE_ANY_ACCESS)
                IOCTL_DISK_SET_DRIVE_LAYOUT_EX = CTL_CODE(IOCTL_DISK_BASE, 0x0015, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
                IOCTL_DISK_CREATE_DISK = CTL_CODE(IOCTL_DISK_BASE, 0x0016, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
                IOCTL_DISK_GET_LENGTH_INFO = CTL_CODE(IOCTL_DISK_BASE, 0x0017, METHOD_BUFFERED, FILE_READ_ACCESS)
                IOCTL_DISK_GET_DRIVE_GEOMETRY_EX = CTL_CODE(IOCTL_DISK_BASE, 0x0028, METHOD_BUFFERED, FILE_ANY_ACCESS)
            # END IF  _WIN32_WINNT  >= 0x0500

            if _WIN32_WINNT  >= 0x0502:
                # New IOCTL for disk devices that support 8 byte LBA
                IOCTL_DISK_REASSIGN_BLOCKS_EX = CTL_CODE(IOCTL_DISK_BASE, 0x0029, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

            # END IF  _WIN32_WINNT  >= 0x0502

            if _WIN32_WINNT  >= 0x0500:
                IOCTL_DISK_UPDATE_DRIVE_SIZE = CTL_CODE(IOCTL_DISK_BASE, 0x0032, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
                IOCTL_DISK_GROW_PARTITION = CTL_CODE(IOCTL_DISK_BASE, 0x0034, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

                IOCTL_DISK_GET_CACHE_INFORMATION = CTL_CODE(IOCTL_DISK_BASE, 0x0035, METHOD_BUFFERED, FILE_READ_ACCESS)
                IOCTL_DISK_SET_CACHE_INFORMATION = CTL_CODE(IOCTL_DISK_BASE, 0x0036, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
                if NTDDI_VERSION  <  NTDDI_WS03:
                    IOCTL_DISK_GET_WRITE_CACHE_STATE =  CTL_CODE(IOCTL_DISK_BASE, 0x0037, METHOD_BUFFERED, FILE_READ_ACCESS)
                else:
                    OBSOLETE_DISK_GET_WRITE_CACHE_STATE = CTL_CODE(IOCTL_DISK_BASE, 0x0037, METHOD_BUFFERED, FILE_READ_ACCESS)
                # END IF

                IOCTL_DISK_DELETE_DRIVE_LAYOUT = CTL_CODE(IOCTL_DISK_BASE, 0x0040, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

                # Called to flush cached information that the driver may have
                # about this
                # device's characteristics. Not all drivers cache
                # characteristics, and not
                # cached properties can be flushed. This simply serves as an
                # update to the
                # driver that it may want to do an expensive reexamination of
                # the device's
                # characteristics now
                # (fixed media size, partition table, etc...)
                IOCTL_DISK_UPDATE_PROPERTIES = CTL_CODE(IOCTL_DISK_BASE, 0x0050, METHOD_BUFFERED, FILE_ANY_ACCESS)

                # Special IOCTLs needed to support PC-98 machines in Japan
                IOCTL_DISK_FORMAT_DRIVE = CTL_CODE(IOCTL_DISK_BASE, 0x00f3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
                IOCTL_DISK_SENSE_DEVICE = CTL_CODE(IOCTL_DISK_BASE, 0x00f8, METHOD_BUFFERED, FILE_ANY_ACCESS)
            # END IF  _WIN32_WINNT  >= 0x0500

            # The following device control codes are common for all class
            # drivers. The
            # functions codes defined here must match all of the other class
            # drivers.
            # Warning: these codes will be replaced in the future by equivalent
            # IOCTL_STORAGE codes
            IOCTL_DISK_CHECK_VERIFY = CTL_CODE(IOCTL_DISK_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
            IOCTL_DISK_MEDIA_REMOVAL = CTL_CODE(IOCTL_DISK_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS)
            IOCTL_DISK_EJECT_MEDIA = CTL_CODE(IOCTL_DISK_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS)
            IOCTL_DISK_LOAD_MEDIA = CTL_CODE(IOCTL_DISK_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS)
            IOCTL_DISK_RESERVE = CTL_CODE(IOCTL_DISK_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS)
            IOCTL_DISK_RELEASE = CTL_CODE(IOCTL_DISK_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS)
            IOCTL_DISK_FIND_NEW_DEVICES = CTL_CODE(IOCTL_DISK_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS)
            IOCTL_DISK_GET_MEDIA_TYPES = CTL_CODE(IOCTL_DISK_BASE, 0x0300, METHOD_BUFFERED, FILE_ANY_ACCESS)


            # Define the partition types returnable by known disk drivers.
            # Entry unused
            PARTITION_ENTRY_UNUSED = 0x00

            # 12-bit FAT entries
            PARTITION_FAT_12 = 0x01

            # Xenix
            PARTITION_XENIX_1 = 0x02

            # Xenix
            PARTITION_XENIX_2 = 0x03

            # 16-bit FAT entries
            PARTITION_FAT_16 = 0x04

            # Extended partition entry
            PARTITION_EXTENDED = 0x05

            # Huge partition MS-DOS V4
            PARTITION_HUGE = 0x06

            # IFS Partition
            PARTITION_IFS = 0x07

            # OS/2 Boot Manager/OPUS/Coherent swap
            PARTITION_OS2BOOTMGR = 0x0A

            # FAT32
            PARTITION_FAT32 = 0x0B

            # FAT32 using extended int13 services
            PARTITION_FAT32_XINT13 = 0x0C

            # Win95 partition using extended int13 services
            PARTITION_XINT13 = 0x0E

            # Same as type 5 but uses extended int13 services
            PARTITION_XINT13_EXTENDED = 0x0F

            # Microsoft recovery partition
            PARTITION_MSFT_RECOVERY = 0x27

            # Main OS partition
            PARTITION_MAIN_OS = 0x28

            # OS data partition
            PARTIITON_OS_DATA = 0x29

            # PreInstalled partition
            PARTITION_PRE_INSTALLED = 0x2A

            # BSP partition
            PARTITION_BSP = 0x2B

            # DPP partition
            PARTITION_DPP = 0x2C

            # Windows system partition
            PARTITION_WINDOWS_SYSTEM = 0x2D

            # PowerPC Reference Platform (PReP) Boot Partition
            PARTITION_PREP = 0x41

            # Logical Disk Manager partition
            PARTITION_LDM = 0x42

            # OnTrack Disk Manager partition
            PARTITION_DM = 0x54

            # EZ-Drive partition
            PARTITION_EZDRIVE = 0x55

            # Unix
            PARTITION_UNIX = 0x63

            # Storage Spaces protective partition
            PARTITION_SPACES = 0xE7

            # Gpt protective partition
            PARTITION_GPT = 0xEE

            # System partition
            PARTITION_SYSTEM = 0xEF

            # NTFT uses high order bits
            VALID_NTFT = 0xC0


            # The high bit of the partition type code indicates that a
            # partition
            # is part of an NTFT mirror or striped array.
            # NTFT partition
            PARTITION_NTFT = 0x80


            # The following macro is used to determine which partitions should
            # be
            # assigned drive letters.
            # + +
            # BOOLEAN
            # IsRecognizedPartition(
            # IN DWORD PartitionType
            # )
            # Routine Description:
            # This macro is used to determine to which partitions drive letters
            # should be assigned.
            # Arguments:
            # PartitionType - Supplies the type of the partition being
            # examined.
            # Return Value:
            # The return value is TRUE if the partition type is recognized,
            # otherwise FALSE is returned.
            # --
            if NTDDI_VERSION  <  NTDDI_VISTA:

                def IsRecognizedPartition( PartitionType ):
                    return (
                        (
                            PartitionType & PARTITION_NTFT and
                            PartitionType & ~0xC0 in (
                                PARTITION_HUGE,
                                PARTITION_IFS,
                                PARTITION_FAT32,
                                PARTITION_FAT32_XINT13
                            )
                        ) or PartitionType in (
                            PARTITION_FAT_12,
                            PARTITION_FAT_16,
                            PARTITION_HUGE,
                            PARTITION_IFS,
                            PARTITION_FAT32,
                            PARTITION_FAT32_XINT13,
                            PARTITION_XINT13
                        )
                    )

            else:
                def IsRecognizedPartition(PartitionType):
                    return PartitionType in (
                        PARTITION_BSP,
                        PARTITION_DPP,
                        PARTITION_FAT_12,
                        PARTITION_FAT_16,
                        PARTITION_FAT32,
                        PARTITION_FAT32_XINT13,
                        PARTITION_HUGE,
                        PARTITION_IFS,
                        PARTITION_MAIN_OS,
                        PARTITION_MSFT_RECOVERY,
                        PARTIITON_OS_DATA,
                        PARTITION_PRE_INSTALLED,
                        PARTITION_SYSTEM,
                        PARTITION_WINDOWS_SYSTEM,
                        PARTITION_XINT13
                    )

            # END IF


            # + +
            # BOOLEAN
            # IsContainerPartition(
            # IN DWORD PartitionType
            # )
            # Routine Description:
            # This macro is used to determine to which partition types are
            # actually
            # containers for other partitions (ie, extended partitions).
            # Arguments:
            # PartitionType - Supplies the type of the partition being
            # examined.
            # Return Value:
            # The return value is TRUE if the partition type is a container,
            # otherwise FALSE is returned.
            # --
            def IsContainerPartition(PartitionType):
                return PartitionType in (
                    PARTITION_EXTENDED,
                    PARTITION_XINT13_EXTENDED
                )


            # + +
            # BOOLEAN
            # IsFTPartition(
            # IN DWORD PartitionType
            # )
            # Routine Description:
            # This macro is used to determine if the given partition is an FT
            # partition.
            # Arguments:
            # PartitionType - Supplies the type of the partition being
            # examined.
            # Return Value:
            # The return value is TRUE if the partition type is an FT
            # partition,
            # otherwise FALSE is returned.
            # --
            def IsFTPartition(PartitionType):
                return (
                    PartitionType & PARTITION_NTFT and
                    PartitionType & ~0xC0 in (
                        PARTITION_HUGE,
                        PARTITION_IFS,
                        PARTITION_FAT32,
                        PARTITION_FAT32_XINT13
                    )
                )


            # Define the media types supported by the driver.
            class _MEDIA_TYPE(ENUM):
                Unknown = 1
                F5_1Pt2_512 = 2
                F3_1Pt44_512 = 3
                F3_2Pt88_512 = 4
                F3_20Pt8_512 = 5
                F3_720_512 = 6
                F5_360_512 = 7
                F5_320_512 = 8
                F5_320_1024 = 9
                F5_180_512 = 10
                F5_160_512 = 11
                RemovableMedia = 12
                FixedMedia = 13
                F3_120M_512 = 14
                F3_640_512 = 15
                F5_640_512 = 16
                F5_720_512 = 17
                F3_1Pt2_512 = 18
                F3_1Pt23_1024 = 19
                F5_1Pt23_1024 = 20
                F3_128Mb_512 = 21
                F3_230Mb_512 = 22
                F8_256_128 = 23
                F3_200Mb_512 = 24
                F3_240M_512 = 25
                F3_32M_512 = 26

            MEDIA_TYPE = _MEDIA_TYPE
            PMEDIA_TYPE = POINTER(_MEDIA_TYPE)


            # Define the input buffer structure for the driver, when
            # it is called with IOCTL_DISK_FORMAT_TRACKS.
            _FORMAT_PARAMETERS._fields_ = [
                ('MediaType', MEDIA_TYPE),
                ('StartCylinderNumber', DWORD),
                ('EndCylinderNumber', DWORD),
                ('StartHeadNumber', DWORD),
                ('EndHeadNumber', DWORD),
            ]


            # Define the BAD_TRACK_NUMBER type. An array of elements of this
            # type is
            # returned by the driver on IOCTL_DISK_FORMAT_TRACKS requests, to
            # indicate
            # what tracks were bad during formatting. The length of that array
            # is
            # reported in the `Information' field of the I/O Status Block.

            BAD_TRACK_NUMBER = WORD
            PBAD_TRACK_NUMBER = POINTER(WORD)

            # Define the input buffer structure for the driver, when
            # it is called with IOCTL_DISK_FORMAT_TRACKS_EX.
            _FORMAT_EX_PARAMETERS._fields_ = [
                ('MediaType', MEDIA_TYPE),
                ('StartCylinderNumber', DWORD),
                ('EndCylinderNumber', DWORD),
                ('StartHeadNumber', DWORD),
                ('EndHeadNumber', DWORD),
                ('FormatGapLength', WORD),
                ('SectorsPerTrack', WORD),
                ('SectorNumber', WORD * 1),
            ]


            # The following structure is returned on an
            # IOCTL_DISK_GET_DRIVE_GEOMETRY
            # request and an array of them is returned on an
            # IOCTL_DISK_GET_MEDIA_TYPES
            # request.
            _DISK_GEOMETRY._fields_ = [
                ('Cylinders', LARGE_INTEGER),
                ('MediaType', MEDIA_TYPE),
                ('TracksPerCylinder', DWORD),
                ('SectorsPerTrack', DWORD),
                ('BytesPerSector', DWORD),
            ]


            # This wmi guid returns a DISK_GEOMETRY structure
            WMI_DISK_GEOMETRY_GUID = [
                0x25007F51,
                0x57C2,
                0x11D1,
                [0xA5, 0x28, 0x0, 0xA0, 0xC9, 0x6, 0x29, 0x10],
            ]


            # The following structure is returned on an
            # IOCTL_DISK_GET_PARTITION_INFO
            # and an IOCTL_DISK_GET_DRIVE_LAYOUT request. It is also used in a
            # request
            # to change the drive layout, IOCTL_DISK_SET_DRIVE_LAYOUT.
            _PARTITION_INFORMATION._fields_ = [
                ('StartingOffset', LARGE_INTEGER),
                ('PartitionLength', LARGE_INTEGER),
                ('HiddenSectors', DWORD),
                ('PartitionNumber', DWORD),
                ('PartitionType', BYTE),
                ('BootIndicator', BOOLEAN),
                ('RecognizedPartition', BOOLEAN),
                ('RewritePartition', BOOLEAN),
            ]


            # The following structure is used to change the partition type of a
            # specified disk partition using an IOCTL_DISK_SET_PARTITION_INFO
            # request.
            _SET_PARTITION_INFORMATION._fields_ = [
                ('PartitionType', BYTE),
            ]


            # The following structures is returned on an
            # IOCTL_DISK_GET_DRIVE_LAYOUT
            # request and given as input to an IOCTL_DISK_SET_DRIVE_LAYOUT
            # request.
            _DRIVE_LAYOUT_INFORMATION._fields_ = [
                ('PartitionCount', DWORD),
                ('Signature', DWORD),
                ('PartitionEntry', PARTITION_INFORMATION * 1),
            ]


            # The following structure is passed in on an IOCTL_DISK_VERIFY
            # request.
            # The offset and length parameters are both given in bytes.
            _VERIFY_INFORMATION._fields_ = [
                ('StartingOffset', LARGE_INTEGER),
                ('Length', DWORD),
            ]


            # The following structure is passed in on an
            # IOCTL_DISK_REASSIGN_BLOCKS
            # request.
            _REASSIGN_BLOCKS._fields_ = [
                ('Reserved', WORD),
                ('Count', WORD),
                ('BlockNumber', DWORD * 1),
            ]


            # The following structure is passed in on an
            # IOCTL_DISK_REASSIGN_BLOCKS_EX
            # request.
            from pyWinAPI.shared.pshpack1_h import * # NOQA

            _REASSIGN_BLOCKS_EX._fields_ = [
                ('Reserved', WORD),
                ('Count', WORD),
                ('BlockNumber', LARGE_INTEGER * 1),
            ]
            from pyWinAPI.shared.poppack_h import * # NOQA

            if _WIN32_WINNT  >= 0x500:
                # Support for GUID Partition Table (GPT) disks.
                # There are currently two ways a disk can be partitioned. With
                # a traditional
                # AT-style master boot record (PARTITION_STYLE_MBR) and with a
                # new, GPT
                # partition table (PARTITION_STYLE_GPT). RAW is for an
                # unrecognizable
                # partition style. There are a very limited number of things
                # you can
                # do with a RAW partititon.
                class _PARTITION_STYLE(ENUM):
                    PARTITION_STYLE_MBR = 1
                    PARTITION_STYLE_GPT = 2
                    PARTITION_STYLE_RAW = 3

                PARTITION_STYLE = _PARTITION_STYLE


                # The following structure defines information in a GPT
                # partition that is
                # not common to both GPT and MBR partitions.
                _PARTITION_INFORMATION_GPT._fields_ = [
                    # Partition type. See table 16-3.
                    ('PartitionType', GUID),
                    # Unique GUID for this partition.
                    ('PartitionId', GUID),
                    # See table 16-4.
                    ('Attributes', DWORD64),
                    # Partition Name in Unicode.
                    ('Name', WCHAR * 36),
                ]


                # The following are GPT partition attributes applicable for any
                # partition type. These attributes are not OS-specific
                GPT_ATTRIBUTE_PLATFORM_REQUIRED = 0x0000000000000001


                # The following are GPT partition attributes applicable when
                # the
                # PartitionType is PARTITION_BASIC_DATA_GUID.
                GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER = 0x8000000000000000
                GPT_BASIC_DATA_ATTRIBUTE_HIDDEN = 0x4000000000000000
                GPT_BASIC_DATA_ATTRIBUTE_SHADOW_COPY = 0x2000000000000000
                GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY = 0x1000000000000000
                GPT_BASIC_DATA_ATTRIBUTE_OFFLINE = 0x0800000000000000
                GPT_BASIC_DATA_ATTRIBUTE_DAX = 0x0400000000000000
                GPT_BASIC_DATA_ATTRIBUTE_SERVICE = 0x0200000000000000


                # The following are GPT partition attributes applicable when
                # the
                # PartitionType is PARTITION_SPACES_GUID.
                GPT_SPACES_ATTRIBUTE_NO_METADATA = 0x8000000000000000


                # The following structure defines information in an MBR
                # partition that is not
                # common to both GPT and MBR partitions.
                _TEMP__PARTITION_INFORMATION_MBR = [
                    ('PartitionType', BYTE),
                    ('BootIndicator', BOOLEAN),
                    ('RecognizedPartition', BOOLEAN),
                    ('HiddenSectors', DWORD),
                ]
                if NTDDI_VERSION  >= NTDDI_WINBLUE: #  ABRACADABRA_THRESHOLD
                    _TEMP__PARTITION_INFORMATION_MBR += [
                        ('PartitionId', GUID),
                    ]
                # END IF


                _PARTITION_INFORMATION_MBR._fields_ = _TEMP__PARTITION_INFORMATION_MBR


                # The structure SET_PARTITION_INFO_EX is used with the ioctl
                # IOCTL_SET_PARTITION_INFO_EX to set information about a
                # specific
                # partition. Note that for MBR partitions, you can only set
                # the partition
                # signature, whereas GPT partitions allow setting of all
                # fields that
                # you can get.
                SET_PARTITION_INFORMATION_MBR = SET_PARTITION_INFORMATION
                SET_PARTITION_INFORMATION_GPT = PARTITION_INFORMATION_GPT


                class DUMMYUNIONNAME(ctypes.Union):
                    pass


                DUMMYUNIONNAME._fields_ = [
                    ('Mbr', SET_PARTITION_INFORMATION_MBR),
                    ('Gpt', SET_PARTITION_INFORMATION_GPT),
                ]
                _SET_PARTITION_INFORMATION_EX.DUMMYUNIONNAME = DUMMYUNIONNAME


                _SET_PARTITION_INFORMATION_EX._fields_ = [
                    ('PartitionStyle', PARTITION_STYLE),
                    ('DUMMYUNIONNAME', _SET_PARTITION_INFORMATION_EX.DUMMYUNIONNAME),
                ]


                # The structure CREATE_DISK_GPT with the ioctl
                # IOCTL_DISK_CREATE_DISK
                # to initialize a disk with an empty GPT partition table.
                # Unique disk id for the disk.
                _CREATE_DISK_GPT._fields_ = [
                    ('DiskId', GUID),
                    # Maximim number of partitions allowable.
                    ('MaxPartitionCount', DWORD),
                ]


                # The structure CREATE_DISK_MBR with the ioctl
                # IOCTL_DISK_CREATE_DISK
                # to initialize a disk with an empty MBR partition table.
                _CREATE_DISK_MBR._fields_ = [
                    ('Signature', DWORD),
                ]


                class DUMMYUNIONNAME(ctypes.Union):
                    pass


                DUMMYUNIONNAME._fields_ = [
                    ('Mbr', CREATE_DISK_MBR),
                    ('Gpt', CREATE_DISK_GPT),
                ]
                _CREATE_DISK.DUMMYUNIONNAME = DUMMYUNIONNAME


                _CREATE_DISK._fields_ = [
                    ('PartitionStyle', PARTITION_STYLE),
                    ('DUMMYUNIONNAME', _CREATE_DISK.DUMMYUNIONNAME),
                ]


                # The structure GET_LENGTH_INFORMATION is used with the ioctl
                # IOCTL_DISK_GET_LENGTH_INFO to obtain the length, in bytes,
                # of the
                # disk, partition, or volume.
                _GET_LENGTH_INFORMATION._fields_ = [
                    ('Length', LARGE_INTEGER),
                ]


                # The PARTITION_INFORMATION_EX structure is used with the
                # IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                # IOCTL_DISK_SET_DRIVE_LAYOUT_EX,
                # IOCTL_DISK_GET_PARTITION_INFO_EX and
                # IOCTL_DISK_GET_PARTITION_INFO_EX calls.
                class DUMMYUNIONNAME(ctypes.Union):
                    pass


                DUMMYUNIONNAME._fields_ = [
                    ('Mbr', PARTITION_INFORMATION_MBR),
                    ('Gpt', PARTITION_INFORMATION_GPT),
                ]
                _PARTITION_INFORMATION_EX.DUMMYUNIONNAME = DUMMYUNIONNAME


                _TEMP__PARTITION_INFORMATION_EX = [
                    ('PartitionStyle', PARTITION_STYLE),
                    ('StartingOffset', LARGE_INTEGER),
                    ('PartitionLength', LARGE_INTEGER),
                    ('PartitionNumber', DWORD),
                    ('RewritePartition', BOOLEAN),
                ]
                if NTDDI_VERSION  >= NTDDI_WIN10_RS3: #  ABRACADABRA_WIN10_RS3
                    _TEMP__PARTITION_INFORMATION_EX += [
                        ('IsServicePartition', BOOLEAN),
                    ]
                # END IF


                _TEMP__PARTITION_INFORMATION_EX += [
                    ('DUMMYUNIONNAME', _PARTITION_INFORMATION_EX.DUMMYUNIONNAME),
                ]
                _PARTITION_INFORMATION_EX._fields_ = _TEMP__PARTITION_INFORMATION_EX


                # GPT specific drive layout information.
                _DRIVE_LAYOUT_INFORMATION_GPT._fields_ = [
                    ('DiskId', GUID),
                    ('StartingUsableOffset', LARGE_INTEGER),
                    ('UsableLength', LARGE_INTEGER),
                    ('MaxPartitionCount', DWORD),
                ]


                # MBR specific drive layout information.
                _TEMP__DRIVE_LAYOUT_INFORMATION_MBR = [
                    ('Signature', DWORD),
                ]
                if NTDDI_VERSION  >= NTDDI_WIN10_RS1: #  ABRACADABRA_WIN10_RS1
                    _TEMP__DRIVE_LAYOUT_INFORMATION_MBR += [
                        ('CheckSum', DWORD),
                    ]
                # END IF


                _DRIVE_LAYOUT_INFORMATION_MBR._fields_ = _TEMP__DRIVE_LAYOUT_INFORMATION_MBR


                # The structure DRIVE_LAYOUT_INFORMATION_EX is used with the
                # IOCTL_SET_DRIVE_LAYOUT_EX and IOCTL_GET_DRIVE_LAYOUT_EX
                # calls.
                class DUMMYUNIONNAME(ctypes.Union):
                    pass


                DUMMYUNIONNAME._fields_ = [
                    ('Mbr', DRIVE_LAYOUT_INFORMATION_MBR),
                    ('Gpt', DRIVE_LAYOUT_INFORMATION_GPT),
                ]
                _DRIVE_LAYOUT_INFORMATION_EX.DUMMYUNIONNAME = DUMMYUNIONNAME


                _DRIVE_LAYOUT_INFORMATION_EX._fields_ = [
                    ('PartitionStyle', DWORD),
                    ('PartitionCount', DWORD),
                    ('DUMMYUNIONNAME', _DRIVE_LAYOUT_INFORMATION_EX.DUMMYUNIONNAME),
                    ('PartitionEntry', PARTITION_INFORMATION_EX * 1),
                ]
            # END IF   (_WIN32_WINNT  >= 0x0500)


            if _WIN32_WINNT  >= 0x0500:
                # The DISK_GEOMETRY_EX structure is returned on issuing an
                # IOCTL_DISK_GET_DRIVE_GEOMETRY_EX ioctl.
                class _DETECTION_TYPE(ENUM):
                    DetectNone = 1
                    DetectInt13 = 2
                    DetectExInt13 = 3

                DETECTION_TYPE = _DETECTION_TYPE

                _DISK_INT13_INFO._fields_ = [
                    ('DriveSelect', WORD),
                    ('MaxCylinders', DWORD),
                    ('SectorsPerTrack', WORD),
                    ('MaxHeads', WORD),
                    ('NumberDrives', WORD),
                ]

                _DISK_EX_INT13_INFO._fields_ = [
                    ('ExBufferSize', WORD),
                    ('ExFlags', WORD),
                    ('ExCylinders', DWORD),
                    ('ExHeads', DWORD),
                    ('ExSectorsPerTrack', DWORD),
                    ('ExSectorsPerDrive', DWORD64),
                    ('ExSectorSize', WORD),
                    ('ExReserved', WORD),
                ]
                if _MSC_VER  >= 1200:
                    pass
                # END IF


                class DUMMYUNIONNAME(ctypes.Union):
                    pass


                class DUMMYSTRUCTNAME(ctypes.Structure):
                    pass


                DUMMYSTRUCTNAME._fields_ = [
                    # information.
                    ('Int13', DISK_INT13_INFO),
                    # If DetectionType == DetectExInt13
                    ('ExInt13', DISK_EX_INT13_INFO),
                ]
                DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


                DUMMYUNIONNAME._fields_ = [
                    ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
                ]
                _DISK_DETECTION_INFO.DUMMYUNIONNAME = DUMMYUNIONNAME


                _DISK_DETECTION_INFO._fields_ = [
                    ('SizeOfDetectInfo', DWORD),
                    ('DetectionType', DETECTION_TYPE),
                    ('DUMMYUNIONNAME', _DISK_DETECTION_INFO.DUMMYUNIONNAME),
                ]

                # If PartitionStyle == MBR
                class DUMMYUNIONNAME(ctypes.Union):
                    pass

                # MBR Signature
                class Mbr(ctypes.Structure):
                    pass


                Mbr._fields_ = [
                    ('Signature', DWORD),
                    # MBR CheckSum
                    ('CheckSum', DWORD),
                ]
                DUMMYUNIONNAME.Mbr = Mbr


                class Gpt(ctypes.Structure):
                    pass


                Gpt._fields_ = [
                    ('DiskId', GUID),
                ]
                DUMMYUNIONNAME.Gpt = Gpt


                DUMMYUNIONNAME._fields_ = [
                    ('Mbr', DUMMYUNIONNAME.Mbr),
                    # If PartitionStyle == GPT
                    ('Gpt', DUMMYUNIONNAME.Gpt),
                ]
                _DISK_PARTITION_INFO.DUMMYUNIONNAME = DUMMYUNIONNAME


                _DISK_PARTITION_INFO._fields_ = [
                    ('SizeOfPartitionInfo', DWORD),
                    # PartitionStyle = RAW, GPT or MBR
                    ('PartitionStyle', PARTITION_STYLE),
                    ('DUMMYUNIONNAME', _DISK_PARTITION_INFO.DUMMYUNIONNAME),
                ]
                if _MSC_VER  >= 1200:
                    pass
                # END IF


                # The Geometry structure is a variable length structure
                # composed of a
                # DISK_GEOMETRY_EX structure followed by a DISK_PARTITION_INFO
                # structure
                # followed by a DISK_DETECTION_DATA structure.
                if NTDDI_VERSION  <  NTDDI_WS03:
                    def DiskGeometryGetPartition(Geometry):
                        return PDISK_PARTITION_INFO(Geometry + 1)


                    def DiskGeometryGetDetect(Geometry):
                        return PDISK_DETECTION_INFO(
                            DiskGeometryGetPartition(Geometry) +
                            DiskGeometryGetPartition(Geometry).SizeOfPartitionInfo
                        )
                else:
                    def DiskGeometryGetPartition(Geometry):
                        return PDISK_PARTITION_INFO(Geometry.Data)


                    def DiskGeometryGetDetect(Geometry):
                        return PDISK_DETECTION_INFO(
                            DiskGeometryGetPartition(Geometry) +
                            DiskGeometryGetPartition(Geometry).SizeOfPartitionInfo
                        )
                # END IF


                # Standard disk geometry: may be faked by driver.
                _DISK_GEOMETRY_EX._fields_ = [
                    ('Geometry', DISK_GEOMETRY),
                    # Must always be correct
                    ('DiskSize', LARGE_INTEGER),
                    # Partition, Detect info
                    ('Data', BYTE * 1),
                ]
            # END IF   (_WIN32_WINNT  >  0x0500)


            if _WIN32_WINNT  >= 0x0400:
                # IOCTL_DISK_CONTROLLER_NUMBER returns the controller and disk
                # number for the handle. This is used to determine if a disk
                # is attached to the primary or secondary IDE controller.
                _DISK_CONTROLLER_NUMBER._fields_ = [
                    ('ControllerNumber', DWORD),
                    ('DiskNumber', DWORD),
                ]
            # END IF  _WIN32_WINNT  >= 0x0400


            if _WIN32_WINNT  >= 0x0500:
                # IOCTL_DISK_SET_CACHE_INFORMATION
                # Input Buffer:
                # A DISK_CACHE_INFORMATION structure which describes how the
                # disk
                # read/write caches should be configured.
                # Output Buffer:
                # None
                # IOCTL_DISK_GET_CACHE_INFORMATION
                # Input Buffer:
                # None
                # Output Buffer:
                # A DISK_CACHE_INFORMATION structure which contains the
                # current state
                # of the disk read/write caches.
                class DISK_CACHE_RETENTION_PRIORITY(ENUM):
                    EqualPriority = 1
                    KeepPrefetchedData = 2
                    KeepReadData = 3

                EqualPriority = DISK_CACHE_RETENTION_PRIORITY.EqualPriority
                KeepPrefetchedData = DISK_CACHE_RETENTION_PRIORITY.KeepPrefetchedData
                KeepReadData = DISK_CACHE_RETENTION_PRIORITY.KeepReadData
                if (OSVER(NTDDI_VERSION) == NTDDI_WINXP):
                    class _DISK_WRITE_CACHE_STATE(ENUM):
                        DiskWriteCacheNormal = 1
                        DiskWriteCacheForceDisable = 2
                        DiskWriteCacheDisableNotSupported = 3

                    DISK_WRITE_CACHE_STATE = _DISK_WRITE_CACHE_STATE
                    PDISK_WRITE_CACHE_STATE = POINTER(_DISK_WRITE_CACHE_STATE)
                # END IF


                class DUMMYUNIONNAME(ctypes.Union):
                    pass


                class ScalarPrefetch(ctypes.Structure):
                    pass


                ScalarPrefetch._fields_ = [
                    ('Minimum', WORD),
                    ('Maximum', WORD),
                    # with the scalar limits to set definite upper limits.
                    ('MaximumBlocks', WORD),
                ]
                DUMMYUNIONNAME.ScalarPrefetch = ScalarPrefetch


                class BlockPrefetch(ctypes.Structure):
                    pass


                BlockPrefetch._fields_ = [
                    ('Minimum', WORD),
                    ('Maximum', WORD),
                ]
                DUMMYUNIONNAME.BlockPrefetch = BlockPrefetch


                DUMMYUNIONNAME._fields_ = [
                    ('ScalarPrefetch', DUMMYUNIONNAME.ScalarPrefetch),
                    ('BlockPrefetch', DUMMYUNIONNAME.BlockPrefetch),
                ]
                _DISK_CACHE_INFORMATION.DUMMYUNIONNAME = DUMMYUNIONNAME


                _DISK_CACHE_INFORMATION._fields_ = [
                    # save the state in non-volatile storage.
                    ('ParametersSavable', BOOLEAN),
                    # Indicates whether the write and read caches are enabled.
                    ('ReadCacheEnabled', BOOLEAN),
                    ('WriteCacheEnabled', BOOLEAN),
                    # means (like prefetch)
                    ('ReadRetentionPriority', DISK_CACHE_RETENTION_PRIORITY),
                    ('WriteRetentionPriority', DISK_CACHE_RETENTION_PRIORITY),
                    # disabled. If this value is set to 0 prefetch will be
                    # disabled.
                    ('DisablePrefetchTransferLength', WORD),
                    # (BlockPrefetch)
                    ('PrefetchScalar', BOOLEAN),
                    # which interpretation is used.
                    ('DUMMYUNIONNAME', _DISK_CACHE_INFORMATION.DUMMYUNIONNAME),
                ]


                # IOCTL_DISK_GROW_PARTITION will update the size of a partition
                # by adding sectors to the length. The number of sectors must
                # be
                # predetermined by examining PARTITION_INFORMATION.
                _DISK_GROW_PARTITION._fields_ = [
                    ('PartitionNumber', DWORD),
                    ('BytesToGrow', LARGE_INTEGER),
                ]
            # END IF  _WIN32_WINNT  >= 0x0500

            # /////////////////////////////////////////////////////
            # //
            # The following structures define disk performance //
            # statistics: specifically the locations of all the //
            # reads and writes which have occured on the disk. //
            # //
            # To use these structures, you must issue an IOCTL_ //
            # DISK_HIST_STRUCTURE (with a DISK_HISTOGRAM) to //
            # obtain the basic histogram information. The  //
            # number of buckets which must allocated is part of //
            # this structure. Allocate the required number of //
            # buckets and call an IOCTL_DISK_HIST_DATA to fill //
            # in the data       //
            # //
            # /////////////////////////////////////////////////////
            HIST_NO_OF_BUCKETS = 24


            _HISTOGRAM_BUCKET._fields_ = [
                ('Reads', DWORD),
                ('Writes', DWORD),
            ]
            HISTOGRAM_BUCKET_SIZE = ctypes.sizeof(HISTOGRAM_BUCKET)
            _DISK_HISTOGRAM._fields_ = [
                ('DiskSize', LARGE_INTEGER),
                ('Start', LARGE_INTEGER),
                ('End', LARGE_INTEGER),
                ('Average', LARGE_INTEGER),
                ('AverageRead', LARGE_INTEGER),
                ('AverageWrite', LARGE_INTEGER),
                ('Granularity', DWORD),
                ('Size', DWORD),
                ('ReadCount', DWORD),
                ('WriteCount', DWORD),
                ('Histogram', PHISTOGRAM_BUCKET),
            ]
            DISK_HISTOGRAM_SIZE = ctypes.sizeof(DISK_HISTOGRAM)
            # /////////////////////////////////////////////////////
            # //
            # The following structures define disk debugging //
            # capabilities. The IOCTLs are directed to one of //
            # the two disk filter drivers.    //
            # //
            # DISKPERF is a utilty for collecting disk request //
            # statistics.       //
            # //
            # SIMBAD is a utility for injecting faults in  //
            # IO requests to disks.      //
            # //
            # /////////////////////////////////////////////////////
            # The following structure is exchanged on an
            # IOCTL_DISK_GET_PERFORMANCE
            # request. This ioctl collects summary disk request statistics used
            # in measuring performance.
            _DISK_PERFORMANCE._fields_ = [
                ('BytesRead', LARGE_INTEGER),
                ('BytesWritten', LARGE_INTEGER),
                ('ReadTime', LARGE_INTEGER),
                ('WriteTime', LARGE_INTEGER),
                ('IdleTime', LARGE_INTEGER),
                ('ReadCount', DWORD),
                ('WriteCount', DWORD),
                ('QueueDepth', DWORD),
                ('SplitCount', DWORD),
                ('QueryTime', LARGE_INTEGER),
                ('StorageDeviceNumber', DWORD),
                ('StorageManagerName', WCHAR * 8),
            ]
            # This structure defines the disk logging record. When disk logging
            # is enabled, one of these is written to an internal buffer for
            # each
            # disk request.
            _DISK_RECORD._fields_ = [
                ('ByteOffset', LARGE_INTEGER),
                ('StartTime', LARGE_INTEGER),
                ('EndTime', LARGE_INTEGER),
                ('VirtualAddress', PVOID),
                ('NumberOfBytes', DWORD),
                ('DeviceNumber', BYTE),
                ('ReadRequest', BOOLEAN),
            ]
            # The following structure is exchanged on an IOCTL_DISK_LOG
            # request.
            # Not all fields are valid with each function type.
            _DISK_LOGGING._fields_ = [
                ('Function', BYTE),
                ('BufferAddress', PVOID),
                ('BufferSize', DWORD),
            ]
            # Disk logging functions
            # Start disk logging. Only the Function and BufferSize fields are
            # valid.
            DISK_LOGGING_START = 0
            # Stop disk logging. Only the Function field is valid.
            DISK_LOGGING_STOP = 1
            # Return disk log. All fields are valid. Data will be copied from
            # internal
            # buffer to buffer specified for the number of bytes requested.
            DISK_LOGGING_DUMP = 2
            # DISK BINNING
            # DISKPERF will keep counters for IO that falls in each of these
            # ranges.
            # The application determines the number and size of the ranges.
            # Joe Lin wanted me to keep it flexible as possible, for instance,
            # IO
            # sizes are interesting in ranges like 0-4096, 4097-16384,
            # 16385-65536, 65537 + .
            DISK_BINNING = 3
            # Bin types
            class _BIN_TYPES(ENUM):
                RequestSize = 1
                RequestLocation = 2

            BIN_TYPES = _BIN_TYPES


            # Bin ranges
            _BIN_RANGE._fields_ = [
                ('StartValue', LARGE_INTEGER),
                ('Length', LARGE_INTEGER),
            ]


            # Bin definition
            _PERF_BIN._fields_ = [
                ('NumberOfBins', DWORD),
                ('TypeOfBin', DWORD),
                ('BinsRanges', BIN_RANGE * 1),
            ]


            # Bin count
            _BIN_COUNT._fields_ = [
                ('BinRange', BIN_RANGE),
                ('BinCount', DWORD),
            ]


            # Bin results
            _BIN_RESULTS._fields_ = [
                ('NumberOfBins', DWORD),
                ('BinCounts', BIN_COUNT * 1),
            ]

            if _WIN32_WINNT  >= 0x0400:
                # Data structures for SMART drive fault prediction.
                # GETVERSIONINPARAMS contains the data returned from the
                # Get Driver Version function.
                from pyWinAPI.shared.pshpack1_h import * # NOQA

                # Binary driver version.
                _GETVERSIONINPARAMS._fields_ = [
                    ('bVersion', BYTE),
                    # Binary driver revision.
                    ('bRevision', BYTE),
                    # Not used.
                    ('bReserved', BYTE),
                    # Bit map of IDE devices.
                    ('bIDEDeviceMap', BYTE),
                    # Bit mask of driver capabilities.
                    ('fCapabilities', DWORD),
                    # For future use.
                    ('dwReserved', DWORD * 4),
                ]
                from pyWinAPI.shared.poppack_h import * # NOQA

                # Bits returned in the fCapabilities member of
                # GETVERSIONINPARAMS
                # ATA ID command supported
                CAP_ATA_ID_CMD = 1

                # ATAPI ID command supported
                CAP_ATAPI_ID_CMD = 2

                # SMART commannds supported
                CAP_SMART_CMD = 4

                # IDE registers
                from pyWinAPI.shared.pshpack1_h import * # NOQA


                # Used for specifying SMART "commands".
                _IDEREGS._fields_ = [
                    ('bFeaturesReg', BYTE),
                    # IDE sector count register
                    ('bSectorCountReg', BYTE),
                    # IDE sector number register
                    ('bSectorNumberReg', BYTE),
                    # IDE low order cylinder value
                    ('bCylLowReg', BYTE),
                    # IDE high order cylinder value
                    ('bCylHighReg', BYTE),
                    # IDE drive/head register
                    ('bDriveHeadReg', BYTE),
                    # Actual IDE command.
                    ('bCommandReg', BYTE),
                    # reserved for future use. Must be zero.
                    ('bReserved', BYTE),
                ]
                from pyWinAPI.shared.poppack_h import * # NOQA

                # Valid values for the bCommandReg member of IDEREGS.
                # Returns ID sector for ATAPI.
                ATAPI_ID_CMD = 0xA1

                # Returns ID sector for ATA.
                ID_CMD = 0xEC

                # Performs SMART cmd.
                SMART_CMD = 0xB0

                # Requires valid bFeaturesReg,
                # bCylLowReg, and bCylHighReg
                # Cylinder register defines for SMART command
                SMART_CYL_LOW = 0x4F
                SMART_CYL_HI = 0xC2

                # SENDCMDINPARAMS contains the input parameters for the
                # Send Command to Drive function.
                from pyWinAPI.shared.pshpack1_h import * # NOQA


                # Buffer size in bytes
                _SENDCMDINPARAMS._fields_ = [
                    ('cBufferSize', DWORD),
                    # Structure with drive register values.
                    ('irDriveRegs', IDEREGS),
                    # Physical drive number to send
                    ('bDriveNumber', BYTE),
                    # Reserved for future expansion.
                    ('bReserved', BYTE * 3),
                    # For future use.
                    ('dwReserved', DWORD * 4),
                    # Input buffer.
                    ('bBuffer', BYTE * 1),
                ]
                from pyWinAPI.shared.poppack_h import * # NOQA

                # Status returned from driver
                from pyWinAPI.shared.pshpack1_h import * # NOQA

                # Error code from driver,
                _DRIVERSTATUS._fields_ = [
                    ('bDriverError', BYTE),
                    # Contents of IDE Error register.
                    ('bIDEError', BYTE),
                    # Reserved for future expansion.
                    ('bReserved', BYTE * 2),
                    # Reserved for future expansion.
                    ('dwReserved', DWORD * 2),
                ]
                from pyWinAPI.shared.poppack_h import * # NOQA

                # bDriverError values
                # No error
                SMART_NO_ERROR = 0

                # Error from IDE controller
                SMART_IDE_ERROR = 1

                # Invalid command flag
                SMART_INVALID_FLAG = 2

                # Invalid command byte
                SMART_INVALID_COMMAND = 3

                # Bad buffer (null, invalid addr..)
                SMART_INVALID_BUFFER = 4

                # Drive number not valid
                SMART_INVALID_DRIVE = 5

                # Invalid IOCTL
                SMART_INVALID_IOCTL = 6

                # Could not lock user's buffer
                SMART_ERROR_NO_MEM = 7

                # Some IDE Register not valid
                SMART_INVALID_REGISTER = 8

                # Invalid cmd flag set
                SMART_NOT_SUPPORTED = 9

                # Cmd issued to device not present
                SMART_NO_IDE_DEVICE = 10

                # although drive number is valid
                # SMART sub commands for execute offline diags
                SMART_OFFLINE_ROUTINE_OFFLINE = 0
                SMART_SHORT_SELFTEST_OFFLINE = 1
                SMART_EXTENDED_SELFTEST_OFFLINE = 2
                SMART_ABORT_OFFLINE_SELFTEST = 127
                SMART_SHORT_SELFTEST_CAPTIVE = 129
                SMART_EXTENDED_SELFTEST_CAPTIVE = 130
                from pyWinAPI.shared.pshpack1_h import * # NOQA


                # Size of bBuffer in bytes
                _SENDCMDOUTPARAMS._fields_ = [
                    ('cBufferSize', DWORD),
                    # Driver status structure.
                    ('DriverStatus', DRIVERSTATUS),
                ]
                from pyWinAPI.shared.poppack_h import * # NOQA
                READ_ATTRIBUTE_BUFFER_SIZE = 512
                IDENTIFY_BUFFER_SIZE = 512
                READ_THRESHOLD_BUFFER_SIZE = 512
                SMART_LOG_SECTOR_SIZE = 512

                # Feature register defines for SMART "sub commands"
                READ_ATTRIBUTES = 0xD0
                READ_THRESHOLDS = 0xD1
                ENABLE_DISABLE_AUTOSAVE = 0xD2
                SAVE_ATTRIBUTE_VALUES = 0xD3
                EXECUTE_OFFLINE_DIAGS = 0xD4
                SMART_READ_LOG = 0xD5
                SMART_WRITE_LOG = 0xD6
                ENABLE_SMART = 0xD8
                DISABLE_SMART = 0xD9
                RETURN_SMART_STATUS = 0xDA
                ENABLE_DISABLE_AUTO_OFFLINE = 0xDB
            # END IF  _WIN32_WINNT  >= 0x0400

            # IOCTLs to query and modify attributes
            # associated with the given disk. These
            # are persisted within the registry.
            IOCTL_DISK_GET_DISK_ATTRIBUTES = CTL_CODE(IOCTL_DISK_BASE, 0x003c, METHOD_BUFFERED, FILE_ANY_ACCESS)
            IOCTL_DISK_SET_DISK_ATTRIBUTES = CTL_CODE(IOCTL_DISK_BASE, 0x003d, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
            DISK_ATTRIBUTE_OFFLINE = 0x0000000000000001
            DISK_ATTRIBUTE_READ_ONLY = 0x0000000000000002

            # IOCTL_DISK_GET_DISK_ATTRIBUTES
            # Input Buffer:
            # None
            # Output Buffer:
            # Structure of type GET_DISK_ATTRIBUTES
            _GET_DISK_ATTRIBUTES._fields_ = [
                # structure for versioning.
                ('Version', DWORD),
                # Reserved. Must ignore.
                ('Reserved1', DWORD),
                # associated with the disk.
                ('Attributes', DWORDLONG),
            ]

            # IOCTL_DISK_SET_DISK_ATTRIBUTES
            # Input Buffer:
            # Structure of type SET_DISK_ATTRIBUTES
            # Output Buffer:
            # None
            _SET_DISK_ATTRIBUTES._fields_ = [
                # structure for versioning.
                ('Version', DWORD),
                # or not.
                ('Persist', BOOLEAN),
                # Reserved. Must set to zero.
                ('Reserved1', BYTE * 3),
                # Specifies the new attributes.
                ('Attributes', DWORDLONG),
                # that are being modified.
                ('AttributesMask', DWORDLONG),
                # Reserved. Must set to zero.
                ('Reserved2', DWORD * 4),
            ]
            IOCTL_DISK_RESET_SNAPSHOT_INFO = CTL_CODE(IOCTL_DISK_BASE, 0x0084, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

            if defined(_MSC_VER):
                if _MSC_VER  >= 1200:
                    pass
                # END IF
            # END IF

        # END IF  WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
    # END IF   _NTDDDISK_H_

    IOCTL_CHANGER_BASE = FILE_DEVICE_CHANGER
    IOCTL_CHANGER_GET_PARAMETERS = CTL_CODE(IOCTL_CHANGER_BASE, 0x0000, METHOD_BUFFERED, FILE_READ_ACCESS)
    IOCTL_CHANGER_GET_STATUS = CTL_CODE(IOCTL_CHANGER_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)
    IOCTL_CHANGER_GET_PRODUCT_DATA = CTL_CODE(IOCTL_CHANGER_BASE, 0x0002, METHOD_BUFFERED, FILE_READ_ACCESS)
    IOCTL_CHANGER_SET_ACCESS = CTL_CODE(IOCTL_CHANGER_BASE, 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
    IOCTL_CHANGER_GET_ELEMENT_STATUS = CTL_CODE(IOCTL_CHANGER_BASE, 0x0005, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
    IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS = CTL_CODE(IOCTL_CHANGER_BASE, 0x0006, METHOD_BUFFERED, FILE_READ_ACCESS)
    IOCTL_CHANGER_SET_POSITION = CTL_CODE(IOCTL_CHANGER_BASE, 0x0007, METHOD_BUFFERED, FILE_READ_ACCESS)
    IOCTL_CHANGER_EXCHANGE_MEDIUM = CTL_CODE(IOCTL_CHANGER_BASE, 0x0008, METHOD_BUFFERED, FILE_READ_ACCESS)
    IOCTL_CHANGER_MOVE_MEDIUM = CTL_CODE(IOCTL_CHANGER_BASE, 0x0009, METHOD_BUFFERED, FILE_READ_ACCESS)
    IOCTL_CHANGER_REINITIALIZE_TRANSPORT = CTL_CODE(IOCTL_CHANGER_BASE, 0x000A, METHOD_BUFFERED, FILE_READ_ACCESS)
    IOCTL_CHANGER_QUERY_VOLUME_TAGS = CTL_CODE(IOCTL_CHANGER_BASE, 0x000B, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

    MAX_VOLUME_ID_SIZE = 36
    MAX_VOLUME_TEMPLATE_SIZE = 40
    VENDOR_ID_LENGTH = 8
    PRODUCT_ID_LENGTH = 16
    REVISION_LENGTH = 4
    SERIAL_NUMBER_LENGTH = 32

    # Common structures describing elements.

    class _ELEMENT_TYPE(ENUM):
        AllElements = 0 # As defined by SCSI
        ChangerTransport = 1 # As defined by SCSI
        ChangerSlot = 2 # As defined by SCSI
        ChangerIEPort = 3 # As defined by SCSI
        ChangerDrive = 4 # As defined by SCSI
        ChangerDoor = 5 # Front panel, used to access internal of cabinet.
        ChangerKeypad = 6 # Keypad/input on front panel.
        ChangerMaxElement = 7 # Placeholder only. Not a valid type.


    ELEMENT_TYPE = _ELEMENT_TYPE
    PELEMENT_TYPE = POINTER(_ELEMENT_TYPE)


    _CHANGER_ELEMENT._fields_ = [
        ('ElementType', ELEMENT_TYPE),
        ('ElementAddress', DWORD),
    ]

    _CHANGER_ELEMENT_LIST._fields_ = [
        ('Element', CHANGER_ELEMENT),
        ('NumberOfElements', DWORD),
    ]

    # Definitions for IOCTL_CHANGER_GET_PARAMETERS
    # Definitions for Features0 of GET_CHANGER_PARAMETERS
    # The medium-changer has a bar code scanner installed.
    CHANGER_BAR_CODE_SCANNER_INSTALLED = 0x00000001

    # The medium-changer has the ability to initialize elements within a
    # specified range.
    CHANGER_INIT_ELEM_STAT_WITH_RANGE = 0x00000002

    # The medium-changer has the ability to close the i/e port door.
    CHANGER_CLOSE_IEPORT = 0x00000004

    # The medium-changer can open the i/e port door.
    CHANGER_OPEN_IEPORT = 0x00000008

    # The medium-changer uses non-volatile memory for element status
    # information.
    CHANGER_STATUS_NON_VOLATILE = 0x00000010

    # The medium-changer supports exchange operations.
    CHANGER_EXCHANGE_MEDIA = 0x00000020

    # The medium-changer has a fixed slot designated for cleaner cartridges.
    CHANGER_CLEANER_SLOT = 0x00000040

    # The medium-changer can be (un)secured to (allow)prevent media removal.
    CHANGER_LOCK_UNLOCK = 0x00000080

    # The medium-changer uses cartridge magazines for some storage slots.
    CHANGER_CARTRIDGE_MAGAZINE = 0x00000100

    # The medium-changer can flip medium.
    CHANGER_MEDIUM_FLIP = 0x00000200

    # The medium-changer can position the transport to a particular element.
    CHANGER_POSITION_TO_ELEMENT = 0x00000400

    # The medium-changer can determine whether media is present
    CHANGER_REPORT_IEPORT_STATE = 0x00000800

    # in the IE Port.
    # The medium-changer can use a drive as an independent storage element.
    CHANGER_STORAGE_DRIVE = 0x00001000

    # The medium-changer can use a i/e port as an independent storage element.
    CHANGER_STORAGE_IEPORT = 0x00002000

    # The medium-changer can use a slot as an independent storage element.
    CHANGER_STORAGE_SLOT = 0x00004000

    # The medium-changer can use a transport as an independent storage element.
    CHANGER_STORAGE_TRANSPORT = 0x00008000

    # The drives controlled by the medium changer require periodic cleaning
    CHANGER_DRIVE_CLEANING_REQUIRED = 0x00010000

    # initiated by an application.
    # The medium-changer requires a drive eject command to be issued, before a
    # changer
    CHANGER_PREDISMOUNT_EJECT_REQUIRED = 0x00020000

    # move / exchange command can be issued to the drive.
    # The access bit in GES isn't valid for cleaner cartridges.
    CHANGER_CLEANER_ACCESS_NOT_VALID = 0x00040000

    # The medium-changer requires a drive eject command to be issued
    CHANGER_PREMOUNT_EJECT_REQUIRED = 0x00080000

    # before a move / exchange command can be issued with the drive as src/dst.
    # The medium-changer supports volume identification.
    CHANGER_VOLUME_IDENTIFICATION = 0x00100000

    # The medium-changer can search for volume information.
    CHANGER_VOLUME_SEARCH = 0x00200000

    # The medium-changer can verify volume information.
    CHANGER_VOLUME_ASSERT = 0x00400000

    # The medium-changer can replace volume information.
    CHANGER_VOLUME_REPLACE = 0x00800000

    # The medium-changer can undefine volume information.
    CHANGER_VOLUME_UNDEFINE = 0x01000000

    # The serial number reported in GetProductData is valid
    CHANGER_SERIAL_NUMBER_VALID = 0x04000000

    # and unique.
    # The medium-changer can be issued a ChangerReinitializeUnit.
    CHANGER_DEVICE_REINITIALIZE_CAPABLE = 0x08000000

    # Indicates that the keypad can be enabled/disabled.
    CHANGER_KEYPAD_ENABLE_DISABLE = 0x10000000

    # Drives must be empty before access via the door is possible.
    CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS = 0x20000000

    # Will be used to indicate Features1 capability bits.
    CHANGER_RESERVED_BIT = 0x80000000

    # Definitions for Features1 of GET_CHANGER_PARAMETERS
    # The transport must be prepositioned to the slot prior to ejecting the
    # media.
    CHANGER_PREDISMOUNT_ALIGN_TO_SLOT = 0x80000001

    # The transport must be prepositioned to the drive prior to ejecting the
    # media.
    CHANGER_PREDISMOUNT_ALIGN_TO_DRIVE = 0x80000002

    # The device will move the cleaner cartridge back into the slot when
    # cleaning has completed.
    CHANGER_CLEANER_AUTODISMOUNT = 0x80000004

    # Device can do src.dest2 exchanges.
    CHANGER_TRUE_EXCHANGE_CAPABLE = 0x80000008

    # Slots have removable trays, requiring multiple moves for inject/eject.
    CHANGER_SLOTS_USE_TRAYS = 0x80000010

    # Media must be returned to the slot from which it originated after a move
    # to another element.
    CHANGER_RTN_MEDIA_TO_ORIGINAL_ADDR = 0x80000020

    # Automated cleaning operations are not supported on this device.
    CHANGER_CLEANER_OPS_NOT_SUPPORTED = 0x80000040

    # Indicates that user action is necessary to open a closed ieport.
    CHANGER_IEPORT_USER_CONTROL_OPEN = 0x80000080

    # Indicates that user action is necessary to close an opened ieport.
    CHANGER_IEPORT_USER_CONTROL_CLOSE = 0x80000100

    # Indicates that a move media to the ieport extends the tray.
    CHANGER_MOVE_EXTENDS_IEPORT = 0x80000200

    # Indicates that a move media from the ieport retracts the tray.
    CHANGER_MOVE_RETRACTS_IEPORT = 0x80000400

    # Definitions for MoveFrom, ExchangeFrom, and PositionCapabilities
    # The device can carry out the operation to a transport from the specified
    # element.
    CHANGER_TO_TRANSPORT = 0x01

    # The device can carry out the operation to a slot from the specified
    # element.
    CHANGER_TO_SLOT = 0x02

    # The device can carry out the operation to an IE Port from the specified
    # element.
    CHANGER_TO_IEPORT = 0x04

    # The device can carry out the operation to a drive from the specified
    # element.
    CHANGER_TO_DRIVE = 0x08

    # Definitions for LockUnlockCapabilities
    # The device can lock/unlock the ieport(s).
    LOCK_UNLOCK_IEPORT = 0x01

    # The device can lock/unlock the door(s).
    LOCK_UNLOCK_DOOR = 0x02

    # The device can lock/unlock the keypad.
    LOCK_UNLOCK_KEYPAD = 0x04


    _GET_CHANGER_PARAMETERS._fields_ = [
        # Size of the structure. Can be used for versioning.
        ('Size', DWORD),
        # Number of N element(s) as defined by the Element Address Page
        # (or equivalent...).
        ('NumberTransportElements', WORD),
        # for data cartridges only
        ('NumberStorageElements', WORD),
        # for cleaner cartridges
        ('NumberCleanerSlots', WORD),
        ('NumberIEElements', WORD),
        ('NumberDataTransferElements', WORD),
        # Number of doors/front panels (allows user entry into the cabinet).
        ('NumberOfDoors', WORD),
        # by the UI to relate the various elements to the user.
        ('FirstSlotNumber', WORD),
        ('FirstDriveNumber', WORD),
        ('FirstTransportNumber', WORD),
        ('FirstIEPortNumber', WORD),
        ('FirstCleanerSlotAddress', WORD),
        # Indicates the capacity of each magazine, if they exist.
        ('MagazineSize', WORD),
        # Only applicable if drive cleaning is supported. See Features0.
        ('DriveCleanTimeout', DWORD),
        # See features bits, above.
        ('Features0', DWORD),
        ('Features1', DWORD),
        # AND-masking with the TO_XXX values will indicate legal destinations.
        ('MoveFromTransport', BYTE),
        ('MoveFromSlot', BYTE),
        ('MoveFromIePort', BYTE),
        ('MoveFromDrive', BYTE),
        # AND-masking with the TO_XXX values will indicate legal destinations.
        ('ExchangeFromTransport', BYTE),
        ('ExchangeFromSlot', BYTE),
        ('ExchangeFromIePort', BYTE),
        ('ExchangeFromDrive', BYTE),
        # CHANGER_LOCK_UNLOCK is set in Features0.
        ('LockUnlockCapabilities', BYTE),
        # CHANGER_POSITION_TO_ELEMENT is set in Features0.
        ('PositionCapabilities', BYTE),
        # For future expansion.
        ('Reserved1', BYTE * 2),
        ('Reserved2', DWORD * 2),
    ]

    # Definitions for IOCTL_CHANGER_GET_PRODUCT_DATA
    _CHANGER_PRODUCT_DATA._fields_ = [
        # Device manufacturer's name - based on inquiry data
        ('VendorId', BYTE * VENDOR_ID_LENGTH),
        # Product identification as defined by the vendor - based on Inquiry
        # data
        ('ProductId', BYTE * PRODUCT_ID_LENGTH),
        # Product revision as defined by the vendor.
        ('Revision', BYTE * REVISION_LENGTH),
        # be from Vital Product Data, for example.
        ('SerialNumber', BYTE * SERIAL_NUMBER_LENGTH),
        # Indicates device type of data transports, as defined by SCSI-2.
        ('DeviceType', BYTE),
    ]

    # Definitions for IOCTL_CHANGER_SET_ACCESS
    LOCK_ELEMENT = 0
    UNLOCK_ELEMENT = 1
    EXTEND_IEPORT = 2
    RETRACT_IEPORT = 3


    _CHANGER_SET_ACCESS._fields_ = [
        # Element can be ChangerIEPort, ChangerDoor, ChangerKeypad
        ('Element', CHANGER_ELEMENT),
        # See above for possible operations.
        ('Control', DWORD),
    ]

    # Definitions for IOCTL_CHANGER_GET_ELEMENT_STATUS
    # Input buffer.
    _CHANGER_READ_ELEMENT_STATUS._fields_ = [
        # List describing the elements and range on which to return
        # information.
        ('ElementList', CHANGER_ELEMENT_LIST),
        # Indicates whether volume tag information is to be returned.
        ('VolumeTagInfo', BOOLEAN),
    ]

    # Output buffer.
    _CHANGER_ELEMENT_STATUS._fields_ = [
        # Element to which this structure refers.
        ('Element', CHANGER_ELEMENT),
        # Needs to be converted to a zero-based offset from the device-unique
        # value.
        ('SrcElementAddress', CHANGER_ELEMENT),
        # See below.
        ('Flags', DWORD),
        # See below for possible values.
        ('ExceptionCode', DWORD),
        # Valid only if ELEMENT_STATUS_ID_VALID is set in Flags.
        ('TargetId', BYTE),
        # Valid only if ELEMENT_STATUS_LUN_VALID is set in Flags.
        ('Lun', BYTE),
        ('Reserved', WORD),
        # Valid only if ELEMENT_STATUS_PVOLTAG bit is set in Flags.
        ('PrimaryVolumeID', BYTE * MAX_VOLUME_ID_SIZE),
        # Valid only if ELEMENT_STATUS_AVOLTAG bit is set in Flags.
        ('AlternateVolumeID', BYTE * MAX_VOLUME_ID_SIZE),
    ]

    # Output buffer. This is same as CHANGER_ELEMENT_STATUS with
    # the addition of product info fields. New applications should
    # use this struct instead of the older CHANGER_ELEMENT_STATUS
    _CHANGER_ELEMENT_STATUS_EX._fields_ = [
        # Element to which this structure refers.
        ('Element', CHANGER_ELEMENT),
        # Needs to be converted to a zero-based offset from the device-unique
        # value.
        ('SrcElementAddress', CHANGER_ELEMENT),
        # See below.
        ('Flags', DWORD),
        # See below for possible values.
        ('ExceptionCode', DWORD),
        # Valid only if ELEMENT_STATUS_ID_VALID is set in Flags.
        ('TargetId', BYTE),
        # Valid only if ELEMENT_STATUS_LUN_VALID is set in Flags.
        ('Lun', BYTE),
        ('Reserved', WORD),
        # Valid only if ELEMENT_STATUS_PVOLTAG bit is set in Flags.
        ('PrimaryVolumeID', BYTE * MAX_VOLUME_ID_SIZE),
        # Valid only if ELEMENT_STATUS_AVOLTAG bit is set in Flags.
        ('AlternateVolumeID', BYTE * MAX_VOLUME_ID_SIZE),
        # Vendor ID
        ('VendorIdentification', BYTE * VENDOR_ID_LENGTH),
        # Product ID
        ('ProductIdentification', BYTE * PRODUCT_ID_LENGTH),
        # Serial number
        ('SerialNumber', BYTE * SERIAL_NUMBER_LENGTH),
    ]

    # Possible flag values
    # Element contains a unit of media.
    ELEMENT_STATUS_FULL = 0x00000001

    # Media in i/e port was placed there by an operator.
    ELEMENT_STATUS_IMPEXP = 0x00000002

    # Element is in an abnormal state; check ExceptionCode field for more
    # information.
    ELEMENT_STATUS_EXCEPT = 0x00000004

    # Access to the i/e port from the medium changer is allowed.
    ELEMENT_STATUS_ACCESS = 0x00000008

    # Export of media is supported.
    ELEMENT_STATUS_EXENAB = 0x00000010

    # Import of media is supported.
    ELEMENT_STATUS_INENAB = 0x00000020

    # Serial number valid for the drive
    ELEMENT_STATUS_PRODUCT_DATA = 0x00000040

    # Lun information is valid.
    ELEMENT_STATUS_LUN_VALID = 0x00001000

    # SCSI Id information is valid.
    ELEMENT_STATUS_ID_VALID = 0x00002000

    # Lun and SCSI Id fields are not on same bus as medium changer.
    ELEMENT_STATUS_NOT_BUS = 0x00008000

    # Media in element was inverted
    # (valid only if ELEMENT_STATUS_SVALID bit is set)
    ELEMENT_STATUS_INVERT = 0x00400000

    # SourceElementAddress field and ELEMENT_STATUS_INVERT bit are valid.
    ELEMENT_STATUS_SVALID = 0x00800000

    # Primary volume information is valid.
    ELEMENT_STATUS_PVOLTAG = 0x10000000

    # Alternate volume information is valid.
    ELEMENT_STATUS_AVOLTAG = 0x20000000

    # ExceptionCode values.
    # Bar code scanner could not read bar code label.
    ERROR_LABEL_UNREADABLE = 0x00000001

    # Label could be invalid due to unit attention condition.
    ERROR_LABEL_QUESTIONABLE = 0x00000002

    # Slot is currently not addressable in the device.
    ERROR_SLOT_NOT_PRESENT = 0x00000004

    # Drive is not installed.
    ERROR_DRIVE_NOT_INSTALLED = 0x00000008

    # Media tray is malfunctioning/broken.
    ERROR_TRAY_MALFUNCTION = 0x00000010

    # An Initialize Element Status command is needed.
    ERROR_INIT_STATUS_NEEDED = 0x00000011

    # Unknown error condition
    ERROR_UNHANDLED_ERROR = 0xFFFFFFFF

    # Definitions for IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS
    _CHANGER_INITIALIZE_ELEMENT_STATUS._fields_ = [
        # List describing the elements and range on which to initialize.
        ('ElementList', CHANGER_ELEMENT_LIST),
        # CHANGER_BAR_CODE_SCANNER_INSTALLED is set in Features0 of
        # CHANGER_GET_PARAMETERS.
        ('BarCodeScan', BOOLEAN),
    ]

    # Definitions for IOCTL_CHANGER_SET_POSITION
    _CHANGER_SET_POSITION._fields_ = [
        # Indicates which transport to move.
        ('Transport', CHANGER_ELEMENT),
        # Indicates the final destination of the transport.
        ('Destination', CHANGER_ELEMENT),
        # Indicates whether the media currently carried by Transport, should
        # be flipped.
        ('Flip', BOOLEAN),
    ]

    # Definitions for IOCTL_CHANGER_EXCHANGE_MEDIUM
    _CHANGER_EXCHANGE_MEDIUM._fields_ = [
        # Indicates which transport to use for the exchange operation.
        ('Transport', CHANGER_ELEMENT),
        # Indicates the source for the media that is to be moved.
        ('Source', CHANGER_ELEMENT),
        # Indicates the final destination of the media originally at Source.
        ('Destination1', CHANGER_ELEMENT),
        # Indicates the destination of the media moved from Destination1.
        ('Destination2', CHANGER_ELEMENT),
        # Indicates whether the medium should be flipped.
        ('Flip1', BOOLEAN),
        ('Flip2', BOOLEAN),
    ]

    # Definitions for IOCTL_CHANGER_MOVE_MEDIUM
    _CHANGER_MOVE_MEDIUM._fields_ = [
        # Indicates which transport to use for the move operation.
        ('Transport', CHANGER_ELEMENT),
        # Indicates the source for the media that is to be moved.
        ('Source', CHANGER_ELEMENT),
        # Indicates the destination of the media originally at Source.
        ('Destination', CHANGER_ELEMENT),
        # Indicates whether the media should be flipped.
        ('Flip', BOOLEAN),
    ]

    # Definitions for IOCTL_QUERY_VOLUME_TAGS
    # Input buffer.
    _CHANGER_SEND_VOLUME_TAG_INFORMATION._fields_ = [
        # Describes the starting element for which to return information.
        ('StartingElement', CHANGER_ELEMENT),
        # Indicates the specific action to perform. See below.
        ('ActionCode', DWORD),
        # Template used by the device to search for volume ids.
        ('VolumeIDTemplate', BYTE * MAX_VOLUME_TEMPLATE_SIZE),
    ]

    # Output buffer.
    _READ_ELEMENT_ADDRESS_INFO._fields_ = [
        # Number of elements matching criteria set forth by ActionCode.
        ('NumberOfElements', DWORD),
        # with the information passed in with the
        # CHANGER_SEND_VOLUME_TAG_INFORMATION structure.
        ('ElementStatus', CHANGER_ELEMENT_STATUS * 1),
    ]

    # Possible ActionCode values. See Features0 of CHANGER_GET_PARAMETERS for
    # compatibility with
    # the current device.
    # Translate - search all defined volume tags.
    SEARCH_ALL = 0x0

    # Translate - search only primary volume tags.
    SEARCH_PRIMARY = 0x1

    # Translate - search only alternate volume tags.
    SEARCH_ALTERNATE = 0x2

    # Translate - search all defined volume tags but ignore sequence numbers.
    SEARCH_ALL_NO_SEQ = 0x4

    # Translate - search only primary volume tags but ignore sequence numbers.
    SEARCH_PRI_NO_SEQ = 0x5

    # Translate - search only alternate volume tags but ignore sequence
    # numbers.
    SEARCH_ALT_NO_SEQ = 0x6

    # Assert - as the primary volume tag - if tag now undefined.
    ASSERT_PRIMARY = 0x8

    # Assert - as the alternate volume tag - if tag now undefined.
    ASSERT_ALTERNATE = 0x9

    # Replace - the primary volume tag - current tag ignored.
    REPLACE_PRIMARY = 0xA

    # Replace - the alternate volume tag - current tag ignored.
    REPLACE_ALTERNATE = 0xB

    # Undefine - the primary volume tag - current tag ignored.
    UNDEFINE_PRIMARY = 0xC

    # Undefine - the alternate volume tag - current tag ignored.
    UNDEFINE_ALTERNATE = 0xD

    # Changer diagnostic test related definitions
    class _CHANGER_DEVICE_PROBLEM_TYPE(ENUM):
        DeviceProblemNone = 1
        DeviceProblemHardware = 2
        DeviceProblemCHMError = 3
        DeviceProblemDoorOpen = 4
        DeviceProblemCalibrationError = 5
        DeviceProblemTargetFailure = 6
        DeviceProblemCHMMoveError = 7
        DeviceProblemCHMZeroError = 8
        DeviceProblemCartridgeInsertError = 9
        DeviceProblemPositionError = 10
        DeviceProblemSensorError = 11
        DeviceProblemCartridgeEjectError = 12
        DeviceProblemGripperError = 13
        DeviceProblemDriveError = 14

    CHANGER_DEVICE_PROBLEM_TYPE = _CHANGER_DEVICE_PROBLEM_TYPE
    PCHANGER_DEVICE_PROBLEM_TYPE = POINTER(_CHANGER_DEVICE_PROBLEM_TYPE)
    IOCTL_SERIAL_LSRMST_INSERT = CTL_CODE(FILE_DEVICE_SERIAL_PORT,31,METHOD_BUFFERED,FILE_ANY_ACCESS)

    IOCTL_SERENUM_EXPOSE_HARDWARE = CTL_CODE(FILE_DEVICE_SERENUM,128,METHOD_BUFFERED,FILE_ANY_ACCESS)
    IOCTL_SERENUM_REMOVE_HARDWARE = CTL_CODE(FILE_DEVICE_SERENUM,129,METHOD_BUFFERED,FILE_ANY_ACCESS)
    IOCTL_SERENUM_PORT_DESC = CTL_CODE(FILE_DEVICE_SERENUM,130,METHOD_BUFFERED,FILE_ANY_ACCESS)
    IOCTL_SERENUM_GET_PORT_NAME = CTL_CODE(FILE_DEVICE_SERENUM,131,METHOD_BUFFERED,FILE_ANY_ACCESS)

    # The following values follow the escape designator in the
    # data stream if the LSRMST_INSERT mode has been turned on.
    SERIAL_LSRMST_ESCAPE = 0x00

    # Following this value is the contents of the line status
    # register, and then the character in the RX hardware when
    # the line status register was encountered.
    SERIAL_LSRMST_LSR_DATA = 0x01

    # Following this value is the contents of the line status
    # register. No error character follows
    SERIAL_LSRMST_LSR_NODATA = 0x02

    # Following this value is the contents of the modem status
    # register.
    SERIAL_LSRMST_MST = 0x03

    # Bit values for FIFO Control Register
    SERIAL_IOC_FCR_FIFO_ENABLE = 0x00000001
    SERIAL_IOC_FCR_RCVR_RESET = 0x00000002
    SERIAL_IOC_FCR_XMIT_RESET = 0x00000004
    SERIAL_IOC_FCR_DMA_MODE = 0x00000008
    SERIAL_IOC_FCR_RES1 = 0x00000010
    SERIAL_IOC_FCR_RES2 = 0x00000020
    SERIAL_IOC_FCR_RCVR_TRIGGER_LSB = 0x00000040
    SERIAL_IOC_FCR_RCVR_TRIGGER_MSB = 0x00000080

    # Bit values for Modem Control Register
    SERIAL_IOC_MCR_DTR = 0x00000001
    SERIAL_IOC_MCR_RTS = 0x00000002
    SERIAL_IOC_MCR_OUT1 = 0x00000004
    SERIAL_IOC_MCR_OUT2 = 0x00000008
    SERIAL_IOC_MCR_LOOP = 0x00000010
    if not defined(_FILESYSTEMFSCTL_):
        _FILESYSTEMFSCTL_ = VOID

        # The following is a list of the native file system fsctls followed by
        # additional network file system fsctls. Some values have been
        # decommissioned.
        FSCTL_REQUEST_OPLOCK_LEVEL_1 = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            0,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
            ),
        )
        FSCTL_REQUEST_OPLOCK_LEVEL_2 = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            1,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
            ),
        )
        FSCTL_REQUEST_BATCH_OPLOCK = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            2,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
            ),
        )
        FSCTL_OPLOCK_BREAK_ACKNOWLEDGE = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            3,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
            ),
        )
        FSCTL_OPBATCH_ACK_CLOSE_PENDING = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            4,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
            ),
        )
        FSCTL_OPLOCK_BREAK_NOTIFY = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            5,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
            ),
        )
        FSCTL_LOCK_VOLUME = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            6,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
            ),
        )
        FSCTL_UNLOCK_VOLUME = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            7,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
            ),
        )
        FSCTL_DISMOUNT_VOLUME = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            8,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
            ),
        )

        # decommissioned fsctl value        9
        FSCTL_IS_VOLUME_MOUNTED = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            10,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
            ),
        )

        # PATHNAME_BUFFER,
        FSCTL_IS_PATHNAME_VALID = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            11,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
            ),
        )
        FSCTL_MARK_VOLUME_DIRTY = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            12,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
            ),
        )

        # decommissioned fsctl value        13
        FSCTL_QUERY_RETRIEVAL_POINTERS = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            14,
            METHOD_NEITHER,
            FILE_ANY_ACCESS,
            ),
        )
        FSCTL_GET_COMPRESSION = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            15,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
            ),
        )
        FSCTL_SET_COMPRESSION = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            16,
            METHOD_BUFFERED,
            FILE_READ_DATA |
            FILE_WRITE_DATA,
            ),
        )

        # decommissioned fsctl value        17
        # decommissioned fsctl value        18
        FSCTL_SET_BOOTLOADER_ACCESSED = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            19,
            METHOD_NEITHER,
            FILE_ANY_ACCESS,
            ),
        )
        FSCTL_MARK_AS_SYSTEM_HIVE = FSCTL_SET_BOOTLOADER_ACCESSED
        FSCTL_OPLOCK_BREAK_ACK_NO_2 = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            20,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
            ),
        )
        FSCTL_INVALIDATE_VOLUMES = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            21,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
            ),
        )

        # FSCTL_QUERY_FAT_BPB_BUFFER
        FSCTL_QUERY_FAT_BPB = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            22,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
            ),
        )
        FSCTL_REQUEST_FILTER_OPLOCK = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            23,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
            ),
        )

        # FILESYSTEM_STATISTICS
        FSCTL_FILESYSTEM_GET_STATISTICS = CTL_CODE(
            (
            FILE_DEVICE_FILE_SYSTEM,
            24,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
            ),
        )
        if _WIN32_WINNT  >= _WIN32_WINNT_NT4:
            # NTFS_VOLUME_DATA_BUFFER
            FSCTL_GET_NTFS_VOLUME_DATA = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                25,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # NTFS_FILE_RECORD_INPUT_BUFFER, NTFS_FILE_RECORD_OUTPUT_BUFFER
            FSCTL_GET_NTFS_FILE_RECORD = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                26,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # STARTING_LCN_INPUT_BUFFER, VOLUME_BITMAP_BUFFER
            FSCTL_GET_VOLUME_BITMAP = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                27,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )

            # STARTING_VCN_INPUT_BUFFER, RETRIEVAL_POINTERS_BUFFER
            FSCTL_GET_RETRIEVAL_POINTERS = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                28,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )

            # MOVE_FILE_DATA,
            FSCTL_MOVE_FILE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                29,
                METHOD_BUFFERED,
                FILE_SPECIAL_ACCESS,
                ),
            )
            FSCTL_IS_VOLUME_DIRTY = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                30,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # decommissioned fsctl value        31
            FSCTL_ALLOW_EXTENDED_DASD_IO = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                32,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_NT4

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN2K:
            # decommissioned fsctl value        33
            # decommissioned fsctl value        34
            FSCTL_FIND_FILES_BY_SID = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                35,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )

            # decommissioned fsctl value        36
            # decommissioned fsctl value        37
            # FILE_OBJECTID_BUFFER
            FSCTL_SET_OBJECT_ID = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                38,
                METHOD_BUFFERED,
                FILE_SPECIAL_ACCESS,
                ),
            )

            # FILE_OBJECTID_BUFFER
            FSCTL_GET_OBJECT_ID = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                39,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_DELETE_OBJECT_ID = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                40,
                METHOD_BUFFERED,
                FILE_SPECIAL_ACCESS,
                ),
            )

            # REPARSE_DATA_BUFFER,
            FSCTL_SET_REPARSE_POINT = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                41,
                METHOD_BUFFERED,
                FILE_SPECIAL_ACCESS,
                ),
            )

            # REPARSE_DATA_BUFFER
            FSCTL_GET_REPARSE_POINT = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                42,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # REPARSE_DATA_BUFFER,
            FSCTL_DELETE_REPARSE_POINT = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                43,
                METHOD_BUFFERED,
                FILE_SPECIAL_ACCESS,
                ),
            )

            # MFT_ENUM_DATA,
            FSCTL_ENUM_USN_DATA = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                44,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )

            # BULK_SECURITY_TEST_DATA,
            FSCTL_SECURITY_ID_CHECK = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                45,
                METHOD_NEITHER,
                FILE_READ_DATA,
                ),
            )

            # READ_USN_JOURNAL_DATA, USN
            FSCTL_READ_USN_JOURNAL = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                46,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_SET_OBJECT_ID_EXTENDED = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                47,
                METHOD_BUFFERED,
                FILE_SPECIAL_ACCESS,
                ),
            )

            # FILE_OBJECTID_BUFFER
            FSCTL_CREATE_OR_GET_OBJECT_ID = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                48,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_SET_SPARSE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                49,
                METHOD_BUFFERED,
                FILE_SPECIAL_ACCESS,
                ),
            )

            # FILE_ZERO_DATA_INFORMATION,
            FSCTL_SET_ZERO_DATA = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                50,
                METHOD_BUFFERED,
                FILE_WRITE_DATA,
                ),
            )

            # FILE_ALLOCATED_RANGE_BUFFER, FILE_ALLOCATED_RANGE_BUFFER
            FSCTL_QUERY_ALLOCATED_RANGES = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                51,
                METHOD_NEITHER,
                FILE_READ_DATA,
                ),
            )
            FSCTL_ENABLE_UPGRADE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                52,
                METHOD_BUFFERED,
                FILE_WRITE_DATA,
                ),
            )

            # ENCRYPTION_BUFFER, DECRYPTION_STATUS_BUFFER
            FSCTL_SET_ENCRYPTION = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                53,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_ENCRYPTION_FSCTL_IO = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                54,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )

            # ENCRYPTED_DATA_INFO, EXTENDED_ENCRYPTED_DATA_INFO
            FSCTL_WRITE_RAW_ENCRYPTED = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                55,
                METHOD_NEITHER,
                FILE_SPECIAL_ACCESS,
                ),
            )

            # REQUEST_RAW_ENCRYPTED_DATA, ENCRYPTED_DATA_INFO,
            # EXTENDED_ENCRYPTED_DATA_INFO
            FSCTL_READ_RAW_ENCRYPTED = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                56,
                METHOD_NEITHER,
                FILE_SPECIAL_ACCESS,
                ),
            )

            # CREATE_USN_JOURNAL_DATA,
            FSCTL_CREATE_USN_JOURNAL = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                57,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )

            # Read the Usn Record for a file
            FSCTL_READ_FILE_USN_DATA = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                58,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )

            # Generate Close Usn Record
            FSCTL_WRITE_USN_CLOSE_RECORD = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                59,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_EXTEND_VOLUME = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                60,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_QUERY_USN_JOURNAL = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                61,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_DELETE_USN_JOURNAL = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                62,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_MARK_HANDLE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                63,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_SIS_COPYFILE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                64,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_SIS_LINK_FILES = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                65,
                METHOD_BUFFERED,
                FILE_READ_DATA |
                FILE_WRITE_DATA,
                ),
            )

            # decommissional fsctl value        66
            # decommissioned fsctl value        67
            # decommissioned fsctl value        68
            FSCTL_RECALL_FILE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                69,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )

            # decommissioned fsctl value        70
            FSCTL_READ_FROM_PLEX = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                71,
                METHOD_OUT_DIRECT,
                FILE_READ_DATA,
                ),
            )

            # FILE_PREFETCH
            FSCTL_FILE_PREFETCH = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                72,
                METHOD_BUFFERED,
                FILE_SPECIAL_ACCESS,
                ),
            )
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN2K

        if _WIN32_WINNT  >= _WIN32_WINNT_VISTA:
            # UDFS R/W
            FSCTL_MAKE_MEDIA_COMPATIBLE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                76,
                METHOD_BUFFERED,
                FILE_WRITE_DATA,
                ),
            )

            # UDFS R/W
            FSCTL_SET_DEFECT_MANAGEMENT = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                77,
                METHOD_BUFFERED,
                FILE_WRITE_DATA,
                ),
            )

            # UDFS R/W
            FSCTL_QUERY_SPARING_INFO = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                78,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # C/UDFS
            FSCTL_QUERY_ON_DISK_VOLUME_INFO = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                79,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # VOLUME_COMPRESSION_STATE
            FSCTL_SET_VOLUME_COMPRESSION_STATE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                80,
                METHOD_BUFFERED,
                FILE_SPECIAL_ACCESS,
                ),
            )

            # decommissioned fsctl value         80
            # TxF
            FSCTL_TXFS_MODIFY_RM = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                81,
                METHOD_BUFFERED,
                FILE_WRITE_DATA,
                ),
            )

            # TxF
            FSCTL_TXFS_QUERY_RM_INFORMATION = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                82,
                METHOD_BUFFERED,
                FILE_READ_DATA,
                ),
            )

            # decommissioned fsctl value         83
            # TxF
            FSCTL_TXFS_ROLLFORWARD_REDO = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                84,
                METHOD_BUFFERED,
                FILE_WRITE_DATA,
                ),
            )

            # TxF
            FSCTL_TXFS_ROLLFORWARD_UNDO = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                85,
                METHOD_BUFFERED,
                FILE_WRITE_DATA,
                ),
            )

            # TxF
            FSCTL_TXFS_START_RM = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                86,
                METHOD_BUFFERED,
                FILE_WRITE_DATA,
                ),
            )

            # TxF
            FSCTL_TXFS_SHUTDOWN_RM = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                87,
                METHOD_BUFFERED,
                FILE_WRITE_DATA,
                ),
            )

            # TxF
            FSCTL_TXFS_READ_BACKUP_INFORMATION = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                88,
                METHOD_BUFFERED,
                FILE_READ_DATA,
                ),
            )

            # TxF
            FSCTL_TXFS_WRITE_BACKUP_INFORMATION = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                89,
                METHOD_BUFFERED,
                FILE_WRITE_DATA,
                ),
            )

            # TxF
            FSCTL_TXFS_CREATE_SECONDARY_RM = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                90,
                METHOD_BUFFERED,
                FILE_WRITE_DATA,
                ),
            )

            # TxF
            FSCTL_TXFS_GET_METADATA_INFO = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                91,
                METHOD_BUFFERED,
                FILE_READ_DATA,
                ),
            )

            # TxF
            FSCTL_TXFS_GET_TRANSACTED_VERSION = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                92,
                METHOD_BUFFERED,
                FILE_READ_DATA,
                ),
            )

            # decommissioned fsctl value         93
            # TxF
            FSCTL_TXFS_SAVEPOINT_INFORMATION = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                94,
                METHOD_BUFFERED,
                FILE_WRITE_DATA,
                ),
            )

            # TxF
            FSCTL_TXFS_CREATE_MINIVERSION = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                95,
                METHOD_BUFFERED,
                FILE_WRITE_DATA,
                ),
            )

            # decommissioned fsctl value         96
            # decommissioned fsctl value         97
            # decommissioned fsctl value         98
            # TxF
            FSCTL_TXFS_TRANSACTION_ACTIVE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                99,
                METHOD_BUFFERED,
                FILE_READ_DATA,
                ),
            )
            FSCTL_SET_ZERO_ON_DEALLOCATION = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                101,
                METHOD_BUFFERED,
                FILE_SPECIAL_ACCESS,
                ),
            )
            FSCTL_SET_REPAIR = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                102,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_GET_REPAIR = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                103,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_WAIT_FOR_REPAIR = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                104,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # decommissioned fsctl value         105
            FSCTL_INITIATE_REPAIR = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                106,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # CSC internal implementation
            FSCTL_CSC_INTERNAL = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                107,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )

            # SHRINK_VOLUME_INFORMATION
            FSCTL_SHRINK_VOLUME = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                108,
                METHOD_BUFFERED,
                FILE_SPECIAL_ACCESS,
                ),
            )
            FSCTL_SET_SHORT_NAME_BEHAVIOR = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                109,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_DFSR_SET_GHOST_HANDLE_STATE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                110,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # Values 111 - 119 are reserved for FSRM.
            # TxF
            FSCTL_TXFS_LIST_TRANSACTION_LOCKED_FILES = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                120,
                METHOD_BUFFERED,
                FILE_READ_DATA,
                ),
            )

            # TxF
            FSCTL_TXFS_LIST_TRANSACTIONS = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                121,
                METHOD_BUFFERED,
                FILE_READ_DATA,
                ),
            )
            FSCTL_QUERY_PAGEFILE_ENCRYPTION = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                122,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_VISTA

        if _WIN32_WINNT  >= _WIN32_WINNT_VISTA:
            FSCTL_RESET_VOLUME_ALLOCATION_HINTS = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                123,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_VISTA

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN7:
            # Dependency File System Filter
            FSCTL_QUERY_DEPENDENT_VOLUME = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                124,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # Query/Change NTFS Security Descriptors
            FSCTL_SD_GLOBAL_CHANGE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                125,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN7

        if _WIN32_WINNT  >= _WIN32_WINNT_VISTA:
            # TxF
            FSCTL_TXFS_READ_BACKUP_INFORMATION2 = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                126,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_VISTA

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN7:
            FSCTL_LOOKUP_STREAM_FROM_CLUSTER = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                127,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # TxF
            FSCTL_TXFS_WRITE_BACKUP_INFORMATION2 = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                128,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_FILE_TYPE_NOTIFICATION = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                129,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF


        if _WIN32_WINNT  >= _WIN32_WINNT_WIN8:
            FSCTL_FILE_LEVEL_TRIM = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                130,
                METHOD_BUFFERED,
                FILE_WRITE_DATA,
                ),
            )
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN8

        # Values 131 - 139 are reserved for FSRM.
        if _WIN32_WINNT  >= _WIN32_WINNT_WIN7:
            # BOOT_AREA_INFO
            FSCTL_GET_BOOT_AREA_INFO = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                140,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # RETRIEVAL_POINTER_BASE
            FSCTL_GET_RETRIEVAL_POINTER_BASE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                141,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # FILE_FS_PERSISTENT_VOLUME_INFORMATION
            FSCTL_SET_PERSISTENT_VOLUME_STATE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                142,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # FILE_FS_PERSISTENT_VOLUME_INFORMATION
            FSCTL_QUERY_PERSISTENT_VOLUME_STATE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                143,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_REQUEST_OPLOCK = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                144,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # CSV_TUNNEL_REQUEST
            FSCTL_CSV_TUNNEL_REQUEST = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                145,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # IS_CSV_FILE
            FSCTL_IS_CSV_FILE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                146,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_QUERY_FILE_SYSTEM_RECOGNITION = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                147,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_CSV_GET_VOLUME_PATH_NAME = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                148,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_CSV_GET_VOLUME_NAME_FOR_VOLUME_MOUNT_POINT = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                149,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_CSV_GET_VOLUME_PATH_NAMES_FOR_VOLUME_NAME = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                150,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_IS_FILE_ON_CSV_VOLUME = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                151,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN7

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN8:
            FSCTL_CORRUPTION_HANDLING = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                152,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_OFFLOAD_READ = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                153,
                METHOD_BUFFERED,
                FILE_READ_ACCESS,
                ),
            )
            FSCTL_OFFLOAD_WRITE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                154,
                METHOD_BUFFERED,
                FILE_WRITE_ACCESS,
                ),
            )
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN8

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN7:
            FSCTL_CSV_INTERNAL = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                155,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN7

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN8:
            FSCTL_SET_PURGE_FAILURE_MODE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                156,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_QUERY_FILE_LAYOUT = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                157,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_IS_VOLUME_OWNED_BYCSVFS = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                158,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # FSCTL_GET_INTEGRITY_INFORMATION_BUFFER
            FSCTL_GET_INTEGRITY_INFORMATION = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                159,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # FSCTL_SET_INTEGRITY_INFORMATION_BUFFER
            FSCTL_SET_INTEGRITY_INFORMATION = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                160,
                METHOD_BUFFERED,
                FILE_READ_DATA |
                FILE_WRITE_DATA,
                ),
            )
            FSCTL_QUERY_FILE_REGIONS = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                161,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN8

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN8:
            # Resume Key Filter
            FSCTL_RKF_INTERNAL = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                171,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_SCRUB_DATA = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                172,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_REPAIR_COPIES = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                173,
                METHOD_BUFFERED,
                FILE_READ_DATA |
                FILE_WRITE_DATA,
                ),
            )
            FSCTL_DISABLE_LOCAL_BUFFERING = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                174,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_CSV_MGMT_LOCK = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                175,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_CSV_QUERY_DOWN_LEVEL_FILE_SYSTEM_CHARACTERISTICS = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                176,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_ADVANCE_FILE_ID = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                177,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_CSV_SYNC_TUNNEL_REQUEST = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                178,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_CSV_QUERY_VETO_FILE_DIRECT_IO = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                179,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_WRITE_USN_REASON = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                180,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_CSV_CONTROL = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                181,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_GET_REFS_VOLUME_DATA = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                182,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_CSV_H_BREAKING_SYNC_TUNNEL_REQUEST = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                185,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN8

        if _WIN32_WINNT  >= _WIN32_WINNT_WINBLUE:
            FSCTL_QUERY_STORAGE_CLASSES = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                187,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_QUERY_REGION_INFO = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                188,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # USN_TRACK_MODIFIED_RANGES
            FSCTL_USN_TRACK_MODIFIED_RANGES = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                189,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WINBLUE)

        if _WIN32_WINNT  >= _WIN32_WINNT_WINBLUE:
            FSCTL_QUERY_SHARED_VIRTUAL_DISK_SUPPORT = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                192,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_SVHDX_SYNC_TUNNEL_REQUEST = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                193,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_SVHDX_SET_INITIATOR_INFORMATION = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                194,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WINBLUE)

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN7:
            FSCTL_SET_EXTERNAL_BACKING = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                195,
                METHOD_BUFFERED,
                FILE_SPECIAL_ACCESS,
                ),
            )
            FSCTL_GET_EXTERNAL_BACKING = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                196,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_DELETE_EXTERNAL_BACKING = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                197,
                METHOD_BUFFERED,
                FILE_SPECIAL_ACCESS,
                ),
            )
            FSCTL_ENUM_EXTERNAL_BACKING = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                198,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_ENUM_OVERLAY = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                199,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_ADD_OVERLAY = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                204,
                METHOD_BUFFERED,
                FILE_WRITE_DATA,
                ),
            )
            FSCTL_REMOVE_OVERLAY = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                205,
                METHOD_BUFFERED,
                FILE_WRITE_DATA,
                ),
            )
            FSCTL_UPDATE_OVERLAY = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                206,
                METHOD_BUFFERED,
                FILE_WRITE_DATA,
                ),
            )
        # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WIN7)

        if _WIN32_WINNT  >= _WIN32_WINNT_WINBLUE:
            FSCTL_DUPLICATE_EXTENTS_TO_FILE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                209,
                METHOD_BUFFERED,
                FILE_WRITE_DATA,
                ),
            )
        # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WINBLUE)

        if _WIN32_WINNT  >= _WIN32_WINNT_WINBLUE:
            FSCTL_SPARSE_OVERALLOCATE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                211,
                METHOD_BUFFERED,
                FILE_SPECIAL_ACCESS,
                ),
            )
            FSCTL_STORAGE_QOS_CONTROL = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                212,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WINBLUE)

        if _WIN32_WINNT  >= _WIN32_WINNT_WINTHRESHOLD:
            FSCTL_INITIATE_FILE_METADATA_OPTIMIZATION = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                215,
                METHOD_BUFFERED,
                FILE_SPECIAL_ACCESS,
                ),
            )
            FSCTL_QUERY_FILE_METADATA_OPTIMIZATION = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                216,
                METHOD_BUFFERED,
                FILE_SPECIAL_ACCESS,
                ),
            )
        # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WINTHRESHOLD)

        if _WIN32_WINNT  >= _WIN32_WINNT_WINBLUE:
            FSCTL_SVHDX_ASYNC_TUNNEL_REQUEST = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                217,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WINBLUE)

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN7:
            FSCTL_GET_WOF_VERSION = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                218,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF


        if _WIN32_WINNT  >= _WIN32_WINNT_WINTHRESHOLD:
            FSCTL_HCS_SYNC_TUNNEL_REQUEST = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                219,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_HCS_ASYNC_TUNNEL_REQUEST = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                220,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # VCN_RANGE_INPUT_BUFFER, EXTENT_READ_CACHE_INFO_BUFFER
            FSCTL_QUERY_EXTENT_READ_CACHE_INFO = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                221,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )

            # REFS_VOLUME_COUNTER_INFO_INPUT_BUFFER, VOLUME_REFS_INFO_BUFFER
            FSCTL_QUERY_REFS_VOLUME_COUNTER_INFO = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                222,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_CLEAN_VOLUME_METADATA = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                223,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX
            FSCTL_SET_INTEGRITY_INFORMATION_EX = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                224,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WINTHRESHOLD)

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN7:
            FSCTL_SUSPEND_OVERLAY = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                225,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF


        if _WIN32_WINNT  >= _WIN32_WINNT_WINTHRESHOLD:
            FSCTL_VIRTUAL_STORAGE_QUERY_PROPERTY = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                226,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # FILESYSTEM_STATISTICS_EX
            FSCTL_FILESYSTEM_GET_STATISTICS_EX = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                227,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_QUERY_VOLUME_CONTAINER_STATE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                228,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # CONTAINER_ROOT_INFO_INPUT CONTAINER_ROOT_INFO_OUTPUT
            FSCTL_SET_LAYER_ROOT = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                229,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF


        if _WIN32_WINNT  >= _WIN32_WINNT_WIN10_TH2:
            FSCTL_QUERY_DIRECT_ACCESS_EXTENTS = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                230,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_NOTIFY_STORAGE_SPACE_ALLOCATION = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                231,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_SSDI_STORAGE_REQUEST = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                232,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF


        if _WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS1:
            FSCTL_QUERY_DIRECT_IMAGE_ORIGINAL_BASE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                233,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # READ_USN_JOURNAL_DATA, USN
            FSCTL_READ_UNPRIVILEGED_USN_JOURNAL = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                234,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF


        if _WIN32_WINNT  >= _WIN32_WINNT_WIN10_TH2:
            # FSCTL_GHOST_FILE_EXTENTS_INPUT_BUFFER
            FSCTL_GHOST_FILE_EXTENTS = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                235,
                METHOD_BUFFERED,
                FILE_WRITE_ACCESS,
                ),
            )
            FSCTL_QUERY_GHOSTED_FILE_EXTENTS = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                236,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF


        if _WIN32_WINNT  >= _WIN32_WINNT_WIN10_TH2:
            FSCTL_UNMAP_SPACE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                237,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF


        if _WIN32_WINNT  >= _WIN32_WINNT_WINTHRESHOLD:
            FSCTL_HCS_SYNC_NO_WRITE_TUNNEL_REQUEST = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                238,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF


        if _WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS2:
            FSCTL_STREAMS_QUERY_PARAMETERS = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                241,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_STREAMS_ASSOCIATE_ID = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                242,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_STREAMS_QUERY_ID = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                243,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )

            # STARTING_VCN_INPUT_BUFFER, RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER
            FSCTL_GET_RETRIEVAL_POINTERS_AND_REFCOUNT = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                244,
                METHOD_NEITHER,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_QUERY_VOLUME_NUMA_INFO = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                245,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF


        if _WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS2:
            FSCTL_REFS_DEALLOCATE_RANGES = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                246,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF


        if _WIN32_WINNT  >= _WIN32_WINNT_WIN10_TH2:
            FSCTL_QUERY_REFS_SMR_VOLUME_INFO = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                247,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_SET_REFS_SMR_VOLUME_GC_PARAMETERS = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                248,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_SET_REFS_FILE_STRICTLY_SEQUENTIAL = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                249,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF


        if _WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS3:
            FSCTL_DUPLICATE_EXTENTS_TO_FILE_EX = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                250,
                METHOD_BUFFERED,
                FILE_WRITE_DATA,
                ),
            )
            FSCTL_QUERY_BAD_RANGES = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                251,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_SET_DAX_ALLOC_ALIGNMENT_HINT = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                252,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_DELETE_CORRUPTED_REFS_CONTAINER = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                253,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_SCRUB_UNDISCOVERABLE_ID = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                254,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS3)

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS4:
            FSCTL_NOTIFY_DATA_CHANGE = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                255,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS4)

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS1:
            FSCTL_START_VIRTUALIZATION_INSTANCE_EX = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                256,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS1)

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS4:
            # protect/unprotect under DPL
            FSCTL_ENCRYPTION_KEY_CONTROL = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                257,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
            FSCTL_VIRTUAL_STORAGE_SET_BEHAVIOR = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                258,
                METHOD_BUFFERED,
                FILE_ANY_ACCESS,
                ),
            )
        # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS4)

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS1:
            # REPARSE_DATA_BUFFER_EX
            FSCTL_SET_REPARSE_POINT_EX = CTL_CODE(
                (
                FILE_DEVICE_FILE_SYSTEM,
                259,
                METHOD_BUFFERED,
                FILE_SPECIAL_ACCESS,
                ),
            )
        # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS1)

        # AVIO IOCTLS.
        IOCTL_AVIO_ALLOCATE_STREAM = CTL_CODE(
            (
            FILE_DEVICE_AVIO,
            1,
            METHOD_BUFFERED,
            FILE_SPECIAL_ACCESS,
            ),
        )
        IOCTL_AVIO_FREE_STREAM = CTL_CODE(
            (
            FILE_DEVICE_AVIO,
            2,
            METHOD_BUFFERED,
            FILE_SPECIAL_ACCESS,
            ),
        )
        IOCTL_AVIO_MODIFY_STREAM = CTL_CODE(
            (
            FILE_DEVICE_AVIO,
            3,
            METHOD_BUFFERED,
            FILE_SPECIAL_ACCESS,
            ),
        )

        # end_ntddk
        # begin_ntifs
        # The following LONG list of structs are associated with the preceeding
        # file system fsctls.
        # == == == == == == == == == == FSCTL_IS_PATHNAME_VALID == == == == ==
        # == == == == == ==
        # Structure for FSCTL_IS_PATHNAME_VALID
        _PATHNAME_BUFFER._fields_ = [
            ('PathNameLength', DWORD),
            ('Name', WCHAR * 1),
        ]


        # == == == == == == == == == == FSCTL_QUERY_BPB_INFO == == == == == ==
        # == == == == ==
        # Structure for FSCTL_QUERY_BPB_INFO
        _FSCTL_QUERY_FAT_BPB_BUFFER._fields_ = [
            ('First0x24BytesOfBootSector', BYTE * 0x24),
        ]
        if _WIN32_WINNT  >= _WIN32_WINNT_NT4:
            # == == == == == == == == == == FSCTL_GET_NTFS_VOLUME_DATA == ==
            # == == == == == == == == ==
            # Structures for FSCTL_GET_NTFS_VOLUME_DATA.
            # The user must pass the basic buffer below. Ntfs
            # will return as many fields as available in the extended
            # buffer which follows immediately after the VOLUME_DATA_BUFFER.
            NTFS_VOLUME_DATA_BUFFER._fields_ = [
                ('VolumeSerialNumber', LARGE_INTEGER),
                ('NumberSectors', LARGE_INTEGER),
                ('TotalClusters', LARGE_INTEGER),
                ('FreeClusters', LARGE_INTEGER),
                ('TotalReserved', LARGE_INTEGER),
                ('BytesPerSector', DWORD),
                ('BytesPerCluster', DWORD),
                ('BytesPerFileRecordSegment', DWORD),
                ('ClustersPerFileRecordSegment', DWORD),
                ('MftValidDataLength', LARGE_INTEGER),
                ('MftStartLcn', LARGE_INTEGER),
                ('Mft2StartLcn', LARGE_INTEGER),
                ('MftZoneStart', LARGE_INTEGER),
                ('MftZoneEnd', LARGE_INTEGER),
            ]

            _TEMP_NTFS_EXTENDED_VOLUME_DATA = [
                ('ByteCount', DWORD),
                ('MajorVersion', WORD),
                ('MinorVersion', WORD),
                ('BytesPerPhysicalSector', DWORD),
                ('LfsMajorVersion', WORD),
                ('LfsMinorVersion', WORD),
            ]
            if _WIN32_WINNT  >= _WIN32_WINNT_WINTHRESHOLD:
                _TEMP_NTFS_EXTENDED_VOLUME_DATA += [
                    ('MaxDeviceTrimExtentCount', DWORD),
                    ('MaxDeviceTrimByteCount', DWORD),
                    ('MaxVolumeTrimExtentCount', DWORD),
                    ('MaxVolumeTrimByteCount', DWORD),
                ]
            # END IF


            NTFS_EXTENDED_VOLUME_DATA._fields_ = _TEMP_NTFS_EXTENDED_VOLUME_DATA
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_NT4


        if _WIN32_WINNT  >= _WIN32_WINNT_WIN8:
            # == == == == == == == == == == FSCTL_GET_REFS_VOLUME_DATA == ==
            # == == == == == == == == ==
            # Structures for FSCTL_GET_REFS_VOLUME_DATA.
            REFS_VOLUME_DATA_BUFFER._fields_ = [
                ('ByteCount', DWORD),
                ('MajorVersion', DWORD),
                ('MinorVersion', DWORD),
                ('BytesPerPhysicalSector', DWORD),
                ('VolumeSerialNumber', LARGE_INTEGER),
                ('NumberSectors', LARGE_INTEGER),
                ('TotalClusters', LARGE_INTEGER),
                ('FreeClusters', LARGE_INTEGER),
                ('TotalReserved', LARGE_INTEGER),
                ('BytesPerSector', DWORD),
                ('BytesPerCluster', DWORD),
                ('MaximumSizeOfResidentFile', LARGE_INTEGER),
                ('Reserved', LARGE_INTEGER * 10),
            ]
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN8

        if _WIN32_WINNT  >= _WIN32_WINNT_NT4:
            # == == == == == == == == == == FSCTL_GET_VOLUME_BITMAP == == ==
            # == == == == == == == ==
            # Structure for FSCTL_GET_VOLUME_BITMAP
            STARTING_LCN_INPUT_BUFFER._fields_ = [
                ('StartingLcn', LARGE_INTEGER),
            ]
            if _WIN32_WINNT  >= _WIN32_WINNT_WINTHRESHOLD:
                GET_VOLUME_BITMAP_FLAG_MASK_METADATA = 0x00000001


                STARTING_LCN_INPUT_BUFFER_EX._fields_ = [
                    ('StartingLcn', LARGE_INTEGER),
                    ('Flags', DWORD),
                ]
            # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WINTHRESHOLD


            VOLUME_BITMAP_BUFFER._fields_ = [
                ('StartingLcn', LARGE_INTEGER),
                ('BitmapSize', LARGE_INTEGER),
                ('Buffer', BYTE * 1),
            ]
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_NT4


        if _WIN32_WINNT  >= _WIN32_WINNT_NT4:
            # == == == == == == == == == == FSCTL_GET_RETRIEVAL_POINTERS == ==
            # == == == == == == == == ==
            # Structure for FSCTL_GET_RETRIEVAL_POINTERS
            STARTING_VCN_INPUT_BUFFER._fields_ = [
                ('StartingVcn', LARGE_INTEGER),
            ]


            class Extents(ctypes.Structure):
                pass


            Extents._fields_ = [
                ('NextVcn', LARGE_INTEGER),
                ('Lcn', LARGE_INTEGER),
            ]
            RETRIEVAL_POINTERS_BUFFER.Extents = Extents


            RETRIEVAL_POINTERS_BUFFER._fields_ = [
                ('ExtentCount', DWORD),
                ('StartingVcn', LARGE_INTEGER),
                ('Extents', RETRIEVAL_POINTERS_BUFFER.Extents * 1),
            ]
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_NT4

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS2:
            # == == == == == == == == == ==
            # FSCTL_GET_RETRIEVAL_POINTERS_AND_REFCOUNT ==
            # Structure for FSCTL_GET_RETRIEVAL_POINTERS_AND_REFCOUNT
            # Input structure is STARTING_VCN_INPUT_BUFFER
            class Extents(ctypes.Structure):
                pass


            Extents._fields_ = [
                ('NextVcn', LARGE_INTEGER),
                ('Lcn', LARGE_INTEGER),
                ('ReferenceCount', DWORD),
            ]
            RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER.Extents = Extents


            RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER._fields_ = [
                ('ExtentCount', DWORD),
                ('StartingVcn', LARGE_INTEGER),
                ('Extents', RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER.Extents * 1),
            ]
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS2


        if _WIN32_WINNT  >= _WIN32_WINNT_NT4:
            # == == == == == == == == == == FSCTL_GET_NTFS_FILE_RECORD == ==
            # == == == == == == == == ==
            # Structures for FSCTL_GET_NTFS_FILE_RECORD
            NTFS_FILE_RECORD_INPUT_BUFFER._fields_ = [
                ('FileReferenceNumber', LARGE_INTEGER),
            ]

            NTFS_FILE_RECORD_OUTPUT_BUFFER._fields_ = [
                ('FileReferenceNumber', LARGE_INTEGER),
                ('FileRecordLength', DWORD),
                ('FileRecordBuffer', BYTE * 1),
            ]
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_NT4

        if _WIN32_WINNT  >= _WIN32_WINNT_NT4:
            # == == == == == == == == == == FSCTL_MOVE_FILE == == == == == ==
            # == == == == ==
            # Structure for FSCTL_MOVE_FILE
            MOVE_FILE_DATA._fields_ = [
                ('FileHandle', HANDLE),
                ('StartingVcn', LARGE_INTEGER),
                ('StartingLcn', LARGE_INTEGER),
                ('ClusterCount', DWORD),
            ]

            MOVE_FILE_RECORD_DATA._fields_ = [
                ('FileHandle', HANDLE),
                ('SourceFileRecord', LARGE_INTEGER),
                ('TargetFileRecord', LARGE_INTEGER),
            ]

            if defined(_WIN64):
                # 32/64 Bit thunking support structure
                _MOVE_FILE_DATA32._fields_ = [
                    ('FileHandle', UINT32),
                    ('StartingVcn', LARGE_INTEGER),
                    ('StartingLcn', LARGE_INTEGER),
                    ('ClusterCount', DWORD),
                ]
            # END IF

        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_NT4


        if _WIN32_WINNT  >= _WIN32_WINNT_WIN2K:
            # == == == == == == == == == == FSCTL_FIND_FILES_BY_SID == == ==
            # == == == == == == == ==
            # Structures for FSCTL_FIND_FILES_BY_SID
            FIND_BY_SID_DATA._fields_ = [
                ('Restart', DWORD),
                ('Sid', SID),
            ]

            FIND_BY_SID_OUTPUT._fields_ = [
                ('NextEntryOffset', DWORD),
                ('FileIndex', DWORD),
                ('FileNameLength', DWORD),
                ('FileName', WCHAR * 1),
            ]
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN2K

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN2K:
            # The following structures apply to Usn operations.
            # == == == == == == == == == == FSCTL_ENUM_USN_DATA == == == == ==
            # == == == == == ==
            # Structure for FSCTL_ENUM_USN_DATA
            MFT_ENUM_DATA_V0._fields_ = [
                ('StartFileReferenceNumber', DWORDLONG),
                ('LowUsn', USN),
                ('HighUsn', USN),
            ]

            MFT_ENUM_DATA_V1._fields_ = [
                ('StartFileReferenceNumber', DWORDLONG),
                ('LowUsn', USN),
                ('HighUsn', USN),
                ('MinMajorVersion', WORD),
                ('MaxMajorVersion', WORD),
            ]
            if NTDDI_VERSION  >= NTDDI_WIN8:
                MFT_ENUM_DATA = MFT_ENUM_DATA_V1
                PMFT_ENUM_DATA = POINTER(MFT_ENUM_DATA_V1)
            else:
                MFT_ENUM_DATA = MFT_ENUM_DATA_V0
                PMFT_ENUM_DATA = POINTER(MFT_ENUM_DATA_V0)

            # == == == == == == == == == == FSCTL_CREATE_USN_JOURNAL == == ==
            # == == == == == == == ==
            # Structure for FSCTL_CREATE_USN_JOURNAL
            CREATE_USN_JOURNAL_DATA._fields_ = [
                ('MaximumSize', DWORDLONG),
                ('AllocationDelta', DWORDLONG),
            ]

            # == == == == == == == == == == FSCTL_READ_FILE_USN_DATA == == ==
            # == == == == == == ==
            # Structure for FSCTL_READ_FILE_USN_DATA
            # Windows 7 and earlier releases did not use an input buffer
            # for this FSCTL. It is valid to omit this, and doing so
            # will default to MinMajorVersion == 2, MaxMajorVersion == 2.
            READ_FILE_USN_DATA._fields_ = [
                ('MinMajorVersion', WORD),
                ('MaxMajorVersion', WORD),
            ]


            # == == == == == == == == == == FSCTL_READ_USN_JOURNAL == == == ==
            # == == == == == == ==
            # Structure for FSCTL_READ_USN_JOURNAL
            READ_USN_JOURNAL_DATA_V0._fields_ = [
                ('StartUsn', USN),
                ('ReasonMask', DWORD),
                ('ReturnOnlyOnClose', DWORD),
                ('Timeout', DWORDLONG),
                ('BytesToWaitFor', DWORDLONG),
                ('UsnJournalID', DWORDLONG),
            ]

            READ_USN_JOURNAL_DATA_V1._fields_ = [
                ('StartUsn', USN),
                ('ReasonMask', DWORD),
                ('ReturnOnlyOnClose', DWORD),
                ('Timeout', DWORDLONG),
                ('BytesToWaitFor', DWORDLONG),
                ('UsnJournalID', DWORDLONG),
                ('MinMajorVersion', WORD),
                ('MaxMajorVersion', WORD),
            ]
            if NTDDI_VERSION >= NTDDI_WIN8:
                READ_USN_JOURNAL_DATA = READ_USN_JOURNAL_DATA_V1
                PREAD_USN_JOURNAL_DATA = POINTER(READ_USN_JOURNAL_DATA_V1)
            else:

                READ_USN_JOURNAL_DATA = READ_USN_JOURNAL_DATA_V0
                PREAD_USN_JOURNAL_DATA = POINTER(READ_USN_JOURNAL_DATA_V0)
            # END IF
            # == == == == == == == == == == FSCTL_USN_TRACK_MODIFIED_RANGES ==
            # == == == == == == == == == ==
            # Structure for FSCTL_USN_TRACK_MODIFIED_RANGES
            USN_TRACK_MODIFIED_RANGES._fields_ = [
                ('Flags', DWORD),
                ('Unused', DWORD),
                ('ChunkSize', DWORDLONG),
                ('FileSizeThreshold', LONGLONG),
            ]

            USN_RANGE_TRACK_OUTPUT._fields_ = [
                ('Usn', USN),
            ]
            FLAG_USN_TRACK_MODIFIED_RANGES_ENABLE = 0x00000001


            # The initial Major.Minor version of the Usn record will be 2.0.
            # In general, the MinorVersion may be changed if fields are added
            # to this structure in such a way that the previous version of the
            # software can still correctly the fields it knows about. The
            # MajorVersion should only be changed if the previous version of
            # any software using this structure would incorrectly handle new
            # records due to structure changes.
            # The first update to this will force the structure to version 2.0.
            # This will add the extended information about the source as
            # well as indicate the file name offset within the structure.
            # The following structure is returned with these fsctls.
            # FSCTL_READ_USN_JOURNAL
            # FSCTL_READ_FILE_USN_DATA
            # FSCTL_ENUM_USN_DATA
            USN_RECORD_V2._fields_ = [
                ('RecordLength', DWORD),
                ('MajorVersion', WORD),
                ('MinorVersion', WORD),
                ('FileReferenceNumber', DWORDLONG),
                ('ParentFileReferenceNumber', DWORDLONG),
                ('Usn', USN),
                ('TimeStamp', LARGE_INTEGER),
                ('Reason', DWORD),
                ('SourceInfo', DWORD),
                ('SecurityId', DWORD),
                ('FileAttributes', DWORD),
                ('FileNameLength', WORD),
                ('FileNameOffset', WORD),
                ('FileName', WCHAR * 1),
            ]

            USN_RECORD_V3._fields_ = [
                ('RecordLength', DWORD),
                ('MajorVersion', WORD),
                ('MinorVersion', WORD),
                ('FileReferenceNumber', FILE_ID_128),
                ('ParentFileReferenceNumber', FILE_ID_128),
                ('Usn', USN),
                ('TimeStamp', LARGE_INTEGER),
                ('Reason', DWORD),
                ('SourceInfo', DWORD),
                ('SecurityId', DWORD),
                ('FileAttributes', DWORD),
                ('FileNameLength', WORD),
                ('FileNameOffset', WORD),
                ('FileName', WCHAR * 1),
            ]
            # TYPEDEF ERROR: 1USN_RECORD_V2 USN_RECORD, *PUSN_RECORD;
            USN_RECORD_COMMON_HEADER._fields_ = [
                ('RecordLength', DWORD),
                ('MajorVersion', WORD),
                ('MinorVersion', WORD),
            ]

            USN_RECORD_EXTENT._fields_ = [
                ('Offset', LONGLONG),
                ('Length', LONGLONG),
            ]

            USN_RECORD_V4._fields_ = [
                ('Header', USN_RECORD_COMMON_HEADER),
                ('FileReferenceNumber', FILE_ID_128),
                ('ParentFileReferenceNumber', FILE_ID_128),
                ('Usn', USN),
                ('Reason', DWORD),
                ('SourceInfo', DWORD),
                ('RemainingExtents', DWORD),
                ('NumberOfExtents', WORD),
                ('ExtentSize', WORD),
                ('Extents', USN_RECORD_EXTENT * 1),
            ]

            USN_RECORD_UNION._fields_ = [
                ('Header', USN_RECORD_COMMON_HEADER),
                ('V2', USN_RECORD_V2),
                ('V3', USN_RECORD_V3),
                ('V4', USN_RECORD_V4),
            ]
            USN_PAGE_SIZE = 0x1000
            USN_REASON_DATA_OVERWRITE = 0x00000001
            USN_REASON_DATA_EXTEND = 0x00000002
            USN_REASON_DATA_TRUNCATION = 0x00000004
            USN_REASON_NAMED_DATA_OVERWRITE = 0x00000010
            USN_REASON_NAMED_DATA_EXTEND = 0x00000020
            USN_REASON_NAMED_DATA_TRUNCATION = 0x00000040
            USN_REASON_FILE_CREATE = 0x00000100
            USN_REASON_FILE_DELETE = 0x00000200
            USN_REASON_EA_CHANGE = 0x00000400
            USN_REASON_SECURITY_CHANGE = 0x00000800
            USN_REASON_RENAME_OLD_NAME = 0x00001000
            USN_REASON_RENAME_NEW_NAME = 0x00002000
            USN_REASON_INDEXABLE_CHANGE = 0x00004000
            USN_REASON_BASIC_INFO_CHANGE = 0x00008000
            USN_REASON_HARD_LINK_CHANGE = 0x00010000
            USN_REASON_COMPRESSION_CHANGE = 0x00020000
            USN_REASON_ENCRYPTION_CHANGE = 0x00040000
            USN_REASON_OBJECT_ID_CHANGE = 0x00080000
            USN_REASON_REPARSE_POINT_CHANGE = 0x00100000
            USN_REASON_STREAM_CHANGE = 0x00200000
            USN_REASON_TRANSACTED_CHANGE = 0x00400000
            USN_REASON_INTEGRITY_CHANGE = 0x00800000
            USN_REASON_DESIRED_STORAGE_CLASS_CHANGE = 0x01000000
            USN_REASON_CLOSE = 0x80000000

            # == == == == == == == == == == FSCTL_QUERY_USN_JOUNAL == == == ==
            # == == == == == == ==
            # Structure for FSCTL_QUERY_USN_JOUNAL
            USN_JOURNAL_DATA_V0._fields_ = [
                ('UsnJournalID', DWORDLONG),
                ('FirstUsn', USN),
                ('NextUsn', USN),
                ('LowestValidUsn', USN),
                ('MaxUsn', USN),
                ('MaximumSize', DWORDLONG),
                ('AllocationDelta', DWORDLONG),
            ]

            USN_JOURNAL_DATA_V1._fields_ = [
                ('UsnJournalID', DWORDLONG),
                ('FirstUsn', USN),
                ('NextUsn', USN),
                ('LowestValidUsn', USN),
                ('MaxUsn', USN),
                ('MaximumSize', DWORDLONG),
                ('AllocationDelta', DWORDLONG),
                ('MinSupportedMajorVersion', WORD),
                ('MaxSupportedMajorVersion', WORD),
            ]

            USN_JOURNAL_DATA_V2._fields_ = [
                ('UsnJournalID', DWORDLONG),
                ('FirstUsn', USN),
                ('NextUsn', USN),
                ('LowestValidUsn', USN),
                ('MaxUsn', USN),
                ('MaximumSize', DWORDLONG),
                ('AllocationDelta', DWORDLONG),
                ('MinSupportedMajorVersion', WORD),
                ('MaxSupportedMajorVersion', WORD),
                ('Flags', DWORD),
                ('RangeTrackChunkSize', DWORDLONG),
                ('RangeTrackFileSizeThreshold', LONGLONG),
            ]
            if NTDDI_VERSION  >= NTDDI_WIN8:
                USN_JOURNAL_DATA = USN_JOURNAL_DATA_V1
                PUSN_JOURNAL_DATA = POINTER(USN_JOURNAL_DATA_V1)
            else:
                USN_JOURNAL_DATA = USN_JOURNAL_DATA_V0
                PUSN_JOURNAL_DATA = POINTER(USN_JOURNAL_DATA_V0)
            # END IF

            # == == == == == == == == == == FSCTL_DELETE_USN_JOURNAL == == ==
            # == == == == == == == ==
            # Structure for FSCTL_DELETE_USN_JOURNAL
            DELETE_USN_JOURNAL_DATA._fields_ = [
                ('UsnJournalID', DWORDLONG),
                ('DeleteFlags', DWORD),
            ]
            USN_DELETE_FLAG_DELETE = 0x00000001
            USN_DELETE_FLAG_NOTIFY = 0x00000002
            USN_DELETE_VALID_FLAGS = 0x00000003

            # == == == == == == == == == == FSCTL_MARK_HANDLE == == == == ==
            # == == == == == ==
            # Structure for FSCTL_MARK_HANDLE
            if _MSC_VER  >= 1200:
                pass
            # END IF


            if _WIN32_WINNT  >= _WIN32_WINNT_WIN8:
                class DUMMYUNIONNAME(ctypes.Union):
                    pass


                DUMMYUNIONNAME._fields_ = [
                    ('UsnSourceInfo', DWORD),
                    ('CopyNumber', DWORD),
                ]
                MARK_HANDLE_INFO.DUMMYUNIONNAME = DUMMYUNIONNAME


            _TEMP_MARK_HANDLE_INFO = [
            ]
            if _WIN32_WINNT  >= _WIN32_WINNT_WIN8:
                _TEMP_MARK_HANDLE_INFO += [
                    ('DUMMYUNIONNAME', MARK_HANDLE_INFO.DUMMYUNIONNAME),
                ]
            else:
                _TEMP_MARK_HANDLE_INFO += [
                    ('UsnSourceInfo', DWORD),
                ]
            # END IF   _WIN32_WINNT  >= _WIN32_WINNT_WIN8


            _TEMP_MARK_HANDLE_INFO += [
                ('VolumeHandle', HANDLE),
                ('HandleInfo', DWORD),
            ]
            MARK_HANDLE_INFO._fields_ = _TEMP_MARK_HANDLE_INFO

            if defined(_WIN64):
                # 32/64 Bit thunking support structure
                if _WIN32_WINNT  >= _WIN32_WINNT_WIN8:
                    class DUMMYUNIONNAME(ctypes.Union):
                        pass


                    DUMMYUNIONNAME._fields_ = [
                        ('UsnSourceInfo', DWORD),
                        ('CopyNumber', DWORD),
                    ]
                    MARK_HANDLE_INFO32.DUMMYUNIONNAME = DUMMYUNIONNAME


                _TEMP_MARK_HANDLE_INFO32 = [
                ]
                if _WIN32_WINNT  >= _WIN32_WINNT_WIN8:
                    _TEMP_MARK_HANDLE_INFO32 += [
                        ('DUMMYUNIONNAME', MARK_HANDLE_INFO32.DUMMYUNIONNAME),
                    ]
                else:
                    _TEMP_MARK_HANDLE_INFO32 += [
                        ('UsnSourceInfo', DWORD),
                    ]
                # END IF   _WIN32_WINNT  >= _WIN32_WINNT_WIN8


                _TEMP_MARK_HANDLE_INFO32 += [
                    ('VolumeHandle', UINT32),
                    ('HandleInfo', DWORD),
                ]
                MARK_HANDLE_INFO32._fields_ = _TEMP_MARK_HANDLE_INFO32
            # END IF


            if _MSC_VER  >= 1200:
                pass
            else:
                pass
            # END IF


            # Flags for the additional source information above.
            # USN_SOURCE_DATA_MANAGEMENT - Service is not modifying the
            # external view
            # of any part of the file. Typical case is HSM moving data to
            # and from external storage.
            # USN_SOURCE_AUXILIARY_DATA - Service is not modifying the
            # external view
            # of the file with regard to the application that created this
            # file.
            # Can be used to add private data streams to a file.
            # USN_SOURCE_REPLICATION_MANAGEMENT - Service is modifying a file
            # to match
            # the contents of the same file which exists in another member of
            # the
            # replica set.
            # USN_SOURCE_CLIENT_REPLICATION_MANAGEMENT - Replication is being
            # performed
            # on clint systems either from the cloud or servers
            USN_SOURCE_DATA_MANAGEMENT = 0x00000001
            USN_SOURCE_AUXILIARY_DATA = 0x00000002
            USN_SOURCE_REPLICATION_MANAGEMENT = 0x00000004
            USN_SOURCE_CLIENT_REPLICATION_MANAGEMENT = 0x00000008
            USN_SOURCE_VALID_FLAGS = (
                USN_SOURCE_DATA_MANAGEMENT |
                USN_SOURCE_AUXILIARY_DATA |
                USN_SOURCE_REPLICATION_MANAGEMENT |
                USN_SOURCE_CLIENT_REPLICATION_MANAGEMENT
            )


            # Flags for the HandleInfo field above
            # MARK_HANDLE_PROTECT_CLUSTERS - disallow any defragmenting
            # (FSCTL_MOVE_FILE) until the
            # the handle is closed
            # MARK_HANDLE_TXF_SYSTEM_LOG - indicates that this stream is being
            # used as the Txf
            # log for an RM on the volume. Must be called in the kernel using
            # IRP_MN_KERNEL_CALL.
            # MARK_HANDLE_NOT_TXF_SYSTEM_LOG - indicates that this user is no
            # longer using this
            # object as a log file.
            # MARK_HANDLE_REALTIME
            # MARK_HANDLE_NOT_REALTIME
            # MARK_HANDLE_READ_COPY - indicates the data must be read from the
            # specified copy.
            # MARK_HANDLE_NOT_READ_COPY - indicates the data is no longer to
            # be read from a specific copy.
            # MARK_HANDLE_CLOUD_SYNC - indicates that the handle belongs to
            # the cloud sync engine
            MARK_HANDLE_PROTECT_CLUSTERS = 0x00000001
            MARK_HANDLE_TXF_SYSTEM_LOG = 0x00000004
            MARK_HANDLE_NOT_TXF_SYSTEM_LOG = 0x00000008
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN2K

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN7:
            MARK_HANDLE_REALTIME = 0x00000020
            MARK_HANDLE_NOT_REALTIME = 0x00000040

            # 8.1 update and newer
            MARK_HANDLE_FILTER_METADATA = 0x00000200
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN7

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN8:
            MARK_HANDLE_READ_COPY = 0x00000080
            MARK_HANDLE_NOT_READ_COPY = 0x00000100

            # 8.1 and newer
            MARK_HANDLE_RETURN_PURGE_FAILURE = 0x00000400
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN8

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN7:
            MARK_HANDLE_CLOUD_SYNC = 0x00000800
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN7

        if _WIN32_WINNT  >= _WIN32_WINNT_WINTHRESHOLD:
            # 9.0 and newer
            MARK_HANDLE_DISABLE_FILE_METADATA_OPTIMIZATION = 0x00001000

            # 9.0 and newer
            MARK_HANDLE_ENABLE_USN_SOURCE_ON_PAGING_IO = 0x00002000

            # 9.0 and newer
            MARK_HANDLE_SKIP_COHERENCY_SYNC_DISALLOW_WRITES = 0x00004000
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WINTHRESHOLD

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS4:
            MARK_HANDLE_ENABLE_CPU_CACHE = 0x10000000
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS4

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN7:
            NO_8DOT3_NAME_PRESENT = 0x00000001
            REMOVED_8DOT3_NAME = 0x00000002
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN7


        if _WIN32_WINNT  >= _WIN32_WINNT_WIN2K:
            # == == == == == == == == == == FSCTL_SECURITY_ID_CHECK == == ==
            # == == == == == == == ==
            # Structure for FSCTL_SECURITY_ID_CHECK
            BULK_SECURITY_TEST_DATA._fields_ = [
                ('DesiredAccess', ACCESS_MASK),
                ('SecurityIds', DWORD * 1),
            ]
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN2K

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN2K:
            # == == == == == == == == == == FSCTL_IS_VOLUME_DIRTY == == == ==
            # == == == == == == ==
            # Output flags for the FSCTL_IS_VOLUME_DIRTY
            VOLUME_IS_DIRTY = 0x00000001
            VOLUME_UPGRADE_SCHEDULED = 0x00000002
            VOLUME_SESSION_OPEN = 0x00000004
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN2K


        if _WIN32_WINNT  >= _WIN32_WINNT_WIN2K:
            # Structures for FSCTL_FILE_PREFETCH
            _FILE_PREFETCH._fields_ = [
                ('Type', DWORD),
                ('Count', DWORD),
                ('Prefetch', DWORDLONG * 1),
            ]

            _FILE_PREFETCH_EX._fields_ = [
                ('Type', DWORD),
                ('Count', DWORD),
                ('Context', PVOID),
                ('Prefetch', DWORDLONG * 1),
            ]
            FILE_PREFETCH_TYPE_FOR_CREATE = 0x1
            FILE_PREFETCH_TYPE_FOR_DIRENUM = 0x2
            FILE_PREFETCH_TYPE_FOR_CREATE_EX = 0x3
            FILE_PREFETCH_TYPE_FOR_DIRENUM_EX = 0x4
            FILE_PREFETCH_TYPE_MAX = 0x4
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN2K


        # == == == == == == == == == == FSCTL_FILESYSTEM_GET_STATISTICS == ==
        # == == == == == == == == ==
        # Structures for FSCTL_FILESYSTEM_GET_STATISTICS
        # Filesystem performance counters
        _FILESYSTEM_STATISTICS._fields_ = [
            ('FileSystemType', WORD),
            # currently version 1
            ('Version', WORD),
            # must by a mutiple of 64 bytes
            ('SizeOfCompleteStructure', DWORD),
            ('UserFileReads', DWORD),
            ('UserFileReadBytes', DWORD),
            ('UserDiskReads', DWORD),
            ('UserFileWrites', DWORD),
            ('UserFileWriteBytes', DWORD),
            ('UserDiskWrites', DWORD),
            ('MetaDataReads', DWORD),
            ('MetaDataReadBytes', DWORD),
            ('MetaDataDiskReads', DWORD),
            ('MetaDataWrites', DWORD),
            ('MetaDataWriteBytes', DWORD),
            ('MetaDataDiskWrites', DWORD),
        ]

        # values for FS_STATISTICS.FileSystemType
        FILESYSTEM_STATISTICS_TYPE_NTFS = 1
        FILESYSTEM_STATISTICS_TYPE_FAT = 2
        FILESYSTEM_STATISTICS_TYPE_EXFAT = 3
        FILESYSTEM_STATISTICS_TYPE_REFS = 4


        # File System Specific Statistics Data
        _FAT_STATISTICS._fields_ = [
            ('CreateHits', DWORD),
            ('SuccessfulCreates', DWORD),
            ('FailedCreates', DWORD),
            ('NonCachedReads', DWORD),
            ('NonCachedReadBytes', DWORD),
            ('NonCachedWrites', DWORD),
            ('NonCachedWriteBytes', DWORD),
            ('NonCachedDiskReads', DWORD),
            ('NonCachedDiskWrites', DWORD),
        ]

        _EXFAT_STATISTICS._fields_ = [
            ('CreateHits', DWORD),
            ('SuccessfulCreates', DWORD),
            ('FailedCreates', DWORD),
            ('NonCachedReads', DWORD),
            ('NonCachedReadBytes', DWORD),
            ('NonCachedWrites', DWORD),
            ('NonCachedWriteBytes', DWORD),
            ('NonCachedDiskReads', DWORD),
            ('NonCachedDiskWrites', DWORD),
        ]


        class MftWritesUserLevel(ctypes.Structure):
            pass


        MftWritesUserLevel._fields_ = [
            ('Write', WORD),
            ('Create', WORD),
            ('SetInfo', WORD),
            ('Flush', WORD),
        ]
        _NTFS_STATISTICS.MftWritesUserLevel = MftWritesUserLevel


        class Mft2WritesUserLevel(ctypes.Structure):
            pass


        Mft2WritesUserLevel._fields_ = [
            ('Write', WORD),
            ('Create', WORD),
            ('SetInfo', WORD),
            ('Flush', WORD),
        ]
        _NTFS_STATISTICS.Mft2WritesUserLevel = Mft2WritesUserLevel


        class BitmapWritesUserLevel(ctypes.Structure):
            pass


        BitmapWritesUserLevel._fields_ = [
            ('Write', WORD),
            ('Create', WORD),
            ('SetInfo', WORD),
        ]
        _NTFS_STATISTICS.BitmapWritesUserLevel = BitmapWritesUserLevel


        class MftBitmapWritesUserLevel(ctypes.Structure):
            pass


        MftBitmapWritesUserLevel._fields_ = [
            ('Write', WORD),
            ('Create', WORD),
            ('SetInfo', WORD),
            ('Flush', WORD),
        ]
        _NTFS_STATISTICS.MftBitmapWritesUserLevel = MftBitmapWritesUserLevel


        # number of individual calls to allocate clusters
        class Allocate(ctypes.Structure):
            pass


        Allocate._fields_ = [
            ('Calls', DWORD),
            # number of clusters allocated
            ('Clusters', DWORD),
            # number of times a hint was specified
            ('Hints', DWORD),
            # number of runs used to satisify all the requests
            ('RunsReturned', DWORD),
            # number of times the hint was useful
            ('HintsHonored', DWORD),
            # number of clusters allocated via the hint
            ('HintsClusters', DWORD),
            # number of times the cache was useful other than the hint
            ('Cache', DWORD),
            # number of clusters allocated via the cache other than the hint
            ('CacheClusters', DWORD),
            # number of times the cache wasn't useful
            ('CacheMiss', DWORD),
            # number of clusters allocated without the cache
            ('CacheMissClusters', DWORD),
        ]
        _NTFS_STATISTICS.Allocate = Allocate


        _NTFS_STATISTICS._fields_ = [
            ('LogFileFullExceptions', DWORD),
            ('OtherExceptions', DWORD),
            # Other meta data io's
            ('MftReads', DWORD),
            ('MftReadBytes', DWORD),
            ('MftWrites', DWORD),
            ('MftWriteBytes', DWORD),
            ('MftWritesUserLevel', _NTFS_STATISTICS.MftWritesUserLevel),
            ('MftWritesFlushForLogFileFull', WORD),
            ('MftWritesLazyWriter', WORD),
            ('MftWritesUserRequest', WORD),
            ('Mft2Writes', DWORD),
            ('Mft2WriteBytes', DWORD),
            ('Mft2WritesUserLevel', _NTFS_STATISTICS.Mft2WritesUserLevel),
            ('Mft2WritesFlushForLogFileFull', WORD),
            ('Mft2WritesLazyWriter', WORD),
            ('Mft2WritesUserRequest', WORD),
            ('RootIndexReads', DWORD),
            ('RootIndexReadBytes', DWORD),
            ('RootIndexWrites', DWORD),
            ('RootIndexWriteBytes', DWORD),
            ('BitmapReads', DWORD),
            ('BitmapReadBytes', DWORD),
            ('BitmapWrites', DWORD),
            ('BitmapWriteBytes', DWORD),
            ('BitmapWritesFlushForLogFileFull', WORD),
            ('BitmapWritesLazyWriter', WORD),
            ('BitmapWritesUserRequest', WORD),
            ('BitmapWritesUserLevel', _NTFS_STATISTICS.BitmapWritesUserLevel),
            ('MftBitmapReads', DWORD),
            ('MftBitmapReadBytes', DWORD),
            ('MftBitmapWrites', DWORD),
            ('MftBitmapWriteBytes', DWORD),
            ('MftBitmapWritesFlushForLogFileFull', WORD),
            ('MftBitmapWritesLazyWriter', WORD),
            ('MftBitmapWritesUserRequest', WORD),
            ('MftBitmapWritesUserLevel', _NTFS_STATISTICS.MftBitmapWritesUserLevel),
            ('UserIndexReads', DWORD),
            ('UserIndexReadBytes', DWORD),
            ('UserIndexWrites', DWORD),
            ('UserIndexWriteBytes', DWORD),
            # Additions for NT 5.0
            ('LogFileReads', DWORD),
            ('LogFileReadBytes', DWORD),
            ('LogFileWrites', DWORD),
            ('LogFileWriteBytes', DWORD),
            ('Allocate', _NTFS_STATISTICS.Allocate),
            # Additions for Windows 8.1
            ('DiskResourcesExhausted', DWORD),
        ]

        _FILESYSTEM_STATISTICS_EX._fields_ = [
            ('FileSystemType', WORD),
            # currently version 1
            ('Version', WORD),
            # must by a mutiple of 64 bytes
            ('SizeOfCompleteStructure', DWORD),
            ('UserFileReads', DWORDLONG),
            ('UserFileReadBytes', DWORDLONG),
            ('UserDiskReads', DWORDLONG),
            ('UserFileWrites', DWORDLONG),
            ('UserFileWriteBytes', DWORDLONG),
            ('UserDiskWrites', DWORDLONG),
            ('MetaDataReads', DWORDLONG),
            ('MetaDataReadBytes', DWORDLONG),
            ('MetaDataDiskReads', DWORDLONG),
            ('MetaDataWrites', DWORDLONG),
            ('MetaDataWriteBytes', DWORDLONG),
            ('MetaDataDiskWrites', DWORDLONG),
        ]


        class MftWritesUserLevel(ctypes.Structure):
            pass


        MftWritesUserLevel._fields_ = [
            ('Write', DWORD),
            ('Create', DWORD),
            ('SetInfo', DWORD),
            ('Flush', DWORD),
        ]
        _NTFS_STATISTICS_EX.MftWritesUserLevel = MftWritesUserLevel


        class Mft2WritesUserLevel(ctypes.Structure):
            pass


        Mft2WritesUserLevel._fields_ = [
            ('Write', DWORD),
            ('Create', DWORD),
            ('SetInfo', DWORD),
            ('Flush', DWORD),
        ]
        _NTFS_STATISTICS_EX.Mft2WritesUserLevel = Mft2WritesUserLevel


        class BitmapWritesUserLevel(ctypes.Structure):
            pass


        BitmapWritesUserLevel._fields_ = [
            ('Write', DWORD),
            ('Create', DWORD),
            ('SetInfo', DWORD),
            ('Flush', DWORD),
        ]
        _NTFS_STATISTICS_EX.BitmapWritesUserLevel = BitmapWritesUserLevel


        class MftBitmapWritesUserLevel(ctypes.Structure):
            pass


        MftBitmapWritesUserLevel._fields_ = [
            ('Write', DWORD),
            ('Create', DWORD),
            ('SetInfo', DWORD),
            ('Flush', DWORD),
        ]
        _NTFS_STATISTICS_EX.MftBitmapWritesUserLevel = MftBitmapWritesUserLevel


        # number of individual calls to allocate clusters
        class Allocate(ctypes.Structure):
            pass


        Allocate._fields_ = [
            ('Calls', DWORD),
            # number of runs used to satisify all the requests
            ('RunsReturned', DWORD),
            # number of times a hint was specified
            ('Hints', DWORD),
            # number of times the hint was useful
            ('HintsHonored', DWORD),
            # number of times the cache was useful other than the hint
            ('Cache', DWORD),
            # number of times the cache wasn't useful
            ('CacheMiss', DWORD),
            # number of clusters allocated
            ('Clusters', DWORDLONG),
            # number of clusters allocated via the hint
            ('HintsClusters', DWORDLONG),
            # number of clusters allocated via the cache other than the hint
            ('CacheClusters', DWORDLONG),
            # number of clusters allocated without the cache
            ('CacheMissClusters', DWORDLONG),
        ]
        _NTFS_STATISTICS_EX.Allocate = Allocate


        _NTFS_STATISTICS_EX._fields_ = [
            ('LogFileFullExceptions', DWORD),
            ('OtherExceptions', DWORD),
            # Other meta data io's
            ('MftReads', DWORDLONG),
            ('MftReadBytes', DWORDLONG),
            ('MftWrites', DWORDLONG),
            ('MftWriteBytes', DWORDLONG),
            ('MftWritesUserLevel', _NTFS_STATISTICS_EX.MftWritesUserLevel),
            ('MftWritesFlushForLogFileFull', DWORD),
            ('MftWritesLazyWriter', DWORD),
            ('MftWritesUserRequest', DWORD),
            ('Mft2Writes', DWORDLONG),
            ('Mft2WriteBytes', DWORDLONG),
            ('Mft2WritesUserLevel', _NTFS_STATISTICS_EX.Mft2WritesUserLevel),
            ('Mft2WritesFlushForLogFileFull', DWORD),
            ('Mft2WritesLazyWriter', DWORD),
            ('Mft2WritesUserRequest', DWORD),
            ('RootIndexReads', DWORDLONG),
            ('RootIndexReadBytes', DWORDLONG),
            ('RootIndexWrites', DWORDLONG),
            ('RootIndexWriteBytes', DWORDLONG),
            ('BitmapReads', DWORDLONG),
            ('BitmapReadBytes', DWORDLONG),
            ('BitmapWrites', DWORDLONG),
            ('BitmapWriteBytes', DWORDLONG),
            ('BitmapWritesFlushForLogFileFull', DWORD),
            ('BitmapWritesLazyWriter', DWORD),
            ('BitmapWritesUserRequest', DWORD),
            ('BitmapWritesUserLevel', _NTFS_STATISTICS_EX.BitmapWritesUserLevel),
            ('MftBitmapReads', DWORDLONG),
            ('MftBitmapReadBytes', DWORDLONG),
            ('MftBitmapWrites', DWORDLONG),
            ('MftBitmapWriteBytes', DWORDLONG),
            ('MftBitmapWritesFlushForLogFileFull', DWORD),
            ('MftBitmapWritesLazyWriter', DWORD),
            ('MftBitmapWritesUserRequest', DWORD),
            ('MftBitmapWritesUserLevel', _NTFS_STATISTICS_EX.MftBitmapWritesUserLevel),
            ('UserIndexReads', DWORDLONG),
            ('UserIndexReadBytes', DWORDLONG),
            ('UserIndexWrites', DWORDLONG),
            ('UserIndexWriteBytes', DWORDLONG),
            # Additions for NT 5.0
            ('LogFileReads', DWORDLONG),
            ('LogFileReadBytes', DWORDLONG),
            ('LogFileWrites', DWORDLONG),
            ('LogFileWriteBytes', DWORDLONG),
            ('Allocate', _NTFS_STATISTICS_EX.Allocate),
            # Additions for Windows 8.1
            ('DiskResourcesExhausted', DWORD),
            # Additions for Windows 10
            ('VolumeTrimCount', DWORDLONG),
            ('VolumeTrimTime', DWORDLONG),
            ('VolumeTrimByteCount', DWORDLONG),
            ('FileLevelTrimCount', DWORDLONG),
            ('FileLevelTrimTime', DWORDLONG),
            ('FileLevelTrimByteCount', DWORDLONG),
            ('VolumeTrimSkippedCount', DWORDLONG),
            ('VolumeTrimSkippedByteCount', DWORDLONG),
            # Additions for NtfsFillStatInfoFromMftRecord
            ('NtfsFillStatInfoFromMftRecordCalledCount', DWORDLONG),
            ('NtfsFillStatInfoFromMftRecordBailedBecauseOfAttributeListCount', DWORDLONG),
            ('NtfsFillStatInfoFromMftRecordBailedBecauseOfNonResReparsePointCount', DWORDLONG),
        ]

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN2K:
            # == == == == == == == == == == FSCTL_SET_OBJECT_ID == == == == ==
            # == == == == == == == == == == ==
            # == == == == == == == == == == FSCTL_GET_OBJECT_ID == == == == ==
            # == == == == == == == == == == ==
            # == == == == == == == == == == FSCTL_CREATE_OR_GET_OBJECT_ID ==
            # == == == == == == == == == ==
            # Structures for FSCTL_SET_OBJECT_ID, FSCTL_GET_OBJECT_ID, and
            # FSCTL_CREATE_OR_GET_OBJECT_ID
            if _MSC_VER  >= 1200:
                pass
            # END IF


            class DUMMYUNIONNAME(ctypes.Union):
                pass


            class DUMMYSTRUCTNAME(ctypes.Structure):
                pass


            DUMMYSTRUCTNAME._fields_ = [
                ('BirthVolumeId', BYTE * 16),
                ('BirthObjectId', BYTE * 16),
                ('DomainId', BYTE * 16),
            ]
            DUMMYUNIONNAME.DUMMYSTRUCTNAME = DUMMYSTRUCTNAME


            DUMMYUNIONNAME._fields_ = [
                ('DUMMYSTRUCTNAME', DUMMYUNIONNAME.DUMMYSTRUCTNAME),
                ('ExtendedInfo', BYTE * 48),
            ]
            _FILE_OBJECTID_BUFFER.DUMMYUNIONNAME = DUMMYUNIONNAME


            _FILE_OBJECTID_BUFFER._fields_ = [
                # This is the portion of the object id that is indexed.
                ('ObjectId', BYTE * 16),
                # some metadata for the user's benefit.
                ('DUMMYUNIONNAME', _FILE_OBJECTID_BUFFER.DUMMYUNIONNAME),
            ]
            if _MSC_VER  >= 1200:
                pass
            else:
                pass
            # END IF

        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN2K

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN2K:
            # == == == == == == == == == == FSCTL_SET_SPARSE == == == == == ==
            # == == == == ==
            # Structure for FSCTL_SET_SPARSE
            _FILE_SET_SPARSE_BUFFER._fields_ = [
                ('SetSparse', BOOLEAN),
            ]
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN2K


        if _WIN32_WINNT  >= _WIN32_WINNT_WIN2K:
            # == == == == == == == == == == FSCTL_SET_ZERO_DATA == == == == ==
            # == == == == == ==
            # Structure for FSCTL_SET_ZERO_DATA
            _FILE_ZERO_DATA_INFORMATION._fields_ = [
                ('FileOffset', LARGE_INTEGER),
                ('BeyondFinalZero', LARGE_INTEGER),
            ]
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN2K

        if _WIN32_WINNT  >= _WIN32_WINNT_WINTHRESHOLD:
            FILE_ZERO_DATA_INFORMATION_FLAG_PRESERVE_CACHED_DATA = 0x00000001


            _FILE_ZERO_DATA_INFORMATION_EX._fields_ = [
                ('FileOffset', LARGE_INTEGER),
                ('BeyondFinalZero', LARGE_INTEGER),
                ('Flags', DWORD),
            ]
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WINTHRESHOLD

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN2K:
            # == == == == == == == == == == FSCTL_QUERY_ALLOCATED_RANGES == ==
            # == == == == == == == == ==
            # Structure for FSCTL_QUERY_ALLOCATED_RANGES
            # Querying the allocated ranges requires an output buffer to store
            # the
            # allocated ranges and an input buffer to specify the range to
            # query.
            # The input buffer contains a single entry, the output buffer is an
            # array of the following structure.
            _FILE_ALLOCATED_RANGE_BUFFER._fields_ = [
                ('FileOffset', LARGE_INTEGER),
                ('Length', LARGE_INTEGER),
            ]
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN2K


        if _WIN32_WINNT  >= _WIN32_WINNT_WIN2K:
            # == == == == == == == == == == == FSCTL_SET_ENCRYPTION == == ==
            # == == == == == == == == == == == == =
            # == == == == == == == == == == == FSCTL_WRITE_RAW_ENCRYPTED == ==
            # == == == == == == == == == == ==
            # == == == == == == == == == == == FSCTL_READ_RAW_ENCRYPTED == ==
            # == == == == == == == == == == == =
            # Structures for FSCTL_SET_ENCRYPTION, FSCTL_WRITE_RAW_ENCRYPTED,
            # and FSCTL_READ_RAW_ENCRYPTED
            # The input buffer to set encryption indicates whether we are to
            # encrypt/decrypt a file
            # or an individual stream.
            _ENCRYPTION_BUFFER._fields_ = [
                ('EncryptionOperation', DWORD),
                ('Private', BYTE * 1),
            ]
            FILE_SET_ENCRYPTION = 0x00000001
            FILE_CLEAR_ENCRYPTION = 0x00000002
            STREAM_SET_ENCRYPTION = 0x00000003
            STREAM_CLEAR_ENCRYPTION = 0x00000004
            MAXIMUM_ENCRYPTION_VALUE = 0x00000004

            # The optional output buffer to set encryption indicates that the
            # last encrypted
            # stream in a file has been marked as decrypted.
            _DECRYPTION_STATUS_BUFFER._fields_ = [
                ('NoEncryptedStreams', BOOLEAN),
            ]
            ENCRYPTION_FORMAT_DEFAULT = 0x01

            # Request Encrypted Data structure. This is used to indicate
            # the range of the file to read. It also describes the
            # output buffer used to return the data.
            _REQUEST_RAW_ENCRYPTED_DATA._fields_ = [
                # round the length up to a file system boundary.
                ('FileOffset', LONGLONG),
                ('Length', DWORD),
            ]

            # Encrypted Data Information structure. This structure
            # is used to return raw encrypted data from a file in
            # order to perform off-line recovery. The data will be
            # encrypted or encrypted and compressed. The off-line
            # service will need to use the encryption and compression
            # format information to recover the file data. In the
            # event that the data is both encrypted and compressed then
            # the decryption must occur before decompression. All
            # the data units below must be encrypted and compressed
            # with the same format.
            # The data will be returned in units. The data unit size
            # will be fixed per request. If the data is compressed
            # then the data unit size will be the compression unit size.
            # This structure is at the beginning of the buffer used to
            # return the encrypted data. The actual raw bytes from
            # the file will follow this buffer. The offset of the
            # raw bytes from the beginning of this structure is
            # specified in the REQUEST_RAW_ENCRYPTED_DATA structure
            # described above.
            _ENCRYPTED_DATA_INFO._fields_ = [
                # that is consistent with the format of the file.
                ('StartingFileOffset', DWORDLONG),
                # output buffer.
                ('OutputBufferOffset', DWORD),
                # passed to the encryption driver.
                ('BytesWithinFileSize', DWORD),
                # byte(s) beyond valid data length must be zeroed.
                ('BytesWithinValidDataLength', DWORD),
                # any of the described chunks are compressed.
                ('CompressionFormat', WORD),
                # data block unit.
                ('DataUnitShift', BYTE),
                ('ChunkShift', BYTE),
                ('ClusterShift', BYTE),
                # The format for the encryption.
                ('EncryptionFormat', BYTE),
                # array.
                ('NumberOfDataBlocks', WORD),
                # is no data to decrypt past the valid data length.
                ('DataBlockSize', DWORD * ANYSIZE_ARRAY),
            ]
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN2K

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN7:
            # Extended encryption structure for read/write raw encrypted
            # operations.
            # This was needed so we can explicitly indicate if a file is
            # sparse or not
            # Flag to indicate the encrypted file is sparse
            ENCRYPTED_DATA_INFO_SPARSE_FILE = 1


            _EXTENDED_ENCRYPTED_DATA_INFO._fields_ = [
                # or not.
                ('ExtendedCode', DWORD),
                # The length of the extended data structure
                ('Length', DWORD),
                # Encrypted data flags (currently only sparse is defined)
                ('Flags', DWORD),
                ('Reserved', DWORD),
            ]
        # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WIN7)


        if _WIN32_WINNT  >= _WIN32_WINNT_WIN2K:
            # == == == == == == == == == == == == FSCTL_READ_FROM_PLEX == ==
            # == == == == == == == == == == == =
            # Request Plex Read Data structure. This is used to indicate
            # the range of the file to read. It also describes
            # which plex to perform the read from.
            _PLEX_READ_DATA_REQUEST._fields_ = [
                # enforce any other applicable limits.
                ('ByteOffset', LARGE_INTEGER),
                ('ByteLength', DWORD),
                ('PlexNumber', DWORD),
            ]
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN2K

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN2K:
            # == == == == == == == == == == == == FSCTL_SIS_COPYFILE == == ==
            # == == == == == == == == == == =
            # Source and destination file names are passed in the
            # FileNameBuffer.
            # Both strings are null terminated, with the source name starting
            # at
            # the beginning of FileNameBuffer, and the destination name
            # immediately
            # following. Length fields include terminating nulls.
            _SI_COPYFILE._fields_ = [
                ('SourceFileNameLength', DWORD),
                ('DestinationFileNameLength', DWORD),
                ('Flags', DWORD),
                ('FileNameBuffer', WCHAR * 1),
            ]

            # Copy only if source is SIS
            COPYFILE_SIS_LINK = 0x0001

            # Replace destination if it exists, otherwise don't.
            COPYFILE_SIS_REPLACE = 0x0002
            COPYFILE_SIS_FLAGS = 0x0003
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN2K


        if _WIN32_WINNT  >= _WIN32_WINNT_VISTA:
            # == == == == == == == == == == == == FSCTL_MAKE_MEDIA_COMPATIBLE
            # == == == == == == == == == == == == == =
            # Input parameter structure for FSCTL_MAKE_MEDIA_COMPATIBLE
            _FILE_MAKE_COMPATIBLE_BUFFER._fields_ = [
                ('CloseDisc', BOOLEAN),
            ]

            # == == == == == == == == == == == == FSCTL_SET_DEFECT_MANAGEMENT
            # == == == == == == == == == == == == == =
            # Input parameter structure for FSCTL_SET_DEFECT_MANAGEMENT
            _FILE_SET_DEFECT_MGMT_BUFFER._fields_ = [
                ('Disable', BOOLEAN),
            ]


            # == == == == == == == == == == == == FSCTL_QUERY_SPARING_INFO ==
            # == == == == == == == == == == == == =
            # Output structure for FSCTL_QUERY_SPARING_INFO
            _FILE_QUERY_SPARING_BUFFER._fields_ = [
                ('SparingUnitBytes', DWORD),
                ('SoftwareSparing', BOOLEAN),
                ('TotalSpareBlocks', DWORD),
                ('FreeSpareBlocks', DWORD),
            ]

            # == == == == == == == == == == = FSCTL_QUERY_ON_DISK_VOLUME_INFO
            # == == == == == == == == == == == ==
            # Output structure for FSCTL_QUERY_ON_DISK_VOLUME_INFO
            # -1 = unknown
            _FILE_QUERY_ON_DISK_VOL_INFO_BUFFER._fields_ = [
                ('DirectoryCount', LARGE_INTEGER),
                # -1 = unknown
                ('FileCount', LARGE_INTEGER),
                # -1 = unknown or n/a
                ('FsFormatMajVersion', WORD),
                # -1 = unknown or n/a
                ('FsFormatMinVersion', WORD),
                ('FsFormatName', WCHAR * 12),
                ('FormatTime', LARGE_INTEGER),
                ('LastUpdateTime', LARGE_INTEGER),
                ('CopyrightInfo', WCHAR * 34),
                ('AbstractInfo', WCHAR * 34),
                ('FormattingImplementationInfo', WCHAR * 34),
                ('LastModifyingImplementationInfo', WCHAR * 34),
            ]


            # == == == == == == == == == == = FSCTL_SET_REPAIR == == == == ==
            # == == == == == == ==
            # Input flags for FSCTL_SET_REPAIR
            SET_REPAIR_ENABLED = 0x00000001
            SET_REPAIR_WARN_ABOUT_DATA_LOSS = 0x00000008
            SET_REPAIR_DISABLED_AND_BUGCHECK_ON_CORRUPT = 0x00000010
            SET_REPAIR_VALID_MASK = 0x00000019

            # == == == == == == == == == == = FSCTL_INITIATE_REPAIR == == ==
            # == == == == == == == == ==
            # Optional output structure for FSCTL_INITIATE_REPAIR
            FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_IN_USE = (
                0x0000000000000001
            )
            FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_REUSED = 0x0000000000000002
            FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_EXIST = (
                0x0000000000000004
            )
            FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_BASE_RECORD = (
                0x0000000000000008
            )
            FILE_INITIATE_REPAIR_HINT1_SYSTEM_FILE = 0x0000000000000010
            FILE_INITIATE_REPAIR_HINT1_NOT_IMPLEMENTED = 0x0000000000000020
            FILE_INITIATE_REPAIR_HINT1_UNABLE_TO_REPAIR = 0x0000000000000040
            FILE_INITIATE_REPAIR_HINT1_REPAIR_DISABLED = 0x0000000000000080
            FILE_INITIATE_REPAIR_HINT1_RECURSIVELY_CORRUPTED = (
                0x0000000000000100
            )
            FILE_INITIATE_REPAIR_HINT1_ORPHAN_GENERATED = 0x0000000000000200
            FILE_INITIATE_REPAIR_HINT1_REPAIRED = 0x0000000000000400
            FILE_INITIATE_REPAIR_HINT1_NOTHING_WRONG = 0x0000000000000800
            FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_NOT_FOUND = 0x0000000000001000
            FILE_INITIATE_REPAIR_HINT1_POTENTIAL_CROSSLINK = 0x0000000000002000
            FILE_INITIATE_REPAIR_HINT1_STALE_INFORMATION = 0x0000000000004000
            FILE_INITIATE_REPAIR_HINT1_CLUSTERS_ALREADY_IN_USE = (
                0x0000000000008000
            )
            FILE_INITIATE_REPAIR_HINT1_LCN_NOT_EXIST = 0x0000000000010000
            FILE_INITIATE_REPAIR_HINT1_INVALID_RUN_LENGTH = 0x0000000000020000
            FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_ORPHAN = (
                0x0000000000040000
            )
            FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_IS_BASE_RECORD = (
                0x0000000000080000
            )
            FILE_INITIATE_REPAIR_HINT1_INVALID_ARRAY_LENGTH_COUNT = (
                0x0000000000100000
            )
            FILE_INITIATE_REPAIR_HINT1_SID_VALID = 0x0000000000200000
            FILE_INITIATE_REPAIR_HINT1_SID_MISMATCH = 0x0000000000400000
            FILE_INITIATE_REPAIR_HINT1_INVALID_PARENT = 0x0000000000800000
            FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_IN_USE = (
                0x0000000001000000
            )
            FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_REUSED = (
                0x0000000002000000
            )
            FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_EXIST = (
                0x0000000004000000
            )
            FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_BASE_RECORD = (
                0x0000000008000000
            )
            FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_INDEX = (
                0x0000000010000000
            )
            FILE_INITIATE_REPAIR_HINT1_VALID_INDEX_ENTRY = 0x0000000020000000
            FILE_INITIATE_REPAIR_HINT1_OUT_OF_GENERIC_NAMES = (
                0x0000000040000000
            )
            FILE_INITIATE_REPAIR_HINT1_OUT_OF_RESOURCE = 0x0000000080000000
            FILE_INITIATE_REPAIR_HINT1_INVALID_LCN = 0x0000000100000000
            FILE_INITIATE_REPAIR_HINT1_INVALID_VCN = 0x0000000200000000
            FILE_INITIATE_REPAIR_HINT1_NAME_CONFLICT = 0x0000000400000000
            FILE_INITIATE_REPAIR_HINT1_ORPHAN = 0x0000000800000000
            FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_TOO_SMALL = 0x0000001000000000
            FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_NON_RESIDENT = (
                0x0000002000000000
            )
            FILE_INITIATE_REPAIR_HINT1_DENY_DEFRAG = 0x0000004000000000
            FILE_INITIATE_REPAIR_HINT1_PREVIOUS_PARENT_STILL_VALID = (
                0x0000008000000000
            )
            FILE_INITIATE_REPAIR_HINT1_INDEX_ENTRY_MISMATCH = (
                0x0000010000000000
            )
            FILE_INITIATE_REPAIR_HINT1_INVALID_ORPHAN_RECOVERY_NAME = (
                0x0000020000000000
            )
            FILE_INITIATE_REPAIR_HINT1_MULTIPLE_FILE_NAME_ATTRIBUTES = (
                0x0000040000000000
            )


            # We need to expose CLSN definition???????????????
            CLSN = DWORDLONG


            _FILE_INITIATE_REPAIR_OUTPUT_BUFFER._fields_ = [
                ('Hint1', DWORDLONG),
                ('Hint2', DWORDLONG),
                ('Clsn', CLSN),
                ('Status', DWORD),
            ]


            # == == == == == == == == == == = FSCTL_SHRINK_VOLUME == == == ==
            # == == == == == == == ==
            # Input structures for FSCTL_SHRINK_VOLUME.
            class _SHRINK_VOLUME_REQUEST_TYPES(ENUM):
                ShrinkPrepare = 1
                ShrinkCommit = 2
                ShrinkAbort = 3

            SHRINK_VOLUME_REQUEST_TYPES = _SHRINK_VOLUME_REQUEST_TYPES
            PSHRINK_VOLUME_REQUEST_TYPES = POINTER(_SHRINK_VOLUME_REQUEST_TYPES)

            _SHRINK_VOLUME_INFORMATION._fields_ = [
                ('ShrinkRequestType', SHRINK_VOLUME_REQUEST_TYPES),
                ('Flags', DWORDLONG),
                ('NewNumberOfSectors', LONGLONG),
            ]

            # == == == == = FSCTL_TXFS_MODIFY_RM,
            # FSCTL_TXFS_QUERY_RM_INFORMATION == == == == == ==
            # Structures for FSCTL_TXFS_MODIFY_RM and
            # FSCTL_TXFS_QUERY_RM_INFORMATION
            # For ModifyRM, TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS
            # and
            # TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT are mutually exclusive.
            # You can specify the log growth amount in number of containers or
            # as a percentage.
            # For ModifyRM, TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX and
            # TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX are mutually exclusive.
            # For ModifyRM, TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN and
            # TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN are mutually exclusive.
            # For ModifyRM, TXFS_RM_FLAG_RESET_RM_AT_NEXT_START and
            # TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START are mutually
            # exclusive and only
            # apply to default RMs.
            # For ModifyRM, TXFS_RM_FLAG_PREFER_CONSISTENCY and
            # TXFS_RM_FLAG_PREFER_AVAILABILITY are mutually exclusive. After
            # calling ModifyRM
            # with one of these flags set the RM must be restarted for the
            # change to take effect.
            TXFS_RM_FLAG_LOGGING_MODE = 0x00000001
            TXFS_RM_FLAG_RENAME_RM = 0x00000002
            TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX = 0x00000004
            TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN = 0x00000008
            TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS = 0x00000010
            TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT = 0x00000020
            TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE = 0x00000040
            TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX = 0x00000080
            TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN = 0x00000100
            TXFS_RM_FLAG_GROW_LOG = 0x00000400
            TXFS_RM_FLAG_SHRINK_LOG = 0x00000800
            TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE = 0x00001000
            TXFS_RM_FLAG_PRESERVE_CHANGES = 0x00002000
            TXFS_RM_FLAG_RESET_RM_AT_NEXT_START = 0x00004000
            TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START = 0x00008000
            TXFS_RM_FLAG_PREFER_CONSISTENCY = 0x00010000
            TXFS_RM_FLAG_PREFER_AVAILABILITY = 0x00020000
            TXFS_LOGGING_MODE_SIMPLE = 0x0001
            TXFS_LOGGING_MODE_FULL = 0x0002
            TXFS_TRANSACTION_STATE_NONE = 0x00
            TXFS_TRANSACTION_STATE_ACTIVE = 0x01
            TXFS_TRANSACTION_STATE_PREPARED = 0x02
            TXFS_TRANSACTION_STATE_NOTACTIVE = 0x03
            TXFS_MODIFY_RM_VALID_FLAGS = (
                TXFS_RM_FLAG_LOGGING_MODE |
                TXFS_RM_FLAG_RENAME_RM |
                TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX |
                TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN |
                TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS |
                TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT |
                TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE |
                TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX |
                TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN |
                TXFS_RM_FLAG_SHRINK_LOG |
                TXFS_RM_FLAG_GROW_LOG |
                TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE |
                TXFS_RM_FLAG_PRESERVE_CHANGES |
                TXFS_RM_FLAG_RESET_RM_AT_NEXT_START |
                TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START |
                TXFS_RM_FLAG_PREFER_CONSISTENCY |
                TXFS_RM_FLAG_PREFER_AVAILABILITY
            )


            _TXFS_MODIFY_RM._fields_ = [
                # TXFS_RM_FLAG_* flags
                ('Flags', DWORD),
                # Maximum log container count if
                # TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX is set.
                ('LogContainerCountMax', DWORD),
                # Minimum log container count if
                # TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN is set.
                ('LogContainerCountMin', DWORD),
                # Target log container count for TXFS_RM_FLAG_SHRINK_LOG or
                # _GROW_LOG.
                ('LogContainerCount', DWORD),
                # flags is set.
                ('LogGrowthIncrement', DWORD),
                # makes the log shrink so that no more than this percentage of
                # the log is free at any time.
                ('LogAutoShrinkPercentage', DWORD),
                # Reserved.
                ('Reserved', DWORDLONG),
                # or TXFS_LOGGING_MODE_FULL.
                ('LoggingMode', WORD),
            ]
            TXFS_RM_STATE_NOT_STARTED = 0
            TXFS_RM_STATE_STARTING = 1
            TXFS_RM_STATE_ACTIVE = 2
            TXFS_RM_STATE_SHUTTING_DOWN = 3

            # The flags field for query RM information is used for the
            # following information:
            # 1) To indicate whether the LogGrowthIncrement field is reported as a percent
            #
            # or as a number of containers. Possible flag values for this are:
            # TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS xor
            # TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT
            # 2) To indicate that there is no set maximum or minimum container count. Possible
            #
            # flag values for this are:
            # TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX
            # TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN
            # Note that these flags are not mutually exclusive.
            # 2) To report whether the RM will be reset the next time it is started. Note that
            #
            # only the default RM will report a meaningful value
            # (secondary RMs will always
            # report DO_NOT_RESET) Possible flag values for this are:
            # TXFS_RM_FLAG_RESET_RM_AT_NEXT_START xor
            # TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START
            # 3) To report whether the RM is in consistency mode or availability mode. Possible
            #
            # flag values for this are:
            # TXFS_RM_FLAG_PREFER_CONSISTENCY xor
            # TXFS_RM_FLAG_PREFER_AVAILABILITY
            # The RmState field can have exactly one of the above-defined
            # TXF_RM_STATE_ values.
            TXFS_QUERY_RM_INFORMATION_VALID_FLAGS = (
                TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS |
                TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT |
                TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX |
                TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN |
                TXFS_RM_FLAG_RESET_RM_AT_NEXT_START |
                TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START |
                TXFS_RM_FLAG_PREFER_CONSISTENCY |
                TXFS_RM_FLAG_PREFER_AVAILABILITY
            )
            _TXFS_QUERY_RM_INFORMATION._fields_ = [
                # will indicate how much space is required to hold everything.
                ('BytesRequired', DWORD),
                # LSN of earliest available record in the RM's log.
                ('TailLsn', DWORDLONG),
                # LSN of most recently-written record in the RM's log.
                ('CurrentLsn', DWORDLONG),
                # LSN of the log's archive tail.
                ('ArchiveTailLsn', DWORDLONG),
                # Size of a log container in bytes.
                ('LogContainerSize', DWORDLONG),
                # Highest virtual clock value recorded in this RM's log.
                ('HighestVirtualClock', LARGE_INTEGER),
                # Number of containers in this RM's log.
                ('LogContainerCount', DWORD),
                # Maximum-allowed log container count.
                ('LogContainerCountMax', DWORD),
                # Minimum-allowed log container count.
                ('LogContainerCountMin', DWORD),
                # flags is set.
                ('LogGrowthIncrement', DWORD),
                # the log will not automatically shrink).
                ('LogAutoShrinkPercentage', DWORD),
                # what the flags here mean.
                ('Flags', DWORD),
                # Exactly one of TXFS_LOGGING_MODE_SIMPLE or
                # TXFS_LOGGING_MODE_FULL.
                ('LoggingMode', WORD),
                # Reserved.
                ('Reserved', WORD),
                # Activity state of the RM. May be exactly one of the
                # above-defined TXF_RM_STATE_ values.
                ('RmState', DWORD),
                # Total capacity of the log in bytes.
                ('LogCapacity', DWORDLONG),
                # Amount of free space in the log in bytes.
                ('LogFree', DWORDLONG),
                # Size of $Tops in bytes.
                ('TopsSize', DWORDLONG),
                # Amount of space in $Tops in use.
                ('TopsUsed', DWORDLONG),
                # Number of transactions active in the RM at the time of the
                # call.
                ('TransactionCount', DWORDLONG),
                # Total number of single-phase commits that have happened the
                # RM.
                ('OnePCCount', DWORDLONG),
                # Total number of two-phase commits that have happened the RM.
                ('TwoPCCount', DWORDLONG),
                # Number of times the log has filled up.
                ('NumberLogFileFull', DWORDLONG),
                # Age of oldest active transaction in the RM, in milliseconds.
                ('OldestTransactionAge', DWORDLONG),
                # Name of the RM.
                ('RMName', GUID),
                # string indicating the path to the RM's transaction manager's
                # log.
                ('TmLogPathOffset', DWORD),
            ]
            # == == == == == == == == == == == == FSCTL_TXFS_ROLLFORWARD_REDO
            # == == == == == == == == == == == ==
            # Structures for FSCTL_TXFS_ROLLFORWARD_REDO
            TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN = 0x01
            TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK = 0x02
            TXFS_ROLLFORWARD_REDO_VALID_FLAGS = (
                TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN |
                TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK
            )
            _TXFS_ROLLFORWARD_REDO_INFORMATION._fields_ = [
                ('LastVirtualClock', LARGE_INTEGER),
                ('LastRedoLsn', DWORDLONG),
                ('HighestRecoveryLsn', DWORDLONG),
                ('Flags', DWORD),
            ]

            if defined(DEPRECATE_SUPPORTED):
                if not defined(USE_TXF_DEPRECATED_FUNCTIONALITY):
                    pass
                # END IF
            # END IF

            # == == == == == == == == == == == == FSCTL_TXFS_START_RM == == ==
            # == == == == == == == == ==
            # Structures for FSCTL_TXFS_START_RM
            # Note that TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS
            # and
            # TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT are mutually
            # exclusive.
            # You can specify the log growth amount in number of containers or
            # as a percentage.
            # TXFS_START_RM_FLAG_CONTAINER_COUNT_MAX and
            # TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX
            # are mutually exclusive.
            # TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN and
            # TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN
            # are mutually exclusive.
            # TXFS_START_RM_FLAG_PREFER_CONSISTENCY and
            # TXFS_START_RM_FLAG_PREFER_AVAILABILITY
            # are mutually exclusive.
            # Optional parameters will have system-supplied defaults applied
            # if omitted.
            TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX = 0x00000001
            TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN = 0x00000002
            TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE = 0x00000004
            TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS = 0x00000008
            TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT = 0x00000010
            TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE = 0x00000020
            TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX = 0x00000040
            TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN = 0x00000080
            TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT = 0x00000200
            TXFS_START_RM_FLAG_LOGGING_MODE = 0x00000400
            TXFS_START_RM_FLAG_PRESERVE_CHANGES = 0x00000800
            TXFS_START_RM_FLAG_PREFER_CONSISTENCY = 0x00001000
            TXFS_START_RM_FLAG_PREFER_AVAILABILITY = 0x00002000
            TXFS_START_RM_VALID_FLAGS = (
                TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX |
                TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN |
                TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE |
                TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS |
                TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT |
                TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE |
                TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT |
                TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX |
                TXFS_START_RM_FLAG_LOGGING_MODE |
                TXFS_START_RM_FLAG_PRESERVE_CHANGES |
                TXFS_START_RM_FLAG_PREFER_CONSISTENCY |
                TXFS_START_RM_FLAG_PREFER_AVAILABILITY
            )

            _TXFS_START_RM_INFORMATION._fields_ = [
                # TXFS_START_RM_FLAG_* flags.
                ('Flags', DWORD),
                # RM log container size, in bytes. This parameter is optional.
                ('LogContainerSize', DWORDLONG),
                # RM minimum log container count. This parameter is optional.
                ('LogContainerCountMin', DWORD),
                # RM maximum log container count. This parameter is optional.
                ('LogContainerCountMax', DWORD),
                # optional.
                ('LogGrowthIncrement', DWORD),
                # RM log auto shrink percentage. This parameter is optional.
                ('LogAutoShrinkPercentage', DWORD),
                # value. This parameter is required.
                ('TmLogPathOffset', DWORD),
                # This parameter is required.
                ('TmLogPathLength', WORD),
                # and will default to TXFS_LOGGING_MODE_SIMPLE.
                ('LoggingMode', WORD),
                # is required.
                ('LogPathLength', WORD),
                # Reserved.
                ('Reserved', WORD),
                # This parameter is required.
                ('LogPath', WCHAR * 1),
            ]

            if defined(DEPRECATE_SUPPORTED):
                if not defined(USE_TXF_DEPRECATED_FUNCTIONALITY):
                    pass
                # END IF
            # END IF

            # == == == == == == == == == == == == FSCTL_TXFS_GET_METADATA_INFO
            # == == == == == == == == == == == ==
            # Structures for FSCTL_TXFS_GET_METADATA_INFO
            class TxfFileId(ctypes.Structure):
                pass


            TxfFileId._fields_ = [
                ('LowPart', LONGLONG),
                ('HighPart', LONGLONG),
            ]
            _TXFS_GET_METADATA_INFO_OUT.TxfFileId = TxfFileId

            _TXFS_GET_METADATA_INFO_OUT._fields_ = [
                # Returns the TxfId of the file referenced by the handle used
                # to call this routine.
                ('TxfFileId', _TXFS_GET_METADATA_INFO_OUT.TxfFileId),
                # The GUID of the transaction that has the file locked, if
                # applicable.
                ('LockingTransaction', GUID),
                # Returns the LSN for the most recent log record we've written
                # for the file.
                ('LastLsn', DWORDLONG),
                # Transaction state, a TXFS_TRANSACTION_STATE_* value.
                ('TransactionState', DWORD),
            ]

            # == == == == == == == == =
            # FSCTL_TXFS_LIST_TRANSACTION_LOCKED_FILES =
            # Structures for FSCTL_TXFS_LIST_TRANSACTION_LOCKED_FILES
            # TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_CREATED means the
            # reported name was created
            # in the locking transaction.
            # TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_DELETED means the
            # reported name was deleted
            # in the locking transaction.
            # Note that both flags may appear if the name was both created and
            # deleted in the same
            # transaction. In that case the FileName[] member will contain
            # only "\0", as there is
            # no meaningful name to report.
            TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_CREATED = 0x00000001
            TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_DELETED = 0x00000002

            _TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY._fields_ = [
                # structure to the next
                # TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY.
                ('Offset', DWORDLONG),
                # current name was deleted or created in the transaction.
                ('NameFlags', DWORD),
                # NTFS File ID of the file.
                ('FileId', LONGLONG),
                # Reserved.
                ('Reserved1', DWORD),
                ('Reserved2', DWORD),
                ('Reserved3', LONGLONG),
                # NULL-terminated Unicode path to this file, relative to RM
                # root.
                ('FileName', WCHAR * 1),
            ]

            _TXFS_LIST_TRANSACTION_LOCKED_FILES._fields_ = [
                # GUID name of the KTM transaction that files should be
                # enumerated from.
                ('KtmTransaction', GUID),
                # On output, the number of files involved in the transaction
                # on this RM.
                ('NumberOfFiles', DWORDLONG),
                # This value may change from call to call as the transaction
                # locks more files.
                ('BufferSizeRequired', DWORDLONG),
                # TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY.
                ('Offset', DWORDLONG),
            ]

            # == == == == == == == == == == FSCTL_TXFS_LIST_TRANSACTIONS == ==
            # == == == == == == == == ==
            # Structures for FSCTL_TXFS_LIST_TRANSACTIONS
            _TXFS_LIST_TRANSACTIONS_ENTRY._fields_ = [
                # Transaction GUID.
                ('TransactionId', GUID),
                # Transaction state, a TXFS_TRANSACTION_STATE_* value.
                ('TransactionState', DWORD),
                # Reserved fields
                ('Reserved1', DWORD),
                ('Reserved2', DWORD),
                ('Reserved3', LONGLONG),
            ]

            _TXFS_LIST_TRANSACTIONS._fields_ = [
                # On output, the number of transactions involved in this RM.
                ('NumberOfTransactions', DWORDLONG),
                # as transactions enter and exit the system.
                ('BufferSizeRequired', DWORDLONG),
            ]

            # == == == == == == == == == == FSCTL_TXFS_READ_BACKUP_INFORMATION
            # == == == == == == == == == == ==
            # Structures for FSCTL_TXFS_READ_BACKUP_INFORMATION
            if _MSC_VER  >= 1200:
                pass
            # END IF


            class DUMMYUNIONNAME(ctypes.Union):
                pass


            DUMMYUNIONNAME._fields_ = [
                # Used to return the required buffer size if return code is
                # STATUS_BUFFER_OVERFLOW
                ('BufferLength', DWORD),
                # On success the data is copied here.
                ('Buffer', BYTE * 1),
            ]
            _TXFS_READ_BACKUP_INFORMATION_OUT.DUMMYUNIONNAME = DUMMYUNIONNAME

            _TXFS_READ_BACKUP_INFORMATION_OUT._fields_ = [
                ('DUMMYUNIONNAME', _TXFS_READ_BACKUP_INFORMATION_OUT.DUMMYUNIONNAME),
            ]
            if _MSC_VER  >= 1200:
                pass
            else:
                pass
            # END IF

            # == == == == == == == == == ==
            # FSCTL_TXFS_WRITE_BACKUP_INFORMATION ==
            # Structures for FSCTL_TXFS_WRITE_BACKUP_INFORMATION
            _TXFS_WRITE_BACKUP_INFORMATION._fields_ = [
                # FSCTL_TXFS_READ_BACKUP_INFORMATION goes here.
                ('Buffer', BYTE * 1),
            ]

            # == == == == == == == == == == FSCTL_TXFS_GET_TRANSACTED_VERSION
            # == == == == == == == == == == ==
            # Output structure for FSCTL_TXFS_GET_TRANSACTED_VERSION
            TXFS_TRANSACTED_VERSION_NONTRANSACTED = 0xFFFFFFFE
            TXFS_TRANSACTED_VERSION_UNCOMMITTED = 0xFFFFFFFF

            _TXFS_GET_TRANSACTED_VERSION._fields_ = [
                # transactional writer handles.
                ('ThisBaseVersion', DWORD),
                # The most recent committed version available.
                ('LatestVersion', DWORD),
                # If it is not a handle to a minivers, this field will be 0.
                ('ThisMiniVersion', WORD),
                # visible to the transaction bound to this handle, this field
                # will be zero.
                ('FirstMiniVersion', WORD),
                # visible to the transaction bound to this handle, this field
                # will be zero.
                ('LatestMiniVersion', WORD),
            ]

            # == == == == == == == == == == FSCTL_TXFS_SAVEPOINT_INFORMATION
            # == == == == == == == == == == ==
            # Structures for FSCTL_TXFS_SAVEPOINT_INFORMATION
            # Note that the TXFS_SAVEPOINT_INFORMATION structure is both and
            # in and out structure.
            # The KtmTransaction and ActionCode members are always
            # in-parameters, and the SavepointId
            # member is either an in-parameter, an out-parameter, or not used
            # (see its definition below).
            # Create a new savepoint.
            TXFS_SAVEPOINT_SET = 0x00000001

            # Roll back to a specified savepoint.
            TXFS_SAVEPOINT_ROLLBACK = 0x00000002

            # Clear (make unavailable for rollback) the most recently set
            # savepoint
            # that has not yet been cleared.
            TXFS_SAVEPOINT_CLEAR = 0x00000004

            # Clear all savepoints from the transaction.
            TXFS_SAVEPOINT_CLEAR_ALL = 0x00000010

            _TXFS_SAVEPOINT_INFORMATION._fields_ = [
                # Handle to the transaction on which to perform the savepoint
                # operation.
                ('KtmTransaction', HANDLE),
                # Specifies the savepoint action to take. A TXFS_SAVEPOINT_*
                # value.
                ('ActionCode', DWORD),
                # Not used for TXFS_CLEAR_SAVEPOINT or
                # TXFS_CLEAR_ALL_SAVEPOINTS.
                ('SavepointId', DWORD),
            ]

            if defined(DEPRECATE_SUPPORTED):
                if not defined(USE_TXF_DEPRECATED_FUNCTIONALITY):
                    pass
                # END IF
            # END IF

            # == == == == == == == == == == FSCTL_TXFS_CREATE_MINIVERSION ==
            # == == == == == == == == == ==
            # Structures for FSCTL_TXFS_CREATE_MINIVERSION
            # Only an out parameter is necessary. That returns the identifier
            # of the new miniversion created.
            _TXFS_CREATE_MINIVERSION_INFO._fields_ = [
                ('StructureVersion', WORD),
                ('StructureLength', WORD),
                # The base version for the newly created miniversion.
                ('BaseVersion', DWORD),
                # The miniversion that was just created.
                ('MiniVersion', WORD),
            ]

            if defined(DEPRECATE_SUPPORTED):
                if not defined(USE_TXF_DEPRECATED_FUNCTIONALITY):
                    pass
                # END IF
            # END IF

            # == == == == == == == == == == FSCTL_TXFS_TRANSACTION_ACTIVE ==
            # == == == == == == == == == ==
            # Structure for FSCTL_TXFS_TRANSACTION_ACTIVE
            _TXFS_TRANSACTION_ACTIVE_INFO._fields_ = [
                # Whether or not the volume had active transactions when this
                # snapshot was taken.
                ('TransactionsActiveAtSnapshot', BOOLEAN),
            ]
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_VISTA

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN7:
            # == == == == == == == == == == == = FSCTL_GET_BOOT_AREA_INFO ==
            # == == == == == == == == == == == ==
            # Output structure for FSCTL_GET_BOOT_AREA_INFO
            class BootSectors(ctypes.Structure):
                pass


            BootSectors._fields_ = [
                ('Offset', LARGE_INTEGER),
            ]
            _BOOT_AREA_INFO.BootSectors = BootSectors

            _BOOT_AREA_INFO._fields_ = [
                # the count of boot sectors present on the file system
                ('BootSectorCount', DWORD),
                ('BootSectors', _BOOT_AREA_INFO.BootSectors * 2),
            ]

            # == == == == == == == == == == FSCTL_GET_RETRIEVAL_POINTER_BASE
            # == == == == == == == == == == ==
            # Output structure for FSCTL_GET_RETRIEVAL_POINTER_BASE
            _RETRIEVAL_POINTER_BASE._fields_ = [
                # sector offset to the first allocatable unit on the filesystem
                ('FileAreaOffset', LARGE_INTEGER),
            ]

            # == == == == == == == == == ==
            # FSCTL_QUERY_PERSISTENT_VOLUME_STATE
            # == == == == == == == == == == FSCTL_SET_PERSISTENT_VOLUME_STATE
            # == == == == == == == == == == ==
            # Structure for FSCTL_SET_PERSISTENT_VOLUME_STATE and
            # FSCTL_GET_PERSISTENT_VOLUME_STATE. The initial version will be
            # 1.0
            _FILE_FS_PERSISTENT_VOLUME_INFORMATION._fields_ = [
                ('VolumeFlags', DWORD),
                ('FlagMask', DWORD),
                ('Version', DWORD),
                ('Reserved', DWORD),
            ]

            # VolumeFlags values
            PERSISTENT_VOLUME_STATE_SHORT_NAME_CREATION_DISABLED = 0x00000001
            if _WIN32_WINNT  >= _WIN32_WINNT_WIN8:
                PERSISTENT_VOLUME_STATE_VOLUME_SCRUB_DISABLED = 0x00000002
            # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WIN8)

            if _WIN32_WINNT  >= _WIN32_WINNT_WINBLUE:
                # Persistent volume flags to control the file systems' storage
                # tiering
                # awareness.
                PERSISTENT_VOLUME_STATE_GLOBAL_METADATA_NO_SEEK_PENALTY = (
                    0x00000004
                )
                PERSISTENT_VOLUME_STATE_LOCAL_METADATA_NO_SEEK_PENALTY = (
                    0x00000008
                )
                PERSISTENT_VOLUME_STATE_NO_HEAT_GATHERING = 0x00000010
            # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WINBLUE)

            # These are flags that define a volume's dependency on WimBoot
            # file.
            if _WIN32_WINNT  >= _WIN32_WINNT_WIN7:
                # The volume backs a system critical volume, typically the one
                # that has wimboot
                # image file serving the system files
                PERSISTENT_VOLUME_STATE_CONTAINS_BACKING_WIM = 0x00000020

                # The volume is backed by other volume that actually has the
                # system files.
                # And hence this relies on the other volume being present in
                # order for the sytem to boot up.
                PERSISTENT_VOLUME_STATE_BACKED_BY_WIM = 0x00000040
            # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WIN7)

            if _WIN32_WINNT  >= _WIN32_WINNT_WINTHRESHOLD:
                # Writes dynamic redirection on tiered volumes will be disabled
                PERSISTENT_VOLUME_STATE_NO_WRITE_AUTO_TIERING = 0x00000080
            # END IF   #if (_WIN32_WINNT  >= _WIN32_WINNT_WINTHRESHOLD)

            if _WIN32_WINNT  >= _WIN32_WINNT_WINTHRESHOLD:
                # Disable txf on volume
                PERSISTENT_VOLUME_STATE_TXF_DISABLED = 0x00000100
            # END IF   #if (_WIN32_WINNT  >= _WIN32_WINNT_WINTHRESHOLD)

            # == == == == == == == == == ==
            # FSCTL_QUERY_FILE_SYSTEM_RECOGNITION
            # Structure for FSCTL_QUERY_FILE_SYSTEM_RECOGNITION
            _FILE_SYSTEM_RECOGNITION_INFORMATION._fields_ = [
                ('FileSystem', CHAR * 9),
            ]

            # == == == == == == == == == == == == == = FSCTL_REQUEST_OPLOCK ==
            # == == == == == == == == == == == == =
            # Structures for FSCTL_REQUEST_OPLOCK
            OPLOCK_LEVEL_CACHE_READ = 0x00000001
            OPLOCK_LEVEL_CACHE_HANDLE = 0x00000002
            OPLOCK_LEVEL_CACHE_WRITE = 0x00000004
            REQUEST_OPLOCK_INPUT_FLAG_REQUEST = 0x00000001
            REQUEST_OPLOCK_INPUT_FLAG_ACK = 0x00000002
            REQUEST_OPLOCK_INPUT_FLAG_COMPLETE_ACK_ON_CLOSE = 0x00000004
            REQUEST_OPLOCK_CURRENT_VERSION = 1

            _REQUEST_OPLOCK_INPUT_BUFFER._fields_ = [
                # This should be set to REQUEST_OPLOCK_CURRENT_VERSION.
                ('StructureVersion', WORD),
                ('StructureLength', WORD),
                # One or more OPLOCK_LEVEL_CACHE_* values to indicate the
                # desired level of the oplock.
                ('RequestedOplockLevel', DWORD),
                # REQUEST_OPLOCK_INPUT_FLAG_* flags.
                ('Flags', DWORD),
            ]
            REQUEST_OPLOCK_OUTPUT_FLAG_ACK_REQUIRED = 0x00000001
            REQUEST_OPLOCK_OUTPUT_FLAG_MODES_PROVIDED = 0x00000002

            _REQUEST_OPLOCK_OUTPUT_BUFFER._fields_ = [
                # This should be set to REQUEST_OPLOCK_CURRENT_VERSION.
                ('StructureVersion', WORD),
                ('StructureLength', WORD),
                # was just broken.
                ('OriginalOplockLevel', DWORD),
                # on the operation returning this buffer.
                ('NewOplockLevel', DWORD),
                # REQUEST_OPLOCK_OUTPUT_FLAG_* flags.
                ('Flags', DWORD),
                # contain the access mode and share mode of the request that
                # is causing the break.
                ('AccessMode', ACCESS_MASK),
                ('ShareMode', WORD),
            ]

            # == == == == == == == == == == == = FSCTL_QUERY_DEPENDENT_VOLUME
            # == == == == == == == == == == == =
            if not defined(_VIRTUAL_STORAGE_TYPE_DEFINED):
                _VIRTUAL_STORAGE_TYPE_DEFINED = VOID

                _VIRTUAL_STORAGE_TYPE._fields_ = [
                    ('DeviceId', DWORD),
                    ('VendorId', GUID),
                ]
            # END IF

            # These structures are used by the FSCTL_QUERY_DEPENDENT_VOLUME
            _STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST._fields_ = [
                ('RequestLevel', DWORD),
                ('RequestFlags', DWORD),
            ]
            QUERY_DEPENDENT_VOLUME_REQUEST_FLAG_HOST_VOLUMES = 0x1
            QUERY_DEPENDENT_VOLUME_REQUEST_FLAG_GUEST_VOLUMES = 0x2

            _STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY._fields_ = [
                ('EntryLength', DWORD),
                ('DependencyTypeFlags', DWORD),
                ('ProviderSpecificFlags', DWORD),
                ('VirtualStorageType', VIRTUAL_STORAGE_TYPE),
            ]

            _STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY._fields_ = [
                ('EntryLength', DWORD),
                ('DependencyTypeFlags', DWORD),
                ('ProviderSpecificFlags', DWORD),
                ('VirtualStorageType', VIRTUAL_STORAGE_TYPE),
                # Root parent is 0, every child level after that is incremented
                ('AncestorLevel', DWORD),
                ('HostVolumeNameOffset', DWORD),
                ('HostVolumeNameSize', DWORD),
                ('DependentVolumeNameOffset', DWORD),
                ('DependentVolumeNameSize', DWORD),
                ('RelativePathOffset', DWORD),
                ('RelativePathSize', DWORD),
                ('DependentDeviceNameOffset', DWORD),
                ('DependentDeviceNameSize', DWORD),
            ]

            if defined(_MSC_EXTENSIONS):
                if _MSC_VER >= 1200:
                    pass
                # END IF

                class DUMMYUNIONNAME(ctypes.Union):
                    pass


                DUMMYUNIONNAME._fields_ = [
                    ('Lev1Depends', STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY * 0),
                    ('Lev2Depends', STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY * 0),
                ]
                _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE.DUMMYUNIONNAME = DUMMYUNIONNAME

                _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE._fields_ = [
                    ('ResponseLevel', DWORD),
                    ('NumberEntries', DWORD),
                    ('DUMMYUNIONNAME', _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE.DUMMYUNIONNAME),
                ]
                if _MSC_VER  >= 1200:
                    pass
                # END IF

            # END IF

            # == == == == == == == == == == == == == FSCTL_SD_GLOBAL_CHANGE ==
            # == == == == == == == == == == == ==
            # Structures for FSCTL_SD_GLOBAL_CHANGE
            # list of operations supported
            SD_GLOBAL_CHANGE_TYPE_MACHINE_SID = 1
            SD_GLOBAL_CHANGE_TYPE_QUERY_STATS = 1 << 16
            SD_GLOBAL_CHANGE_TYPE_ENUM_SDS = 2 << 16

            # Operation specific structures for
            # SD_GLOBAL_CHANGE_TYPE_MACHINE_SID
            _SD_CHANGE_MACHINE_SID_INPUT._fields_ = [
                # structure.
                ('CurrentMachineSIDOffset', WORD),
                ('CurrentMachineSIDLength', WORD),
                # structure.
                ('NewMachineSIDOffset', WORD),
                ('NewMachineSIDLength', WORD),
            ]

            _SD_CHANGE_MACHINE_SID_OUTPUT._fields_ = [
                # How many entries were successfully changed in the $Secure
                # stream
                ('NumSDChangedSuccess', DWORDLONG),
                # How many entries failed the update in the $Secure stream
                ('NumSDChangedFail', DWORDLONG),
                # How many entries are unused in the current security stream
                ('NumSDUnused', DWORDLONG),
                # The total number of entries processed in the $Secure stream
                ('NumSDTotal', DWORDLONG),
                # How many entries were successfully changed in the $MFT file
                ('NumMftSDChangedSuccess', DWORDLONG),
                # How many entries failed the update in the $MFT file
                ('NumMftSDChangedFail', DWORDLONG),
                # Total number of entriess process in the $MFT file
                ('NumMftSDTotal', DWORDLONG),
            ]

            # Operation specific structures for
            # SD_GLOBAL_CHANGE_TYPE_QUERY_STATS
            _SD_QUERY_STATS_INPUT._fields_ = [
                ('Reserved', DWORD),
            ]

            _SD_QUERY_STATS_OUTPUT._fields_ = [
                # data stream ($Secure:$SDS).
                ('SdsStreamSize', DWORDLONG),
                ('SdsAllocationSize', DWORDLONG),
                # stream ($Secure:$SII).
                ('SiiStreamSize', DWORDLONG),
                ('SiiAllocationSize', DWORDLONG),
                # hash index stream ($Secure:$SDH).
                ('SdhStreamSize', DWORDLONG),
                ('SdhAllocationSize', DWORDLONG),
                # stream.
                ('NumSDTotal', DWORDLONG),
                # stream.
                ('NumSDUnused', DWORDLONG),
            ]

            # Operation specific structures for SD_GLOBAL_CHANGE_TYPE_ENUM_SDS
            _SD_ENUM_SDS_INPUT._fields_ = [
                # offset.
                ('StartingOffset', DWORDLONG),
                # a time. Set to 0 for no max.
                ('MaxSDEntriesToReturn', DWORDLONG),
            ]

            _SD_ENUM_SDS_ENTRY._fields_ = [
                # Hash value of the security decriptor.
                ('Hash', DWORD),
                # SecurityId for the security descriptor.
                ('SecurityId', DWORD),
                # data stream.
                ('Offset', DWORDLONG),
                # header.
                ('Length', DWORD),
                # Actual security decriptor, variable length.
                ('Descriptor', BYTE * 1),
            ]

            _SD_ENUM_SDS_OUTPUT._fields_ = [
                # structure.
                ('NextOffset', DWORDLONG),
                # The total number of entries returned.
                ('NumSDEntriesReturned', DWORDLONG),
                # The total number of bytes of entries returned.
                ('NumSDBytesReturned', DWORDLONG),
                # will be aligned to a 16-byte boundary.)
                ('SDEntry', SD_ENUM_SDS_ENTRY * 1),
            ]

            # Generic INPUT & OUTPUT structures for FSCTL_SD_GLOBAL_CHANGE
            if _MSC_VER  >= 1200:
                pass
            # END IF


            class DUMMYUNIONNAME(ctypes.Union):
                pass


            DUMMYUNIONNAME._fields_ = [
                ('SdChange', SD_CHANGE_MACHINE_SID_INPUT),
                ('SdQueryStats', SD_QUERY_STATS_INPUT),
                ('SdEnumSds', SD_ENUM_SDS_INPUT),
            ]
            _SD_GLOBAL_CHANGE_INPUT.DUMMYUNIONNAME = DUMMYUNIONNAME

            _SD_GLOBAL_CHANGE_INPUT._fields_ = [
                # Input flags (none currently defined)
                ('Flags', DWORD),
                # of the below union is in use.
                ('ChangeType', DWORD),
                ('DUMMYUNIONNAME', _SD_GLOBAL_CHANGE_INPUT.DUMMYUNIONNAME),
            ]


            class DUMMYUNIONNAME(ctypes.Union):
                pass


            DUMMYUNIONNAME._fields_ = [
                ('SdChange', SD_CHANGE_MACHINE_SID_OUTPUT),
                ('SdQueryStats', SD_QUERY_STATS_OUTPUT),
                ('SdEnumSds', SD_ENUM_SDS_OUTPUT),
            ]
            _SD_GLOBAL_CHANGE_OUTPUT.DUMMYUNIONNAME = DUMMYUNIONNAME

            _SD_GLOBAL_CHANGE_OUTPUT._fields_ = [
                # Output State Flags (none currently defined)
                ('Flags', DWORD),
                # Specifies which below union to use
                ('ChangeType', DWORD),
                ('DUMMYUNIONNAME', _SD_GLOBAL_CHANGE_OUTPUT.DUMMYUNIONNAME),
            ]

            if _MSC_VER  >= 1200:
                pass
            else:
                pass
            # END IF

            # == == == == == == == == == == FSCTL_LOOKUP_STREAM_FROM_CLUSTER
            # == == == == == == == == == == == =
            _LOOKUP_STREAM_FROM_CLUSTER_INPUT._fields_ = [
                # Flags for the operation. Currently no flags are defined.
                ('Flags', DWORD),
                # number or the operation will fail.
                ('NumberOfClusters', DWORD),
                # An array of one or more clusters to look up.
                ('Cluster', LARGE_INTEGER * 1),
            ]

            _LOOKUP_STREAM_FROM_CLUSTER_OUTPUT._fields_ = [
                # returned. If no entries are returned, this value is zero.
                ('Offset', DWORD),
                # enough.
                ('NumberOfMatches', DWORD),
                # contain all matching entries to the input criteria.
                ('BufferSizeRequired', DWORD),
            ]
            LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_PAGE_FILE = 0x00000001
            LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_DENY_DEFRAG_SET = 0x00000002
            LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_FS_SYSTEM_FILE = 0x00000004
            LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_TXF_SYSTEM_FILE = 0x00000008
            LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_MASK = 0xFF000000
            LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_DATA = 0x01000000
            LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_INDEX = 0x02000000
            LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_SYSTEM = 0x03000000

            _LOOKUP_STREAM_FROM_CLUSTER_ENTRY._fields_ = [
                # returned. If there are no more entries, this value is zero.
                ('OffsetToNext', DWORD),
                # Flags describing characteristics about this stream.
                ('Flags', DWORD),
                # This value is reserved and is currently zero.
                ('Reserved', LARGE_INTEGER),
                # of the clusters passed in the input structure.
                ('Cluster', LARGE_INTEGER),
                # cluster.
                ('FileName', WCHAR * 1),
            ]

            # == == == == == == == == == == FSCTL_FILE_TYPE_NOTIFICATION == ==
            # == == == == == == == == == =
            # This is the structure for the FSCTL_FILE_TYPE_NOTIFICATION
            # operation.
            # Its purpose is to notify the storage stack about the extents of
            # certain
            # types of files. This is only callable from kernel mode
            _FILE_TYPE_NOTIFICATION_INPUT._fields_ = [
                # FILE_TYPE_NOTIFICATION_FLAG_*
                ('Flags', DWORD),
                # A count of how many FileTypeID guids are given
                ('NumFileTypeIDs', DWORD),
                # This is a unique identifer for the type of file notification
                # occuring
                ('FileTypeID', GUID * 1),
            ]

            # Flags for the given operation
            # Set when adding the specified usage on the given file
            FILE_TYPE_NOTIFICATION_FLAG_USAGE_BEGIN = 0x00000001

            # Set when removing the specified usage on the given file
            FILE_TYPE_NOTIFICATION_FLAG_USAGE_END = 0x00000002

            # These are the globally defined file types
            FILE_TYPE_NOTIFICATION_GUID_PAGE_FILE = DEFINE_GUID(
                0x0D0A64A1,
                0x38FC,
                0x4DB8,
                0x9F,
                0xE7,
                0x3F,
                0x43,
                0x52,
                0xCD,
                0x7C,
                0x5C
            )
            FILE_TYPE_NOTIFICATION_GUID_HIBERNATION_FILE = DEFINE_GUID(
                0xB7624D64,
                0xB9A3,
                0x4CF8,
                0x80,
                0x11,
                0x5B,
                0x86,
                0xC9,
                0x40,
                0xE7,
                0xB7
            )
            FILE_TYPE_NOTIFICATION_GUID_CRASHDUMP_FILE = DEFINE_GUID(
                0x9D453EB7,
                0xD2A6,
                0x4DBD,
                0xA2,
                0xE3,
                0xFB,
                0xD0,
                0xED,
                0x91,
                0x09,
                0xA9
            )

            # == == == == == == == == == == == == =FSCTL_CSV_MGMT_LOCK == ==
            # == == == == == == == == == == == =
            CSV_MGMTLOCK_CHECK_VOLUME_REDIRECTED = 0x00000001

            _CSV_MGMT_LOCK._fields_ = [
                ('Flags', DWORD),
            ]

            # == == == == == == == == == == == == = FSCTL_IS_CSV_FILE == == ==
            # == == == == == == == == == == ==
            # Structure for FSCTL_IS_CSV_FILE
            _CSV_NAMESPACE_INFO._fields_ = [
                ('Version', DWORD),
                ('DeviceNumber', DWORD),
                ('StartingOffset', LARGE_INTEGER),
                ('SectorSize', DWORD),
            ]
            CSV_NAMESPACE_INFO_V1 = ctypes.sizeof(CSV_NAMESPACE_INFO)
            CSV_INVALID_DEVICE_NUMBER = 0xFFFFFFFF

            # == == == == == == == == == == == == = FSCTL_CSV_CONTROL == == ==
            # == == == == == == == == == == == =
            class _CSV_CONTROL_OP(ENUM):
                CsvControlStartRedirectFile = 0x02
                CsvControlStopRedirectFile = 0x03
                CsvControlQueryRedirectState = 0x04
                CsvControlQueryFileRevision = 0x06
                CsvControlQueryMdsPath = 0x08
                CsvControlQueryFileRevisionFileId128 = 0x09
                CsvControlQueryVolumeRedirectState = 0x0A
                CsvControlEnableUSNRangeModificationTracking = 0x0D
                CsvControlMarkHandleLocalVolumeMount = 0x0E
                CsvControlUnmarkHandleLocalVolumeMount = 0x0F
                CsvControlGetCsvFsMdsPathV2 = 0x12
                CsvControlDisableCaching = 0x13
                CsvControlEnableCaching = 0x14

            CSV_CONTROL_OP = _CSV_CONTROL_OP
            PCSV_CONTROL_OP = POINTER(_CSV_CONTROL_OP)

            _CSV_CONTROL_PARAM._fields_ = [
                ('Operation', CSV_CONTROL_OP),
                ('Unused', LONGLONG),
            ]

            # Output for the CsvControlQueryRedirectState
            _CSV_QUERY_REDIRECT_STATE._fields_ = [
                ('MdsNodeId', DWORD),
                ('DsNodeId', DWORD),
                ('FileRedirected', BOOLEAN),
            ]

            # Output for the CsvControlQueryFileRevision
            # Note that revision tracking is per file, and not per
            # stream so it changes every time one of the stream
            # changes.
            _CSV_QUERY_FILE_REVISION._fields_ = [
                # NTFS File Id
                ('FileId', LONGLONG),
                # assume that the file was modified
                ('FileRevision', LONGLONG * 3),
            ]

            # Output for the CsvControlQueryFileRevisionFileId128
            # Note that revision tracking is per file, and not per
            # stream so it changes every time one of the stream
            # changes.
            _CSV_QUERY_FILE_REVISION_FILE_ID_128._fields_ = [
                # File Id
                ('FileId', FILE_ID_128),
                # assume that the file was modified
                ('FileRevision', LONGLONG * 3),
            ]

            # Output for the CsvControlQueryMdsPath
            # This control returns the path that is used by CSV to
            # communicate to the MDS
            _CSV_QUERY_MDS_PATH._fields_ = [
                ('MdsNodeId', DWORD),
                ('DsNodeId', DWORD),
                ('PathLength', DWORD),
                ('Path', WCHAR * 1),
            ]


            class _CSVFS_DISK_CONNECTIVITY(ENUM):
                CsvFsDiskConnectivityNone = 0
                CsvFsDiskConnectivityMdsNodeOnly = 1
                CsvFsDiskConnectivitySubsetOfNodes = 2
                CsvFsDiskConnectivityAllNodes = 3

            CSVFS_DISK_CONNECTIVITY = _CSVFS_DISK_CONNECTIVITY
            PCSVFS_DISK_CONNECTIVITY = POINTER(_CSVFS_DISK_CONNECTIVITY)

            # Output for the CsvControlQueryVolumeRedirectState
            _CSV_QUERY_VOLUME_REDIRECT_STATE._fields_ = [
                ('MdsNodeId', DWORD),
                ('DsNodeId', DWORD),
                ('IsDiskConnected', BOOLEAN),
                ('ClusterEnableDirectIo', BOOLEAN),
                ('DiskConnectivity', CSVFS_DISK_CONNECTIVITY),
            ]

            # Structure is defined up to and including field PathLength
            CSV_QUERY_MDS_PATH_V2_VERSION_1 = 1
            CSV_QUERY_MDS_PATH_FLAG_STORAGE_ON_THIS_NODE_IS_CONNECTED = 0x1
            CSV_QUERY_MDS_PATH_FLAG_CSV_DIRECT_IO_ENABLED = 0x2
            CSV_QUERY_MDS_PATH_FLAG_SMB_BYPASS_CSV_ENABLED = 0x4

            # Output for the CsvControlGetCsvFsMdsPathV2
            _CSV_QUERY_MDS_PATH_V2._fields_ = [
                # CSV_QUERY_MDS_PATH_V2_VERSION_*
                ('Version', LONGLONG),
                # all the data
                ('RequiredSize', DWORD),
                # otherwise current node is a DS
                ('MdsNodeId', DWORD),
                ('DsNodeId', DWORD),
                # A combination of CSV_QUERY_MDS_PATH_FLAG_* flags
                ('Flags', DWORD),
                # Describes disk connectivity across all cluster nodes
                ('DiskConnectivity', CSVFS_DISK_CONNECTIVITY),
                # Volume GUID of this CSV volume
                ('VolumeId', GUID),
                # number of elements is IpAddressLength /
                # (ctypes.sizeof(SOCKADDR_INET)
                ('IpAddressOffset', DWORD),
                ('IpAddressLength', DWORD),
                # characters in that string
                ('PathOffset', DWORD),
                ('PathLength', DWORD),
            ]
            # == == == == == == == == == == ==
            # FSCTL_CSV_QUERY_VETO_FILE_DIRECT_IO == =
            # In output buffer set Veto to TRUE to prevent CsvFs from
            # performing DirectIO on the stream.
            # VetoedFromAltitude and Reason are optional fields that
            # are used to help with troubleshooting. CSV writes these
            # strings to the diagnostic log. Filter can set it to a
            # string that would hint why volume is in a redirected mode.
            _CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT._fields_ = [
                ('VetoedFromAltitudeIntegral', DWORDLONG),
                ('VetoedFromAltitudeDecimal', DWORDLONG),
                ('Reason', WCHAR * 256),
            ]
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN7
        if _WIN32_WINNT  >= _WIN32_WINNT_WIN8:
            # == == == == == == == == == == == == =
            # FSCTL_IS_VOLUME_OWNED_BYCSVFS = ==
            _CSV_IS_OWNED_BY_CSVFS._fields_ = [
                ('OwnedByCSVFS', BOOLEAN),
            ]

            # == == == == == == == == == == == == FSCTL_FILE_LEVEL_TRIM == ==
            # == == == == == == == == == == == =
            # Structure defintions for supporint file level trim
            _FILE_LEVEL_TRIM_RANGE._fields_ = [
                # Bytes offset from the front of the given file to trim at
                ('Offset', DWORDLONG),
                # Length in bytes to trim from the given offset
                ('Length', DWORDLONG),
            ]

            # Input buffer defining what ranges to trim
            _FILE_LEVEL_TRIM._fields_ = [
                # similar.
                ('Key', DWORD),
                # A count of how many Offset:Length pairs are given
                ('NumRanges', DWORD),
                # All the pairs.
                ('Ranges', FILE_LEVEL_TRIM_RANGE * 1),
            ]

            # This is an optional output buffer
            _FILE_LEVEL_TRIM_OUTPUT._fields_ = [
                # that were processed
                ('NumRangesProcessed', DWORD),
            ]

            # == == == == == == == == == == FSCTL_QUERY_FILE_LAYOUT == == ==
            # == == == == == == == == == == =
            # Clear the state of the internal cursor.
            QUERY_FILE_LAYOUT_RESTART = 0x00000001

            # Request that the API call retrieve name information for the
            # objects on the volume.
            QUERY_FILE_LAYOUT_INCLUDE_NAMES = 0x00000002

            # Request that the API call include streams of the file.
            QUERY_FILE_LAYOUT_INCLUDE_STREAMS = 0x00000004

            # Include extent information with the attribute entries, where
            # applicable.
            # Use of this flag requires the _INCLUDE_STREAMS flag.
            QUERY_FILE_LAYOUT_INCLUDE_EXTENTS = 0x00000008

            # Include extra information, such as modification times and
            # security
            # IDs, with each returned file layout entry.
            QUERY_FILE_LAYOUT_INCLUDE_EXTRA_INFO = 0x00000010

            # Include unallocated attributes in the enumeration, which in NTFS
            # means one
            # of two cases:
            # 1. Resident attributes.
            # 2. Compressed or sparse nonresident attributes with no physical
            # allocation (consisting only of a sparse hole).
            # This flag may only be used when no cluster ranges are specified
            # (i. e.
            # on a whole-volume query).
            QUERY_FILE_LAYOUT_INCLUDE_STREAMS_WITH_NO_CLUSTERS_ALLOCATED = (
                0x00000020
            )

            # Request the full path to the file be included in the file name.
            # This flag must be used with QUERY_FILE_LAYOUT_INCLUDE_NAMES
            QUERY_FILE_LAYOUT_INCLUDE_FULL_PATH_IN_NAMES = 0x00000040

            # Enable QueryFileLayout to include information on attribute
            # streams.
            # Additionally, individual stream information flags must be
            # enabled for
            # information on a given stream to be returned.
            QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION = 0x00000080

            # Have QueryFileLayout include information on DSC streams.
            # This flag must be used in conjunction with
            # QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION
            QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_DSC_ATTRIBUTE = (
                0x00000100
            )

            # Have QueryFileLayout include information on TxF streams.
            # This flag must be used in conjunction with
            # QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION
            QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_TXF_ATTRIBUTE = (
                0x00000200
            )

            # Have QueryFileLayout include information on EFS streams.
            # This flag must be used in conjunction with
            # QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION
            QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_EFS_ATTRIBUTE = (
                0x00000400
            )

            # We can ask (politely) QueryFileLayout to only return files that
            # have
            # a given set of attributes present. This flag must be used with
            # at least
            # one attribute type flag or Query File Layout will return no
            # files.
            QUERY_FILE_LAYOUT_INCLUDE_ONLY_FILES_WITH_SPECIFIC_ATTRIBUTES = (
                0x00000800
            )

            # Have QueryFileLayout include files with a DSC attribute in the
            # output buffer.
            # This must be used in conjunction with
            # QUERY_FILE_LAYOUT_INCLUDE_ONLY_FILES_WITH_SPECIFIC_ATTRIBUTES
            QUERY_FILE_LAYOUT_INCLUDE_FILES_WITH_DSC_ATTRIBUTE = 0x00001000


            class _QUERY_FILE_LAYOUT_FILTER_TYPE(ENUM):
                QUERY_FILE_LAYOUT_FILTER_TYPE_NONE = 0
                QUERY_FILE_LAYOUT_FILTER_TYPE_CLUSTERS = 1
                QUERY_FILE_LAYOUT_FILTER_TYPE_FILEID = 2
                QUERY_FILE_LAYOUT_NUM_FILTER_TYPES = 3

            QUERY_FILE_LAYOUT_FILTER_TYPE = _QUERY_FILE_LAYOUT_FILTER_TYPE

            _CLUSTER_RANGE._fields_ = [
                # (inclusive).
                ('StartingCluster', LARGE_INTEGER),
                # The length of the cluster region.
                ('ClusterCount', LARGE_INTEGER),
            ]

            _FILE_REFERENCE_RANGE._fields_ = [
                # query region (inclusive).
                ('StartingFileReferenceNumber', DWORDLONG),
                # query region (inclusive).
                ('EndingFileReferenceNumber', DWORDLONG),
            ]


            class Filter(ctypes.Union):
                pass


            Filter._fields_ = [
                ('ClusterRanges', CLUSTER_RANGE * 1),
                ('FileReferenceRanges', FILE_REFERENCE_RANGE * 1),
            ]
            _QUERY_FILE_LAYOUT_INPUT.Filter = Filter
            _QUERY_FILE_LAYOUT_INPUT._fields_ = [
                # number or the operation will fail.
                ('NumberOfPairs', DWORD),
                # Flags for the operation.
                ('Flags', DWORD),
                # The type of filter being applied for this operation.
                ('FilterType', QUERY_FILE_LAYOUT_FILTER_TYPE),
                # Reserved for future use. Should be set to zero.
                ('Reserved', DWORD),
                # the caller's actual set of cluster ranges or filter ranges.
                ('Filter', _QUERY_FILE_LAYOUT_INPUT.Filter),
            ]
            # Indicates that the filesystem is returning stream extents in a
            # single-instanced fashion.
            QUERY_FILE_LAYOUT_SINGLE_INSTANCED = 0x00000001
            _QUERY_FILE_LAYOUT_OUTPUT._fields_ = [
                # this iteration.
                ('FileEntryCount', DWORD),
                # expressed in bytes.
                ('FirstFileOffset', DWORD),
                # entire output set.
                ('Flags', DWORD),
                # For alignment/later use.
                ('Reserved', DWORD),
            ]
            _FILE_LAYOUT_ENTRY._fields_ = [
                # (current version number is 1).
                ('Version', DWORD),
                # or zero if this is the last entry.
                ('NextFileOffset', DWORD),
                # file.
                ('Flags', DWORD),
                # File attributes.
                ('FileAttributes', DWORD),
                # File ID for this file.
                ('FileReferenceNumber', DWORDLONG),
                # zero if there are no link records.
                ('FirstNameOffset', DWORD),
                # zero if there are no stream records.
                ('FirstStreamOffset', DWORD),
                # not returned.
                ('ExtraInfoOffset', DWORD),
                # For alignment/future use.
                ('Reserved', DWORD),
            ]
            # Each file name entry may be one, both, or neither of
            # these.
            FILE_LAYOUT_NAME_ENTRY_PRIMARY = 0x00000001
            FILE_LAYOUT_NAME_ENTRY_DOS = 0x00000002
            _FILE_LAYOUT_NAME_ENTRY._fields_ = [
                # or zero if this is the last entry.
                ('NextNameOffset', DWORD),
                # Flags for this file name entry.
                ('Flags', DWORD),
                # Parent FRN for this link.
                ('ParentFileReferenceNumber', DWORDLONG),
                # File name length (bytes).
                ('FileNameLength', DWORD),
                # For later use/alignment.
                ('Reserved', DWORD),
                # (NOT null-terminated).
                ('FileName', WCHAR * 1),
            ]


            class BasicInformation(ctypes.Structure):
                pass


            BasicInformation._fields_ = [
                ('CreationTime', LARGE_INTEGER),
                ('LastAccessTime', LARGE_INTEGER),
                ('LastWriteTime', LARGE_INTEGER),
                ('ChangeTime', LARGE_INTEGER),
                ('FileAttributes', DWORD),
            ]
            _FILE_LAYOUT_INFO_ENTRY.BasicInformation = BasicInformation

            _FILE_LAYOUT_INFO_ENTRY._fields_ = [
                # Basic information for this file.
                ('BasicInformation', _FILE_LAYOUT_INFO_ENTRY.BasicInformation),
                # Owner ID for this file.
                ('OwnerId', DWORD),
                # Security ID for this file.
                ('SecurityId', DWORD),
                # Update sequence number for this file.
                ('Usn', USN),
            ]

            # This attribute/stream is known to the filesystem to be immovable.
            STREAM_LAYOUT_ENTRY_IMMOVABLE = 0x00000001

            # This attribute/stream is currently pinned by another application.
            # It is unmovable for the duration of the pin.
            STREAM_LAYOUT_ENTRY_PINNED = 0x00000002

            # This attribute is resident.
            STREAM_LAYOUT_ENTRY_RESIDENT = 0x00000004

            # This attribute has no clusters allocated to it.
            STREAM_LAYOUT_ENTRY_NO_CLUSTERS_ALLOCATED = 0x00000008

            # This layout entry contains the information (data) for the
            # attribute
            STREAM_LAYOUT_ENTRY_HAS_INFORMATION = 0x00000010


            _STREAM_LAYOUT_ENTRY._fields_ = [
                # Version of this struct. Current version is 2.
                ('Version', DWORD),
                # Offset to the next stream entry (bytes).
                ('NextStreamOffset', DWORD),
                # FSCTL-specific flags.
                ('Flags', DWORD),
                # stream record.
                ('ExtentInformationOffset', DWORD),
                # in bytes.
                ('AllocationSize', LARGE_INTEGER),
                # End of file location as a byte offset.
                ('EndOfFile', LARGE_INTEGER),
                # content of the stream
                ('StreamInformationOffset', DWORD),
                # Attribute code.
                ('AttributeTypeCode', DWORD),
                # Stream attribute flags.
                ('AttributeFlags', DWORD),
                # Length of the stream identifier, in bytes.
                ('StreamIdentifierLength', DWORD),
                # buffer.
                ('StreamIdentifier', WCHAR * 1),
            ]

            # Flag noting that the extent information may be interpreted as
            # a RETRIEVAL_POINTERS_BUFFER structure
            STREAM_EXTENT_ENTRY_AS_RETRIEVAL_POINTERS = 0x00000001

            # Flag noting that all of the stream's extents are returned in
            # this structure, even if only some of them fall within the
            # caller's
            # specified interest region(s).
            STREAM_EXTENT_ENTRY_ALL_EXTENTS = 0x00000002


            class ExtentInformation(ctypes.Union):
                pass


            ExtentInformation._fields_ = [
                # will use.
                ('RetrievalPointers', RETRIEVAL_POINTERS_BUFFER),
            ]
            _STREAM_EXTENT_ENTRY.ExtentInformation = ExtentInformation

            _STREAM_EXTENT_ENTRY._fields_ = [
                # Extent-level flags for this entry.
                ('Flags', DWORD),
                ('ExtentInformation', _STREAM_EXTENT_ENTRY.ExtentInformation),
            ]

            # == == == == == == == == == == FSCTL_GET_INTEGRITY_INFORMATION /
            # FSCTL_SET_INTEGRITY_INFORMATION == == == == == == == == == == ==
            # == == =
            CHECKSUM_TYPE_UNCHANGED = -1
            CHECKSUM_TYPE_NONE = 0
            CHECKSUM_TYPE_CRC32 = 1
            CHECKSUM_TYPE_CRC64 = 2
            CHECKSUM_TYPE_ECC = 3
            CHECKSUM_TYPE_FIRST_UNUSED_TYPE = 4
            FSCTL_INTEGRITY_FLAG_CHECKSUM_ENFORCEMENT_OFF = 1

            # Checksum algorithm. e.g. CHECKSUM_TYPE_UNCHANGED,
            # CHECKSUM_TYPE_NONE, CHECKSUM_TYPE_CRC32
            _FSCTL_GET_INTEGRITY_INFORMATION_BUFFER._fields_ = [
                ('ChecksumAlgorithm', WORD),
                # Must be 0
                ('Reserved', WORD),
                # FSCTL_INTEGRITY_FLAG_xxx
                ('Flags', DWORD),
                ('ChecksumChunkSizeInBytes', DWORD),
                ('ClusterSizeInBytes', DWORD),
            ]

            # Checksum algorithm. e.g. CHECKSUM_TYPE_UNCHANGED,
            # CHECKSUM_TYPE_NONE, CHECKSUM_TYPE_CRC32
            _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER._fields_ = [
                ('ChecksumAlgorithm', WORD),
                # Must be 0
                ('Reserved', WORD),
                # FSCTL_INTEGRITY_FLAG_xxx
                ('Flags', DWORD),
            ]

            # == == == == == == == == == == FSCTL_SET_INTEGRITY_INFORMATION_EX
            # == == == == == == == == == == == == == =
            if _WIN32_WINNT  >= _WIN32_WINNT_WINTHRESHOLD:
                # 0 to disable integrity, 1 to enable integrity
                _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX._fields_ = [
                    ('EnableIntegrity', BYTE),
                    # 1 to keep the current integrity state and ignore the
                    # value in EnableIntegrity, 0 to use EnableIntegrity value
                    ('KeepIntegrityStateUnchanged', BYTE),
                    # Must be 0
                    ('Reserved', WORD),
                    # FSCTL_INTEGRITY_FLAG_xxx
                    ('Flags', DWORD),
                    # Structure version info, must be 1
                    ('Version', BYTE),
                    # Must be 0
                    ('Reserved2', BYTE * 7),
                ]
            # END IF   #if (_WIN32_WINNT  >= _WIN32_WINNT_WINTHRESHOLD)

            # == == == == == == == == == == == == FSCTL_OFFLOAD_READ == == ==
            # == == == == == == == == == == == ==
            # Structures used by FSCTL_OFFLOAD_READ operation
            _FSCTL_OFFLOAD_READ_INPUT._fields_ = [
                ('Size', DWORD),
                ('Flags', DWORD),
                # In milliseconds
                ('TokenTimeToLive', DWORD),
                ('Reserved', DWORD),
                ('FileOffset', DWORDLONG),
                ('CopyLength', DWORDLONG),
            ]

            _FSCTL_OFFLOAD_READ_OUTPUT._fields_ = [
                ('Size', DWORD),
                ('Flags', DWORD),
                ('TransferLength', DWORDLONG),
                ('Token', BYTE * 512),
            ]
            OFFLOAD_READ_FLAG_ALL_ZERO_BEYOND_CURRENT_RANGE = 1

            # == == == == == == == == == == == == FSCTL_OFFLOAD_WRITE == == ==
            # == == == == == == == == == == == =
            # Structures used by FSCTL_OFFLOAD_WRITE operation
            _FSCTL_OFFLOAD_WRITE_INPUT._fields_ = [
                ('Size', DWORD),
                ('Flags', DWORD),
                ('FileOffset', DWORDLONG),
                ('CopyLength', DWORDLONG),
                ('TransferOffset', DWORDLONG),
                ('Token', BYTE * 512),
            ]

            _FSCTL_OFFLOAD_WRITE_OUTPUT._fields_ = [
                ('Size', DWORD),
                ('Flags', DWORD),
                ('LengthWritten', DWORDLONG),
            ]

            # == == == == == == == == == == == == FSCTL_SET_PURGE_FAILURE_MODE
            # == == == == == == == == == == == == == =
            # Structure defintions for supporting purge failure mode
            _SET_PURGE_FAILURE_MODE_INPUT._fields_ = [
                ('Flags', DWORD),
            ]

            # Enable purge failure mode
            SET_PURGE_FAILURE_MODE_ENABLED = 0x00000001

            # Disable purge failure mode
            SET_PURGE_FAILURE_MODE_DISABLED = 0x00000002

            # == == == == == == == == == == == = FSCTL_REPAIR_COPIES == == ==
            # == == == == == == == == == == == =
            _REPAIR_COPIES_INPUT._fields_ = [
                # (ctypes.sizeof(REPAIR_COPIES_INPUT)
                ('Size', DWORD),
                # Reserved (must be zero)
                ('Flags', DWORD),
                ('FileOffset', LARGE_INTEGER),
                ('Length', DWORD),
                # The copy number of the source copy.
                ('SourceCopy', DWORD),
                # The number of copies that will be repaired.
                ('NumberOfRepairCopies', DWORD),
                # The copy numbers of all the copies that will be repaired.
                ('RepairCopies', DWORD * ANYSIZE_ARRAY),
            ]
            _REPAIR_COPIES_OUTPUT._fields_ = [
                # (ctypes.sizeof(REPAIR_COPIES_OUTPUT)
                ('Size', DWORD),
                # Operational status
                ('Status', DWORD),
                # File Offset hint to use to resume repair operation skipping
                ('ResumeFileOffset', LARGE_INTEGER),
            ]
            # == == == == == == == == == == == = FSCTL_QUERY_FILE_REGIONS ==
            # == == == == == == == == == == == == == =
            # Structures used for querying for Various file region definitions
            # The initial values if for query VDL
            # Bit flags which may be OR'd together to define the usage of the
            # given range
            # If the given bit is SET, then the specified region has that
            # attribute
            # if the bit is NOT set, then the specified region does NOT have
            # that attribute
            FILE_REGION_USAGE_VALID_CACHED_DATA = 0x00000001
            FILE_REGION_USAGE_VALID_NONCACHED_DATA = 0x00000002
            FILE_REGION_USAGE_OTHER_PAGE_ALIGNMENT = 0x00000004
            FILE_REGION_USAGE_LARGE_PAGE_ALIGNMENT = 0x00000008
            if defined(_WIN64):
                FILE_REGION_USAGE_HUGE_PAGE_ALIGNMENT = 0x00000010
                FILE_REGION_USAGE_QUERY_ALIGNMENT = (
                    FILE_REGION_USAGE_LARGE_PAGE_ALIGNMENT |
                    FILE_REGION_USAGE_HUGE_PAGE_ALIGNMENT
                )
            else:
                FILE_REGION_USAGE_QUERY_ALIGNMENT = (
                    FILE_REGION_USAGE_LARGE_PAGE_ALIGNMENT
                )
            # END IF   _WIN64

            _FILE_REGION_INFO._fields_ = [
                ('FileOffset', LONGLONG),
                ('Length', LONGLONG),
                ('Usage', DWORD),
                ('Reserved', DWORD),
            ]

            # none currently defined
            _FILE_REGION_OUTPUT._fields_ = [
                ('Flags', DWORD),
                # count of total regions that could be returned
                ('TotalRegionEntryCount', DWORD),
                # count of regions that were returned
                ('RegionEntryCount', DWORD),
                # for longlong alignment
                ('Reserved', DWORD),
                ('Region', FILE_REGION_INFO * 1),
            ]

            # This is an optional buffer given on input to specify a region of
            # the
            # file the caller is interested in
            _FILE_REGION_INPUT._fields_ = [
                ('FileOffset', LONGLONG),
                ('Length', LONGLONG),
                ('DesiredUsage', DWORD),
            ]
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN8

        if _WIN32_WINNT >= _WIN32_WINNT_WIN8:
            # == == == == == == == == == == == = FSCTL_WRITE_USN_REASON == ==
            # == == == == == == == == == == == == =
            # The list of valid USN reasons that can be set with this FSCTL.
            # Any bits
            # which are specified which are not defined by this mask are
            # silently
            # stripped. This operation will not be failed for sending
            # undefined reasons
            # This operation is only supported from kernel mode.
            # The output of this operation is a USN structure.
            VALID_WRITE_USN_REASON_MASK = (
                USN_REASON_DATA_OVERWRITE |
                USN_REASON_CLOSE
            )

            _WRITE_USN_REASON_INPUT._fields_ = [
                # Flags for this operation (none defined)
                ('Flags', DWORD),
                # A list of USN reasons to set
                ('UsnReasonToWrite', DWORD),
            ]

            # No Flags currently defined
        # END IF  _WIN32_WINNT  >= _WIN32_WINNT_WIN8

        if _WIN32_WINNT >= _WIN32_WINNT_WINBLUE:
            # ****************** FSCTL_QUERY_STORAGE_CLASSES
            # ***************************
            # The FILE_STORAGE_TIER is an identifier for the storage tier
            # relative to the volume.
            # The storage tier ID for a particular volume has no relationship
            # to the storage tier
            # ID with the same value on a different volume.
            # Notenot The MediaType is used to indicate an uninitialized
            # in-memory DSC structure.
            # Do not use values 0xfe or 0xff as media types.
            FILE_STORAGE_TIER_NAME_LENGTH = 256
            FILE_STORAGE_TIER_DESCRIPTION_LENGTH = 512

            # These flags *must* match those for _STORAGE_TIER as the file
            # system does a
            # pass through.
            FILE_STORAGE_TIER_FLAG_NO_SEEK_PENALTY = 0x00020000
            FILE_STORAGE_TIER_FLAG_WRITE_BACK_CACHE = 0x00200000
            FILE_STORAGE_TIER_FLAG_READ_CACHE = 0x00400000
            FILE_STORAGE_TIER_FLAG_PARITY = 0x00800000
            FILE_STORAGE_TIER_FLAG_SMR = 0x01000000


            class _FILE_STORAGE_TIER_MEDIA_TYPE(ENUM):
                FileStorageTierMediaTypeUnspecified = 0
                FileStorageTierMediaTypeDisk = 1
                FileStorageTierMediaTypeSsd = 2
                FileStorageTierMediaTypeScm = 4
                FileStorageTierMediaTypeMax = 5

            FILE_STORAGE_TIER_MEDIA_TYPE = _FILE_STORAGE_TIER_MEDIA_TYPE
            PFILE_STORAGE_TIER_MEDIA_TYPE = POINTER(_FILE_STORAGE_TIER_MEDIA_TYPE)


            class _FILE_STORAGE_TIER_CLASS(ENUM):
                FileStorageTierClassUnspecified = 0
                FileStorageTierClassCapacity = 1
                FileStorageTierClassPerformance = 2
                FileStorageTierClassMax = 3

            FILE_STORAGE_TIER_CLASS = _FILE_STORAGE_TIER_CLASS
            PFILE_STORAGE_TIER_CLASS = POINTER(_FILE_STORAGE_TIER_CLASS)

            _FILE_STORAGE_TIER._fields_ = [
                # Tier ID
                ('Id', GUID),
                # Name for the tier
                ('Name', WCHAR * FILE_STORAGE_TIER_NAME_LENGTH),
                # Note for the tier
                ('Description', WCHAR * FILE_STORAGE_TIER_NAME_LENGTH),
                # Flags: FILE_STORAGE_TIER_FLAG_xxx
                ('Flags', DWORDLONG),
                # Provisioned capacity of the tier
                ('ProvisionedCapacity', DWORDLONG),
                # Media type of the tier
                ('MediaType', FILE_STORAGE_TIER_MEDIA_TYPE),
                # Classification of the tier
                ('Class', FILE_STORAGE_TIER_CLASS),
            ]

            # This structure has the same fields as
            # STORAGE_DEVICE_TIERING_DESCRIPTOR and
            # that structure reserves the upper WORD of the Flags field for
            # file system use.
            # We define the following possible values for the Flags field.
            QUERY_STORAGE_CLASSES_FLAGS_MEASURE_WRITE = 0x80000000
            QUERY_STORAGE_CLASSES_FLAGS_MEASURE_READ = 0x40000000
            QUERY_STORAGE_CLASSES_FLAGS_NO_DEFRAG_VOLUME = 0x20000000

            # The response returns a single structure of
            # FSCTL_QUERY_STORAGE_CLASSES_OUTPUT
            # that has all the tiers for this volume.
            _FSCTL_QUERY_STORAGE_CLASSES_OUTPUT._fields_ = [
                # as the version
                ('Version', DWORD),
                # all the variable sized fields
                ('Size', DWORD),
                # Flags
                ('Flags', DWORD),
                # The total number of available tiers for this disk
                ('TotalNumberOfTiers', DWORD),
                # The number of tiers that fit in the output
                ('NumberOfTiersReturned', DWORD),
                # Detailed info on the storage tiers.
                ('Tiers', FILE_STORAGE_TIER * ANYSIZE_ARRAY),
            ]
            FSCTL_QUERY_STORAGE_CLASSES_OUTPUT_VERSION = (
                ctypes.sizeof(FSCTL_QUERY_STORAGE_CLASSES_OUTPUT)
            )

            # This structure lists information on the stream.
            class _StreamInformation(ctypes.Union):
                pass


            class _DesiredStorageClass(ctypes.Structure):
                pass


            _DesiredStorageClass._fields_ = [
                # Class
                ('Class', FILE_STORAGE_TIER_CLASS),
                # Flags
                ('Flags', DWORD),
            ]
            DesiredStorageClass = _DesiredStorageClass
            _StreamInformation.DesiredStorageClass = DesiredStorageClass

            _StreamInformation._fields_ = [
                # Desired Storage Class
                ('DesiredStorageClass', _StreamInformation.DesiredStorageClass),
            ]
            StreamInformation = _StreamInformation
            _STREAM_INFORMATION_ENTRY.StreamInformation = StreamInformation


            _STREAM_INFORMATION_ENTRY._fields_ = [
                # Version of this struct. Current version is 1.
                ('Version', DWORD),
                # Flags
                ('Flags', DWORD),
                # the various types in a union.
                ('StreamInformation', _STREAM_INFORMATION_ENTRY.StreamInformation),
            ]

            # ****************** FSCTL_QUERY_REGION_INFO
            # *******************************
            # Input structure for FSCTL_QUERY_REGION_INFO.
            # This FSCTL returns the storage tier regions from the storage
            # stack for a particular volume.
            _FSCTL_QUERY_REGION_INFO_INPUT._fields_ = [
                # The version of this structure.
                ('Version', DWORD),
                # The size of this structure in bytes.
                ('Size', DWORD),
                # Reserved for future use.
                ('Flags', DWORD),
                # Number of entries in TierIds, 0 for all for volume
                ('NumberOfTierIds', DWORD),
                # Storage tiers to return information for
                ('TierIds', GUID * ANYSIZE_ARRAY),
            ]
            FSCTL_QUERY_REGION_INFO_INPUT_VERSION = (
                ctypes.sizeof(FSCTL_QUERY_REGION_INFO_INPUT)
            )
            # Structure that describes a single storage tier region.
            _FILE_STORAGE_TIER_REGION._fields_ = [
                # Tier ID
                ('TierId', GUID),
                # offset of region in bytes
                ('Offset', DWORDLONG),
                # length of region in bytes
                ('Length', DWORDLONG),
            ]
            # Output structure for FSCTL_QUERY_REGION_INFO.
            # The FSCTL_QUERY_REGION_INFO response returns a single one of
            # these that include
            # multiple FILE_STORAGE_TIER_REGION records, one for each region.
            _FSCTL_QUERY_REGION_INFO_OUTPUT._fields_ = [
                # The version of this structure.
                ('Version', DWORD),
                # The size of this structure in bytes.
                ('Size', DWORD),
                # Reserved for future use.
                ('Flags', DWORD),
                # Reserved for future use.
                ('Reserved', DWORD),
                # in bytes, must align to slab boundary
                ('Alignment', DWORDLONG),
                # Total number of available regions.
                ('TotalNumberOfRegions', DWORD),
                # Number of regions that fit in the output.
                ('NumberOfRegionsReturned', DWORD),
                # Detailed info on the regions.
                ('Regions', FILE_STORAGE_TIER_REGION * ANYSIZE_ARRAY),
            ]
            FSCTL_QUERY_REGION_INFO_OUTPUT_VERSION = (
                ctypes.sizeof(FSCTL_QUERY_REGION_INFO_OUTPUT)
            )
            # This structure contains the information for the Desired Storage
            # Class attribute.
            _FILE_DESIRED_STORAGE_CLASS_INFORMATION._fields_ = [
                # Class type of the tier
                ('Class', FILE_STORAGE_TIER_CLASS),
                # Flags
                ('Flags', DWORD),
            ]
            # This structure has the same fields as
            # STORAGE_DEVICE_TIERING_DESCRIPTOR and
            # that structure reserves the upper WORD of the Flags field for
            # file system use.
            # We define the following possible values for the Flags field.
            QUERY_STORAGE_CLASSES_FLAGS_MEASURE_WRITE = 0x80000000
            QUERY_STORAGE_CLASSES_FLAGS_MEASURE_READ = 0x40000000
            # == == == == == == == = FSCTL_DUPLICATE_EXTENTS_TO_FILE == == ==
            # == == == == == == ==
            _DUPLICATE_EXTENTS_DATA._fields_ = [
                ('FileHandle', HANDLE),
                ('SourceFileOffset', LARGE_INTEGER),
                ('TargetFileOffset', LARGE_INTEGER),
                ('ByteCount', LARGE_INTEGER),
            ]

            if ((_WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS2) and defined(_WIN64)):
                # 32/64 Bit thunking support structure
                _DUPLICATE_EXTENTS_DATA32._fields_ = [
                    ('FileHandle', UINT32),
                    ('SourceFileOffset', LARGE_INTEGER),
                    ('TargetFileOffset', LARGE_INTEGER),
                    ('ByteCount', LARGE_INTEGER),
                ]
            # END IF  ((_WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS2) and defined(_WIN64))
        # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WINBLUE)

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS3:
            # == == == == == == == = FSCTL_DUPLICATE_EXTENTS_TO_FILE_EX == ==
            # == == == == == == ==
            DUPLICATE_EXTENTS_DATA_EX_SOURCE_ATOMIC = 0x00000001

            _DUPLICATE_EXTENTS_DATA_EX._fields_ = [
                ('Size', SIZE_T),
                ('FileHandle', HANDLE),
                ('SourceFileOffset', LARGE_INTEGER),
                ('TargetFileOffset', LARGE_INTEGER),
                ('ByteCount', LARGE_INTEGER),
                ('Flags', DWORD),
            ]
            if ((_WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS3) and defined(_WIN64)):
                # 32/64 Bit thunking support structure
                _DUPLICATE_EXTENTS_DATA_EX32._fields_ = [
                    ('Size', DWORD32),
                    ('FileHandle', DWORD32),
                    ('SourceFileOffset', LARGE_INTEGER),
                    ('TargetFileOffset', LARGE_INTEGER),
                    ('ByteCount', LARGE_INTEGER),
                    ('Flags', DWORD),
                ]
            # END IF  ((_WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS3) and defined(_WIN64))
        # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS3)

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS2:
            # == == == == == == == == == == FSCTL_QUERY_REFS_SMR_VOLUME_INFO
            # == == == == == == == == == == == =
            REFS_SMR_VOLUME_INFO_OUTPUT_VERSION_V1 = 1


            class _REFS_SMR_VOLUME_GC_STATE(ENUM):
                SmrGcStateInactive = 0
                SmrGcStatePaused = 1
                SmrGcStateActive = 2
                SmrGcStateActiveFullSpeed = 3

            REFS_SMR_VOLUME_GC_STATE = _REFS_SMR_VOLUME_GC_STATE
            PREFS_SMR_VOLUME_GC_STATE = POINTER(_REFS_SMR_VOLUME_GC_STATE)

            _REFS_SMR_VOLUME_INFO_OUTPUT._fields_ = [
                ('Version', DWORD),
                ('Flags', DWORD),
                ('SizeOfRandomlyWritableTier', LARGE_INTEGER),
                ('FreeSpaceInRandomlyWritableTier', LARGE_INTEGER),
                ('SizeofSMRTier', LARGE_INTEGER),
                ('FreeSpaceInSMRTier', LARGE_INTEGER),
                ('UsableFreeSpaceInSMRTier', LARGE_INTEGER),
                ('VolumeGcState', REFS_SMR_VOLUME_GC_STATE),
                ('VolumeGcLastStatus', DWORD),
                ('Unused', DWORDLONG * 7),
            ]

            # == == == == == == == == == ==
            # FSCTL_SET_REFS_SMR_VOLUME_GC_PARAMETERS == =
            REFS_SMR_VOLUME_GC_PARAMETERS_VERSION_V1 = 1


            class _REFS_SMR_VOLUME_GC_ACTION(ENUM):
                SmrGcActionStart = 1
                SmrGcActionStartFullSpeed = 2
                SmrGcActionPause = 3
                SmrGcActionStop = 4

            REFS_SMR_VOLUME_GC_ACTION = _REFS_SMR_VOLUME_GC_ACTION
            PREFS_SMR_VOLUME_GC_ACTION = POINTER(_REFS_SMR_VOLUME_GC_ACTION)


            class _REFS_SMR_VOLUME_GC_METHOD(ENUM):
                SmrGcMethodCompaction = 1
                SmrGcMethodCompression = 2
                SmrGcMethodRotation = 3

            REFS_SMR_VOLUME_GC_METHOD = _REFS_SMR_VOLUME_GC_METHOD
            PREFS_SMR_VOLUME_GC_METHOD = POINTER(_REFS_SMR_VOLUME_GC_METHOD)

            _REFS_SMR_VOLUME_GC_PARAMETERS._fields_ = [
                ('Version', DWORD),
                ('Flags', DWORD),
                ('Action', REFS_SMR_VOLUME_GC_ACTION),
                ('Method', REFS_SMR_VOLUME_GC_METHOD),
                ('IoGranularity', DWORD),
                ('CompressionFormat', DWORD),
                ('Unused', DWORDLONG * 8),
            ]

            # == == == == == == == == == == STREAMS CONSTANTS == == == == ==
            # == == == == == == =
            STREAMS_INVALID_ID = 0
            STREAMS_MAX_ID = MAXWORD

            # == == == == == == == == == == FSCTL_STREAMS_QUERY_PARAMETERS ==
            # == == == == == == == == == == =
            _STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER._fields_ = [
                ('OptimalWriteSize', DWORD),
                ('StreamGranularitySize', DWORD),
                ('StreamIdMin', DWORD),
                ('StreamIdMax', DWORD),
            ]

            # == == == == == == == == == == FSCTL_STREAMS_ASSOCIATE_ID == ==
            # == == == == == == == == == =
            STREAMS_ASSOCIATE_ID_CLEAR = 0x1
            STREAMS_ASSOCIATE_ID_SET = 0x2

            _STREAMS_ASSOCIATE_ID_INPUT_BUFFER._fields_ = [
                ('Flags', DWORD),
                ('StreamId', DWORD),
            ]

            # == == == == == == == == == == FSCTL_STREAMS_QUERY_ID == == == ==
            # == == == == == == == =
            _STREAMS_QUERY_ID_OUTPUT_BUFFER._fields_ = [
                ('StreamId', DWORD),
            ]
        # END IF   #if (_WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS2)

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS3:
            # == == == == == == == = FSCTL_QUERY_BAD_RANGES == == == == == ==
            # == == ==
            _QUERY_BAD_RANGES_INPUT_RANGE._fields_ = [
                # Starting offset of the range in bytes.
                ('StartOffset', DWORDLONG),
                # Length of the range in bytes.
                ('LengthInBytes', DWORDLONG),
            ]

            # Input buffer defining the ranges in the file to look for
            # bad ranges. A NULL input buffer would lookup the entire
            # file.
            _QUERY_BAD_RANGES_INPUT._fields_ = [
                ('Flags', DWORD),
                # Number of ranges given, in the Ranges array.
                ('NumRanges', DWORD),
                # will be capped at allocation size.
                ('Ranges', QUERY_BAD_RANGES_INPUT_RANGE * 1),
            ]

            _QUERY_BAD_RANGES_OUTPUT_RANGE._fields_ = [
                # Flags, reserved for future.
                ('Flags', DWORD),
                ('Reserved', DWORD),
                # Starting offset of the range in bytes.
                ('StartOffset', DWORDLONG),
                # Length of the range in bytes.
                ('LengthInBytes', DWORDLONG),
            ]

            # Output buffer defining the bad ranges.
            _QUERY_BAD_RANGES_OUTPUT._fields_ = [
                ('Flags', DWORD),
                # array.
                ('NumBadRanges', DWORD),
                # from which the user can requery the remaining bad ranges.
                ('NextOffsetToLookUp', DWORDLONG),
                # ranges that user asked for.
                ('BadRanges', QUERY_BAD_RANGES_OUTPUT_RANGE * 1),
            ]

            # == == == == = FSCTL_SET_DAX_ALLOC_ALIGNMENT_HINT == == == == =
            # Once this FSCTL is issued for a file, the following
            # allocations to the file will be examined to see if
            # the given offset is being allocated and if so the
            # allocation will be placed such that the physical
            # address corresponding to that allocation is aligned
            # to the given AlignmentValue, if we have free space
            # available at aligned regions.
            # To reset the alignment constraint you can issue this
            # FSCTL with AlignmentValue of 1 i.e. AlignmentShift
            # as 0.
            _TEMP__SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT = [
                ('Flags', DWORD),
                # AlignmentValue = (1 < < AlignmentShift);
                ('AlignmentShift', DWORD),
                # and the physical address are 1gb aligned.
                ('FileOffsetToAlign', DWORDLONG),
            ]
            if _WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS4:
                _TEMP__SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT += [
                    # AlignmentShift could not be found.
                    ('FallbackAlignmentShift', DWORD),
                ]
            # END IF   (_WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS4)

            _SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT._fields_ = _TEMP__SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT
            if _WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS4:
                # MANDATORY - If allocation satisyfing AlignmentShift
                # (or at least
                # FallbackAlignmentShift if
                # specified) cannot be found, then fail
                # the file system operation (e.g. extending the file).
                DAX_ALLOC_ALIGNMENT_FLAG_MANDATORY = 0x00000001

                # FALLBACK_SPECIFIED - Indicates that the
                # FallbackAlignmentShift field
                # is present in the input structure and indicates a fallback
                # alignment if the optimal alignment isn't available.
                DAX_ALLOC_ALIGNMENT_FLAG_FALLBACK_SPECIFIED = 0x00000002
            # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS4)

            # == == == == = FSCTL_VIRTUAL_STORAGE_SET_BEHAVIOR == == == == =
            # Configures file system-specific behaviors for files
            # used as backing stored for virtual storage devices.
            class _VIRTUAL_STORAGE_BEHAVIOR_CODE(ENUM):
                VirtualStorageBehaviorUndefined = 0
                VirtualStorageBehaviorCacheWriteThrough = 1
                VirtualStorageBehaviorCacheWriteBack = 2

            VIRTUAL_STORAGE_BEHAVIOR_CODE = _VIRTUAL_STORAGE_BEHAVIOR_CODE
            PVIRTUAL_STORAGE_BEHAVIOR_CODE = POINTER(_VIRTUAL_STORAGE_BEHAVIOR_CODE)

            _VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT._fields_ = [
                ('Size', DWORD),
                ('BehaviorCode', VIRTUAL_STORAGE_BEHAVIOR_CODE),
            ]

            # TO BE DELETED: add for testing purpose only.
            _ENCRYPTION_KEY_CTRL_INPUT._fields_ = [
                ('IsProtect', BOOLEAN),
            ]

            # end testing purpose only
        # END IF  (_WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS3)

        if _WIN32_WINNT >= _WIN32_WINNT_WIN7:
            # Generic fsctl headers which can be sent to the driver.
            WOF_CURRENT_VERSION = 0x00000001
            WOF_PROVIDER_WIM = 0x00000001
            WOF_PROVIDER_FILE = 0x00000002
            WOF_PROVIDER_CLOUD = 0x00000003

            _WOF_EXTERNAL_INFO._fields_ = [
                ('Version', DWORD),
                ('Provider', DWORD),
            ]

            _WOF_EXTERNAL_FILE_ID._fields_ = [
                ('FileId', FILE_ID_128),
            ]

            _WOF_VERSION_INFO._fields_ = [
                ('WofVersion', DWORD),
            ]

            # Structures for WIM provider specific fsctl's.
            if not defined(WIM_PROVIDER_HASH_SIZE):
                WIM_PROVIDER_HASH_SIZE = 20
            # END IF

            WIM_PROVIDER_CURRENT_VERSION = 0x00000001
            WIM_PROVIDER_EXTERNAL_FLAG_NOT_ACTIVE = 0x00000001
            WIM_PROVIDER_EXTERNAL_FLAG_SUSPENDED = 0x00000002

            _WIM_PROVIDER_EXTERNAL_INFO._fields_ = [
                ('Version', DWORD),
                ('Flags', DWORD),
                ('DataSourceId', LARGE_INTEGER),
                ('ResourceHash', BYTE * WIM_PROVIDER_HASH_SIZE),
            ]

            # WimType specifies a set of flags corresponding to the type of
            # WIM.
            # WIM_BOOT_OS_WIM means the wim contains Windows system files.
            # WIM_BOOT_NOT_OS_WIM means the wim contains 3rd party files or
            # data files.
            # Do not use WIM_BOOT_OS_WIM for data that should be preserved on
            # system upgrade.
            WIM_BOOT_OS_WIM = 0x00000001
            WIM_BOOT_NOT_OS_WIM = 0x00000000

            _WIM_PROVIDER_ADD_OVERLAY_INPUT._fields_ = [
                ('WimType', DWORD),
                ('WimIndex', DWORD),
                ('WimFileNameOffset', DWORD),
                ('WimFileNameLength', DWORD),
            ]

            _WIM_PROVIDER_UPDATE_OVERLAY_INPUT._fields_ = [
                ('DataSourceId', LARGE_INTEGER),
                ('WimFileNameOffset', DWORD),
                ('WimFileNameLength', DWORD),
            ]

            _WIM_PROVIDER_REMOVE_OVERLAY_INPUT._fields_ = [
                ('DataSourceId', LARGE_INTEGER),
            ]

            _WIM_PROVIDER_SUSPEND_OVERLAY_INPUT._fields_ = [
                ('DataSourceId', LARGE_INTEGER),
            ]

            _WIM_PROVIDER_OVERLAY_ENTRY._fields_ = [
                ('NextEntryOffset', DWORD),
                ('DataSourceId', LARGE_INTEGER),
                ('WimGuid', GUID),
                ('WimFileNameOffset', DWORD),
                ('WimType', DWORD),
                ('WimIndex', DWORD),
                ('Flags', DWORD),
            ]
        # END IF

        if _WIN32_WINNT >= _WIN32_WINNT_WIN7:
            # Structures for WOF File provider specific fsctl's.
            FILE_PROVIDER_CURRENT_VERSION = 0x00000001
            FILE_PROVIDER_SINGLE_FILE = 0x00000001
            FILE_PROVIDER_COMPRESSION_XPRESS4K = 0x00000000
            FILE_PROVIDER_COMPRESSION_LZX = 0x00000001
            FILE_PROVIDER_COMPRESSION_XPRESS8K = 0x00000002
            FILE_PROVIDER_COMPRESSION_XPRESS16K = 0x00000003
            FILE_PROVIDER_COMPRESSION_MAXIMUM = 0x00000004
            FILE_PROVIDER_FLAG_COMPRESS_ON_WRITE = 0x00000001

            _FILE_PROVIDER_EXTERNAL_INFO_V0._fields_ = [
                ('Version', DWORD),
                ('Algorithm', DWORD),
            ]

            _FILE_PROVIDER_EXTERNAL_INFO_V1._fields_ = [
                ('Version', DWORD),
                ('Algorithm', DWORD),
                ('Flags', DWORD),
            ]

            FILE_PROVIDER_EXTERNAL_INFO = FILE_PROVIDER_EXTERNAL_INFO_V1
            PFILE_PROVIDER_EXTERNAL_INFO = PFILE_PROVIDER_EXTERNAL_INFO_V1
        # END IF    (_WIN32_WINNT  >= _WIN32_WINNT_WIN7)

        if _WIN32_WINNT  >= _WIN32_WINNT_WINTHRESHOLD:
            _CONTAINER_VOLUME_STATE._fields_ = [
                ('Flags', DWORD),
            ]
            CONTAINER_VOLUME_STATE_HOSTING_CONTAINER = 0x00000001

            _CONTAINER_ROOT_INFO_INPUT._fields_ = [
                ('Flags', DWORD),
            ]

            _CONTAINER_ROOT_INFO_OUTPUT._fields_ = [
                ('ContainerRootIdLength', WORD),
                ('ContainerRootId', BYTE * ANYSIZE_ARRAY),
            ]
            CONTAINER_ROOT_INFO_FLAG_SCRATCH_ROOT = 0x00000001
            CONTAINER_ROOT_INFO_FLAG_LAYER_ROOT = 0x00000002
            CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_ROOT = 0x00000004
            CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_TARGET_ROOT = 0x00000008
            CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_EXCEPTION_ROOT = 0x00000010
            CONTAINER_ROOT_INFO_FLAG_BIND_ROOT = 0x00000020
            CONTAINER_ROOT_INFO_FLAG_BIND_TARGET_ROOT = 0x00000040
            CONTAINER_ROOT_INFO_FLAG_BIND_EXCEPTION_ROOT = 0x00000080
            CONTAINER_ROOT_INFO_VALID_FLAGS = 0x000000FF
        # END IF

        if _WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS1:
            _VIRTUALIZATION_INSTANCE_INFO_INPUT._fields_ = [
                ('NumberOfWorkerThreads', DWORD),
                ('Flags', DWORD),
            ]
            GV_CURRENT_VERSION = 2

            # (ctypes.sizeof(VIRTUALIZATION_INSTANCE_INFO_INPUT_EX)
            _VIRTUALIZATION_INSTANCE_INFO_INPUT_EX._fields_ = [
                ('HeaderSize', WORD),
                ('Flags', DWORD),
                # Total Size of the NotificationInfo Buffer.
                ('NotificationInfoSize', DWORD),
                # Offset from beginning of this struct to the NotificationInfo
                # Buffer.
                ('NotificationInfoOffset', WORD),
                # This should be set to GV_CURRENT_VERSION.
                ('ProviderMajorVersion', WORD),
            ]
            _VIRTUALIZATION_INSTANCE_INFO_OUTPUT._fields_ = [
                ('VirtualizationInstanceID', GUID),
            ]
            # Structures for FSCTL_GET_FILTER_FILE_IDENTIFIER.
            _GET_FILTER_FILE_IDENTIFIER_INPUT._fields_ = [
                ('AltitudeLength', WORD),
                ('Altitude', WCHAR * ANYSIZE_ARRAY),
            ]
            _GET_FILTER_FILE_IDENTIFIER_OUTPUT._fields_ = [
                ('FilterFileIdentifierLength', WORD),
                ('FilterFileIdentifier', BYTE * ANYSIZE_ARRAY),
            ]
        # END IF    (_WIN32_WINNT  >= _WIN32_WINNT_WIN10_RS1)
        # end_ntosifs
        # begin_ntifs begin_winioctl
        # ****************** Insert New FSCTLs Here
        # ********************************    # END IF   _FILESYSTEMFSCTL_
    # == == == == == == == = END FileSystem FSCTL Structure Defintions == ==
    # == == == == == == ==
    # Some applications include both ntioapi_x.h and winioctl.h
    if not defined(SMB_CCF_APP_INSTANCE_EA_NAME):
        SMB_CCF_APP_INSTANCE_EA_NAME = "ClusteredApplicationInstance"
    # END IF  SMB_CCF_APP_INSTANCE_EA_NAME

    if not defined(_NETWORK_APP_INSTANCE_EA_DEFINED):
        _NETWORK_APP_INSTANCE_EA_DEFINED = VOID

        if NTDDI_VERSION  >= NTDDI_WIN10:
            # Define the SMB Cluster Client Failover AppInstance Extended
            # Attribute name
            # newer version of input payload assumes that EA is not just a
            # GUID,
            # but instead is a structure that contains additional information
            # Is used only when file is opened directly on CSVFS. This flag is
            # ignored when file
            # is opened over SMB.
            # Tells CSVFS that this file open should be valid only on
            # coordinating node.
            # If open comes to CSVFS, and this node is not a coordinating then
            # open would fail.
            # If file is opened, and coordinating node is moved then file open
            # will be invalidated
            if not defined(NETWORK_APP_INSTANCE_CSV_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR):
                NETWORK_APP_INSTANCE_CSV_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR = (
                    0x00000001
                )
            # END IF  NETWORK_APP_INSTANCE_CSV_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR

            _NETWORK_APP_INSTANCE_EA._fields_ = [
                # the application.
                ('AppInstanceID', GUID),
                # Combination of the NETWORK_APP_INSTANCE_CSV_FLAGS_* flags
                ('CsvFlags', DWORD),
            ]
        # END IF   (NTDDI_VERSION  >= NTDDI_WIN10)
    # END IF  _NETWORK_APP_INSTANCE_EA_DEFINED

    # 'V'
    IOCTL_VOLUME_BASE = 0x00000056

    if NTDDI_VERSION  >= NTDDI_WIN2K:
        # IOCTL to obtain the physical location of
        # the specified volume on one or more disks.
        IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS = CTL_CODE(
            IOCTL_VOLUME_BASE,
            0,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )

        # IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS
        # Input Buffer:
        # None
        # Output Buffer:
        # Structure of type VOLUME_DISK_EXTENTS
        _DISK_EXTENT._fields_ = [
            # the disk on which this extent resides.
            ('DiskNumber', DWORD),
            # disk.
            ('StartingOffset', LARGE_INTEGER),
            ('ExtentLength', LARGE_INTEGER),
        ]

        _VOLUME_DISK_EXTENTS._fields_ = [
            # of sectors that make up this volume.
            ('NumberOfDiskExtents', DWORD),
            ('Extents', DISK_EXTENT * ANYSIZE_ARRAY),
        ]

        # IOCTLs to transition the specified volume
        # between r/w and non r/w modes.
        IOCTL_VOLUME_ONLINE = CTL_CODE(
            IOCTL_VOLUME_BASE,
            2,
            METHOD_BUFFERED,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS,

        )
        IOCTL_VOLUME_OFFLINE = CTL_CODE(
            IOCTL_VOLUME_BASE,
            3,
            METHOD_BUFFERED,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS,
        )

        # IOCTL_VOLUME_ONLINE
        # IOCTL_VOLUME_OFFLINE
        # Input Buffer:
        # None
        # Output Buffer:
        # None
    # END IF   NTDDI_VERSION  >= NTDDI_WIN2K

    if NTDDI_VERSION >= NTDDI_WINXP:
        # IOCTL to determine whether the specified
        # volume resides on a disk that is an online
        # cluster resource or not.
        IOCTL_VOLUME_IS_CLUSTERED = CTL_CODE(
            IOCTL_VOLUME_BASE,
            12,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )

        # IOCTL_VOLUME_IS_CLUSTERED
        # InputBuffer:
        # None
        # Output Buffer:
        # None
        # IOCTL to query the attributes on volumes.
        IOCTL_VOLUME_GET_GPT_ATTRIBUTES = CTL_CODE(
            IOCTL_VOLUME_BASE,
            14,
            METHOD_BUFFERED,
            FILE_ANY_ACCESS,
        )

        # IOCTL_VOLUME_GET_GPT_ATTRIBUTES
        # Input Buffer:
        # None
        # Output Buffer:
        # Structure of type VOLUME_GET_GPT_ATTRIBUTES_INFORMATION
        _VOLUME_GET_GPT_ATTRIBUTES_INFORMATION._fields_ = [
            # associated with this volume.
            ('GptAttributes', DWORDLONG),
        ]
    # END IF   NTDDI_VERSION  >= NTDDI_WINXP

    if NTDDI_VERSION >= NTDDI_WINTHRESHOLD:
        # This is a function prototype for a routine that will be called from
        # the
        # IoPropagateIrpExtensionEx routine whenever the IopFsTrackOffsetType
        # extension type is set for a given IRP
        if not defined(_IO_IRP_EXT_TRACK_OFFSET_HEADER_):
            _IO_IRP_EXT_TRACK_OFFSET_HEADER_ = VOID

            _IO_IRP_EXT_TRACK_OFFSET_HEADER = struct

            # VOID (*PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK)( _In_ struct _IO_IRP_EXT_TRACK_OFFSET_HEADER *SourceContext, _Inout_ struct _IO_IRP_EXT_TRACK_OFFSET_HEADER *TargetContext, _In_ LONGLONG RelativeOffset );
            PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK = CALLBACK(
                VOID,
                POINTER(_IO_IRP_EXT_TRACK_OFFSET_HEADER),
                POINTER(_IO_IRP_EXT_TRACK_OFFSET_HEADER),
                LONGLONG,
            )

            # When any IRP extension exists which has an OFFSET which needs
            # processing,
            # the Irp extension field in the IRP must point to one of these
            # structures.
            # This is so IoPropagateIrpExtensionEx can calculate proper file
            # offset
            # adjustments for the sub IRPS as they are split and shifted
            # Track Offset
            IRP_EXT_TRACK_OFFSET_HEADER_VALIDATION_VALUE = 'TO'

            _IO_IRP_EXT_TRACK_OFFSET_HEADER._fields_ = [
                ('Validation', WORD),
                # identify the usage of the header. eg:
                # EFS_TRACKED_OFFSET_HEADER_FLAG
                ('Flags', WORD),
                ('TrackedOffsetCallback', PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK),
            ]

            # When using the TrackedOffset IRP extension one of the following
            # flag must be specified so that we can distinguish it from other
            # components setting this IRP extension
            # EFS Flag
            EFS_TRACKED_OFFSET_HEADER_FLAG = 0x0001

            # SPACES Flag
            SPACES_TRACKED_OFFSET_HEADER_FLAG = 0x0002
        # END IF   _IO_IRP_EXT_TRACK_OFFSET_HEADER_
    # END IF   (NTDDI_VERSION  >= NTDDI_WINTHRESHOLD)

    if _MSC_VER  >= 1200:
        pass
    # END IF

# END IF   _WINIOCTL_


